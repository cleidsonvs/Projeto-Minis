
;(function (global, factory) {
   typeof exports === 'object' && typeof module !== 'undefined'
       && typeof require === 'function' ? factory(require('../../moment')) :
   typeof define === 'function' && define.amd ? define(['../../moment'], factory) :
   factory(global.moment)
}(this, function (moment) { 'use strict';

    function each(array, callback) {
        var i;
        for (i = 0; i < array.length; i++) {
            callback(array[i], i, array);
        }
    }

    function objectKeys(obj) {
        if (Object.keys) {
            return Object.keys(obj);
        } else {
            // IE8
            var res = [], i;
            for (i in obj) {
                if (obj.hasOwnProperty(i)) {
                    res.push(i);
                }
            }
            return res;
        }
    }

    // Pick the first defined of two or three arguments.
    function defaults(a, b, c) {
        if (a != null) {
            return a;
        }
        if (b != null) {
            return b;
        }
        return c;
    }

    function defineCommonLocaleTests(locale, options) {
        test('lenient ordinal parsing', function (assert) {
            var i, ordinalStr, testMoment;
            for (i = 1; i <= 31; ++i) {
                ordinalStr = moment([2014, 0, i]).format('YYYY MM Do');
                testMoment = moment(ordinalStr, 'YYYY MM Do');
                assert.equal(testMoment.year(), 2014,
                        'lenient ordinal parsing ' + i + ' year check');
                assert.equal(testMoment.month(), 0,
                        'lenient ordinal parsing ' + i + ' month check');
                assert.equal(testMoment.date(), i,
                        'lenient ordinal parsing ' + i + ' date check');
            }
        });

        test('lenient ordinal parsing of number', function (assert) {
            var i, testMoment;
            for (i = 1; i <= 31; ++i) {
                testMoment = moment('2014 01 ' + i, 'YYYY MM Do');
                assert.equal(testMoment.year(), 2014,
                        'lenient ordinal parsing of number ' + i + ' year check');
                assert.equal(testMoment.month(), 0,
                        'lenient ordinal parsing of number ' + i + ' month check');
                assert.equal(testMoment.date(), i,
                        'lenient ordinal parsing of number ' + i + ' date check');
            }
        });

        test('strict ordinal parsing', function (assert) {
            var i, ordinalStr, testMoment;
            for (i = 1; i <= 31; ++i) {
                ordinalStr = moment([2014, 0, i]).format('YYYY MM Do');
                testMoment = moment(ordinalStr, 'YYYY MM Do', true);
                assert.ok(testMoment.isValid(), 'strict ordinal parsing ' + i);
            }
        });

        test('meridiem invariant', function (assert) {
            var h, m, t1, t2;
            for (h = 0; h < 24; ++h) {
                for (m = 0; m < 60; m += 15) {
                    t1 = moment.utc([2000, 0, 1, h, m]);
                    t2 = moment.utc(t1.format('A h:mm'), 'A h:mm');
                    assert.equal(t2.format('HH:mm'), t1.format('HH:mm'),
                            'meridiem at ' + t1.format('HH:mm'));
                }
            }
        });

        test('date format correctness', function (assert) {
            var data, tokens;
            data = moment.localeData()._longDateFormat;
            tokens = objectKeys(data);
            each(tokens, function (srchToken) {
                // Check each format string to make sure it does not contain any
                // tokens that need to be expanded.
                each(tokens, function (baseToken) {
                    // strip escaped sequences
                    var format = data[baseToken].replace(/(\[[^\]]*\])/g, '');
                    assert.equal(false, !!~format.indexOf(srchToken),
                            'contains ' + srchToken + ' in ' + baseToken);
                });
            });
        });

        test('month parsing correctness', function (assert) {
            var i, m;

            if (locale === 'tr') {
                // I can't fix it :(
                expect(0);
                return;
            }
            function tester(format) {
                var r;
                r = moment(m.format(format), format);
                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format);
                r = moment(m.format(format).toLocaleUpperCase(), format);
                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' upper');
                r = moment(m.format(format).toLocaleLowerCase(), format);
                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' lower');

                r = moment(m.format(format), format, true);
                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' strict');
                r = moment(m.format(format).toLocaleUpperCase(), format, true);
                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' upper strict');
                r = moment(m.format(format).toLocaleLowerCase(), format, true);
                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' lower strict');
            }

            for (i = 0; i < 12; ++i) {
                m = moment([2015, i, 15, 18]);
                tester('MMM');
                tester('MMM.');
                tester('MMMM');
                tester('MMMM.');
            }
        });

        test('weekday parsing correctness', function (assert) {
            var i, m;

            if (locale === 'tr' || locale === 'az') {
                // There is a lower-case letter (Ä±), that converted to upper then
                // lower changes to i
                expect(0);
                return;
            }
            function tester(format) {
                var r, baseMsg = 'weekday ' + m.weekday() + ' fmt ' + format;
                r = moment(m.format(format), format);
                assert.equal(r.weekday(), m.weekday(), baseMsg);
                r = moment(m.format(format).toLocaleUpperCase(), format);
                assert.equal(r.weekday(), m.weekday(), baseMsg + ' upper');
                r = moment(m.format(format).toLocaleLowerCase(), format);
                assert.equal(r.weekday(), m.weekday(), baseMsg + ' lower');

                r = moment(m.format(format), format, true);
                assert.equal(r.weekday(), m.weekday(), baseMsg + ' strict');
                r = moment(m.format(format).toLocaleUpperCase(), format, true);
                assert.equal(r.weekday(), m.weekday(), baseMsg + ' upper strict');
                r = moment(m.format(format).toLocaleLowerCase(), format, true);
                assert.equal(r.weekday(), m.weekday(), baseMsg + ' lower strict');
            }

            for (i = 0; i < 7; ++i) {
                m = moment.utc([2015, i, 15, 18]);
                tester('dd');
                tester('ddd');
                tester('dddd');
            }
        });
    }

    function setupDeprecationHandler(test, moment, scope) {
        test._expectedDeprecations = null;
        test._observedDeprecations = null;
        test._oldSupress = moment.suppressDeprecationWarnings;
        moment.suppressDeprecationWarnings = true;
        test.expectedDeprecations = function () {
            test._expectedDeprecations = arguments;
            test._observedDeprecations = [];
        };
        moment.deprecationHandler = function (name, msg) {
            var deprecationId = matchedDeprecation(name, msg, test._expectedDeprecations);
            if (deprecationId === -1) {
                throw new Error('Unexpected deprecation thrown name=' +
                        name + ' msg=' + msg);
            }
            test._observedDeprecations[deprecationId] = 1;
        };
    }

    function teardownDeprecationHandler(test, moment, scope) {
        moment.suppressDeprecationWarnings = test._oldSupress;

        if (test._expectedDeprecations != null) {
            var missedDeprecations = [];
            each(test._expectedDeprecations, function (deprecationPattern, id) {
                if (test._observedDeprecations[id] !== 1) {
                    missedDeprecations.push(deprecationPattern);
                }
            });
            if (missedDeprecations.length !== 0) {
                throw new Error('Expected deprecation warnings did not happen: ' +
                        missedDeprecations.join(' '));
            }
        }
    }

    function matchedDeprecation(name, msg, deprecations) {
        if (deprecations == null) {
            return -1;
        }
        for (var i = 0; i < deprecations.length; ++i) {
            if (name != null && name === deprecations[i]) {
                return i;
            }
            if (msg != null && msg.substring(0, deprecations[i].length) === deprecations[i]) {
                return i;
            }
        }
        return -1;
    }

    /*global QUnit:false*/

    var test = QUnit.test;

    var expect = QUnit.expect;

    function module (name, lifecycle) {
        QUnit.module(name, {
            setup : function () {
                moment.locale('en');
                moment.createFromInputFallback = function (config) {
                    throw new Error('input not handled by moment: ' + config._i);
                };
                setupDeprecationHandler(test, moment, 'core');
                if (lifecycle && lifecycle.setup) {
                    lifecycle.setup();
                }
            },
            teardown : function () {
                teardownDeprecationHandler(test, moment, 'core');
                if (lifecycle && lifecycle.teardown) {
                    lifecycle.teardown();
                }
            }
        });
    }

    function localeModule (name, lifecycle) {
        QUnit.module('locale:' + name, {
            setup : function () {
                moment.locale(name);
                moment.createFromInputFallback = function (config) {
                    throw new Error('input not handled by moment: ' + config._i);
                };
                setupDeprecationHandler(test, moment, 'locale');
                if (lifecycle && lifecycle.setup) {
                    lifecycle.setup();
                }
            },
            teardown : function () {
                moment.locale('en');
                teardownDeprecationHandler(test, moment, 'locale');
                if (lifecycle && lifecycle.teardown) {
                    lifecycle.teardown();
                }
            }
        });
        defineCommonLocaleTests(name, -1, -1);
    }

    localeModule('af');

    test('parse', function (assert) {
        var tests = 'Januarie Jan_Februarie Feb_Maart Mar_April Apr_Mei Mei_Junie Jun_Julie Jul_Augustus Aug_September Sep_Oktober Okt_November Nov_Desember Des'.split('_'), i;
        function equalTest(input, mmm, i) {
            assert.equal(moment(input, mmm).month(), i, input + ' should be month ' + (i + 1));
        }
        for (i = 0; i < 12; i++) {
            tests[i] = tests[i].split(' ');
            equalTest(tests[i][0], 'MMM', i);
            equalTest(tests[i][1], 'MMM', i);
            equalTest(tests[i][0], 'MMMM', i);
            equalTest(tests[i][1], 'MMMM', i);
            equalTest(tests[i][0].toLocaleLowerCase(), 'MMMM', i);
            equalTest(tests[i][1].toLocaleLowerCase(), 'MMMM', i);
            equalTest(tests[i][0].toLocaleUpperCase(), 'MMMM', i);
            equalTest(tests[i][1].toLocaleUpperCase(), 'MMMM', i);
        }
    });

    test('format', function (assert) {
        var a = [
                ['dddd, MMMM Do YYYY, h:mm:ss a',      'Sondag, Februarie 14de 2010, 3:25:50 nm'],
                ['ddd, hA',                            'Son, 3NM'],
                ['M Mo MM MMMM MMM',                   '2 2de 02 Februarie Feb'],
                ['YYYY YY',                            '2010 10'],
                ['D Do DD',                            '14 14de 14'],
                ['d do dddd ddd dd',                   '0 0de Sondag Son So'],
                ['DDD DDDo DDDD',                      '45 45ste 045'],
                ['w wo ww',                            '6 6de 06'],
                ['h hh',                               '3 03'],
                ['H HH',                               '15 15'],
                ['m mm',                               '25 25'],
                ['s ss',                               '50 50'],
                ['a A',                                'nm NM'],
                ['[the] DDDo [day of the year]',       'the 45ste day of the year'],
                ['LT',                                 '15:25'],
                ['LTS',                                '15:25:50'],
                ['L',                                  '14/02/2010'],
                ['LL',                                 '14 Februarie 2010'],
                ['LLL',                                '14 Februarie 2010 15:25'],
                ['LLLL',                               'Sondag, 14 Februarie 2010 15:25'],
                ['l',                                  '14/2/2010'],
                ['ll',                                 '14 Feb 2010'],
                ['lll',                                '14 Feb 2010 15:25'],
                ['llll',                               'Son, 14 Feb 2010 15:25']
            ],
            b = moment(new Date(2010, 1, 14, 15, 25, 50, 125)),
            i;
        for (i = 0; i < a.length; i++) {
            assert.equal(b.format(a[i][0]), a[i][1], a[i][0] + ' ---> ' + a[i][1]);
        }
    });

    test('format ordinal', function (assert) {
        assert.equal(moment([2011, 0, 1]).format('DDDo'), '1ste', '1ste');
        assert.equal(moment([2011, 0, 2]).format('DDDo'), '2de', '2de');
        assert.equal(moment([2011, 0, 3]).format('DDDo'), '3de', '3de');
        assert.equal(moment([2011, 0, 4]).format('DDDo'), '4de', '4de');
        assert.equal(moment([2011, 0, 5]).format('DDDo'), '5de', '5de');
        assert.equal(moment([2011, 0, 6]).format('DDDo'), '6de', '6de');
        assert.equal(moment([2011, 0, 7]).format('DDDo'), '7de', '7de');
        assert.equal(moment([2011, 0, 8]).format('DDDo'), '8ste', '8ste');
        assert.equal(moment([2011, 0, 9]).format('DDDo'), '9de', '9de');
        assert.equal(moment([2011, 0, 10]).format('DDDo'), '10de', '10de');

        assert.equal(moment([2011, 0, 11]).format('DDDo'), '11de', '11de');
        assert.equal(moment([2011, 0, 12]).format('DDDo'), '12de', '12de');
        assert.equal(moment([2011, 0, 13]).format('DDDo'), '13de', '13de');
        assert.equal(moment([2011, 0, 14]).format('DDDo'), '14de', '14de');
        assert.equal(moment([2011, 0, 15]).format('DDDo'), '15de', '15de');
        assert.equal(moment([2011, 0, 16]).format('DDDo'), '16de', '16de');
        assert.equal(moment([2011, 0, 17]).format('DDDo'), '17de', '17de');
        assert.equal(moment([2011, 0, 18]).format('DDDo'), '18de', '18de');
        assert.equal(moment([2011, 0, 19]).format('DDDo'), '19de', '19de');
        assert.equal(moment([2011, 0, 20]).format('DDDo'), '20ste', '20ste');

        assert.equal(moment([2011, 0, 21]).format('DDDo'), '21ste', '21ste');
        assert.equal(moment([2011, 0, 22]).format('DDDo'), '22ste', '22ste');
        assert.equal(moment([2011, 0, 23]).format('DDDo'), '23ste', '23ste');
        assert.equal(moment([2011, 0, 24]).format('DDDo'), '24ste', '24ste');
        assert.equal(moment([2011, 0, 25]).format('DDDo'), '25ste', '25ste');
        assert.equal(moment([2011, 0, 26]).format('DDDo'), '26ste', '26ste');
        assert.equal(moment([2011, 0, 27]).format('DDDo'), '27ste', '27ste');
        assert.equal(moment([2011, 0, 28]).format('DDDo'), '28ste', '28ste');
        assert.equal(moment([2011, 0, 29]).format('DDDo'), '29ste', '29ste');
        assert.equal(moment([2011, 0, 30]).format('DDDo'), '30ste', '30ste');

        assert.equal(moment([2011, 0, 31]).format('DDDo'), '31ste', '31ste');
    });

    test('format month', function (assert) {
        var expected = 'Januarie Jan_Februarie Feb_Maart Mar_April Apr_Mei Mei_Junie Jun_Julie Jul_Augustus Aug_September Sep_Oktober Okt_November Nov_Desember Des'.split('_'), i;
        for (i = 0; i < expected.length; i++) {
            assert.equal(moment([2011, i, 1]).format('MMMM MMM'), expected[i], expected[i]);
        }
    });

    test('format week', function (assert) {
        var expected = 'Sondag Son So_Maandag Maa Ma_Dinsdag Din Di_Woensdag Woe Wo_Donderdag Don Do_Vrydag Vry Vr_Saterdag Sat Sa'.split('_'), i;
        for (i = 0; i < expected.length; i++) {
            assert.equal(moment([2011, 0, 2 + i]).format('dddd ddd dd'), expected[i], expected[i]);
        }
    });

    test('from', function (assert) {
        var start = moment([2007, 1, 28]);
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 44}), true),  '\'n paar sekondes', '44 seconds = a few seconds');
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 45}), true),  '\'n minuut',      '45 seconds = a minute');
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 89}), true),  '\'n minuut',      '89 seconds = a minute');
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 90}), true),  '2 minute',     '90 seconds = 2 minutes');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 44}), true),  '44 minute',    '44 minutes = 44 minutes');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 45}), true),  '\'n uur',       '45 minutes = an hour');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 89}), true),  '\'n uur',       '89 minutes = an hour');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 90}), true),  '2 ure',       '90 minutes = 2 hours');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 5}), true),   '5 ure',       '5 hours = 5 hours');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 21}), true),  '21 ure',      '21 hours = 21 hours');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 22}), true),  '\'n dag',         '22 hours = a day');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 35}), true),  '\'n dag',         '35 hours = a day');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 36}), true),  '2 dae',        '36 hours = 2 days');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 1}), true),   '\'n dag',         '1 day = a day');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 5}), true),   '5 dae',        '5 days = 5 days');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 25}), true),  '25 dae',       '25 days = 25 days');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 26}), true),  '\'n maand',       '26 days = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 30}), true),  '\'n maand',       '30 days = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 43}), true),  '\'n maand',       '43 days = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 46}), true),  '2 maande',      '46 days = 2 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 74}), true),  '2 maande',      '75 days = 2 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 76}), true),  '3 maande',      '76 days = 3 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({M: 1}), true),   '\'n maand',       '1 month = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({M: 5}), true),   '5 maande',      '5 months = 5 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 345}), true), '\'n jaar',        '345 days = a year');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 548}), true), '2 jaar',       '548 days = 2 years');
        assert.equal(start.from(moment([2007, 1, 28]).add({y: 1}), true),   '\'n jaar',        '1 year = a year');
        assert.equal(start.from(moment([2007, 1, 28]).add({y: 5}), true),   '5 jaar',       '5 years = 5 years');
    });

    test('suffix', function (assert) {
        assert.equal(moment(30000).from(0), 'oor \'n paar sekondes',  'prefix');
        assert.equal(moment(0).from(30000), '\'n paar sekondes gelede', 'suffix');
    });

    test('now from now', function (assert) {
        assert.equal(moment().fromNow(), '\'n paar sekondes gelede',  'now from now should display as in the past');
    });

    test('fromNow', function (assert) {
        assert.equal(moment().add({s: 30}).fromNow(), 'oor \'n paar sekondes', 'in a few seconds');
        assert.equal(moment().add({d: 5}).fromNow(), 'oor 5 dae', 'in 5 days');
    });

    test('calendar day', function (assert) {
        var a = moment().hours(12).minutes(0).seconds(0);

        assert.equal(moment(a).calendar(),                   'Vandag om 12:00',     'today at the same time');
        assert.equal(moment(a).add({m: 25}).calendar(),      'Vandag om 12:25',     'Now plus 25 min');
        assert.equal(moment(a).add({h: 1}).calendar(),       'Vandag om 13:00',     'Now plus 1 hour');
        assert.equal(moment(a).add({d: 1}).calendar(),       'MÃ´re om 12:00',       'tomorrow at the same time');
        assert.equal(moment(a).subtract({h: 1}).calendar(),  'Vandag om 11:00',     'Now minus 1 hour');
        assert.equal(moment(a).subtract({d: 1}).calendar(),  'Gister om 12:00',     'yesterday at the same time');
    });

    test('calendar next week', function (assert) {
        var i, m;
        for (i = 2; i < 7; i++) {
            m = moment().add({d: i});
            assert.equal(m.calendar(),       m.format('dddd [om] LT'),  'Today + ' + i + ' days current time');
            m.hours(0).minutes(0).seconds(0).milliseconds(0);
            assert.equal(m.calendar(),       m.format('dddd [om] LT'),  'Today + ' + i + ' days beginning of day');
            m.hours(23).minutes(59).seconds(59).milliseconds(999);
            assert.equal(m.calendar(),       m.format('dddd [om] LT'),  'Today + ' + i + ' days end of day');
        }
    });

    test('calendar last week', function (assert) {
        var i, m;
        for (i = 2; i < 7; i++) {
            m = moment().subtract({d: i});
            assert.equal(m.calendar(),       m.format('[Laas] dddd [om] LT'),  'Today - ' + i + ' days current time');
            m.hours(0).minutes(0).seconds(0).milliseconds(0);
            assert.equal(m.calendar(),       m.format('[Laas] dddd [om] LT'),  'Today - ' + i + ' days beginning of day');
            m.hours(23).minutes(59).seconds(59).milliseconds(999);
            assert.equal(m.calendar(),       m.format('[Laas] dddd [om] LT'),  'Today - ' + i + ' days end of day');
        }
    });

    test('calendar all else', function (assert) {
        var weeksAgo = moment().subtract({w: 1}),
            weeksFromNow = moment().add({w: 1});

        assert.equal(weeksAgo.calendar(),       weeksAgo.format('L'),  '1 week ago');
        assert.equal(weeksFromNow.calendar(),   weeksFromNow.format('L'),  'in 1 week');

        weeksAgo = moment().subtract({w: 2});
        weeksFromNow = moment().add({w: 2});

        assert.equal(weeksAgo.calendar(),       weeksAgo.format('L'),  '2 weeks ago');
        assert.equal(weeksFromNow.calendar(),   weeksFromNow.format('L'),  'in 2 weeks');
    });

    test('weeks year starting sunday formatted', function (assert) {
        assert.equal(moment([2012, 0,  1]).format('w ww wo'), '52 52 52ste', 'Jan  1 2012 should be week 52');
        assert.equal(moment([2012, 0,  2]).format('w ww wo'),   '1 01 1ste', 'Jan  2 2012 should be week 1');
        assert.equal(moment([2012, 0,  8]).format('w ww wo'),   '1 01 1ste', 'Jan  8 2012 should be week 1');
        assert.equal(moment([2012, 0,  9]).format('w ww wo'),    '2 02 2de', 'Jan  9 2012 should be week 2');
        assert.equal(moment([2012, 0, 15]).format('w ww wo'),    '2 02 2de', 'Jan 15 2012 should be week 2');
    });

}));

;(function (global, factory) {
   typeof exports === 'object' && typeof module !== 'undefined'
       && typeof require === 'function' ? factory(require('../../moment')) :
   typeof define === 'function' && define.amd ? define(['../../moment'], factory) :
   factory(global.moment)
}(this, function (moment) { 'use strict';

    function each(array, callback) {
        var i;
        for (i = 0; i < array.length; i++) {
            callback(array[i], i, array);
        }
    }

    function objectKeys(obj) {
        if (Object.keys) {
            return Object.keys(obj);
        } else {
            // IE8
            var res = [], i;
            for (i in obj) {
                if (obj.hasOwnProperty(i)) {
                    res.push(i);
                }
            }
            return res;
        }
    }

    // Pick the first defined of two or three arguments.
    function defaults(a, b, c) {
        if (a != null) {
            return a;
        }
        if (b != null) {
            return b;
        }
        return c;
    }

    function defineCommonLocaleTests(locale, options) {
        test('lenient ordinal parsing', function (assert) {
            var i, ordinalStr, testMoment;
            for (i = 1; i <= 31; ++i) {
                ordinalStr = moment([2014, 0, i]).format('YYYY MM Do');
                testMoment = moment(ordinalStr, 'YYYY MM Do');
                assert.equal(testMoment.year(), 2014,
                        'lenient ordinal parsing ' + i + ' year check');
                assert.equal(testMoment.month(), 0,
                        'lenient ordinal parsing ' + i + ' month check');
                assert.equal(testMoment.date(), i,
                        'lenient ordinal parsing ' + i + ' date check');
            }
        });

        test('lenient ordinal parsing of number', function (assert) {
            var i, testMoment;
            for (i = 1; i <= 31; ++i) {
                testMoment = moment('2014 01 ' + i, 'YYYY MM Do');
                assert.equal(testMoment.year(), 2014,
                        'lenient ordinal parsing of number ' + i + ' year check');
                assert.equal(testMoment.month(), 0,
                        'lenient ordinal parsing of number ' + i + ' month check');
                assert.equal(testMoment.date(), i,
                        'lenient ordinal parsing of number ' + i + ' date check');
            }
        });

        test('strict ordinal parsing', function (assert) {
            var i, ordinalStr, testMoment;
            for (i = 1; i <= 31; ++i) {
                ordinalStr = moment([2014, 0, i]).format('YYYY MM Do');
                testMoment = moment(ordinalStr, 'YYYY MM Do', true);
                assert.ok(testMoment.isValid(), 'strict ordinal parsing ' + i);
            }
        });

        test('meridiem invariant', function (assert) {
            var h, m, t1, t2;
            for (h = 0; h < 24; ++h) {
                for (m = 0; m < 60; m += 15) {
                    t1 = moment.utc([2000, 0, 1, h, m]);
                    t2 = moment.utc(t1.format('A h:mm'), 'A h:mm');
                    assert.equal(t2.format('HH:mm'), t1.format('HH:mm'),
                            'meridiem at ' + t1.format('HH:mm'));
                }
            }
        });

        test('date format correctness', function (assert) {
            var data, tokens;
            data = moment.localeData()._longDateFormat;
            tokens = objectKeys(data);
            each(tokens, function (srchToken) {
                // Check each format string to make sure it does not contain any
                // tokens that need to be expanded.
                each(tokens, function (baseToken) {
                    // strip escaped sequences
                    var format = data[baseToken].replace(/(\[[^\]]*\])/g, '');
                    assert.equal(false, !!~format.indexOf(srchToken),
                            'contains ' + srchToken + ' in ' + baseToken);
                });
            });
        });

        test('month parsing correctness', function (assert) {
            var i, m;

            if (locale === 'tr') {
                // I can't fix it :(
                expect(0);
                return;
            }
            function tester(format) {
                var r;
                r = moment(m.format(format), format);
                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format);
                r = moment(m.format(format).toLocaleUpperCase(), format);
                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' upper');
                r = moment(m.format(format).toLocaleLowerCase(), format);
                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' lower');

                r = moment(m.format(format), format, true);
                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' strict');
                r = moment(m.format(format).toLocaleUpperCase(), format, true);
                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' upper strict');
                r = moment(m.format(format).toLocaleLowerCase(), format, true);
                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' lower strict');
            }

            for (i = 0; i < 12; ++i) {
                m = moment([2015, i, 15, 18]);
                tester('MMM');
                tester('MMM.');
                tester('MMMM');
                tester('MMMM.');
            }
        });

        test('weekday parsing correctness', function (assert) {
            var i, m;

            if (locale === 'tr' || locale === 'az') {
                // There is a lower-case letter (Ä±), that converted to upper then
                // lower changes to i
                expect(0);
                return;
            }
            function tester(format) {
                var r, baseMsg = 'weekday ' + m.weekday() + ' fmt ' + format;
                r = moment(m.format(format), format);
                assert.equal(r.weekday(), m.weekday(), baseMsg);
                r = moment(m.format(format).toLocaleUpperCase(), format);
                assert.equal(r.weekday(), m.weekday(), baseMsg + ' upper');
                r = moment(m.format(format).toLocaleLowerCase(), format);
                assert.equal(r.weekday(), m.weekday(), baseMsg + ' lower');

                r = moment(m.format(format), format, true);
                assert.equal(r.weekday(), m.weekday(), baseMsg + ' strict');
                r = moment(m.format(format).toLocaleUpperCase(), format, true);
                assert.equal(r.weekday(), m.weekday(), baseMsg + ' upper strict');
                r = moment(m.format(format).toLocaleLowerCase(), format, true);
                assert.equal(r.weekday(), m.weekday(), baseMsg + ' lower strict');
            }

            for (i = 0; i < 7; ++i) {
                m = moment.utc([2015, i, 15, 18]);
                tester('dd');
                tester('ddd');
                tester('dddd');
            }
        });
    }

    function setupDeprecationHandler(test, moment, scope) {
        test._expectedDeprecations = null;
        test._observedDeprecations = null;
        test._oldSupress = moment.suppressDeprecationWarnings;
        moment.suppressDeprecationWarnings = true;
        test.expectedDeprecations = function () {
            test._expectedDeprecations = arguments;
            test._observedDeprecations = [];
        };
        moment.deprecationHandler = function (name, msg) {
            var deprecationId = matchedDeprecation(name, msg, test._expectedDeprecations);
            if (deprecationId === -1) {
                throw new Error('Unexpected deprecation thrown name=' +
                        name + ' msg=' + msg);
            }
            test._observedDeprecations[deprecationId] = 1;
        };
    }

    function teardownDeprecationHandler(test, moment, scope) {
        moment.suppressDeprecationWarnings = test._oldSupress;

        if (test._expectedDeprecations != null) {
            var missedDeprecations = [];
            each(test._expectedDeprecations, function (deprecationPattern, id) {
                if (test._observedDeprecations[id] !== 1) {
                    missedDeprecations.push(deprecationPattern);
                }
            });
            if (missedDeprecations.length !== 0) {
                throw new Error('Expected deprecation warnings did not happen: ' +
                        missedDeprecations.join(' '));
            }
        }
    }

    function matchedDeprecation(name, msg, deprecations) {
        if (deprecations == null) {
            return -1;
        }
        for (var i = 0; i < deprecations.length; ++i) {
            if (name != null && name === deprecations[i]) {
                return i;
            }
            if (msg != null && msg.substring(0, deprecations[i].length) === deprecations[i]) {
                return i;
            }
        }
        return -1;
    }

    /*global QUnit:false*/

    var test = QUnit.test;

    var expect = QUnit.expect;

    function module (name, lifecycle) {
        QUnit.module(name, {
            setup : function () {
                moment.locale('en');
                moment.createFromInputFallback = function (config) {
                    throw new Error('input not handled by moment: ' + config._i);
                };
                setupDeprecationHandler(test, moment, 'core');
                if (lifecycle && lifecycle.setup) {
                    lifecycle.setup();
                }
            },
            teardown : function () {
                teardownDeprecationHandler(test, moment, 'core');
                if (lifecycle && lifecycle.teardown) {
                    lifecycle.teardown();
                }
            }
        });
    }

    function localeModule (name, lifecycle) {
        QUnit.module('locale:' + name, {
            setup : function () {
                moment.locale(name);
                moment.createFromInputFallback = function (config) {
                    throw new Error('input not handled by moment: ' + config._i);
                };
                setupDeprecationHandler(test, moment, 'locale');
                if (lifecycle && lifecycle.setup) {
                    lifecycle.setup();
                }
            },
            teardown : function () {
                moment.locale('en');
                teardownDeprecationHandler(test, moment, 'locale');
                if (lifecycle && lifecycle.teardown) {
                    lifecycle.teardown();
                }
            }
        });
        defineCommonLocaleTests(name, -1, -1);
    }

    localeModule('ar-ma');

    test('parse', function (assert) {
        var tests = 'ÙÙØ§ÙØ±:ÙÙØ§ÙØ±_ÙØ¨Ø±Ø§ÙØ±:ÙØ¨Ø±Ø§ÙØ±_ÙØ§Ø±Ø³:ÙØ§Ø±Ø³_Ø£Ø¨Ø±ÙÙ:Ø£Ø¨Ø±ÙÙ_ÙØ§Ù:ÙØ§Ù_ÙÙÙÙÙ:ÙÙÙÙÙ_ÙÙÙÙÙØ²:ÙÙÙÙÙØ²_ØºØ´Øª:ØºØ´Øª_Ø´ØªÙØ¨Ø±:Ø´ØªÙØ¨Ø±_Ø£ÙØªÙØ¨Ø±:Ø£ÙØªÙØ¨Ø±_ÙÙÙØ¨Ø±:ÙÙÙØ¨Ø±_Ø¯Ø¬ÙØ¨Ø±:Ø¯Ø¬ÙØ¨Ø±'.split('_'), i;
        function equalTest(input, mmm, i) {
            assert.equal(moment(input, mmm).month(), i, input + ' should be month ' + (i + 1));
        }
        for (i = 0; i < 12; i++) {
            tests[i] = tests[i].split(':');
            equalTest(tests[i][0], 'MMM', i);
            equalTest(tests[i][1], 'MMM', i);
            equalTest(tests[i][0], 'MMMM', i);
            equalTest(tests[i][1], 'MMMM', i);
            equalTest(tests[i][0].toLocaleLowerCase(), 'MMMM', i);
            equalTest(tests[i][1].toLocaleLowerCase(), 'MMMM', i);
            equalTest(tests[i][0].toLocaleUpperCase(), 'MMMM', i);
            equalTest(tests[i][1].toLocaleUpperCase(), 'MMMM', i);
        }
    });

    test('format', function (assert) {
        var a = [
                ['dddd, MMMM Do YYYY, h:mm:ss a',      'Ø§ÙØ£Ø­Ø¯, ÙØ¨Ø±Ø§ÙØ± 14 2010, 3:25:50 pm'],
                ['ddd, hA',                            'Ø§Ø­Ø¯, 3PM'],
                ['M Mo MM MMMM MMM',                   '2 2 02 ÙØ¨Ø±Ø§ÙØ± ÙØ¨Ø±Ø§ÙØ±'],
                ['YYYY YY',                            '2010 10'],
                ['D Do DD',                            '14 14 14'],
                ['d do dddd ddd dd',                   '0 0 Ø§ÙØ£Ø­Ø¯ Ø§Ø­Ø¯ Ø­'],
                ['DDD DDDo DDDD',                      '45 45 045'],
                ['w wo ww',                            '8 8 08'],
                ['h hh',                               '3 03'],
                ['H HH',                               '15 15'],
                ['m mm',                               '25 25'],
                ['s ss',                               '50 50'],
                ['a A',                                'pm PM'],
                ['[the] DDDo [day of the year]',       'the 45 day of the year'],
                ['LT',                                 '15:25'],
                ['LTS',                                '15:25:50'],
                ['L',                                  '14/02/2010'],
                ['LL',                                 '14 ÙØ¨Ø±Ø§ÙØ± 2010'],
                ['LLL',                                '14 ÙØ¨Ø±Ø§ÙØ± 2010 15:25'],
                ['LLLL',                               'Ø§ÙØ£Ø­Ø¯ 14 ÙØ¨Ø±Ø§ÙØ± 2010 15:25'],
                ['l',                                  '14/2/2010'],
                ['ll',                                 '14 ÙØ¨Ø±Ø§ÙØ± 2010'],
                ['lll',                                '14 ÙØ¨Ø±Ø§ÙØ± 2010 15:25'],
                ['llll',                               'Ø§Ø­Ø¯ 14 ÙØ¨Ø±Ø§ÙØ± 2010 15:25']
            ],
            b = moment(new Date(2010, 1, 14, 15, 25, 50, 125)),
            i;
        for (i = 0; i < a.length; i++) {
            assert.equal(b.format(a[i][0]), a[i][1], a[i][0] + ' ---> ' + a[i][1]);
        }
    });

    test('format ordinal', function (assert) {
        assert.equal(moment([2011, 0, 1]).format('DDDo'), '1', '1');
        assert.equal(moment([2011, 0, 2]).format('DDDo'), '2', '2');
        assert.equal(moment([2011, 0, 3]).format('DDDo'), '3', '3');
        assert.equal(moment([2011, 0, 4]).format('DDDo'), '4', '4');
        assert.equal(moment([2011, 0, 5]).format('DDDo'), '5', '5');
        assert.equal(moment([2011, 0, 6]).format('DDDo'), '6', '6');
        assert.equal(moment([2011, 0, 7]).format('DDDo'), '7', '7');
        assert.equal(moment([2011, 0, 8]).format('DDDo'), '8', '8');
        assert.equal(moment([2011, 0, 9]).format('DDDo'), '9', '9');
        assert.equal(moment([2011, 0, 10]).format('DDDo'), '10', '10');

        assert.equal(moment([2011, 0, 11]).format('DDDo'), '11', '11');
        assert.equal(moment([2011, 0, 12]).format('DDDo'), '12', '12');
        assert.equal(moment([2011, 0, 13]).format('DDDo'), '13', '13');
        assert.equal(moment([2011, 0, 14]).format('DDDo'), '14', '14');
        assert.equal(moment([2011, 0, 15]).format('DDDo'), '15', '15');
        assert.equal(moment([2011, 0, 16]).format('DDDo'), '16', '16');
        assert.equal(moment([2011, 0, 17]).format('DDDo'), '17', '17');
        assert.equal(moment([2011, 0, 18]).format('DDDo'), '18', '18');
        assert.equal(moment([2011, 0, 19]).format('DDDo'), '19', '19');
        assert.equal(moment([2011, 0, 20]).format('DDDo'), '20', '20');

        assert.equal(moment([2011, 0, 21]).format('DDDo'), '21', '21');
        assert.equal(moment([2011, 0, 22]).format('DDDo'), '22', '22');
        assert.equal(moment([2011, 0, 23]).format('DDDo'), '23', '23');
        assert.equal(moment([2011, 0, 24]).format('DDDo'), '24', '24');
        assert.equal(moment([2011, 0, 25]).format('DDDo'), '25', '25');
        assert.equal(moment([2011, 0, 26]).format('DDDo'), '26', '26');
        assert.equal(moment([2011, 0, 27]).format('DDDo'), '27', '27');
        assert.equal(moment([2011, 0, 28]).format('DDDo'), '28', '28');
        assert.equal(moment([2011, 0, 29]).format('DDDo'), '29', '29');
        assert.equal(moment([2011, 0, 30]).format('DDDo'), '30', '30');

        assert.equal(moment([2011, 0, 31]).format('DDDo'), '31', '31');
    });

    test('format month', function (assert) {
        var expected = 'ÙÙØ§ÙØ± ÙÙØ§ÙØ±_ÙØ¨Ø±Ø§ÙØ± ÙØ¨Ø±Ø§ÙØ±_ÙØ§Ø±Ø³ ÙØ§Ø±Ø³_Ø£Ø¨Ø±ÙÙ Ø£Ø¨Ø±ÙÙ_ÙØ§Ù ÙØ§Ù_ÙÙÙÙÙ ÙÙÙÙÙ_ÙÙÙÙÙØ² ÙÙÙÙÙØ²_ØºØ´Øª ØºØ´Øª_Ø´ØªÙØ¨Ø± Ø´ØªÙØ¨Ø±_Ø£ÙØªÙØ¨Ø± Ø£ÙØªÙØ¨Ø±_ÙÙÙØ¨Ø± ÙÙÙØ¨Ø±_Ø¯Ø¬ÙØ¨Ø± Ø¯Ø¬ÙØ¨Ø±'.split('_'), i;
        for (i = 0; i < expected.length; i++) {
            assert.equal(moment([2011, i, 1]).format('MMMM MMM'), expected[i], expected[i]);
        }
    });

    test('format week', function (assert) {
        var expected = 'Ø§ÙØ£Ø­Ø¯ Ø§Ø­Ø¯ Ø­_Ø§ÙØ¥ØªÙÙÙ Ø§ØªÙÙÙ Ù_Ø§ÙØ«ÙØ§Ø«Ø§Ø¡ Ø«ÙØ§Ø«Ø§Ø¡ Ø«_Ø§ÙØ£Ø±Ø¨Ø¹Ø§Ø¡ Ø§Ø±Ø¨Ø¹Ø§Ø¡ Ø±_Ø§ÙØ®ÙÙØ³ Ø®ÙÙØ³ Ø®_Ø§ÙØ¬ÙØ¹Ø© Ø¬ÙØ¹Ø© Ø¬_Ø§ÙØ³Ø¨Øª Ø³Ø¨Øª Ø³'.split('_'), i;
        for (i = 0; i < expected.length; i++) {
            assert.equal(moment([2011, 0, 2 + i]).format('dddd ddd dd'), expected[i], expected[i]);
        }
    });

    test('from', function (assert) {
        var start = moment([2007, 1, 28]);
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 44}), true),  'Ø«ÙØ§Ù', '44 seconds = a few seconds');
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 45}), true),  'Ø¯ÙÙÙØ©',      '45 seconds = a minute');
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 89}), true),  'Ø¯ÙÙÙØ©',      '89 seconds = a minute');
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 90}), true),  '2 Ø¯ÙØ§Ø¦Ù',     '90 seconds = 2 minutes');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 44}), true),  '44 Ø¯ÙØ§Ø¦Ù',    '44 minutes = 44 minutes');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 45}), true),  'Ø³Ø§Ø¹Ø©',       '45 minutes = an hour');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 89}), true),  'Ø³Ø§Ø¹Ø©',       '89 minutes = an hour');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 90}), true),  '2 Ø³Ø§Ø¹Ø§Øª',       '90 minutes = 2 hours');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 5}), true),   '5 Ø³Ø§Ø¹Ø§Øª',       '5 hours = 5 hours');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 21}), true),  '21 Ø³Ø§Ø¹Ø§Øª',      '21 hours = 21 hours');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 22}), true),  'ÙÙÙ',         '22 hours = a day');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 35}), true),  'ÙÙÙ',         '35 hours = a day');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 36}), true),  '2 Ø£ÙØ§Ù',        '36 hours = 2 days');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 1}), true),   'ÙÙÙ',         '1 day = a day');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 5}), true),   '5 Ø£ÙØ§Ù',        '5 days = 5 days');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 25}), true),  '25 Ø£ÙØ§Ù',       '25 days = 25 days');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 26}), true),  'Ø´ÙØ±',       '26 days = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 30}), true),  'Ø´ÙØ±',       '30 days = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 43}), true),  'Ø´ÙØ±',       '43 days = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 46}), true),  '2 Ø£Ø´ÙØ±',      '46 days = 2 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 74}), true),  '2 Ø£Ø´ÙØ±',      '75 days = 2 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 76}), true),  '3 Ø£Ø´ÙØ±',      '76 days = 3 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({M: 1}), true),   'Ø´ÙØ±',       '1 month = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({M: 5}), true),   '5 Ø£Ø´ÙØ±',      '5 months = 5 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 345}), true), 'Ø³ÙØ©',        '345 days = a year');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 548}), true), '2 Ø³ÙÙØ§Øª',       '548 days = 2 years');
        assert.equal(start.from(moment([2007, 1, 28]).add({y: 1}), true),   'Ø³ÙØ©',        '1 year = a year');
        assert.equal(start.from(moment([2007, 1, 28]).add({y: 5}), true),   '5 Ø³ÙÙØ§Øª',       '5 years = 5 years');
    });

    test('suffix', function (assert) {
        assert.equal(moment(30000).from(0), 'ÙÙ Ø«ÙØ§Ù',  'prefix');
        assert.equal(moment(0).from(30000), 'ÙÙØ° Ø«ÙØ§Ù', 'suffix');
    });

    test('now from now', function (assert) {
        assert.equal(moment().fromNow(), 'ÙÙØ° Ø«ÙØ§Ù',  'now from now should display as in the past');
    });

    test('fromNow', function (assert) {
        assert.equal(moment().add({s: 30}).fromNow(), 'ÙÙ Ø«ÙØ§Ù', 'in a few seconds');
        assert.equal(moment().add({d: 5}).fromNow(), 'ÙÙ 5 Ø£ÙØ§Ù', 'in 5 days');
    });

    test('calendar day', function (assert) {
        var a = moment().hours(12).minutes(0).seconds(0);

        assert.equal(moment(a).calendar(),                   'Ø§ÙÙÙÙ Ø¹ÙÙ Ø§ÙØ³Ø§Ø¹Ø© 12:00',     'today at the same time');
        assert.equal(moment(a).add({m: 25}).calendar(),      'Ø§ÙÙÙÙ Ø¹ÙÙ Ø§ÙØ³Ø§Ø¹Ø© 12:25',     'Now plus 25 min');
        assert.equal(moment(a).add({h: 1}).calendar(),       'Ø§ÙÙÙÙ Ø¹ÙÙ Ø§ÙØ³Ø§Ø¹Ø© 13:00',     'Now plus 1 hour');
        assert.equal(moment(a).add({d: 1}).calendar(),       'ØºØ¯Ø§ Ø¹ÙÙ Ø§ÙØ³Ø§Ø¹Ø© 12:00',      'tomorrow at the same time');
        assert.equal(moment(a).subtract({h: 1}).calendar(),  'Ø§ÙÙÙÙ Ø¹ÙÙ Ø§ÙØ³Ø§Ø¹Ø© 11:00',     'Now minus 1 hour');
        assert.equal(moment(a).subtract({d: 1}).calendar(),  'Ø£ÙØ³ Ø¹ÙÙ Ø§ÙØ³Ø§Ø¹Ø© 12:00',     'yesterday at the same time');
    });

    test('calendar next week', function (assert) {
        var i, m;
        for (i = 2; i < 7; i++) {
            m = moment().add({d: i});
            assert.equal(m.calendar(),       m.format('dddd [Ø¹ÙÙ Ø§ÙØ³Ø§Ø¹Ø©] LT'),  'Today + ' + i + ' days current time');
            m.hours(0).minutes(0).seconds(0).milliseconds(0);
            assert.equal(m.calendar(),       m.format('dddd [Ø¹ÙÙ Ø§ÙØ³Ø§Ø¹Ø©] LT'),  'Today + ' + i + ' days beginning of day');
            m.hours(23).minutes(59).seconds(59).milliseconds(999);
            assert.equal(m.calendar(),       m.format('dddd [Ø¹ÙÙ Ø§ÙØ³Ø§Ø¹Ø©] LT'),  'Today + ' + i + ' days end of day');
        }
    });

    test('calendar last week', function (assert) {
        var i, m;
        for (i = 2; i < 7; i++) {
            m = moment().subtract({d: i});
            assert.equal(m.calendar(),       m.format('dddd [Ø¹ÙÙ Ø§ÙØ³Ø§Ø¹Ø©] LT'),  'Today - ' + i + ' days current time');
            m.hours(0).minutes(0).seconds(0).milliseconds(0);
            assert.equal(m.calendar(),       m.format('dddd [Ø¹ÙÙ Ø§ÙØ³Ø§Ø¹Ø©] LT'),  'Today - ' + i + ' days beginning of day');
            m.hours(23).minutes(59).seconds(59).milliseconds(999);
            assert.equal(m.calendar(),       m.format('dddd [Ø¹ÙÙ Ø§ÙØ³Ø§Ø¹Ø©] LT'),  'Today - ' + i + ' days end of day');
        }
    });

    test('calendar all else', function (assert) {
        var weeksAgo = moment().subtract({w: 1}),
            weeksFromNow = moment().add({w: 1});

        assert.equal(weeksAgo.calendar(),       weeksAgo.format('L'),  '1 week ago');
        assert.equal(weeksFromNow.calendar(),   weeksFromNow.format('L'),  'in 1 week');

        weeksAgo = moment().subtract({w: 2});
        weeksFromNow = moment().add({w: 2});

        assert.equal(weeksAgo.calendar(),       weeksAgo.format('L'),  '2 weeks ago');
        assert.equal(weeksFromNow.calendar(),   weeksFromNow.format('L'),  'in 2 weeks');
    });

    test('weeks year starting sunday formatted', function (assert) {
        assert.equal(moment([2011, 11, 31]).format('w ww wo'), '1 01 1', 'Dec 31 2011 should be week 1');
        assert.equal(moment([2012,  0,  6]).format('w ww wo'), '1 01 1', 'Jan  6 2012 should be week 1');
        assert.equal(moment([2012,  0,  7]).format('w ww wo'), '2 02 2', 'Jan  7 2012 should be week 2');
        assert.equal(moment([2012,  0, 13]).format('w ww wo'), '2 02 2', 'Jan 13 2012 should be week 2');
        assert.equal(moment([2012,  0, 14]).format('w ww wo'), '3 03 3', 'Jan 14 2012 should be week 3');
    });

}));

;(function (global, factory) {
   typeof exports === 'object' && typeof module !== 'undefined'
       && typeof require === 'function' ? factory(require('../../moment')) :
   typeof define === 'function' && define.amd ? define(['../../moment'], factory) :
   factory(global.moment)
}(this, function (moment) { 'use strict';

    function each(array, callback) {
        var i;
        for (i = 0; i < array.length; i++) {
            callback(array[i], i, array);
        }
    }

    function objectKeys(obj) {
        if (Object.keys) {
            return Object.keys(obj);
        } else {
            // IE8
            var res = [], i;
            for (i in obj) {
                if (obj.hasOwnProperty(i)) {
                    res.push(i);
                }
            }
            return res;
        }
    }

    // Pick the first defined of two or three arguments.
    function defaults(a, b, c) {
        if (a != null) {
            return a;
        }
        if (b != null) {
            return b;
        }
        return c;
    }

    function defineCommonLocaleTests(locale, options) {
        test('lenient ordinal parsing', function (assert) {
            var i, ordinalStr, testMoment;
            for (i = 1; i <= 31; ++i) {
                ordinalStr = moment([2014, 0, i]).format('YYYY MM Do');
                testMoment = moment(ordinalStr, 'YYYY MM Do');
                assert.equal(testMoment.year(), 2014,
                        'lenient ordinal parsing ' + i + ' year check');
                assert.equal(testMoment.month(), 0,
                        'lenient ordinal parsing ' + i + ' month check');
                assert.equal(testMoment.date(), i,
                        'lenient ordinal parsing ' + i + ' date check');
            }
        });

        test('lenient ordinal parsing of number', function (assert) {
            var i, testMoment;
            for (i = 1; i <= 31; ++i) {
                testMoment = moment('2014 01 ' + i, 'YYYY MM Do');
                assert.equal(testMoment.year(), 2014,
                        'lenient ordinal parsing of number ' + i + ' year check');
                assert.equal(testMoment.month(), 0,
                        'lenient ordinal parsing of number ' + i + ' month check');
                assert.equal(testMoment.date(), i,
                        'lenient ordinal parsing of number ' + i + ' date check');
            }
        });

        test('strict ordinal parsing', function (assert) {
            var i, ordinalStr, testMoment;
            for (i = 1; i <= 31; ++i) {
                ordinalStr = moment([2014, 0, i]).format('YYYY MM Do');
                testMoment = moment(ordinalStr, 'YYYY MM Do', true);
                assert.ok(testMoment.isValid(), 'strict ordinal parsing ' + i);
            }
        });

        test('meridiem invariant', function (assert) {
            var h, m, t1, t2;
            for (h = 0; h < 24; ++h) {
                for (m = 0; m < 60; m += 15) {
                    t1 = moment.utc([2000, 0, 1, h, m]);
                    t2 = moment.utc(t1.format('A h:mm'), 'A h:mm');
                    assert.equal(t2.format('HH:mm'), t1.format('HH:mm'),
                            'meridiem at ' + t1.format('HH:mm'));
                }
            }
        });

        test('date format correctness', function (assert) {
            var data, tokens;
            data = moment.localeData()._longDateFormat;
            tokens = objectKeys(data);
            each(tokens, function (srchToken) {
                // Check each format string to make sure it does not contain any
                // tokens that need to be expanded.
                each(tokens, function (baseToken) {
                    // strip escaped sequences
                    var format = data[baseToken].replace(/(\[[^\]]*\])/g, '');
                    assert.equal(false, !!~format.indexOf(srchToken),
                            'contains ' + srchToken + ' in ' + baseToken);
                });
            });
        });

        test('month parsing correctness', function (assert) {
            var i, m;

            if (locale === 'tr') {
                // I can't fix it :(
                expect(0);
                return;
            }
            function tester(format) {
                var r;
                r = moment(m.format(format), format);
                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format);
                r = moment(m.format(format).toLocaleUpperCase(), format);
                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' upper');
                r = moment(m.format(format).toLocaleLowerCase(), format);
                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' lower');

                r = moment(m.format(format), format, true);
                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' strict');
                r = moment(m.format(format).toLocaleUpperCase(), format, true);
                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' upper strict');
                r = moment(m.format(format).toLocaleLowerCase(), format, true);
                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' lower strict');
            }

            for (i = 0; i < 12; ++i) {
                m = moment([2015, i, 15, 18]);
                tester('MMM');
                tester('MMM.');
                tester('MMMM');
                tester('MMMM.');
            }
        });

        test('weekday parsing correctness', function (assert) {
            var i, m;

            if (locale === 'tr' || locale === 'az') {
                // There is a lower-case letter (Ä±), that converted to upper then
                // lower changes to i
                expect(0);
                return;
            }
            function tester(format) {
                var r, baseMsg = 'weekday ' + m.weekday() + ' fmt ' + format;
                r = moment(m.format(format), format);
                assert.equal(r.weekday(), m.weekday(), baseMsg);
                r = moment(m.format(format).toLocaleUpperCase(), format);
                assert.equal(r.weekday(), m.weekday(), baseMsg + ' upper');
                r = moment(m.format(format).toLocaleLowerCase(), format);
                assert.equal(r.weekday(), m.weekday(), baseMsg + ' lower');

                r = moment(m.format(format), format, true);
                assert.equal(r.weekday(), m.weekday(), baseMsg + ' strict');
                r = moment(m.format(format).toLocaleUpperCase(), format, true);
                assert.equal(r.weekday(), m.weekday(), baseMsg + ' upper strict');
                r = moment(m.format(format).toLocaleLowerCase(), format, true);
                assert.equal(r.weekday(), m.weekday(), baseMsg + ' lower strict');
            }

            for (i = 0; i < 7; ++i) {
                m = moment.utc([2015, i, 15, 18]);
                tester('dd');
                tester('ddd');
                tester('dddd');
            }
        });
    }

    function setupDeprecationHandler(test, moment, scope) {
        test._expectedDeprecations = null;
        test._observedDeprecations = null;
        test._oldSupress = moment.suppressDeprecationWarnings;
        moment.suppressDeprecationWarnings = true;
        test.expectedDeprecations = function () {
            test._expectedDeprecations = arguments;
            test._observedDeprecations = [];
        };
        moment.deprecationHandler = function (name, msg) {
            var deprecationId = matchedDeprecation(name, msg, test._expectedDeprecations);
            if (deprecationId === -1) {
                throw new Error('Unexpected deprecation thrown name=' +
                        name + ' msg=' + msg);
            }
            test._observedDeprecations[deprecationId] = 1;
        };
    }

    function teardownDeprecationHandler(test, moment, scope) {
        moment.suppressDeprecationWarnings = test._oldSupress;

        if (test._expectedDeprecations != null) {
            var missedDeprecations = [];
            each(test._expectedDeprecations, function (deprecationPattern, id) {
                if (test._observedDeprecations[id] !== 1) {
                    missedDeprecations.push(deprecationPattern);
                }
            });
            if (missedDeprecations.length !== 0) {
                throw new Error('Expected deprecation warnings did not happen: ' +
                        missedDeprecations.join(' '));
            }
        }
    }

    function matchedDeprecation(name, msg, deprecations) {
        if (deprecations == null) {
            return -1;
        }
        for (var i = 0; i < deprecations.length; ++i) {
            if (name != null && name === deprecations[i]) {
                return i;
            }
            if (msg != null && msg.substring(0, deprecations[i].length) === deprecations[i]) {
                return i;
            }
        }
        return -1;
    }

    /*global QUnit:false*/

    var test = QUnit.test;

    var expect = QUnit.expect;

    function module (name, lifecycle) {
        QUnit.module(name, {
            setup : function () {
                moment.locale('en');
                moment.createFromInputFallback = function (config) {
                    throw new Error('input not handled by moment: ' + config._i);
                };
                setupDeprecationHandler(test, moment, 'core');
                if (lifecycle && lifecycle.setup) {
                    lifecycle.setup();
                }
            },
            teardown : function () {
                teardownDeprecationHandler(test, moment, 'core');
                if (lifecycle && lifecycle.teardown) {
                    lifecycle.teardown();
                }
            }
        });
    }

    function localeModule (name, lifecycle) {
        QUnit.module('locale:' + name, {
            setup : function () {
                moment.locale(name);
                moment.createFromInputFallback = function (config) {
                    throw new Error('input not handled by moment: ' + config._i);
                };
                setupDeprecationHandler(test, moment, 'locale');
                if (lifecycle && lifecycle.setup) {
                    lifecycle.setup();
                }
            },
            teardown : function () {
                moment.locale('en');
                teardownDeprecationHandler(test, moment, 'locale');
                if (lifecycle && lifecycle.teardown) {
                    lifecycle.teardown();
                }
            }
        });
        defineCommonLocaleTests(name, -1, -1);
    }

    localeModule('ar-sa');

    test('parse', function (assert) {
        var tests = 'ÙÙØ§ÙØ±:ÙÙØ§ÙØ±_ÙØ¨Ø±Ø§ÙØ±:ÙØ¨Ø±Ø§ÙØ±_ÙØ§Ø±Ø³:ÙØ§Ø±Ø³_Ø£Ø¨Ø±ÙÙ:Ø£Ø¨Ø±ÙÙ_ÙØ§ÙÙ:ÙØ§ÙÙ_ÙÙÙÙÙ:ÙÙÙÙÙ_ÙÙÙÙÙ:ÙÙÙÙÙ_Ø£ØºØ³Ø·Ø³:Ø£ØºØ³Ø·Ø³_Ø³Ø¨ØªÙØ¨Ø±:Ø³Ø¨ØªÙØ¨Ø±_Ø£ÙØªÙØ¨Ø±:Ø£ÙØªÙØ¨Ø±_ÙÙÙÙØ¨Ø±:ÙÙÙÙØ¨Ø±_Ø¯ÙØ³ÙØ¨Ø±:Ø¯ÙØ³ÙØ¨Ø±'.split('_'), i;
        function equalTest(input, mmm, i) {
            assert.equal(moment(input, mmm).month(), i, input + ' should be month ' + (i + 1) + ' instead is month ' + moment(input, mmm).month());
        }
        for (i = 0; i < 12; i++) {
            tests[i] = tests[i].split(':');
            equalTest(tests[i][0], 'MMM', i);
            equalTest(tests[i][1], 'MMM', i);
            equalTest(tests[i][0], 'MMMM', i);
            equalTest(tests[i][1], 'MMMM', i);
            equalTest(tests[i][0].toLocaleLowerCase(), 'MMMM', i);
            equalTest(tests[i][1].toLocaleLowerCase(), 'MMMM', i);
            equalTest(tests[i][0].toLocaleUpperCase(), 'MMMM', i);
            equalTest(tests[i][1].toLocaleUpperCase(), 'MMMM', i);
        }
    });

    test('format', function (assert) {
        var a = [
                ['dddd, MMMM Do YYYY, h:mm:ss a',      'Ø§ÙØ£Ø­Ø¯Ø ÙØ¨Ø±Ø§ÙØ± Ù¡Ù¤ Ù¢Ù Ù¡Ù Ø Ù£:Ù¢Ù¥:Ù¥Ù  Ù'],
                ['ddd, hA',                            'Ø£Ø­Ø¯Ø Ù£Ù'],
                ['M Mo MM MMMM MMM',                   'Ù¢ Ù¢ Ù Ù¢ ÙØ¨Ø±Ø§ÙØ± ÙØ¨Ø±Ø§ÙØ±'],
                ['YYYY YY',                            'Ù¢Ù Ù¡Ù  Ù¡Ù '],
                ['D Do DD',                            'Ù¡Ù¤ Ù¡Ù¤ Ù¡Ù¤'],
                ['d do dddd ddd dd',                   'Ù  Ù  Ø§ÙØ£Ø­Ø¯ Ø£Ø­Ø¯ Ø­'],
                ['DDD DDDo DDDD',                      'Ù¤Ù¥ Ù¤Ù¥ Ù Ù¤Ù¥'],
                ['w wo ww',                            'Ù¨ Ù¨ Ù Ù¨'],
                ['h hh',                               'Ù£ Ù Ù£'],
                ['H HH',                               'Ù¡Ù¥ Ù¡Ù¥'],
                ['m mm',                               'Ù¢Ù¥ Ù¢Ù¥'],
                ['s ss',                               'Ù¥Ù  Ù¥Ù '],
                ['a A',                                'Ù Ù'],
                ['[the] DDDo [day of the year]',       'the Ù¤Ù¥ day of the year'],
                ['LT',                                 'Ù¡Ù¥:Ù¢Ù¥'],
                ['LTS',                                'Ù¡Ù¥:Ù¢Ù¥:Ù¥Ù '],
                ['L',                                  'Ù¡Ù¤/Ù Ù¢/Ù¢Ù Ù¡Ù '],
                ['LL',                                 'Ù¡Ù¤ ÙØ¨Ø±Ø§ÙØ± Ù¢Ù Ù¡Ù '],
                ['LLL',                                'Ù¡Ù¤ ÙØ¨Ø±Ø§ÙØ± Ù¢Ù Ù¡Ù  Ù¡Ù¥:Ù¢Ù¥'],
                ['LLLL',                               'Ø§ÙØ£Ø­Ø¯ Ù¡Ù¤ ÙØ¨Ø±Ø§ÙØ± Ù¢Ù Ù¡Ù  Ù¡Ù¥:Ù¢Ù¥'],
                ['l',                                  'Ù¡Ù¤/Ù¢/Ù¢Ù Ù¡Ù '],
                ['ll',                                 'Ù¡Ù¤ ÙØ¨Ø±Ø§ÙØ± Ù¢Ù Ù¡Ù '],
                ['lll',                                'Ù¡Ù¤ ÙØ¨Ø±Ø§ÙØ± Ù¢Ù Ù¡Ù  Ù¡Ù¥:Ù¢Ù¥'],
                ['llll',                               'Ø£Ø­Ø¯ Ù¡Ù¤ ÙØ¨Ø±Ø§ÙØ± Ù¢Ù Ù¡Ù  Ù¡Ù¥:Ù¢Ù¥']
            ],
            b = moment(new Date(2010, 1, 14, 15, 25, 50, 125)),
            i;
        for (i = 0; i < a.length; i++) {
            assert.equal(b.format(a[i][0]), a[i][1], a[i][0] + ' ---> ' + a[i][1]);
        }
    });

    test('format ordinal', function (assert) {
        assert.equal(moment([2011, 0, 1]).format('DDDo'), 'Ù¡', '1');
        assert.equal(moment([2011, 0, 2]).format('DDDo'), 'Ù¢', '2');
        assert.equal(moment([2011, 0, 3]).format('DDDo'), 'Ù£', '3');
        assert.equal(moment([2011, 0, 4]).format('DDDo'), 'Ù¤', '4');
        assert.equal(moment([2011, 0, 5]).format('DDDo'), 'Ù¥', '5');
        assert.equal(moment([2011, 0, 6]).format('DDDo'), 'Ù¦', '6');
        assert.equal(moment([2011, 0, 7]).format('DDDo'), 'Ù§', '7');
        assert.equal(moment([2011, 0, 8]).format('DDDo'), 'Ù¨', '8');
        assert.equal(moment([2011, 0, 9]).format('DDDo'), 'Ù©', '9');
        assert.equal(moment([2011, 0, 10]).format('DDDo'), 'Ù¡Ù ', '10');

        assert.equal(moment([2011, 0, 11]).format('DDDo'), 'Ù¡Ù¡', '11');
        assert.equal(moment([2011, 0, 12]).format('DDDo'), 'Ù¡Ù¢', '12');
        assert.equal(moment([2011, 0, 13]).format('DDDo'), 'Ù¡Ù£', '13');
        assert.equal(moment([2011, 0, 14]).format('DDDo'), 'Ù¡Ù¤', '14');
        assert.equal(moment([2011, 0, 15]).format('DDDo'), 'Ù¡Ù¥', '15');
        assert.equal(moment([2011, 0, 16]).format('DDDo'), 'Ù¡Ù¦', '16');
        assert.equal(moment([2011, 0, 17]).format('DDDo'), 'Ù¡Ù§', '17');
        assert.equal(moment([2011, 0, 18]).format('DDDo'), 'Ù¡Ù¨', '18');
        assert.equal(moment([2011, 0, 19]).format('DDDo'), 'Ù¡Ù©', '19');
        assert.equal(moment([2011, 0, 20]).format('DDDo'), 'Ù¢Ù ', '20');

        assert.equal(moment([2011, 0, 21]).format('DDDo'), 'Ù¢Ù¡', '21');
        assert.equal(moment([2011, 0, 22]).format('DDDo'), 'Ù¢Ù¢', '22');
        assert.equal(moment([2011, 0, 23]).format('DDDo'), 'Ù¢Ù£', '23');
        assert.equal(moment([2011, 0, 24]).format('DDDo'), 'Ù¢Ù¤', '24');
        assert.equal(moment([2011, 0, 25]).format('DDDo'), 'Ù¢Ù¥', '25');
        assert.equal(moment([2011, 0, 26]).format('DDDo'), 'Ù¢Ù¦', '26');
        assert.equal(moment([2011, 0, 27]).format('DDDo'), 'Ù¢Ù§', '27');
        assert.equal(moment([2011, 0, 28]).format('DDDo'), 'Ù¢Ù¨', '28');
        assert.equal(moment([2011, 0, 29]).format('DDDo'), 'Ù¢Ù©', '29');
        assert.equal(moment([2011, 0, 30]).format('DDDo'), 'Ù£Ù ', '30');

        assert.equal(moment([2011, 0, 31]).format('DDDo'), 'Ù£Ù¡', '31');
    });

    test('format month', function (assert) {
        var expected = 'ÙÙØ§ÙØ± ÙÙØ§ÙØ±_ÙØ¨Ø±Ø§ÙØ± ÙØ¨Ø±Ø§ÙØ±_ÙØ§Ø±Ø³ ÙØ§Ø±Ø³_Ø£Ø¨Ø±ÙÙ Ø£Ø¨Ø±ÙÙ_ÙØ§ÙÙ ÙØ§ÙÙ_ÙÙÙÙÙ ÙÙÙÙÙ_ÙÙÙÙÙ ÙÙÙÙÙ_Ø£ØºØ³Ø·Ø³ Ø£ØºØ³Ø·Ø³_Ø³Ø¨ØªÙØ¨Ø± Ø³Ø¨ØªÙØ¨Ø±_Ø£ÙØªÙØ¨Ø± Ø£ÙØªÙØ¨Ø±_ÙÙÙÙØ¨Ø± ÙÙÙÙØ¨Ø±_Ø¯ÙØ³ÙØ¨Ø± Ø¯ÙØ³ÙØ¨Ø±'.split('_'), i;
        for (i = 0; i < expected.length; i++) {
            assert.equal(moment([2011, i, 1]).format('MMMM MMM'), expected[i], expected[i]);
        }
    });

    test('format week', function (assert) {
        var expected = 'Ø§ÙØ£Ø­Ø¯ Ø£Ø­Ø¯ Ø­_Ø§ÙØ¥Ø«ÙÙÙ Ø¥Ø«ÙÙÙ Ù_Ø§ÙØ«ÙØ§Ø«Ø§Ø¡ Ø«ÙØ§Ø«Ø§Ø¡ Ø«_Ø§ÙØ£Ø±Ø¨Ø¹Ø§Ø¡ Ø£Ø±Ø¨Ø¹Ø§Ø¡ Ø±_Ø§ÙØ®ÙÙØ³ Ø®ÙÙØ³ Ø®_Ø§ÙØ¬ÙØ¹Ø© Ø¬ÙØ¹Ø© Ø¬_Ø§ÙØ³Ø¨Øª Ø³Ø¨Øª Ø³'.split('_'), i;
        for (i = 0; i < expected.length; i++) {
            assert.equal(moment([2011, 0, 2 + i]).format('dddd ddd dd'), expected[i], expected[i]);
        }
    });

    test('from', function (assert) {
        var start = moment([2007, 1, 28]);
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 44}), true),  'Ø«ÙØ§Ù', '44 seconds = a few seconds');
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 45}), true),  'Ø¯ÙÙÙØ©',      '45 seconds = a minute');
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 89}), true),  'Ø¯ÙÙÙØ©',      '89 seconds = a minute');
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 90}), true),  'Ù¢ Ø¯ÙØ§Ø¦Ù',     '90 seconds = 2 minutes');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 44}), true),  'Ù¤Ù¤ Ø¯ÙØ§Ø¦Ù',    '44 minutes = 44 minutes');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 45}), true),  'Ø³Ø§Ø¹Ø©',       '45 minutes = an hour');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 89}), true),  'Ø³Ø§Ø¹Ø©',       '89 minutes = an hour');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 90}), true),  'Ù¢ Ø³Ø§Ø¹Ø§Øª',       '90 minutes = 2 hours');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 5}), true),   'Ù¥ Ø³Ø§Ø¹Ø§Øª',       '5 hours = 5 hours');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 21}), true),  'Ù¢Ù¡ Ø³Ø§Ø¹Ø§Øª',      '21 hours = 21 hours');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 22}), true),  'ÙÙÙ',         '22 hours = a day');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 35}), true),  'ÙÙÙ',         '35 hours = a day');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 36}), true),  'Ù¢ Ø£ÙØ§Ù',        '36 hours = 2 days');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 1}), true),   'ÙÙÙ',         '1 day = a day');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 5}), true),   'Ù¥ Ø£ÙØ§Ù',        '5 days = 5 days');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 25}), true),  'Ù¢Ù¥ Ø£ÙØ§Ù',       '25 days = 25 days');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 26}), true),  'Ø´ÙØ±',       '26 days = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 30}), true),  'Ø´ÙØ±',       '30 days = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 43}), true),  'Ø´ÙØ±',       '43 days = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 46}), true),  'Ù¢ Ø£Ø´ÙØ±',      '46 days = 2 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 74}), true),  'Ù¢ Ø£Ø´ÙØ±',      '75 days = 2 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 76}), true),  'Ù£ Ø£Ø´ÙØ±',      '76 days = 3 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({M: 1}), true),   'Ø´ÙØ±',       '1 month = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({M: 5}), true),   'Ù¥ Ø£Ø´ÙØ±',      '5 months = 5 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 345}), true), 'Ø³ÙØ©',        '345 days = a year');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 548}), true), 'Ù¢ Ø³ÙÙØ§Øª',       '548 days = 2 years');
        assert.equal(start.from(moment([2007, 1, 28]).add({y: 1}), true),   'Ø³ÙØ©',        '1 year = a year');
        assert.equal(start.from(moment([2007, 1, 28]).add({y: 5}), true),   'Ù¥ Ø³ÙÙØ§Øª',       '5 years = 5 years');
    });

    test('suffix', function (assert) {
        assert.equal(moment(30000).from(0), 'ÙÙ Ø«ÙØ§Ù',  'prefix');
        assert.equal(moment(0).from(30000), 'ÙÙØ° Ø«ÙØ§Ù', 'suffix');
    });

    test('now from now', function (assert) {
        assert.equal(moment().fromNow(), 'ÙÙØ° Ø«ÙØ§Ù',  'now from now should display as in the past');
    });

    test('fromNow', function (assert) {
        assert.equal(moment().add({s: 30}).fromNow(), 'ÙÙ Ø«ÙØ§Ù', 'in a few seconds');
        assert.equal(moment().add({d: 5}).fromNow(), 'ÙÙ Ù¥ Ø£ÙØ§Ù', 'in 5 days');
    });

    test('calendar day', function (assert) {
        var a = moment().hours(12).minutes(0).seconds(0);

        assert.equal(moment(a).calendar(),                   'Ø§ÙÙÙÙ Ø¹ÙÙ Ø§ÙØ³Ø§Ø¹Ø© Ù¡Ù¢:Ù Ù ',     'today at the same time');
        assert.equal(moment(a).add({m: 25}).calendar(),      'Ø§ÙÙÙÙ Ø¹ÙÙ Ø§ÙØ³Ø§Ø¹Ø© Ù¡Ù¢:Ù¢Ù¥',     'Now plus 25 min');
        assert.equal(moment(a).add({h: 1}).calendar(),       'Ø§ÙÙÙÙ Ø¹ÙÙ Ø§ÙØ³Ø§Ø¹Ø© Ù¡Ù£:Ù Ù ',     'Now plus 1 hour');
        assert.equal(moment(a).add({d: 1}).calendar(),       'ØºØ¯Ø§ Ø¹ÙÙ Ø§ÙØ³Ø§Ø¹Ø© Ù¡Ù¢:Ù Ù ',       'tomorrow at the same time');
        assert.equal(moment(a).subtract({h: 1}).calendar(),  'Ø§ÙÙÙÙ Ø¹ÙÙ Ø§ÙØ³Ø§Ø¹Ø© Ù¡Ù¡:Ù Ù ',     'Now minus 1 hour');
        assert.equal(moment(a).subtract({d: 1}).calendar(),  'Ø£ÙØ³ Ø¹ÙÙ Ø§ÙØ³Ø§Ø¹Ø© Ù¡Ù¢:Ù Ù ',      'yesterday at the same time');
    });

    test('calendar next week', function (assert) {
        var i, m;
        for (i = 2; i < 7; i++) {
            m = moment().add({d: i});
            assert.equal(m.calendar(),       m.format('dddd [Ø¹ÙÙ Ø§ÙØ³Ø§Ø¹Ø©] LT'),  'Today + ' + i + ' days current time');
            m.hours(0).minutes(0).seconds(0).milliseconds(0);
            assert.equal(m.calendar(),       m.format('dddd [Ø¹ÙÙ Ø§ÙØ³Ø§Ø¹Ø©] LT'),  'Today + ' + i + ' days beginning of day');
            m.hours(23).minutes(59).seconds(59).milliseconds(999);
            assert.equal(m.calendar(),       m.format('dddd [Ø¹ÙÙ Ø§ÙØ³Ø§Ø¹Ø©] LT'),  'Today + ' + i + ' days end of day');
        }
    });

    test('calendar last week', function (assert) {
        var i, m;
        for (i = 2; i < 7; i++) {
            m = moment().subtract({d: i});
            assert.equal(m.calendar(),       m.format('dddd [Ø¹ÙÙ Ø§ÙØ³Ø§Ø¹Ø©] LT'),  'Today - ' + i + ' days current time');
            m.hours(0).minutes(0).seconds(0).milliseconds(0);
            assert.equal(m.calendar(),       m.format('dddd [Ø¹ÙÙ Ø§ÙØ³Ø§Ø¹Ø©] LT'),  'Today - ' + i + ' days beginning of day');
            m.hours(23).minutes(59).seconds(59).milliseconds(999);
            assert.equal(m.calendar(),       m.format('dddd [Ø¹ÙÙ Ø§ÙØ³Ø§Ø¹Ø©] LT'),  'Today - ' + i + ' days end of day');
        }
    });

    test('calendar all else', function (assert) {
        var weeksAgo = moment().subtract({w: 1}),
            weeksFromNow = moment().add({w: 1});

        assert.equal(weeksAgo.calendar(),       weeksAgo.format('L'),  '1 week ago');
        assert.equal(weeksFromNow.calendar(),   weeksFromNow.format('L'),  'in 1 week');

        weeksAgo = moment().subtract({w: 2});
        weeksFromNow = moment().add({w: 2});

        assert.equal(weeksAgo.calendar(),       weeksAgo.format('L'),  '2 weeks ago');
        assert.equal(weeksFromNow.calendar(),   weeksFromNow.format('L'),  'in 2 weeks');
    });

    test('weeks year starting wednesday custom', function (assert) {
        assert.equal(moment('2003 1 6', 'gggg w d').format('YYYY-MM-DD'), 'Ù¢Ù Ù Ù¢-Ù¡Ù¢-Ù¢Ù¨', 'Week 1 of 2003 should be Dec 28 2002');
        assert.equal(moment('2003 1 0', 'gggg w e').format('YYYY-MM-DD'), 'Ù¢Ù Ù Ù¢-Ù¡Ù¢-Ù¢Ù¨', 'Week 1 of 2003 should be Dec 28 2002');
        assert.equal(moment('2003 1 6', 'gggg w d').format('gggg w d'), 'Ù¢Ù Ù Ù£ Ù¡ Ù¦', 'Saturday of week 1 of 2003 parsed should be formatted as 2003 1 6');
        assert.equal(moment('2003 1 0', 'gggg w e').format('gggg w e'), 'Ù¢Ù Ù Ù£ Ù¡ Ù ', '1st day of week 1 of 2003 parsed should be formatted as 2003 1 0');
    });

    test('weeks year starting sunday formatted', function (assert) {
        assert.equal(moment([2011, 11, 31]).format('w ww wo'), 'Ù¡ Ù Ù¡ Ù¡', 'Dec 31 2011 should be week 1');
        assert.equal(moment([2012,  0,  6]).format('w ww wo'), 'Ù¡ Ù Ù¡ Ù¡', 'Jan  6 2012 should be week 1');
        assert.equal(moment([2012,  0,  7]).format('w ww wo'), 'Ù¢ Ù Ù¢ Ù¢', 'Jan  7 2012 should be week 2');
        assert.equal(moment([2012,  0, 13]).format('w ww wo'), 'Ù¢ Ù Ù¢ Ù¢', 'Jan 13 2012 should be week 2');
        assert.equal(moment([2012,  0, 14]).format('w ww wo'), 'Ù£ Ù Ù£ Ù£', 'Jan 14 2012 should be week 3');
    });

}));

;(function (global, factory) {
   typeof exports === 'object' && typeof module !== 'undefined'
       && typeof require === 'function' ? factory(require('../../moment')) :
   typeof define === 'function' && define.amd ? define(['../../moment'], factory) :
   factory(global.moment)
}(this, function (moment) { 'use strict';

    function each(array, callback) {
        var i;
        for (i = 0; i < array.length; i++) {
            callback(array[i], i, array);
        }
    }

    function objectKeys(obj) {
        if (Object.keys) {
            return Object.keys(obj);
        } else {
            // IE8
            var res = [], i;
            for (i in obj) {
                if (obj.hasOwnProperty(i)) {
                    res.push(i);
                }
            }
            return res;
        }
    }

    // Pick the first defined of two or three arguments.
    function defaults(a, b, c) {
        if (a != null) {
            return a;
        }
        if (b != null) {
            return b;
        }
        return c;
    }

    function defineCommonLocaleTests(locale, options) {
        test('lenient ordinal parsing', function (assert) {
            var i, ordinalStr, testMoment;
            for (i = 1; i <= 31; ++i) {
                ordinalStr = moment([2014, 0, i]).format('YYYY MM Do');
                testMoment = moment(ordinalStr, 'YYYY MM Do');
                assert.equal(testMoment.year(), 2014,
                        'lenient ordinal parsing ' + i + ' year check');
                assert.equal(testMoment.month(), 0,
                        'lenient ordinal parsing ' + i + ' month check');
                assert.equal(testMoment.date(), i,
                        'lenient ordinal parsing ' + i + ' date check');
            }
        });

        test('lenient ordinal parsing of number', function (assert) {
            var i, testMoment;
            for (i = 1; i <= 31; ++i) {
                testMoment = moment('2014 01 ' + i, 'YYYY MM Do');
                assert.equal(testMoment.year(), 2014,
                        'lenient ordinal parsing of number ' + i + ' year check');
                assert.equal(testMoment.month(), 0,
                        'lenient ordinal parsing of number ' + i + ' month check');
                assert.equal(testMoment.date(), i,
                        'lenient ordinal parsing of number ' + i + ' date check');
            }
        });

        test('strict ordinal parsing', function (assert) {
            var i, ordinalStr, testMoment;
            for (i = 1; i <= 31; ++i) {
                ordinalStr = moment([2014, 0, i]).format('YYYY MM Do');
                testMoment = moment(ordinalStr, 'YYYY MM Do', true);
                assert.ok(testMoment.isValid(), 'strict ordinal parsing ' + i);
            }
        });

        test('meridiem invariant', function (assert) {
            var h, m, t1, t2;
            for (h = 0; h < 24; ++h) {
                for (m = 0; m < 60; m += 15) {
                    t1 = moment.utc([2000, 0, 1, h, m]);
                    t2 = moment.utc(t1.format('A h:mm'), 'A h:mm');
                    assert.equal(t2.format('HH:mm'), t1.format('HH:mm'),
                            'meridiem at ' + t1.format('HH:mm'));
                }
            }
        });

        test('date format correctness', function (assert) {
            var data, tokens;
            data = moment.localeData()._longDateFormat;
            tokens = objectKeys(data);
            each(tokens, function (srchToken) {
                // Check each format string to make sure it does not contain any
                // tokens that need to be expanded.
                each(tokens, function (baseToken) {
                    // strip escaped sequences
                    var format = data[baseToken].replace(/(\[[^\]]*\])/g, '');
                    assert.equal(false, !!~format.indexOf(srchToken),
                            'contains ' + srchToken + ' in ' + baseToken);
                });
            });
        });

        test('month parsing correctness', function (assert) {
            var i, m;

            if (locale === 'tr') {
                // I can't fix it :(
                expect(0);
                return;
            }
            function tester(format) {
                var r;
                r = moment(m.format(format), format);
                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format);
                r = moment(m.format(format).toLocaleUpperCase(), format);
                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' upper');
                r = moment(m.format(format).toLocaleLowerCase(), format);
                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' lower');

                r = moment(m.format(format), format, true);
                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' strict');
                r = moment(m.format(format).toLocaleUpperCase(), format, true);
                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' upper strict');
                r = moment(m.format(format).toLocaleLowerCase(), format, true);
                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' lower strict');
            }

            for (i = 0; i < 12; ++i) {
                m = moment([2015, i, 15, 18]);
                tester('MMM');
                tester('MMM.');
                tester('MMMM');
                tester('MMMM.');
            }
        });

        test('weekday parsing correctness', function (assert) {
            var i, m;

            if (locale === 'tr' || locale === 'az') {
                // There is a lower-case letter (Ä±), that converted to upper then
                // lower changes to i
                expect(0);
                return;
            }
            function tester(format) {
                var r, baseMsg = 'weekday ' + m.weekday() + ' fmt ' + format;
                r = moment(m.format(format), format);
                assert.equal(r.weekday(), m.weekday(), baseMsg);
                r = moment(m.format(format).toLocaleUpperCase(), format);
                assert.equal(r.weekday(), m.weekday(), baseMsg + ' upper');
                r = moment(m.format(format).toLocaleLowerCase(), format);
                assert.equal(r.weekday(), m.weekday(), baseMsg + ' lower');

                r = moment(m.format(format), format, true);
                assert.equal(r.weekday(), m.weekday(), baseMsg + ' strict');
                r = moment(m.format(format).toLocaleUpperCase(), format, true);
                assert.equal(r.weekday(), m.weekday(), baseMsg + ' upper strict');
                r = moment(m.format(format).toLocaleLowerCase(), format, true);
                assert.equal(r.weekday(), m.weekday(), baseMsg + ' lower strict');
            }

            for (i = 0; i < 7; ++i) {
                m = moment.utc([2015, i, 15, 18]);
                tester('dd');
                tester('ddd');
                tester('dddd');
            }
        });
    }

    function setupDeprecationHandler(test, moment, scope) {
        test._expectedDeprecations = null;
        test._observedDeprecations = null;
        test._oldSupress = moment.suppressDeprecationWarnings;
        moment.suppressDeprecationWarnings = true;
        test.expectedDeprecations = function () {
            test._expectedDeprecations = arguments;
            test._observedDeprecations = [];
        };
        moment.deprecationHandler = function (name, msg) {
            var deprecationId = matchedDeprecation(name, msg, test._expectedDeprecations);
            if (deprecationId === -1) {
                throw new Error('Unexpected deprecation thrown name=' +
                        name + ' msg=' + msg);
            }
            test._observedDeprecations[deprecationId] = 1;
        };
    }

    function teardownDeprecationHandler(test, moment, scope) {
        moment.suppressDeprecationWarnings = test._oldSupress;

        if (test._expectedDeprecations != null) {
            var missedDeprecations = [];
            each(test._expectedDeprecations, function (deprecationPattern, id) {
                if (test._observedDeprecations[id] !== 1) {
                    missedDeprecations.push(deprecationPattern);
                }
            });
            if (missedDeprecations.length !== 0) {
                throw new Error('Expected deprecation warnings did not happen: ' +
                        missedDeprecations.join(' '));
            }
        }
    }

    function matchedDeprecation(name, msg, deprecations) {
        if (deprecations == null) {
            return -1;
        }
        for (var i = 0; i < deprecations.length; ++i) {
            if (name != null && name === deprecations[i]) {
                return i;
            }
            if (msg != null && msg.substring(0, deprecations[i].length) === deprecations[i]) {
                return i;
            }
        }
        return -1;
    }

    /*global QUnit:false*/

    var test = QUnit.test;

    var expect = QUnit.expect;

    function module (name, lifecycle) {
        QUnit.module(name, {
            setup : function () {
                moment.locale('en');
                moment.createFromInputFallback = function (config) {
                    throw new Error('input not handled by moment: ' + config._i);
                };
                setupDeprecationHandler(test, moment, 'core');
                if (lifecycle && lifecycle.setup) {
                    lifecycle.setup();
                }
            },
            teardown : function () {
                teardownDeprecationHandler(test, moment, 'core');
                if (lifecycle && lifecycle.teardown) {
                    lifecycle.teardown();
                }
            }
        });
    }

    function localeModule (name, lifecycle) {
        QUnit.module('locale:' + name, {
            setup : function () {
                moment.locale(name);
                moment.createFromInputFallback = function (config) {
                    throw new Error('input not handled by moment: ' + config._i);
                };
                setupDeprecationHandler(test, moment, 'locale');
                if (lifecycle && lifecycle.setup) {
                    lifecycle.setup();
                }
            },
            teardown : function () {
                moment.locale('en');
                teardownDeprecationHandler(test, moment, 'locale');
                if (lifecycle && lifecycle.teardown) {
                    lifecycle.teardown();
                }
            }
        });
        defineCommonLocaleTests(name, -1, -1);
    }

    localeModule('ar-tn');

    test('parse', function (assert) {
        var tests = 'Ø¬Ø§ÙÙÙ:Ø¬Ø§ÙÙÙ_ÙÙÙØ±Ù:ÙÙÙØ±Ù_ÙØ§Ø±Ø³:ÙØ§Ø±Ø³_Ø£ÙØ±ÙÙ:Ø£ÙØ±ÙÙ_ÙØ§Ù:ÙØ§Ù_Ø¬ÙØ§Ù:Ø¬ÙØ§Ù_Ø¬ÙÙÙÙØ©:Ø¬ÙÙÙÙØ©_Ø£ÙØª:Ø£ÙØª_Ø³Ø¨ØªÙØ¨Ø±:Ø³Ø¨ØªÙØ¨Ø±_Ø£ÙØªÙØ¨Ø±:Ø£ÙØªÙØ¨Ø±_ÙÙÙÙØ¨Ø±:ÙÙÙÙØ¨Ø±_Ø¯ÙØ³ÙØ¨Ø±:Ø¯ÙØ³ÙØ¨Ø±'.split('_'),
            i;

        function equalTest(input, mmm, i) {
            assert.equal(moment(input, mmm).month(), i, input + ' should be month ' + (i + 1));
        }
        for (i = 0; i < 12; i++) {
            tests[i] = tests[i].split(':');
            equalTest(tests[i][0], 'MMM', i);
            equalTest(tests[i][1], 'MMM', i);
            equalTest(tests[i][0], 'MMMM', i);
            equalTest(tests[i][1], 'MMMM', i);
            equalTest(tests[i][0].toLocaleLowerCase(), 'MMMM', i);
            equalTest(tests[i][1].toLocaleLowerCase(), 'MMMM', i);
            equalTest(tests[i][0].toLocaleUpperCase(), 'MMMM', i);
            equalTest(tests[i][1].toLocaleUpperCase(), 'MMMM', i);
        }
    });

    test('format', function (assert) {
        var a = [
                ['dddd, MMMM Do YYYY, h:mm:ss a', 'Ø§ÙØ£Ø­Ø¯, ÙÙÙØ±Ù 14 2010, 3:25:50 pm'],
                ['ddd, hA', 'Ø£Ø­Ø¯, 3PM'],
                ['M Mo MM MMMM MMM', '2 2 02 ÙÙÙØ±Ù ÙÙÙØ±Ù'],
                ['YYYY YY', '2010 10'],
                ['D Do DD', '14 14 14'],
                ['d do dddd ddd dd', '0 0 Ø§ÙØ£Ø­Ø¯ Ø£Ø­Ø¯ Ø­'],
                ['DDD DDDo DDDD', '45 45 045'],
                ['w wo ww', '6 6 06'],
                ['h hh', '3 03'],
                ['H HH', '15 15'],
                ['m mm', '25 25'],
                ['s ss', '50 50'],
                ['a A', 'pm PM'],
                ['[the] DDDo [day of the year]', 'the 45 day of the year'],
                ['LT', '15:25'],
                ['LTS', '15:25:50'],
                ['L', '14/02/2010'],
                ['LL', '14 ÙÙÙØ±Ù 2010'],
                ['LLL', '14 ÙÙÙØ±Ù 2010 15:25'],
                ['LLLL', 'Ø§ÙØ£Ø­Ø¯ 14 ÙÙÙØ±Ù 2010 15:25'],
                ['l', '14/2/2010'],
                ['ll', '14 ÙÙÙØ±Ù 2010'],
                ['lll', '14 ÙÙÙØ±Ù 2010 15:25'],
                ['llll', 'Ø£Ø­Ø¯ 14 ÙÙÙØ±Ù 2010 15:25']
            ],
            b = moment(new Date(2010, 1, 14, 15, 25, 50, 125)),
            i;
        for (i = 0; i < a.length; i++) {
            assert.equal(b.format(a[i][0]), a[i][1], a[i][0] + ' ---> ' + a[i][1]);
        }
    });

    test('format ordinal', function (assert) {
        assert.equal(moment([2011, 0, 1]).format('DDDo'), '1', '1');
        assert.equal(moment([2011, 0, 2]).format('DDDo'), '2', '2');
        assert.equal(moment([2011, 0, 3]).format('DDDo'), '3', '3');
        assert.equal(moment([2011, 0, 4]).format('DDDo'), '4', '4');
        assert.equal(moment([2011, 0, 5]).format('DDDo'), '5', '5');
        assert.equal(moment([2011, 0, 6]).format('DDDo'), '6', '6');
        assert.equal(moment([2011, 0, 7]).format('DDDo'), '7', '7');
        assert.equal(moment([2011, 0, 8]).format('DDDo'), '8', '8');
        assert.equal(moment([2011, 0, 9]).format('DDDo'), '9', '9');
        assert.equal(moment([2011, 0, 10]).format('DDDo'), '10', '10');

        assert.equal(moment([2011, 0, 11]).format('DDDo'), '11', '11');
        assert.equal(moment([2011, 0, 12]).format('DDDo'), '12', '12');
        assert.equal(moment([2011, 0, 13]).format('DDDo'), '13', '13');
        assert.equal(moment([2011, 0, 14]).format('DDDo'), '14', '14');
        assert.equal(moment([2011, 0, 15]).format('DDDo'), '15', '15');
        assert.equal(moment([2011, 0, 16]).format('DDDo'), '16', '16');
        assert.equal(moment([2011, 0, 17]).format('DDDo'), '17', '17');
        assert.equal(moment([2011, 0, 18]).format('DDDo'), '18', '18');
        assert.equal(moment([2011, 0, 19]).format('DDDo'), '19', '19');
        assert.equal(moment([2011, 0, 20]).format('DDDo'), '20', '20');

        assert.equal(moment([2011, 0, 21]).format('DDDo'), '21', '21');
        assert.equal(moment([2011, 0, 22]).format('DDDo'), '22', '22');
        assert.equal(moment([2011, 0, 23]).format('DDDo'), '23', '23');
        assert.equal(moment([2011, 0, 24]).format('DDDo'), '24', '24');
        assert.equal(moment([2011, 0, 25]).format('DDDo'), '25', '25');
        assert.equal(moment([2011, 0, 26]).format('DDDo'), '26', '26');
        assert.equal(moment([2011, 0, 27]).format('DDDo'), '27', '27');
        assert.equal(moment([2011, 0, 28]).format('DDDo'), '28', '28');
        assert.equal(moment([2011, 0, 29]).format('DDDo'), '29', '29');
        assert.equal(moment([2011, 0, 30]).format('DDDo'), '30', '30');

        assert.equal(moment([2011, 0, 31]).format('DDDo'), '31', '31');
    });

    test('format month', function (assert) {
        var expected = 'Ø¬Ø§ÙÙÙ Ø¬Ø§ÙÙÙ_ÙÙÙØ±Ù ÙÙÙØ±Ù_ÙØ§Ø±Ø³ ÙØ§Ø±Ø³_Ø£ÙØ±ÙÙ Ø£ÙØ±ÙÙ_ÙØ§Ù ÙØ§Ù_Ø¬ÙØ§Ù Ø¬ÙØ§Ù_Ø¬ÙÙÙÙØ© Ø¬ÙÙÙÙØ©_Ø£ÙØª Ø£ÙØª_Ø³Ø¨ØªÙØ¨Ø± Ø³Ø¨ØªÙØ¨Ø±_Ø£ÙØªÙØ¨Ø± Ø£ÙØªÙØ¨Ø±_ÙÙÙÙØ¨Ø± ÙÙÙÙØ¨Ø±_Ø¯ÙØ³ÙØ¨Ø± Ø¯ÙØ³ÙØ¨Ø±'.split('_'),
            i;
        for (i = 0; i < expected.length; i++) {
            assert.equal(moment([2011, i, 1]).format('MMMM MMM'), expected[i], expected[i]);
        }
    });

    test('format week', function (assert) {
        var expected = 'Ø§ÙØ£Ø­Ø¯ Ø£Ø­Ø¯ Ø­_Ø§ÙØ¥Ø«ÙÙÙ Ø¥Ø«ÙÙÙ Ù_Ø§ÙØ«ÙØ§Ø«Ø§Ø¡ Ø«ÙØ§Ø«Ø§Ø¡ Ø«_Ø§ÙØ£Ø±Ø¨Ø¹Ø§Ø¡ Ø£Ø±Ø¨Ø¹Ø§Ø¡ Ø±_Ø§ÙØ®ÙÙØ³ Ø®ÙÙØ³ Ø®_Ø§ÙØ¬ÙØ¹Ø© Ø¬ÙØ¹Ø© Ø¬_Ø§ÙØ³Ø¨Øª Ø³Ø¨Øª Ø³'.split('_'),
            i;
        for (i = 0; i < expected.length; i++) {
            assert.equal(moment([2011, 0, 2 + i]).format('dddd ddd dd'), expected[i], expected[i]);
        }
    });

    test('from', function (assert) {
        var start = moment([2007, 1, 28]);
        assert.equal(start.from(moment([2007, 1, 28]).add({
            s: 44
        }), true), 'Ø«ÙØ§Ù', '44 seconds = a few seconds');
        assert.equal(start.from(moment([2007, 1, 28]).add({
            s: 45
        }), true), 'Ø¯ÙÙÙØ©', '45 seconds = a minute');
        assert.equal(start.from(moment([2007, 1, 28]).add({
            s: 89
        }), true), 'Ø¯ÙÙÙØ©', '89 seconds = a minute');
        assert.equal(start.from(moment([2007, 1, 28]).add({
            s: 90
        }), true), '2 Ø¯ÙØ§Ø¦Ù', '90 seconds = 2 minutes');
        assert.equal(start.from(moment([2007, 1, 28]).add({
            m: 44
        }), true), '44 Ø¯ÙØ§Ø¦Ù', '44 minutes = 44 minutes');
        assert.equal(start.from(moment([2007, 1, 28]).add({
            m: 45
        }), true), 'Ø³Ø§Ø¹Ø©', '45 minutes = an hour');
        assert.equal(start.from(moment([2007, 1, 28]).add({
            m: 89
        }), true), 'Ø³Ø§Ø¹Ø©', '89 minutes = an hour');
        assert.equal(start.from(moment([2007, 1, 28]).add({
            m: 90
        }), true), '2 Ø³Ø§Ø¹Ø§Øª', '90 minutes = 2 hours');
        assert.equal(start.from(moment([2007, 1, 28]).add({
            h: 5
        }), true), '5 Ø³Ø§Ø¹Ø§Øª', '5 hours = 5 hours');
        assert.equal(start.from(moment([2007, 1, 28]).add({
            h: 21
        }), true), '21 Ø³Ø§Ø¹Ø§Øª', '21 hours = 21 hours');
        assert.equal(start.from(moment([2007, 1, 28]).add({
            h: 22
        }), true), 'ÙÙÙ', '22 hours = a day');
        assert.equal(start.from(moment([2007, 1, 28]).add({
            h: 35
        }), true), 'ÙÙÙ', '35 hours = a day');
        assert.equal(start.from(moment([2007, 1, 28]).add({
            h: 36
        }), true), '2 Ø£ÙØ§Ù', '36 hours = 2 days');
        assert.equal(start.from(moment([2007, 1, 28]).add({
            d: 1
        }), true), 'ÙÙÙ', '1 day = a day');
        assert.equal(start.from(moment([2007, 1, 28]).add({
            d: 5
        }), true), '5 Ø£ÙØ§Ù', '5 days = 5 days');
        assert.equal(start.from(moment([2007, 1, 28]).add({
            d: 25
        }), true), '25 Ø£ÙØ§Ù', '25 days = 25 days');
        assert.equal(start.from(moment([2007, 1, 28]).add({
            d: 26
        }), true), 'Ø´ÙØ±', '26 days = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({
            d: 30
        }), true), 'Ø´ÙØ±', '30 days = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({
            d: 43
        }), true), 'Ø´ÙØ±', '43 days = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({
            d: 46
        }), true), '2 Ø£Ø´ÙØ±', '46 days = 2 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({
            d: 74
        }), true), '2 Ø£Ø´ÙØ±', '75 days = 2 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({
            d: 76
        }), true), '3 Ø£Ø´ÙØ±', '76 days = 3 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({
            M: 1
        }), true), 'Ø´ÙØ±', '1 month = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({
            M: 5
        }), true), '5 Ø£Ø´ÙØ±', '5 months = 5 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({
            d: 345
        }), true), 'Ø³ÙØ©', '345 days = a year');
        assert.equal(start.from(moment([2007, 1, 28]).add({
            d: 548
        }), true), '2 Ø³ÙÙØ§Øª', '548 days = 2 years');
        assert.equal(start.from(moment([2007, 1, 28]).add({
            y: 1
        }), true), 'Ø³ÙØ©', '1 year = a year');
        assert.equal(start.from(moment([2007, 1, 28]).add({
            y: 5
        }), true), '5 Ø³ÙÙØ§Øª', '5 years = 5 years');
    });

    test('suffix', function (assert) {
        assert.equal(moment(30000).from(0), 'ÙÙ Ø«ÙØ§Ù', 'prefix');
        assert.equal(moment(0).from(30000), 'ÙÙØ° Ø«ÙØ§Ù', 'suffix');
    });

    test('now from now', function (assert) {
        assert.equal(moment().fromNow(), 'ÙÙØ° Ø«ÙØ§Ù', 'now from now should display as in the past');
    });

    test('fromNow', function (assert) {
        assert.equal(moment().add({
            s: 30
        }).fromNow(), 'ÙÙ Ø«ÙØ§Ù', 'in a few seconds');
        assert.equal(moment().add({
            d: 5
        }).fromNow(), 'ÙÙ 5 Ø£ÙØ§Ù', 'in 5 days');
    });

    test('calendar day', function (assert) {
        var a = moment().hours(12).minutes(0).seconds(0);

        assert.equal(moment(a).calendar(),                  'Ø§ÙÙÙÙ Ø¹ÙÙ Ø§ÙØ³Ø§Ø¹Ø© 12:00', 'today at the same time');
        assert.equal(moment(a).add({m: 25}).calendar(),     'Ø§ÙÙÙÙ Ø¹ÙÙ Ø§ÙØ³Ø§Ø¹Ø© 12:25', 'Now plus 25 min');
        assert.equal(moment(a).add({h: 1}).calendar(),      'Ø§ÙÙÙÙ Ø¹ÙÙ Ø§ÙØ³Ø§Ø¹Ø© 13:00', 'Now plus 1 hour');
        assert.equal(moment(a).add({d: 1}).calendar(),      'ØºØ¯Ø§ Ø¹ÙÙ Ø§ÙØ³Ø§Ø¹Ø© 12:00',  'tomorrow at the same time');
        assert.equal(moment(a).subtract({h: 1}).calendar(), 'Ø§ÙÙÙÙ Ø¹ÙÙ Ø§ÙØ³Ø§Ø¹Ø© 11:00', 'Now minus 1 hour');
        assert.equal(moment(a).subtract({d: 1}).calendar(), 'Ø£ÙØ³ Ø¹ÙÙ Ø§ÙØ³Ø§Ø¹Ø© 12:00',  'yesterday at the same time');
    });

    test('calendar next week', function (assert) {
        var i, m;
        for (i = 2; i < 7; i++) {
            m = moment().add({
                d: i
            });
            assert.equal(m.calendar(), m.format('dddd [Ø¹ÙÙ Ø§ÙØ³Ø§Ø¹Ø©] LT'), 'Today + ' + i + ' days current time');
            m.hours(0).minutes(0).seconds(0).milliseconds(0);
            assert.equal(m.calendar(), m.format('dddd [Ø¹ÙÙ Ø§ÙØ³Ø§Ø¹Ø©] LT'), 'Today + ' + i + ' days beginning of day');
            m.hours(23).minutes(59).seconds(59).milliseconds(999);
            assert.equal(m.calendar(), m.format('dddd [Ø¹ÙÙ Ø§ÙØ³Ø§Ø¹Ø©] LT'), 'Today + ' + i + ' days end of day');
        }
    });

    test('calendar last week', function (assert) {
        var i, m;
        for (i = 2; i < 7; i++) {
            m = moment().subtract({
                d: i
            });
            assert.equal(m.calendar(), m.format('dddd [Ø¹ÙÙ Ø§ÙØ³Ø§Ø¹Ø©] LT'), 'Today - ' + i + ' days current time');
            m.hours(0).minutes(0).seconds(0).milliseconds(0);
            assert.equal(m.calendar(), m.format('dddd [Ø¹ÙÙ Ø§ÙØ³Ø§Ø¹Ø©] LT'), 'Today - ' + i + ' days beginning of day');
            m.hours(23).minutes(59).seconds(59).milliseconds(999);
            assert.equal(m.calendar(), m.format('dddd [Ø¹ÙÙ Ø§ÙØ³Ø§Ø¹Ø©] LT'), 'Today - ' + i + ' days end of day');
        }
    });

    test('calendar all else', function (assert) {
        var weeksAgo = moment().subtract({
                w: 1
            }),
            weeksFromNow = moment().add({
                w: 1
            });

        assert.equal(weeksAgo.calendar(), weeksAgo.format('L'), '1 week ago');
        assert.equal(weeksFromNow.calendar(), weeksFromNow.format('L'), 'in 1 week');

        weeksAgo = moment().subtract({
            w: 2
        });
        weeksFromNow = moment().add({
            w: 2
        });

        assert.equal(weeksAgo.calendar(), weeksAgo.format('L'), '2 weeks ago');
        assert.equal(weeksFromNow.calendar(), weeksFromNow.format('L'), 'in 2 weeks');
    });

    test('weeks year starting sunday formatted', function (assert) {
        assert.equal(moment([2012, 0,  1]).format('w ww wo'), '52 52 52', 'Jan  1 2012 should be week 52');
        assert.equal(moment([2012, 0,  2]).format('w ww wo'), '1 01 1', 'Jan  2 2012 should be week 1');
        assert.equal(moment([2012, 0,  8]).format('w ww wo'), '1 01 1', 'Jan  8 2012 should be week 1');
        assert.equal(moment([2012, 0,  9]).format('w ww wo'),   '2 02 2', 'Jan  9 2012 should be week 2');
        assert.equal(moment([2012, 0, 15]).format('w ww wo'),   '2 02 2', 'Jan 15 2012 should be week 2');
    });

}));

;(function (global, factory) {
   typeof exports === 'object' && typeof module !== 'undefined'
       && typeof require === 'function' ? factory(require('../../moment')) :
   typeof define === 'function' && define.amd ? define(['../../moment'], factory) :
   factory(global.moment)
}(this, function (moment) { 'use strict';

    function each(array, callback) {
        var i;
        for (i = 0; i < array.length; i++) {
            callback(array[i], i, array);
        }
    }

    function objectKeys(obj) {
        if (Object.keys) {
            return Object.keys(obj);
        } else {
            // IE8
            var res = [], i;
            for (i in obj) {
                if (obj.hasOwnProperty(i)) {
                    res.push(i);
                }
            }
            return res;
        }
    }

    // Pick the first defined of two or three arguments.
    function defaults(a, b, c) {
        if (a != null) {
            return a;
        }
        if (b != null) {
            return b;
        }
        return c;
    }

    function defineCommonLocaleTests(locale, options) {
        test('lenient ordinal parsing', function (assert) {
            var i, ordinalStr, testMoment;
            for (i = 1; i <= 31; ++i) {
                ordinalStr = moment([2014, 0, i]).format('YYYY MM Do');
                testMoment = moment(ordinalStr, 'YYYY MM Do');
                assert.equal(testMoment.year(), 2014,
                        'lenient ordinal parsing ' + i + ' year check');
                assert.equal(testMoment.month(), 0,
                        'lenient ordinal parsing ' + i + ' month check');
                assert.equal(testMoment.date(), i,
                        'lenient ordinal parsing ' + i + ' date check');
            }
        });

        test('lenient ordinal parsing of number', function (assert) {
            var i, testMoment;
            for (i = 1; i <= 31; ++i) {
                testMoment = moment('2014 01 ' + i, 'YYYY MM Do');
                assert.equal(testMoment.year(), 2014,
                        'lenient ordinal parsing of number ' + i + ' year check');
                assert.equal(testMoment.month(), 0,
                        'lenient ordinal parsing of number ' + i + ' month check');
                assert.equal(testMoment.date(), i,
                        'lenient ordinal parsing of number ' + i + ' date check');
            }
        });

        test('strict ordinal parsing', function (assert) {
            var i, ordinalStr, testMoment;
            for (i = 1; i <= 31; ++i) {
                ordinalStr = moment([2014, 0, i]).format('YYYY MM Do');
                testMoment = moment(ordinalStr, 'YYYY MM Do', true);
                assert.ok(testMoment.isValid(), 'strict ordinal parsing ' + i);
            }
        });

        test('meridiem invariant', function (assert) {
            var h, m, t1, t2;
            for (h = 0; h < 24; ++h) {
                for (m = 0; m < 60; m += 15) {
                    t1 = moment.utc([2000, 0, 1, h, m]);
                    t2 = moment.utc(t1.format('A h:mm'), 'A h:mm');
                    assert.equal(t2.format('HH:mm'), t1.format('HH:mm'),
                            'meridiem at ' + t1.format('HH:mm'));
                }
            }
        });

        test('date format correctness', function (assert) {
            var data, tokens;
            data = moment.localeData()._longDateFormat;
            tokens = objectKeys(data);
            each(tokens, function (srchToken) {
                // Check each format string to make sure it does not contain any
                // tokens that need to be expanded.
                each(tokens, function (baseToken) {
                    // strip escaped sequences
                    var format = data[baseToken].replace(/(\[[^\]]*\])/g, '');
                    assert.equal(false, !!~format.indexOf(srchToken),
                            'contains ' + srchToken + ' in ' + baseToken);
                });
            });
        });

        test('month parsing correctness', function (assert) {
            var i, m;

            if (locale === 'tr') {
                // I can't fix it :(
                expect(0);
                return;
            }
            function tester(format) {
                var r;
                r = moment(m.format(format), format);
                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format);
                r = moment(m.format(format).toLocaleUpperCase(), format);
                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' upper');
                r = moment(m.format(format).toLocaleLowerCase(), format);
                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' lower');

                r = moment(m.format(format), format, true);
                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' strict');
                r = moment(m.format(format).toLocaleUpperCase(), format, true);
                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' upper strict');
                r = moment(m.format(format).toLocaleLowerCase(), format, true);
                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' lower strict');
            }

            for (i = 0; i < 12; ++i) {
                m = moment([2015, i, 15, 18]);
                tester('MMM');
                tester('MMM.');
                tester('MMMM');
                tester('MMMM.');
            }
        });

        test('weekday parsing correctness', function (assert) {
            var i, m;

            if (locale === 'tr' || locale === 'az') {
                // There is a lower-case letter (Ä±), that converted to upper then
                // lower changes to i
                expect(0);
                return;
            }
            function tester(format) {
                var r, baseMsg = 'weekday ' + m.weekday() + ' fmt ' + format;
                r = moment(m.format(format), format);
                assert.equal(r.weekday(), m.weekday(), baseMsg);
                r = moment(m.format(format).toLocaleUpperCase(), format);
                assert.equal(r.weekday(), m.weekday(), baseMsg + ' upper');
                r = moment(m.format(format).toLocaleLowerCase(), format);
                assert.equal(r.weekday(), m.weekday(), baseMsg + ' lower');

                r = moment(m.format(format), format, true);
                assert.equal(r.weekday(), m.weekday(), baseMsg + ' strict');
                r = moment(m.format(format).toLocaleUpperCase(), format, true);
                assert.equal(r.weekday(), m.weekday(), baseMsg + ' upper strict');
                r = moment(m.format(format).toLocaleLowerCase(), format, true);
                assert.equal(r.weekday(), m.weekday(), baseMsg + ' lower strict');
            }

            for (i = 0; i < 7; ++i) {
                m = moment.utc([2015, i, 15, 18]);
                tester('dd');
                tester('ddd');
                tester('dddd');
            }
        });
    }

    function setupDeprecationHandler(test, moment, scope) {
        test._expectedDeprecations = null;
        test._observedDeprecations = null;
        test._oldSupress = moment.suppressDeprecationWarnings;
        moment.suppressDeprecationWarnings = true;
        test.expectedDeprecations = function () {
            test._expectedDeprecations = arguments;
            test._observedDeprecations = [];
        };
        moment.deprecationHandler = function (name, msg) {
            var deprecationId = matchedDeprecation(name, msg, test._expectedDeprecations);
            if (deprecationId === -1) {
                throw new Error('Unexpected deprecation thrown name=' +
                        name + ' msg=' + msg);
            }
            test._observedDeprecations[deprecationId] = 1;
        };
    }

    function teardownDeprecationHandler(test, moment, scope) {
        moment.suppressDeprecationWarnings = test._oldSupress;

        if (test._expectedDeprecations != null) {
            var missedDeprecations = [];
            each(test._expectedDeprecations, function (deprecationPattern, id) {
                if (test._observedDeprecations[id] !== 1) {
                    missedDeprecations.push(deprecationPattern);
                }
            });
            if (missedDeprecations.length !== 0) {
                throw new Error('Expected deprecation warnings did not happen: ' +
                        missedDeprecations.join(' '));
            }
        }
    }

    function matchedDeprecation(name, msg, deprecations) {
        if (deprecations == null) {
            return -1;
        }
        for (var i = 0; i < deprecations.length; ++i) {
            if (name != null && name === deprecations[i]) {
                return i;
            }
            if (msg != null && msg.substring(0, deprecations[i].length) === deprecations[i]) {
                return i;
            }
        }
        return -1;
    }

    /*global QUnit:false*/

    var test = QUnit.test;

    var expect = QUnit.expect;

    function module (name, lifecycle) {
        QUnit.module(name, {
            setup : function () {
                moment.locale('en');
                moment.createFromInputFallback = function (config) {
                    throw new Error('input not handled by moment: ' + config._i);
                };
                setupDeprecationHandler(test, moment, 'core');
                if (lifecycle && lifecycle.setup) {
                    lifecycle.setup();
                }
            },
            teardown : function () {
                teardownDeprecationHandler(test, moment, 'core');
                if (lifecycle && lifecycle.teardown) {
                    lifecycle.teardown();
                }
            }
        });
    }

    function localeModule (name, lifecycle) {
        QUnit.module('locale:' + name, {
            setup : function () {
                moment.locale(name);
                moment.createFromInputFallback = function (config) {
                    throw new Error('input not handled by moment: ' + config._i);
                };
                setupDeprecationHandler(test, moment, 'locale');
                if (lifecycle && lifecycle.setup) {
                    lifecycle.setup();
                }
            },
            teardown : function () {
                moment.locale('en');
                teardownDeprecationHandler(test, moment, 'locale');
                if (lifecycle && lifecycle.teardown) {
                    lifecycle.teardown();
                }
            }
        });
        defineCommonLocaleTests(name, -1, -1);
    }

    localeModule('ar');

    var months = [
        'ÙØ§ÙÙÙ Ø§ÙØ«Ø§ÙÙ ÙÙØ§ÙØ±',
        'Ø´Ø¨Ø§Ø· ÙØ¨Ø±Ø§ÙØ±',
        'Ø¢Ø°Ø§Ø± ÙØ§Ø±Ø³',
        'ÙÙØ³Ø§Ù Ø£Ø¨Ø±ÙÙ',
        'Ø£ÙØ§Ø± ÙØ§ÙÙ',
        'Ø­Ø²ÙØ±Ø§Ù ÙÙÙÙÙ',
        'ØªÙÙØ² ÙÙÙÙÙ',
        'Ø¢Ø¨ Ø£ØºØ³Ø·Ø³',
        'Ø£ÙÙÙÙ Ø³Ø¨ØªÙØ¨Ø±',
        'ØªØ´Ø±ÙÙ Ø§ÙØ£ÙÙ Ø£ÙØªÙØ¨Ø±',
        'ØªØ´Ø±ÙÙ Ø§ÙØ«Ø§ÙÙ ÙÙÙÙØ¨Ø±',
        'ÙØ§ÙÙÙ Ø§ÙØ£ÙÙ Ø¯ÙØ³ÙØ¨Ø±'
    ];

    test('parse', function (assert) {
        var tests = months, i;
        function equalTest(input, mmm, i) {
            assert.equal(moment(input, mmm).month(), i, input + ' should be month ' + (i + 1) + ' instead is month ' + moment(input, mmm).month());
        }
        for (i = 0; i < 12; i++) {
            equalTest(tests[i], 'MMM', i);
            equalTest(tests[i], 'MMM', i);
            equalTest(tests[i], 'MMMM', i);
            equalTest(tests[i], 'MMMM', i);
            equalTest(tests[i].toLocaleLowerCase(), 'MMMM', i);
            equalTest(tests[i].toLocaleLowerCase(), 'MMMM', i);
            equalTest(tests[i].toLocaleUpperCase(), 'MMMM', i);
            equalTest(tests[i].toLocaleUpperCase(), 'MMMM', i);
        }
    });

    test('format', function (assert) {
        var a = [
                ['dddd, MMMM Do YYYY, h:mm:ss a',      'Ø§ÙØ£Ø­Ø¯Ø Ø´Ø¨Ø§Ø· ÙØ¨Ø±Ø§ÙØ± Ù¡Ù¤ Ù¢Ù Ù¡Ù Ø Ù£:Ù¢Ù¥:Ù¥Ù  Ù'],
                ['ddd, hA',                            'Ø£Ø­Ø¯Ø Ù£Ù'],
                ['M Mo MM MMMM MMM',                   'Ù¢ Ù¢ Ù Ù¢ Ø´Ø¨Ø§Ø· ÙØ¨Ø±Ø§ÙØ± Ø´Ø¨Ø§Ø· ÙØ¨Ø±Ø§ÙØ±'],
                ['YYYY YY',                            'Ù¢Ù Ù¡Ù  Ù¡Ù '],
                ['D Do DD',                            'Ù¡Ù¤ Ù¡Ù¤ Ù¡Ù¤'],
                ['d do dddd ddd dd',                   'Ù  Ù  Ø§ÙØ£Ø­Ø¯ Ø£Ø­Ø¯ Ø­'],
                ['DDD DDDo DDDD',                      'Ù¤Ù¥ Ù¤Ù¥ Ù Ù¤Ù¥'],
                ['w wo ww',                            'Ù¨ Ù¨ Ù Ù¨'],
                ['h hh',                               'Ù£ Ù Ù£'],
                ['H HH',                               'Ù¡Ù¥ Ù¡Ù¥'],
                ['m mm',                               'Ù¢Ù¥ Ù¢Ù¥'],
                ['s ss',                               'Ù¥Ù  Ù¥Ù '],
                ['a A',                                'Ù Ù'],
                ['[the] DDDo [day of the year]',       'the Ù¤Ù¥ day of the year'],
                ['LT',                                 'Ù¡Ù¥:Ù¢Ù¥'],
                ['LTS',                                'Ù¡Ù¥:Ù¢Ù¥:Ù¥Ù '],
                ['L',                                  'Ù¡Ù¤/\u200fÙ¢/\u200fÙ¢Ù Ù¡Ù '],
                ['LL',                                 'Ù¡Ù¤ Ø´Ø¨Ø§Ø· ÙØ¨Ø±Ø§ÙØ± Ù¢Ù Ù¡Ù '],
                ['LLL',                                'Ù¡Ù¤ Ø´Ø¨Ø§Ø· ÙØ¨Ø±Ø§ÙØ± Ù¢Ù Ù¡Ù  Ù¡Ù¥:Ù¢Ù¥'],
                ['LLLL',                               'Ø§ÙØ£Ø­Ø¯ Ù¡Ù¤ Ø´Ø¨Ø§Ø· ÙØ¨Ø±Ø§ÙØ± Ù¢Ù Ù¡Ù  Ù¡Ù¥:Ù¢Ù¥'],
                ['l',                                  'Ù¡Ù¤/\u200fÙ¢/\u200fÙ¢Ù Ù¡Ù '],
                ['ll',                                 'Ù¡Ù¤ Ø´Ø¨Ø§Ø· ÙØ¨Ø±Ø§ÙØ± Ù¢Ù Ù¡Ù '],
                ['lll',                                'Ù¡Ù¤ Ø´Ø¨Ø§Ø· ÙØ¨Ø±Ø§ÙØ± Ù¢Ù Ù¡Ù  Ù¡Ù¥:Ù¢Ù¥'],
                ['llll',                               'Ø£Ø­Ø¯ Ù¡Ù¤ Ø´Ø¨Ø§Ø· ÙØ¨Ø±Ø§ÙØ± Ù¢Ù Ù¡Ù  Ù¡Ù¥:Ù¢Ù¥']
            ],
            b = moment(new Date(2010, 1, 14, 15, 25, 50, 125)),
            i;
        for (i = 0; i < a.length; i++) {
            assert.equal(b.format(a[i][0]), a[i][1], a[i][0] + ' ---> ' + a[i][1]);
        }
    });

    test('format ordinal', function (assert) {
        assert.equal(moment([2011, 0, 1]).format('DDDo'), 'Ù¡', '1');
        assert.equal(moment([2011, 0, 2]).format('DDDo'), 'Ù¢', '2');
        assert.equal(moment([2011, 0, 3]).format('DDDo'), 'Ù£', '3');
        assert.equal(moment([2011, 0, 4]).format('DDDo'), 'Ù¤', '4');
        assert.equal(moment([2011, 0, 5]).format('DDDo'), 'Ù¥', '5');
        assert.equal(moment([2011, 0, 6]).format('DDDo'), 'Ù¦', '6');
        assert.equal(moment([2011, 0, 7]).format('DDDo'), 'Ù§', '7');
        assert.equal(moment([2011, 0, 8]).format('DDDo'), 'Ù¨', '8');
        assert.equal(moment([2011, 0, 9]).format('DDDo'), 'Ù©', '9');
        assert.equal(moment([2011, 0, 10]).format('DDDo'), 'Ù¡Ù ', '10');

        assert.equal(moment([2011, 0, 11]).format('DDDo'), 'Ù¡Ù¡', '11');
        assert.equal(moment([2011, 0, 12]).format('DDDo'), 'Ù¡Ù¢', '12');
        assert.equal(moment([2011, 0, 13]).format('DDDo'), 'Ù¡Ù£', '13');
        assert.equal(moment([2011, 0, 14]).format('DDDo'), 'Ù¡Ù¤', '14');
        assert.equal(moment([2011, 0, 15]).format('DDDo'), 'Ù¡Ù¥', '15');
        assert.equal(moment([2011, 0, 16]).format('DDDo'), 'Ù¡Ù¦', '16');
        assert.equal(moment([2011, 0, 17]).format('DDDo'), 'Ù¡Ù§', '17');
        assert.equal(moment([2011, 0, 18]).format('DDDo'), 'Ù¡Ù¨', '18');
        assert.equal(moment([2011, 0, 19]).format('DDDo'), 'Ù¡Ù©', '19');
        assert.equal(moment([2011, 0, 20]).format('DDDo'), 'Ù¢Ù ', '20');

        assert.equal(moment([2011, 0, 21]).format('DDDo'), 'Ù¢Ù¡', '21');
        assert.equal(moment([2011, 0, 22]).format('DDDo'), 'Ù¢Ù¢', '22');
        assert.equal(moment([2011, 0, 23]).format('DDDo'), 'Ù¢Ù£', '23');
        assert.equal(moment([2011, 0, 24]).format('DDDo'), 'Ù¢Ù¤', '24');
        assert.equal(moment([2011, 0, 25]).format('DDDo'), 'Ù¢Ù¥', '25');
        assert.equal(moment([2011, 0, 26]).format('DDDo'), 'Ù¢Ù¦', '26');
        assert.equal(moment([2011, 0, 27]).format('DDDo'), 'Ù¢Ù§', '27');
        assert.equal(moment([2011, 0, 28]).format('DDDo'), 'Ù¢Ù¨', '28');
        assert.equal(moment([2011, 0, 29]).format('DDDo'), 'Ù¢Ù©', '29');
        assert.equal(moment([2011, 0, 30]).format('DDDo'), 'Ù£Ù ', '30');

        assert.equal(moment([2011, 0, 31]).format('DDDo'), 'Ù£Ù¡', '31');
    });

    test('format month', function (assert) {
        var expected = months, i;
        for (i = 0; i < expected.length; i++) {
            assert.equal(moment([2011, i, 1]).format('MMMM'), expected[i], expected[i]);
            assert.equal(moment([2011, i, 1]).format('MMM'), expected[i], expected[i]);
        }
    });

    test('format week', function (assert) {
        var expected = 'Ø§ÙØ£Ø­Ø¯ Ø£Ø­Ø¯ Ø­_Ø§ÙØ¥Ø«ÙÙÙ Ø¥Ø«ÙÙÙ Ù_Ø§ÙØ«ÙØ§Ø«Ø§Ø¡ Ø«ÙØ§Ø«Ø§Ø¡ Ø«_Ø§ÙØ£Ø±Ø¨Ø¹Ø§Ø¡ Ø£Ø±Ø¨Ø¹Ø§Ø¡ Ø±_Ø§ÙØ®ÙÙØ³ Ø®ÙÙØ³ Ø®_Ø§ÙØ¬ÙØ¹Ø© Ø¬ÙØ¹Ø© Ø¬_Ø§ÙØ³Ø¨Øª Ø³Ø¨Øª Ø³'.split('_'), i;
        for (i = 0; i < expected.length; i++) {
            assert.equal(moment([2011, 0, 2 + i]).format('dddd ddd dd'), expected[i], expected[i]);
        }
    });

    test('from', function (assert) {
        var start = moment([2007, 1, 28]);
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 44}), true),  'Ù¤Ù¤ Ø«Ø§ÙÙØ©', '44 seconds = a few seconds');
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 45}), true),  'Ø¯ÙÙÙØ© ÙØ§Ø­Ø¯Ø©',      '45 seconds = a minute');
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 89}), true),  'Ø¯ÙÙÙØ© ÙØ§Ø­Ø¯Ø©',      '89 seconds = a minute');
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 90}), true),  'Ø¯ÙÙÙØªØ§Ù',     '90 seconds = 2 minutes');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 44}), true),  'Ù¤Ù¤ Ø¯ÙÙÙØ©',    '44 minutes = 44 minutes');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 45}), true),  'Ø³Ø§Ø¹Ø© ÙØ§Ø­Ø¯Ø©',       '45 minutes = an hour');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 89}), true),  'Ø³Ø§Ø¹Ø© ÙØ§Ø­Ø¯Ø©',       '89 minutes = an hour');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 90}), true),  'Ø³Ø§Ø¹ØªØ§Ù',       '90 minutes = 2 hours');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 5}), true),   'Ù¥ Ø³Ø§Ø¹Ø§Øª',       '5 hours = 5 hours');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 21}), true),  'Ù¢Ù¡ Ø³Ø§Ø¹Ø©',      '21 hours = 21 hours');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 22}), true),  'ÙÙÙ ÙØ§Ø­Ø¯',         '22 hours = a day');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 35}), true),  'ÙÙÙ ÙØ§Ø­Ø¯',         '35 hours = a day');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 36}), true),  'ÙÙÙØ§Ù',        '36 hours = 2 days');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 1}), true),   'ÙÙÙ ÙØ§Ø­Ø¯',         '1 day = a day');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 5}), true),   'Ù¥ Ø£ÙØ§Ù',        '5 days = 5 days');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 25}), true),  'Ù¢Ù¥ ÙÙÙÙØ§',       '25 days = 25 days');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 26}), true),  'Ø´ÙØ± ÙØ§Ø­Ø¯',       '26 days = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 30}), true),  'Ø´ÙØ± ÙØ§Ø­Ø¯',       '30 days = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 43}), true),  'Ø´ÙØ± ÙØ§Ø­Ø¯',       '43 days = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 46}), true),  'Ø´ÙØ±Ø§Ù',      '46 days = 2 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 74}), true),  'Ø´ÙØ±Ø§Ù',      '75 days = 2 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 76}), true),  'Ù£ Ø£Ø´ÙØ±',      '76 days = 3 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({M: 1}), true),   'Ø´ÙØ± ÙØ§Ø­Ø¯',       '1 month = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({M: 5}), true),   'Ù¥ Ø£Ø´ÙØ±',      '5 months = 5 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 345}), true), 'Ø¹Ø§Ù ÙØ§Ø­Ø¯',        '345 days = a year');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 548}), true), 'Ø¹Ø§ÙØ§Ù',       '548 days = 2 years');
        assert.equal(start.from(moment([2007, 1, 28]).add({y: 1}), true),   'Ø¹Ø§Ù ÙØ§Ø­Ø¯',        '1 year = a year');
        assert.equal(start.from(moment([2007, 1, 28]).add({y: 5}), true),   'Ù¥ Ø£Ø¹ÙØ§Ù',       '5 years = 5 years');
    });

    test('suffix', function (assert) {
        assert.equal(moment(30000).from(0), 'Ø¨Ø¹Ø¯ Ù£Ù  Ø«Ø§ÙÙØ©',  'prefix');
        assert.equal(moment(0).from(30000), 'ÙÙØ° Ù£Ù  Ø«Ø§ÙÙØ©', 'suffix');
    });

    test('now from now', function (assert) {
        assert.equal(moment().fromNow(), 'ÙÙØ° Ø«Ø§ÙÙØ© ÙØ§Ø­Ø¯Ø©',  'now from now should display as in the past');
    });

    test('fromNow', function (assert) {
        assert.equal(moment().add({s: 30}).fromNow(), 'Ø¨Ø¹Ø¯ Ù£Ù  Ø«Ø§ÙÙØ©', 'in a few seconds');
        assert.equal(moment().add({d: 5}).fromNow(), 'Ø¨Ø¹Ø¯ Ù¥ Ø£ÙØ§Ù', 'in 5 days');
    });

    test('calendar day', function (assert) {
        var a = moment().hours(12).minutes(0).seconds(0);

        assert.equal(moment(a).calendar(),                   'Ø§ÙÙÙÙ Ø¹ÙØ¯ Ø§ÙØ³Ø§Ø¹Ø© Ù¡Ù¢:Ù Ù ',     'today at the same time');
        assert.equal(moment(a).add({m: 25}).calendar(),      'Ø§ÙÙÙÙ Ø¹ÙØ¯ Ø§ÙØ³Ø§Ø¹Ø© Ù¡Ù¢:Ù¢Ù¥',     'Now plus 25 min');
        assert.equal(moment(a).add({h: 1}).calendar(),       'Ø§ÙÙÙÙ Ø¹ÙØ¯ Ø§ÙØ³Ø§Ø¹Ø© Ù¡Ù£:Ù Ù ',     'Now plus 1 hour');
        assert.equal(moment(a).add({d: 1}).calendar(),       'ØºØ¯ÙØ§ Ø¹ÙØ¯ Ø§ÙØ³Ø§Ø¹Ø© Ù¡Ù¢:Ù Ù ',      'tomorrow at the same time');
        assert.equal(moment(a).subtract({h: 1}).calendar(),  'Ø§ÙÙÙÙ Ø¹ÙØ¯ Ø§ÙØ³Ø§Ø¹Ø© Ù¡Ù¡:Ù Ù ',     'Now minus 1 hour');
        assert.equal(moment(a).subtract({d: 1}).calendar(),  'Ø£ÙØ³ Ø¹ÙØ¯ Ø§ÙØ³Ø§Ø¹Ø© Ù¡Ù¢:Ù Ù ',       'yesterday at the same time');
    });

    test('calendar next week', function (assert) {
        var i, m;
        for (i = 2; i < 7; i++) {
            m = moment().add({d: i});
            assert.equal(m.calendar(),       m.format('dddd [Ø¹ÙØ¯ Ø§ÙØ³Ø§Ø¹Ø©] LT'),  'Today + ' + i + ' days current time');
            m.hours(0).minutes(0).seconds(0).milliseconds(0);
            assert.equal(m.calendar(),       m.format('dddd [Ø¹ÙØ¯ Ø§ÙØ³Ø§Ø¹Ø©] LT'),  'Today + ' + i + ' days beginning of day');
            m.hours(23).minutes(59).seconds(59).milliseconds(999);
            assert.equal(m.calendar(),       m.format('dddd [Ø¹ÙØ¯ Ø§ÙØ³Ø§Ø¹Ø©] LT'),  'Today + ' + i + ' days end of day');
        }
    });

    test('calendar last week', function (assert) {
        var i, m;
        for (i = 2; i < 7; i++) {
            m = moment().subtract({d: i});
            assert.equal(m.calendar(),       m.format('dddd [Ø¹ÙØ¯ Ø§ÙØ³Ø§Ø¹Ø©] LT'),  'Today - ' + i + ' days current time');
            m.hours(0).minutes(0).seconds(0).milliseconds(0);
            assert.equal(m.calendar(),       m.format('dddd [Ø¹ÙØ¯ Ø§ÙØ³Ø§Ø¹Ø©] LT'),  'Today - ' + i + ' days beginning of day');
            m.hours(23).minutes(59).seconds(59).milliseconds(999);
            assert.equal(m.calendar(),       m.format('dddd [Ø¹ÙØ¯ Ø§ÙØ³Ø§Ø¹Ø©] LT'),  'Today - ' + i + ' days end of day');
        }
    });

    test('calendar all else', function (assert) {
        var weeksAgo = moment().subtract({w: 1}),
            weeksFromNow = moment().add({w: 1});

        assert.equal(weeksAgo.calendar(),       weeksAgo.format('L'),  '1 week ago');
        assert.equal(weeksFromNow.calendar(),   weeksFromNow.format('L'),  'in 1 week');

        weeksAgo = moment().subtract({w: 2});
        weeksFromNow = moment().add({w: 2});

        assert.equal(weeksAgo.calendar(),       weeksAgo.format('L'),  '2 weeks ago');
        assert.equal(weeksFromNow.calendar(),   weeksFromNow.format('L'),  'in 2 weeks');
    });

    test('weeks year starting wednesday custom', function (assert) {
        assert.equal(moment('2003 1 6', 'gggg w d').format('YYYY-MM-DD'), 'Ù¢Ù Ù Ù¢-Ù¡Ù¢-Ù¢Ù¨', 'Week 1 of 2003 should be Dec 28 2002');
        assert.equal(moment('2003 1 0', 'gggg w e').format('YYYY-MM-DD'), 'Ù¢Ù Ù Ù¢-Ù¡Ù¢-Ù¢Ù¨', 'Week 1 of 2003 should be Dec 28 2002');
        assert.equal(moment('2003 1 6', 'gggg w d').format('gggg w d'), 'Ù¢Ù Ù Ù£ Ù¡ Ù¦', 'Saturday of week 1 of 2003 parsed should be formatted as 2003 1 6');
        assert.equal(moment('2003 1 0', 'gggg w e').format('gggg w e'), 'Ù¢Ù Ù Ù£ Ù¡ Ù ', '1st day of week 1 of 2003 parsed should be formatted as 2003 1 0');
    });

    test('weeks year starting sunday formatted', function (assert) {
        assert.equal(moment([2011, 11, 31]).format('w ww wo'), 'Ù¡ Ù Ù¡ Ù¡', 'Dec 31 2011 should be week 1');
        assert.equal(moment([2012,  0,  6]).format('w ww wo'), 'Ù¡ Ù Ù¡ Ù¡', 'Jan  6 2012 should be week 1');
        assert.equal(moment([2012,  0,  7]).format('w ww wo'), 'Ù¢ Ù Ù¢ Ù¢', 'Jan  7 2012 should be week 2');
        assert.equal(moment([2012,  0, 13]).format('w ww wo'), 'Ù¢ Ù Ù¢ Ù¢', 'Jan 13 2012 should be week 2');
        assert.equal(moment([2012,  0, 14]).format('w ww wo'), 'Ù£ Ù Ù£ Ù£', 'Jan 14 2012 should be week 3');
    });

    test('no leading zeros in long date formats', function (assert) {
        var i, j, longDateStr, shortDateStr;
        for (i = 1; i <= 9; ++i) {
            for (j = 1; j <= 9; ++j) {
                longDateStr = moment([2014, i, j]).format('L');
                shortDateStr = moment([2014, i, j]).format('l');
                assert.equal(longDateStr, shortDateStr, 'should not have leading zeros in month or day');
            }
        }
    });

}));

;(function (global, factory) {
   typeof exports === 'object' && typeof module !== 'undefined'
       && typeof require === 'function' ? factory(require('../../moment')) :
   typeof define === 'function' && define.amd ? define(['../../moment'], factory) :
   factory(global.moment)
}(this, function (moment) { 'use strict';

    function each(array, callback) {
        var i;
        for (i = 0; i < array.length; i++) {
            callback(array[i], i, array);
        }
    }

    function objectKeys(obj) {
        if (Object.keys) {
            return Object.keys(obj);
        } else {
            // IE8
            var res = [], i;
            for (i in obj) {
                if (obj.hasOwnProperty(i)) {
                    res.push(i);
                }
            }
            return res;
        }
    }

    // Pick the first defined of two or three arguments.
    function defaults(a, b, c) {
        if (a != null) {
            return a;
        }
        if (b != null) {
            return b;
        }
        return c;
    }

    function defineCommonLocaleTests(locale, options) {
        test('lenient ordinal parsing', function (assert) {
            var i, ordinalStr, testMoment;
            for (i = 1; i <= 31; ++i) {
                ordinalStr = moment([2014, 0, i]).format('YYYY MM Do');
                testMoment = moment(ordinalStr, 'YYYY MM Do');
                assert.equal(testMoment.year(), 2014,
                        'lenient ordinal parsing ' + i + ' year check');
                assert.equal(testMoment.month(), 0,
                        'lenient ordinal parsing ' + i + ' month check');
                assert.equal(testMoment.date(), i,
                        'lenient ordinal parsing ' + i + ' date check');
            }
        });

        test('lenient ordinal parsing of number', function (assert) {
            var i, testMoment;
            for (i = 1; i <= 31; ++i) {
                testMoment = moment('2014 01 ' + i, 'YYYY MM Do');
                assert.equal(testMoment.year(), 2014,
                        'lenient ordinal parsing of number ' + i + ' year check');
                assert.equal(testMoment.month(), 0,
                        'lenient ordinal parsing of number ' + i + ' month check');
                assert.equal(testMoment.date(), i,
                        'lenient ordinal parsing of number ' + i + ' date check');
            }
        });

        test('strict ordinal parsing', function (assert) {
            var i, ordinalStr, testMoment;
            for (i = 1; i <= 31; ++i) {
                ordinalStr = moment([2014, 0, i]).format('YYYY MM Do');
                testMoment = moment(ordinalStr, 'YYYY MM Do', true);
                assert.ok(testMoment.isValid(), 'strict ordinal parsing ' + i);
            }
        });

        test('meridiem invariant', function (assert) {
            var h, m, t1, t2;
            for (h = 0; h < 24; ++h) {
                for (m = 0; m < 60; m += 15) {
                    t1 = moment.utc([2000, 0, 1, h, m]);
                    t2 = moment.utc(t1.format('A h:mm'), 'A h:mm');
                    assert.equal(t2.format('HH:mm'), t1.format('HH:mm'),
                            'meridiem at ' + t1.format('HH:mm'));
                }
            }
        });

        test('date format correctness', function (assert) {
            var data, tokens;
            data = moment.localeData()._longDateFormat;
            tokens = objectKeys(data);
            each(tokens, function (srchToken) {
                // Check each format string to make sure it does not contain any
                // tokens that need to be expanded.
                each(tokens, function (baseToken) {
                    // strip escaped sequences
                    var format = data[baseToken].replace(/(\[[^\]]*\])/g, '');
                    assert.equal(false, !!~format.indexOf(srchToken),
                            'contains ' + srchToken + ' in ' + baseToken);
                });
            });
        });

        test('month parsing correctness', function (assert) {
            var i, m;

            if (locale === 'tr') {
                // I can't fix it :(
                expect(0);
                return;
            }
            function tester(format) {
                var r;
                r = moment(m.format(format), format);
                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format);
                r = moment(m.format(format).toLocaleUpperCase(), format);
                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' upper');
                r = moment(m.format(format).toLocaleLowerCase(), format);
                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' lower');

                r = moment(m.format(format), format, true);
                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' strict');
                r = moment(m.format(format).toLocaleUpperCase(), format, true);
                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' upper strict');
                r = moment(m.format(format).toLocaleLowerCase(), format, true);
                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' lower strict');
            }

            for (i = 0; i < 12; ++i) {
                m = moment([2015, i, 15, 18]);
                tester('MMM');
                tester('MMM.');
                tester('MMMM');
                tester('MMMM.');
            }
        });

        test('weekday parsing correctness', function (assert) {
            var i, m;

            if (locale === 'tr' || locale === 'az') {
                // There is a lower-case letter (Ä±), that converted to upper then
                // lower changes to i
                expect(0);
                return;
            }
            function tester(format) {
                var r, baseMsg = 'weekday ' + m.weekday() + ' fmt ' + format;
                r = moment(m.format(format), format);
                assert.equal(r.weekday(), m.weekday(), baseMsg);
                r = moment(m.format(format).toLocaleUpperCase(), format);
                assert.equal(r.weekday(), m.weekday(), baseMsg + ' upper');
                r = moment(m.format(format).toLocaleLowerCase(), format);
                assert.equal(r.weekday(), m.weekday(), baseMsg + ' lower');

                r = moment(m.format(format), format, true);
                assert.equal(r.weekday(), m.weekday(), baseMsg + ' strict');
                r = moment(m.format(format).toLocaleUpperCase(), format, true);
                assert.equal(r.weekday(), m.weekday(), baseMsg + ' upper strict');
                r = moment(m.format(format).toLocaleLowerCase(), format, true);
                assert.equal(r.weekday(), m.weekday(), baseMsg + ' lower strict');
            }

            for (i = 0; i < 7; ++i) {
                m = moment.utc([2015, i, 15, 18]);
                tester('dd');
                tester('ddd');
                tester('dddd');
            }
        });
    }

    function setupDeprecationHandler(test, moment, scope) {
        test._expectedDeprecations = null;
        test._observedDeprecations = null;
        test._oldSupress = moment.suppressDeprecationWarnings;
        moment.suppressDeprecationWarnings = true;
        test.expectedDeprecations = function () {
            test._expectedDeprecations = arguments;
            test._observedDeprecations = [];
        };
        moment.deprecationHandler = function (name, msg) {
            var deprecationId = matchedDeprecation(name, msg, test._expectedDeprecations);
            if (deprecationId === -1) {
                throw new Error('Unexpected deprecation thrown name=' +
                        name + ' msg=' + msg);
            }
            test._observedDeprecations[deprecationId] = 1;
        };
    }

    function teardownDeprecationHandler(test, moment, scope) {
        moment.suppressDeprecationWarnings = test._oldSupress;

        if (test._expectedDeprecations != null) {
            var missedDeprecations = [];
            each(test._expectedDeprecations, function (deprecationPattern, id) {
                if (test._observedDeprecations[id] !== 1) {
                    missedDeprecations.push(deprecationPattern);
                }
            });
            if (missedDeprecations.length !== 0) {
                throw new Error('Expected deprecation warnings did not happen: ' +
                        missedDeprecations.join(' '));
            }
        }
    }

    function matchedDeprecation(name, msg, deprecations) {
        if (deprecations == null) {
            return -1;
        }
        for (var i = 0; i < deprecations.length; ++i) {
            if (name != null && name === deprecations[i]) {
                return i;
            }
            if (msg != null && msg.substring(0, deprecations[i].length) === deprecations[i]) {
                return i;
            }
        }
        return -1;
    }

    /*global QUnit:false*/

    var test = QUnit.test;

    var expect = QUnit.expect;

    function module (name, lifecycle) {
        QUnit.module(name, {
            setup : function () {
                moment.locale('en');
                moment.createFromInputFallback = function (config) {
                    throw new Error('input not handled by moment: ' + config._i);
                };
                setupDeprecationHandler(test, moment, 'core');
                if (lifecycle && lifecycle.setup) {
                    lifecycle.setup();
                }
            },
            teardown : function () {
                teardownDeprecationHandler(test, moment, 'core');
                if (lifecycle && lifecycle.teardown) {
                    lifecycle.teardown();
                }
            }
        });
    }

    function localeModule (name, lifecycle) {
        QUnit.module('locale:' + name, {
            setup : function () {
                moment.locale(name);
                moment.createFromInputFallback = function (config) {
                    throw new Error('input not handled by moment: ' + config._i);
                };
                setupDeprecationHandler(test, moment, 'locale');
                if (lifecycle && lifecycle.setup) {
                    lifecycle.setup();
                }
            },
            teardown : function () {
                moment.locale('en');
                teardownDeprecationHandler(test, moment, 'locale');
                if (lifecycle && lifecycle.teardown) {
                    lifecycle.teardown();
                }
            }
        });
        defineCommonLocaleTests(name, -1, -1);
    }

    localeModule('az');

    test('parse', function (assert) {
        var tests = 'yanvar yan_fevral fev_mart mar_Aprel apr_may may_iyun iyn_iyul iyl_Avqust avq_sentyabr sen_oktyabr okt_noyabr noy_dekabr dek'.split('_'), i;
        function equalTest(input, mmm, i) {
            assert.equal(moment(input, mmm).month(), i, input + ' should be month ' + (i + 1));
        }
        for (i = 0; i < 12; i++) {
            tests[i] = tests[i].split(' ');
            equalTest(tests[i][0], 'MMM', i);
            equalTest(tests[i][1], 'MMM', i);
            equalTest(tests[i][0], 'MMMM', i);
            equalTest(tests[i][1], 'MMMM', i);
            equalTest(tests[i][0].toLocaleLowerCase(), 'MMMM', i);
            equalTest(tests[i][1].toLocaleLowerCase(), 'MMMM', i);
            equalTest(tests[i][0].toLocaleUpperCase(), 'MMMM', i);
            equalTest(tests[i][1].toLocaleUpperCase(), 'MMMM', i);
        }
    });

    test('format', function (assert) {
        var a = [
                ['dddd, D MMMM YYYY, HH:mm:ss',        'Bazar, 14 fevral 2010, 15:25:50'],
                ['ddd, A h',                           'Baz, gÃ¼ndÃ¼z 3'],
                ['M Mo MM MMMM MMM',                   '2 2-nci 02 fevral fev'],
                ['YYYY YY',                            '2010 10'],
                ['D Do DD',                            '14 14-Ã¼ncÃ¼ 14'],
                ['d do dddd ddd dd',                   '0 0-Ä±ncÄ± Bazar Baz Bz'],
                ['DDD DDDo DDDD',                      '45 45-inci 045'],
                ['w wo ww',                            '7 7-nci 07'],
                ['h hh',                               '3 03'],
                ['H HH',                               '15 15'],
                ['m mm',                               '25 25'],
                ['s ss',                               '50 50'],
                ['a A',                                'gÃ¼ndÃ¼z gÃ¼ndÃ¼z'],
                ['[ilin] DDDo [gÃ¼nÃ¼]',                 'ilin 45-inci gÃ¼nÃ¼'],
                ['LT',                                 '15:25'],
                ['LTS',                                '15:25:50'],
                ['L',                                  '14.02.2010'],
                ['LL',                                 '14 fevral 2010'],
                ['LLL',                                '14 fevral 2010 15:25'],
                ['LLLL',                               'Bazar, 14 fevral 2010 15:25'],
                ['l',                                  '14.2.2010'],
                ['ll',                                 '14 fev 2010'],
                ['lll',                                '14 fev 2010 15:25'],
                ['llll',                               'Baz, 14 fev 2010 15:25']
            ],
            DDDo = [
                [359, '360-Ä±ncÄ±'],
                [199, '200-Ã¼ncÃ¼'],
                [149, '150-nci']
            ],
            dt = moment(new Date(2010, 1, 14, 15, 25, 50, 125)),
            DDDoDt,
            i;

        for (i = 0; i < a.length; i++) {
            assert.equal(dt.format(a[i][0]), a[i][1], a[i][0] + ' ---> ' + a[i][1]);
        }
        for (i = 0; i < DDDo.length; i++) {
            DDDoDt = moment([2010]);
            assert.equal(DDDoDt.add(DDDo[i][0], 'days').format('DDDo'), DDDo[i][1], DDDo[i][0] + ' ---> ' + DDDo[i][1]);
        }
    });

    test('format ordinal', function (assert) {
        assert.equal(moment([2011, 0, 1]).format('DDDo'), '1-inci', '1st');
        assert.equal(moment([2011, 0, 2]).format('DDDo'), '2-nci', '2nd');
        assert.equal(moment([2011, 0, 3]).format('DDDo'), '3-Ã¼ncÃ¼', '3rd');
        assert.equal(moment([2011, 0, 4]).format('DDDo'), '4-Ã¼ncÃ¼', '4th');
        assert.equal(moment([2011, 0, 5]).format('DDDo'), '5-inci', '5th');
        assert.equal(moment([2011, 0, 6]).format('DDDo'), '6-ncÄ±', '6th');
        assert.equal(moment([2011, 0, 7]).format('DDDo'), '7-nci', '7th');
        assert.equal(moment([2011, 0, 8]).format('DDDo'), '8-inci', '8th');
        assert.equal(moment([2011, 0, 9]).format('DDDo'), '9-uncu', '9th');
        assert.equal(moment([2011, 0, 10]).format('DDDo'), '10-uncu', '10th');

        assert.equal(moment([2011, 0, 11]).format('DDDo'), '11-inci', '11th');
        assert.equal(moment([2011, 0, 12]).format('DDDo'), '12-nci', '12th');
        assert.equal(moment([2011, 0, 13]).format('DDDo'), '13-Ã¼ncÃ¼', '13th');
        assert.equal(moment([2011, 0, 14]).format('DDDo'), '14-Ã¼ncÃ¼', '14th');
        assert.equal(moment([2011, 0, 15]).format('DDDo'), '15-inci', '15th');
        assert.equal(moment([2011, 0, 16]).format('DDDo'), '16-ncÄ±', '16th');
        assert.equal(moment([2011, 0, 17]).format('DDDo'), '17-nci', '17th');
        assert.equal(moment([2011, 0, 18]).format('DDDo'), '18-inci', '18th');
        assert.equal(moment([2011, 0, 19]).format('DDDo'), '19-uncu', '19th');
        assert.equal(moment([2011, 0, 20]).format('DDDo'), '20-nci', '20th');

        assert.equal(moment([2011, 0, 21]).format('DDDo'), '21-inci', '21th');
        assert.equal(moment([2011, 0, 22]).format('DDDo'), '22-nci', '22th');
        assert.equal(moment([2011, 0, 23]).format('DDDo'), '23-Ã¼ncÃ¼', '23th');
        assert.equal(moment([2011, 0, 24]).format('DDDo'), '24-Ã¼ncÃ¼', '24th');
        assert.equal(moment([2011, 0, 25]).format('DDDo'), '25-inci', '25th');
        assert.equal(moment([2011, 0, 26]).format('DDDo'), '26-ncÄ±', '26th');
        assert.equal(moment([2011, 0, 27]).format('DDDo'), '27-nci', '27th');
        assert.equal(moment([2011, 0, 28]).format('DDDo'), '28-inci', '28th');
        assert.equal(moment([2011, 0, 29]).format('DDDo'), '29-uncu', '29th');
        assert.equal(moment([2011, 0, 30]).format('DDDo'), '30-uncu', '30th');

        assert.equal(moment([2011, 0, 31]).format('DDDo'), '31-inci', '31st');
    });

    test('format month', function (assert) {
        var expected = 'yanvar yan_fevral fev_mart mar_aprel apr_may may_iyun iyn_iyul iyl_avqust avq_sentyabr sen_oktyabr okt_noyabr noy_dekabr dek'.split('_'), i;
        for (i = 0; i < expected.length; i++) {
            assert.equal(moment([2011, i, 1]).format('MMMM MMM'), expected[i], expected[i]);
        }
    });

    test('format week', function (assert) {
        var expected = 'Bazar Baz Bz_Bazar ertÉsi BzE BE_ÃÉrÅÉnbÉ axÅamÄ± ÃAx ÃA_ÃÉrÅÉnbÉ ÃÉr ÃÉ_CÃ¼mÉ axÅamÄ± CAx CA_CÃ¼mÉ CÃ¼m CÃ¼_ÅÉnbÉ ÅÉn ÅÉ'.split('_'), i;
        for (i = 0; i < expected.length; i++) {
            assert.equal(moment([2011, 0, 2 + i]).format('dddd ddd dd'), expected[i], expected[i]);
        }
    });

    test('from', function (assert) {
        var start = moment([2007, 1, 28]);
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 44}), true),  'birneÃ§É saniyyÉ', '44 seconds = a few seconds');
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 45}), true),  'bir dÉqiqÉ',      '45 seconds = a minute');
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 89}), true),  'bir dÉqiqÉ',      '89 seconds = a minute');
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 90}), true),  '2 dÉqiqÉ',     '90 seconds = 2 minutes');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 44}), true),  '44 dÉqiqÉ',    '44 minutes = 44 minutes');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 45}), true),  'bir saat',       '45 minutes = an hour');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 89}), true),  'bir saat',       '89 minutes = an hour');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 90}), true),  '2 saat',       '90 minutes = 2 hours');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 5}), true),   '5 saat',       '5 hours = 5 hours');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 21}), true),  '21 saat',      '21 hours = 21 hours');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 22}), true),  'bir gÃ¼n',         '22 hours = a day');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 35}), true),  'bir gÃ¼n',         '35 hours = a day');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 36}), true),  '2 gÃ¼n',        '36 hours = 2 days');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 1}), true),   'bir gÃ¼n',         '1 day = a day');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 5}), true),   '5 gÃ¼n',        '5 days = 5 days');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 25}), true),  '25 gÃ¼n',       '25 days = 25 days');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 26}), true),  'bir ay',       '26 days = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 30}), true),  'bir ay',       '30 days = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 46}), true),  '2 ay',      '46 days = 2 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 74}), true),  '2 ay',      '75 days = 2 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 76}), true),  '3 ay',      '76 days = 3 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({M: 1}), true),   'bir ay',       '1 month = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({M: 5}), true),   '5 ay',      '5 months = 5 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 345}), true), 'bir il',        '345 days = a year');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 548}), true), '2 il',       '548 days = 2 years');
        assert.equal(start.from(moment([2007, 1, 28]).add({y: 1}), true),   'bir il',        '1 year = a year');
        assert.equal(start.from(moment([2007, 1, 28]).add({y: 5}), true),   '5 il',       '5 years = 5 years');
    });

    test('suffix', function (assert) {
        assert.equal(moment(30000).from(0), 'birneÃ§É saniyyÉ sonra',  'prefix');
        assert.equal(moment(0).from(30000), 'birneÃ§É saniyyÉ ÉvvÉl', 'suffix');
    });

    test('now from now', function (assert) {
        assert.equal(moment().fromNow(), 'birneÃ§É saniyyÉ ÉvvÉl',  'now from now should display as in the past');
    });

    test('fromNow', function (assert) {
        assert.equal(moment().add({s: 30}).fromNow(), 'birneÃ§É saniyyÉ sonra', 'in a few seconds');
        assert.equal(moment().add({d: 5}).fromNow(), '5 gÃ¼n sonra', 'in 5 days');
    });

    test('calendar day', function (assert) {
        var a = moment().hours(12).minutes(0).seconds(0);

        assert.equal(moment(a).calendar(),                   'bugÃ¼n saat 12:00',     'today at the same time');
        assert.equal(moment(a).add({m: 25}).calendar(),      'bugÃ¼n saat 12:25',     'Now plus 25 min');
        assert.equal(moment(a).add({h: 1}).calendar(),       'bugÃ¼n saat 13:00',     'Now plus 1 hour');
        assert.equal(moment(a).add({d: 1}).calendar(),       'sabah saat 12:00',     'tomorrow at the same time');
        assert.equal(moment(a).subtract({h: 1}).calendar(),  'bugÃ¼n saat 11:00',     'Now minus 1 hour');
        assert.equal(moment(a).subtract({d: 1}).calendar(),  'dÃ¼nÉn 12:00',          'yesterday at the same time');
    });

    test('calendar next week', function (assert) {
        var i, m;
        for (i = 2; i < 7; i++) {
            m = moment().add({d: i});
            assert.equal(m.calendar(),       m.format('[gÉlÉn hÉftÉ] dddd [saat] LT'),  'Today + ' + i + ' days current time');
            m.hours(0).minutes(0).seconds(0).milliseconds(0);
            assert.equal(m.calendar(),       m.format('[gÉlÉn hÉftÉ] dddd [saat] LT'),  'Today + ' + i + ' days beginning of day');
            m.hours(23).minutes(59).seconds(59).milliseconds(999);
            assert.equal(m.calendar(),       m.format('[gÉlÉn hÉftÉ] dddd [saat] LT'),  'Today + ' + i + ' days end of day');
        }
    });

    test('calendar last week', function (assert) {
        var i, m;
        for (i = 2; i < 7; i++) {
            m = moment().subtract({d: i});
            assert.equal(m.calendar(),       m.format('[keÃ§Én hÉftÉ] dddd [saat] LT'),  'Today - ' + i + ' days current time');
            m.hours(0).minutes(0).seconds(0).milliseconds(0);
            assert.equal(m.calendar(),       m.format('[keÃ§Én hÉftÉ] dddd [saat] LT'),  'Today - ' + i + ' days beginning of day');
            m.hours(23).minutes(59).seconds(59).milliseconds(999);
            assert.equal(m.calendar(),       m.format('[keÃ§Én hÉftÉ] dddd [saat] LT'),  'Today - ' + i + ' days end of day');
        }
    });

    test('calendar all else', function (assert) {
        var weeksAgo = moment().subtract({w: 1}),
            weeksFromNow = moment().add({w: 1});

        assert.equal(weeksAgo.calendar(),       weeksAgo.format('L'),  '1 week ago');
        assert.equal(weeksFromNow.calendar(),   weeksFromNow.format('L'),  'in 1 week');

        weeksAgo = moment().subtract({w: 2});
        weeksFromNow = moment().add({w: 2});

        assert.equal(weeksAgo.calendar(),       weeksAgo.format('L'),  '2 weeks ago');
        assert.equal(weeksFromNow.calendar(),   weeksFromNow.format('L'),  'in 2 weeks');
    });

    test('weeks year starting sunday formatted', function (assert) {
        assert.equal(moment([2011, 11, 26]).format('w ww wo'), '1 01 1-inci', 'Dec 26 2011 should be week 1');
        assert.equal(moment([2012,  0,  1]).format('w ww wo'), '1 01 1-inci', 'Jan  1 2012 should be week 1');
        assert.equal(moment([2012,  0,  2]).format('w ww wo'), '2 02 2-nci', 'Jan  2 2012 should be week 2');
        assert.equal(moment([2012,  0,  8]).format('w ww wo'), '2 02 2-nci', 'Jan  8 2012 should be week 2');
        assert.equal(moment([2012,  0,  9]).format('w ww wo'), '3 03 3-Ã¼ncÃ¼', 'Jan  9 2012 should be week 3');
    });

}));

;(function (global, factory) {
   typeof exports === 'object' && typeof module !== 'undefined'
       && typeof require === 'function' ? factory(require('../../moment')) :
   typeof define === 'function' && define.amd ? define(['../../moment'], factory) :
   factory(global.moment)
}(this, function (moment) { 'use strict';

    function each(array, callback) {
        var i;
        for (i = 0; i < array.length; i++) {
            callback(array[i], i, array);
        }
    }

    function objectKeys(obj) {
        if (Object.keys) {
            return Object.keys(obj);
        } else {
            // IE8
            var res = [], i;
            for (i in obj) {
                if (obj.hasOwnProperty(i)) {
                    res.push(i);
                }
            }
            return res;
        }
    }

    // Pick the first defined of two or three arguments.
    function defaults(a, b, c) {
        if (a != null) {
            return a;
        }
        if (b != null) {
            return b;
        }
        return c;
    }

    function defineCommonLocaleTests(locale, options) {
        test('lenient ordinal parsing', function (assert) {
            var i, ordinalStr, testMoment;
            for (i = 1; i <= 31; ++i) {
                ordinalStr = moment([2014, 0, i]).format('YYYY MM Do');
                testMoment = moment(ordinalStr, 'YYYY MM Do');
                assert.equal(testMoment.year(), 2014,
                        'lenient ordinal parsing ' + i + ' year check');
                assert.equal(testMoment.month(), 0,
                        'lenient ordinal parsing ' + i + ' month check');
                assert.equal(testMoment.date(), i,
                        'lenient ordinal parsing ' + i + ' date check');
            }
        });

        test('lenient ordinal parsing of number', function (assert) {
            var i, testMoment;
            for (i = 1; i <= 31; ++i) {
                testMoment = moment('2014 01 ' + i, 'YYYY MM Do');
                assert.equal(testMoment.year(), 2014,
                        'lenient ordinal parsing of number ' + i + ' year check');
                assert.equal(testMoment.month(), 0,
                        'lenient ordinal parsing of number ' + i + ' month check');
                assert.equal(testMoment.date(), i,
                        'lenient ordinal parsing of number ' + i + ' date check');
            }
        });

        test('strict ordinal parsing', function (assert) {
            var i, ordinalStr, testMoment;
            for (i = 1; i <= 31; ++i) {
                ordinalStr = moment([2014, 0, i]).format('YYYY MM Do');
                testMoment = moment(ordinalStr, 'YYYY MM Do', true);
                assert.ok(testMoment.isValid(), 'strict ordinal parsing ' + i);
            }
        });

        test('meridiem invariant', function (assert) {
            var h, m, t1, t2;
            for (h = 0; h < 24; ++h) {
                for (m = 0; m < 60; m += 15) {
                    t1 = moment.utc([2000, 0, 1, h, m]);
                    t2 = moment.utc(t1.format('A h:mm'), 'A h:mm');
                    assert.equal(t2.format('HH:mm'), t1.format('HH:mm'),
                            'meridiem at ' + t1.format('HH:mm'));
                }
            }
        });

        test('date format correctness', function (assert) {
            var data, tokens;
            data = moment.localeData()._longDateFormat;
            tokens = objectKeys(data);
            each(tokens, function (srchToken) {
                // Check each format string to make sure it does not contain any
                // tokens that need to be expanded.
                each(tokens, function (baseToken) {
                    // strip escaped sequences
                    var format = data[baseToken].replace(/(\[[^\]]*\])/g, '');
                    assert.equal(false, !!~format.indexOf(srchToken),
                            'contains ' + srchToken + ' in ' + baseToken);
                });
            });
        });

        test('month parsing correctness', function (assert) {
            var i, m;

            if (locale === 'tr') {
                // I can't fix it :(
                expect(0);
                return;
            }
            function tester(format) {
                var r;
                r = moment(m.format(format), format);
                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format);
                r = moment(m.format(format).toLocaleUpperCase(), format);
                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' upper');
                r = moment(m.format(format).toLocaleLowerCase(), format);
                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' lower');

                r = moment(m.format(format), format, true);
                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' strict');
                r = moment(m.format(format).toLocaleUpperCase(), format, true);
                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' upper strict');
                r = moment(m.format(format).toLocaleLowerCase(), format, true);
                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' lower strict');
            }

            for (i = 0; i < 12; ++i) {
                m = moment([2015, i, 15, 18]);
                tester('MMM');
                tester('MMM.');
                tester('MMMM');
                tester('MMMM.');
            }
        });

        test('weekday parsing correctness', function (assert) {
            var i, m;

            if (locale === 'tr' || locale === 'az') {
                // There is a lower-case letter (Ä±), that converted to upper then
                // lower changes to i
                expect(0);
                return;
            }
            function tester(format) {
                var r, baseMsg = 'weekday ' + m.weekday() + ' fmt ' + format;
                r = moment(m.format(format), format);
                assert.equal(r.weekday(), m.weekday(), baseMsg);
                r = moment(m.format(format).toLocaleUpperCase(), format);
                assert.equal(r.weekday(), m.weekday(), baseMsg + ' upper');
                r = moment(m.format(format).toLocaleLowerCase(), format);
                assert.equal(r.weekday(), m.weekday(), baseMsg + ' lower');

                r = moment(m.format(format), format, true);
                assert.equal(r.weekday(), m.weekday(), baseMsg + ' strict');
                r = moment(m.format(format).toLocaleUpperCase(), format, true);
                assert.equal(r.weekday(), m.weekday(), baseMsg + ' upper strict');
                r = moment(m.format(format).toLocaleLowerCase(), format, true);
                assert.equal(r.weekday(), m.weekday(), baseMsg + ' lower strict');
            }

            for (i = 0; i < 7; ++i) {
                m = moment.utc([2015, i, 15, 18]);
                tester('dd');
                tester('ddd');
                tester('dddd');
            }
        });
    }

    function setupDeprecationHandler(test, moment, scope) {
        test._expectedDeprecations = null;
        test._observedDeprecations = null;
        test._oldSupress = moment.suppressDeprecationWarnings;
        moment.suppressDeprecationWarnings = true;
        test.expectedDeprecations = function () {
            test._expectedDeprecations = arguments;
            test._observedDeprecations = [];
        };
        moment.deprecationHandler = function (name, msg) {
            var deprecationId = matchedDeprecation(name, msg, test._expectedDeprecations);
            if (deprecationId === -1) {
                throw new Error('Unexpected deprecation thrown name=' +
                        name + ' msg=' + msg);
            }
            test._observedDeprecations[deprecationId] = 1;
        };
    }

    function teardownDeprecationHandler(test, moment, scope) {
        moment.suppressDeprecationWarnings = test._oldSupress;

        if (test._expectedDeprecations != null) {
            var missedDeprecations = [];
            each(test._expectedDeprecations, function (deprecationPattern, id) {
                if (test._observedDeprecations[id] !== 1) {
                    missedDeprecations.push(deprecationPattern);
                }
            });
            if (missedDeprecations.length !== 0) {
                throw new Error('Expected deprecation warnings did not happen: ' +
                        missedDeprecations.join(' '));
            }
        }
    }

    function matchedDeprecation(name, msg, deprecations) {
        if (deprecations == null) {
            return -1;
        }
        for (var i = 0; i < deprecations.length; ++i) {
            if (name != null && name === deprecations[i]) {
                return i;
            }
            if (msg != null && msg.substring(0, deprecations[i].length) === deprecations[i]) {
                return i;
            }
        }
        return -1;
    }

    /*global QUnit:false*/

    var test = QUnit.test;

    var expect = QUnit.expect;

    function module (name, lifecycle) {
        QUnit.module(name, {
            setup : function () {
                moment.locale('en');
                moment.createFromInputFallback = function (config) {
                    throw new Error('input not handled by moment: ' + config._i);
                };
                setupDeprecationHandler(test, moment, 'core');
                if (lifecycle && lifecycle.setup) {
                    lifecycle.setup();
                }
            },
            teardown : function () {
                teardownDeprecationHandler(test, moment, 'core');
                if (lifecycle && lifecycle.teardown) {
                    lifecycle.teardown();
                }
            }
        });
    }

    function localeModule (name, lifecycle) {
        QUnit.module('locale:' + name, {
            setup : function () {
                moment.locale(name);
                moment.createFromInputFallback = function (config) {
                    throw new Error('input not handled by moment: ' + config._i);
                };
                setupDeprecationHandler(test, moment, 'locale');
                if (lifecycle && lifecycle.setup) {
                    lifecycle.setup();
                }
            },
            teardown : function () {
                moment.locale('en');
                teardownDeprecationHandler(test, moment, 'locale');
                if (lifecycle && lifecycle.teardown) {
                    lifecycle.teardown();
                }
            }
        });
        defineCommonLocaleTests(name, -1, -1);
    }

    localeModule('be');

    test('parse', function (assert) {
        var tests = 'ÑÑÑÐ´Ð·ÐµÐ½Ñ ÑÑÑÐ´_Ð»ÑÑÑ Ð»ÑÑ_ÑÐ°ÐºÐ°Ð²ÑÐº ÑÐ°Ðº_ÐºÑÐ°ÑÐ°Ð²ÑÐº ÐºÑÐ°Ñ_ÑÑÐ°Ð²ÐµÐ½Ñ ÑÑÐ°Ð²_ÑÑÑÐ²ÐµÐ½Ñ ÑÑÑÐ²_Ð»ÑÐ¿ÐµÐ½Ñ Ð»ÑÐ¿_Ð¶Ð½ÑÐ²ÐµÐ½Ñ Ð¶Ð½ÑÐ²_Ð²ÐµÑÐ°ÑÐµÐ½Ñ Ð²ÐµÑ_ÐºÐ°ÑÑÑÑÑÐ½ÑÐº ÐºÐ°ÑÑ_Ð»ÑÑÑÐ°Ð¿Ð°Ð´ Ð»ÑÑÑ_ÑÐ½ÐµÐ¶Ð°Ð½Ñ ÑÐ½ÐµÐ¶'.split('_'), i;
        function equalTest(input, mmm, i) {
            assert.equal(moment(input, mmm).month(), i, input + ' should be month ' + (i + 1));
        }
        for (i = 0; i < 12; i++) {
            tests[i] = tests[i].split(' ');
            equalTest(tests[i][0], 'MMM', i);
            equalTest(tests[i][1], 'MMM', i);
            equalTest(tests[i][0], 'MMMM', i);
            equalTest(tests[i][1], 'MMMM', i);
            equalTest(tests[i][0].toLocaleLowerCase(), 'MMMM', i);
            equalTest(tests[i][1].toLocaleLowerCase(), 'MMMM', i);
            equalTest(tests[i][0].toLocaleUpperCase(), 'MMMM', i);
            equalTest(tests[i][1].toLocaleUpperCase(), 'MMMM', i);
        }
    });

    test('format', function (assert) {
        var a = [
                ['dddd, Do MMMM YYYY, HH:mm:ss',       'Ð½ÑÐ´Ð·ÐµÐ»Ñ, 14-Ð³Ð° Ð»ÑÑÐ°Ð³Ð° 2010, 15:25:50'],
                ['ddd, h A',                           'Ð½Ð´, 3 Ð´Ð½Ñ'],
                ['M Mo MM MMMM MMM',                   '2 2-Ñ 02 Ð»ÑÑÑ Ð»ÑÑ'],
                ['YYYY YY',                            '2010 10'],
                ['D Do DD',                            '14 14-Ð³Ð° 14'],
                ['d do dddd ddd dd',                   '0 0-Ñ Ð½ÑÐ´Ð·ÐµÐ»Ñ Ð½Ð´ Ð½Ð´'],
                ['DDD DDDo DDDD',                      '45 45-Ñ 045'],
                ['w wo ww',                            '7 7-Ñ 07'],
                ['h hh',                               '3 03'],
                ['H HH',                               '15 15'],
                ['m mm',                               '25 25'],
                ['s ss',                               '50 50'],
                ['a A',                                'Ð´Ð½Ñ Ð´Ð½Ñ'],
                ['DDDo [Ð´Ð·ÐµÐ½Ñ Ð³Ð¾Ð´Ð°]',                   '45-Ñ Ð´Ð·ÐµÐ½Ñ Ð³Ð¾Ð´Ð°'],
                ['LT',                                 '15:25'],
                ['LTS',                                '15:25:50'],
                ['L',                                  '14.02.2010'],
                ['LL',                                 '14 Ð»ÑÑÐ°Ð³Ð° 2010 Ð³.'],
                ['LLL',                                '14 Ð»ÑÑÐ°Ð³Ð° 2010 Ð³., 15:25'],
                ['LLLL',                               'Ð½ÑÐ´Ð·ÐµÐ»Ñ, 14 Ð»ÑÑÐ°Ð³Ð° 2010 Ð³., 15:25'],
                ['l',                                  '14.2.2010'],
                ['ll',                                 '14 Ð»ÑÑ 2010 Ð³.'],
                ['lll',                                '14 Ð»ÑÑ 2010 Ð³., 15:25'],
                ['llll',                               'Ð½Ð´, 14 Ð»ÑÑ 2010 Ð³., 15:25']
            ],
            b = moment(new Date(2010, 1, 14, 15, 25, 50, 125)),
            i;
        for (i = 0; i < a.length; i++) {
            assert.equal(b.format(a[i][0]), a[i][1], a[i][0] + ' ---> ' + a[i][1]);
        }
    });

    test('format meridiem', function (assert) {
        assert.equal(moment([2012, 11, 28, 0, 0]).format('A'), 'Ð½Ð¾ÑÑ', 'night');
        assert.equal(moment([2012, 11, 28, 3, 59]).format('A'), 'Ð½Ð¾ÑÑ', 'night');
        assert.equal(moment([2012, 11, 28, 4, 0]).format('A'), 'ÑÐ°Ð½ÑÑÑ', 'morning');
        assert.equal(moment([2012, 11, 28, 11, 59]).format('A'), 'ÑÐ°Ð½ÑÑÑ', 'morning');
        assert.equal(moment([2012, 11, 28, 12, 0]).format('A'), 'Ð´Ð½Ñ', 'afternoon');
        assert.equal(moment([2012, 11, 28, 16, 59]).format('A'), 'Ð´Ð½Ñ', 'afternoon');
        assert.equal(moment([2012, 11, 28, 17, 0]).format('A'), 'Ð²ÐµÑÐ°ÑÐ°', 'evening');
        assert.equal(moment([2012, 11, 28, 23, 59]).format('A'), 'Ð²ÐµÑÐ°ÑÐ°', 'evening');
    });

    test('format ordinal', function (assert) {
        assert.equal(moment([2011, 0, 1]).format('DDDo'), '1-Ñ', '1-Ñ');
        assert.equal(moment([2011, 0, 2]).format('DDDo'), '2-Ñ', '2-Ñ');
        assert.equal(moment([2011, 0, 3]).format('DDDo'), '3-Ñ', '3-Ñ');
        assert.equal(moment([2011, 0, 4]).format('DDDo'), '4-Ñ', '4-Ñ');
        assert.equal(moment([2011, 0, 5]).format('DDDo'), '5-Ñ', '5-Ñ');
        assert.equal(moment([2011, 0, 6]).format('DDDo'), '6-Ñ', '6-Ñ');
        assert.equal(moment([2011, 0, 7]).format('DDDo'), '7-Ñ', '7-Ñ');
        assert.equal(moment([2011, 0, 8]).format('DDDo'), '8-Ñ', '8-Ñ');
        assert.equal(moment([2011, 0, 9]).format('DDDo'), '9-Ñ', '9-Ñ');
        assert.equal(moment([2011, 0, 10]).format('DDDo'), '10-Ñ', '10-Ñ');

        assert.equal(moment([2011, 0, 11]).format('DDDo'), '11-Ñ', '11-Ñ');
        assert.equal(moment([2011, 0, 12]).format('DDDo'), '12-Ñ', '12-Ñ');
        assert.equal(moment([2011, 0, 13]).format('DDDo'), '13-Ñ', '13-Ñ');
        assert.equal(moment([2011, 0, 14]).format('DDDo'), '14-Ñ', '14-Ñ');
        assert.equal(moment([2011, 0, 15]).format('DDDo'), '15-Ñ', '15-Ñ');
        assert.equal(moment([2011, 0, 16]).format('DDDo'), '16-Ñ', '16-Ñ');
        assert.equal(moment([2011, 0, 17]).format('DDDo'), '17-Ñ', '17-Ñ');
        assert.equal(moment([2011, 0, 18]).format('DDDo'), '18-Ñ', '18-Ñ');
        assert.equal(moment([2011, 0, 19]).format('DDDo'), '19-Ñ', '19-Ñ');
        assert.equal(moment([2011, 0, 20]).format('DDDo'), '20-Ñ', '20-Ñ');

        assert.equal(moment([2011, 0, 21]).format('DDDo'), '21-Ñ', '21-Ñ');
        assert.equal(moment([2011, 0, 22]).format('DDDo'), '22-Ñ', '22-Ñ');
        assert.equal(moment([2011, 0, 23]).format('DDDo'), '23-Ñ', '23-Ñ');
        assert.equal(moment([2011, 0, 24]).format('DDDo'), '24-Ñ', '24-Ñ');
        assert.equal(moment([2011, 0, 25]).format('DDDo'), '25-Ñ', '25-Ñ');
        assert.equal(moment([2011, 0, 26]).format('DDDo'), '26-Ñ', '26-Ñ');
        assert.equal(moment([2011, 0, 27]).format('DDDo'), '27-Ñ', '27-Ñ');
        assert.equal(moment([2011, 0, 28]).format('DDDo'), '28-Ñ', '28-Ñ');
        assert.equal(moment([2011, 0, 29]).format('DDDo'), '29-Ñ', '29-Ñ');
        assert.equal(moment([2011, 0, 30]).format('DDDo'), '30-Ñ', '30-Ñ');

        assert.equal(moment([2011, 0, 31]).format('DDDo'), '31-Ñ', '31-Ñ');
    });

    test('format month', function (assert) {
        var expected = 'ÑÑÑÐ´Ð·ÐµÐ½Ñ ÑÑÑÐ´_Ð»ÑÑÑ Ð»ÑÑ_ÑÐ°ÐºÐ°Ð²ÑÐº ÑÐ°Ðº_ÐºÑÐ°ÑÐ°Ð²ÑÐº ÐºÑÐ°Ñ_ÑÑÐ°Ð²ÐµÐ½Ñ ÑÑÐ°Ð²_ÑÑÑÐ²ÐµÐ½Ñ ÑÑÑÐ²_Ð»ÑÐ¿ÐµÐ½Ñ Ð»ÑÐ¿_Ð¶Ð½ÑÐ²ÐµÐ½Ñ Ð¶Ð½ÑÐ²_Ð²ÐµÑÐ°ÑÐµÐ½Ñ Ð²ÐµÑ_ÐºÐ°ÑÑÑÑÑÐ½ÑÐº ÐºÐ°ÑÑ_Ð»ÑÑÑÐ°Ð¿Ð°Ð´ Ð»ÑÑÑ_ÑÐ½ÐµÐ¶Ð°Ð½Ñ ÑÐ½ÐµÐ¶'.split('_'), i;
        for (i = 0; i < expected.length; i++) {
            assert.equal(moment([2011, i, 1]).format('MMMM MMM'), expected[i], expected[i]);
        }
    });

    test('format month case', function (assert) {
        var months = {
            'nominative': 'ÑÑÑÐ´Ð·ÐµÐ½Ñ_Ð»ÑÑÑ_ÑÐ°ÐºÐ°Ð²ÑÐº_ÐºÑÐ°ÑÐ°Ð²ÑÐº_ÑÑÐ°Ð²ÐµÐ½Ñ_ÑÑÑÐ²ÐµÐ½Ñ_Ð»ÑÐ¿ÐµÐ½Ñ_Ð¶Ð½ÑÐ²ÐµÐ½Ñ_Ð²ÐµÑÐ°ÑÐµÐ½Ñ_ÐºÐ°ÑÑÑÑÑÐ½ÑÐº_Ð»ÑÑÑÐ°Ð¿Ð°Ð´_ÑÐ½ÐµÐ¶Ð°Ð½Ñ'.split('_'),
            'accusative': 'ÑÑÑÐ´Ð·ÐµÐ½Ñ_Ð»ÑÑÐ°Ð³Ð°_ÑÐ°ÐºÐ°Ð²ÑÐºÐ°_ÐºÑÐ°ÑÐ°Ð²ÑÐºÐ°_ÑÑÐ°ÑÐ½Ñ_ÑÑÑÐ²ÐµÐ½Ñ_Ð»ÑÐ¿ÐµÐ½Ñ_Ð¶Ð½ÑÑÐ½Ñ_Ð²ÐµÑÐ°ÑÐ½Ñ_ÐºÐ°ÑÑÑÑÑÐ½ÑÐºÐ°_Ð»ÑÑÑÐ°Ð¿Ð°Ð´Ð°_ÑÐ½ÐµÐ¶Ð½Ñ'.split('_')
        }, i;
        for (i = 0; i < 12; i++) {
            assert.equal(moment([2011, i, 1]).format('D MMMM'), '1 ' + months.accusative[i], '1 ' + months.accusative[i]);
            assert.equal(moment([2011, i, 1]).format('MMMM'), months.nominative[i], '1 ' + months.nominative[i]);
        }
    });

    test('format month case with escaped symbols', function (assert) {
        var months = {
            'nominative': 'ÑÑÑÐ´Ð·ÐµÐ½Ñ_Ð»ÑÑÑ_ÑÐ°ÐºÐ°Ð²ÑÐº_ÐºÑÐ°ÑÐ°Ð²ÑÐº_ÑÑÐ°Ð²ÐµÐ½Ñ_ÑÑÑÐ²ÐµÐ½Ñ_Ð»ÑÐ¿ÐµÐ½Ñ_Ð¶Ð½ÑÐ²ÐµÐ½Ñ_Ð²ÐµÑÐ°ÑÐµÐ½Ñ_ÐºÐ°ÑÑÑÑÑÐ½ÑÐº_Ð»ÑÑÑÐ°Ð¿Ð°Ð´_ÑÐ½ÐµÐ¶Ð°Ð½Ñ'.split('_'),
            'accusative': 'ÑÑÑÐ´Ð·ÐµÐ½Ñ_Ð»ÑÑÐ°Ð³Ð°_ÑÐ°ÐºÐ°Ð²ÑÐºÐ°_ÐºÑÐ°ÑÐ°Ð²ÑÐºÐ°_ÑÑÐ°ÑÐ½Ñ_ÑÑÑÐ²ÐµÐ½Ñ_Ð»ÑÐ¿ÐµÐ½Ñ_Ð¶Ð½ÑÑÐ½Ñ_Ð²ÐµÑÐ°ÑÐ½Ñ_ÐºÐ°ÑÑÑÑÑÐ½ÑÐºÐ°_Ð»ÑÑÑÐ°Ð¿Ð°Ð´Ð°_ÑÐ½ÐµÐ¶Ð½Ñ'.split('_')
        }, i;
        for (i = 0; i < 12; i++) {
            assert.equal(moment([2013, i, 1]).format('D[] MMMM'), '1 ' + months.accusative[i], '1 ' + months.accusative[i]);
            assert.equal(moment([2013, i, 1]).format('[<i>]D[</i>] [<b>]MMMM[</b>]'), '<i>1</i> <b>' + months.accusative[i] + '</b>', '1 <b>' + months.accusative[i] + '</b>');
            assert.equal(moment([2013, i, 1]).format('D[-Ñ Ð´Ð·ÐµÐ½Ñ] MMMM'), '1-Ñ Ð´Ð·ÐµÐ½Ñ ' + months.accusative[i], '1-Ñ Ð´Ð·ÐµÐ½Ñ ' + months.accusative[i]);
            assert.equal(moment([2013, i, 1]).format('D, MMMM'), '1, ' + months.nominative[i], '1, ' + months.nominative[i]);
        }
    });

    test('format week', function (assert) {
        var expected = 'Ð½ÑÐ´Ð·ÐµÐ»Ñ Ð½Ð´ Ð½Ð´_Ð¿Ð°Ð½ÑÐ´Ð·ÐµÐ»Ð°Ðº Ð¿Ð½ Ð¿Ð½_Ð°ÑÑÐ¾ÑÐ°Ðº Ð°Ñ Ð°Ñ_ÑÐµÑÐ°Ð´Ð° ÑÑ ÑÑ_ÑÐ°ÑÐ²ÐµÑ ÑÑ ÑÑ_Ð¿ÑÑÐ½ÑÑÐ° Ð¿Ñ Ð¿Ñ_ÑÑÐ±Ð¾ÑÐ° ÑÐ± ÑÐ±'.split('_'), i;
        for (i = 0; i < expected.length; i++) {
            assert.equal(moment([2011, 0, 2 + i]).format('dddd ddd dd'), expected[i], expected[i]);
        }
    });

    test('from', function (assert) {
        var start = moment([2007, 1, 28]);
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 44}), true),  'Ð½ÐµÐºÐ°Ð»ÑÐºÑ ÑÐµÐºÑÐ½Ð´',    '44 seconds = a few seconds');
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 45}), true),  'ÑÐ²ÑÐ»ÑÐ½Ð°',   '45 seconds = a minute');
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 89}), true),  'ÑÐ²ÑÐ»ÑÐ½Ð°',   '89 seconds = a minute');
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 90}), true),  '2 ÑÐ²ÑÐ»ÑÐ½Ñ',  '90 seconds = 2 minutes');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 31}), true),  '31 ÑÐ²ÑÐ»ÑÐ½Ð°',  '31 minutes = 31 minutes');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 44}), true),  '44 ÑÐ²ÑÐ»ÑÐ½Ñ', '44 minutes = 44 minutes');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 45}), true),  'Ð³Ð°Ð´Ð·ÑÐ½Ð°',    '45 minutes = an hour');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 89}), true),  'Ð³Ð°Ð´Ð·ÑÐ½Ð°',    '89 minutes = an hour');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 90}), true),  '2 Ð³Ð°Ð´Ð·ÑÐ½Ñ',    '90 minutes = 2 hours');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 5}), true),   '5 Ð³Ð°Ð´Ð·ÑÐ½',    '5 hours = 5 hours');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 21}), true),  '21 Ð³Ð°Ð´Ð·ÑÐ½Ð°',   '21 hours = 21 hours');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 22}), true),  'Ð´Ð·ÐµÐ½Ñ',      '22 hours = a day');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 35}), true),  'Ð´Ð·ÐµÐ½Ñ',      '35 hours = a day');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 36}), true),  '2 Ð´Ð½Ñ',     '36 hours = 2 days');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 1}), true),   'Ð´Ð·ÐµÐ½Ñ',      '1 day = a day');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 5}), true),   '5 Ð´Ð·ÑÐ½',     '5 days = 5 days');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 11}), true),  '11 Ð´Ð·ÑÐ½',     '11 days = 11 days');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 21}), true),  '21 Ð´Ð·ÐµÐ½Ñ',     '21 days = 21 days');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 25}), true),  '25 Ð´Ð·ÑÐ½',    '25 days = 25 days');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 26}), true),  'Ð¼ÐµÑÑÑ',    '26 days = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 30}), true),  'Ð¼ÐµÑÑÑ',    '30 days = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 43}), true),  'Ð¼ÐµÑÑÑ',    '43 days = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 46}), true),  '2 Ð¼ÐµÑÑÑÑ',   '46 days = 2 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 74}), true),  '2 Ð¼ÐµÑÑÑÑ',   '75 days = 2 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 76}), true),  '3 Ð¼ÐµÑÑÑÑ',   '76 days = 3 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({M: 1}), true),   'Ð¼ÐµÑÑÑ',    '1 month = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({M: 5}), true),   '5 Ð¼ÐµÑÑÑÐ°Ñ',   '5 months = 5 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 345}), true), 'Ð³Ð¾Ð´',     '345 days = a year');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 548}), true), '2 Ð³Ð°Ð´Ñ',    '548 days = 2 years');
        assert.equal(start.from(moment([2007, 1, 28]).add({y: 1}), true),   'Ð³Ð¾Ð´',     '1 year = a year');
        assert.equal(start.from(moment([2007, 1, 28]).add({y: 5}), true),   '5 Ð³Ð°Ð´Ð¾Ñ',    '5 years = 5 years');
    });

    test('suffix', function (assert) {
        assert.equal(moment(30000).from(0), 'Ð¿ÑÐ°Ð· Ð½ÐµÐºÐ°Ð»ÑÐºÑ ÑÐµÐºÑÐ½Ð´', 'prefix');
        assert.equal(moment(0).from(30000), 'Ð½ÐµÐºÐ°Ð»ÑÐºÑ ÑÐµÐºÑÐ½Ð´ ÑÐ°Ð¼Ñ', 'suffix');
    });

    test('fromNow', function (assert) {
        assert.equal(moment().add({s: 30}).fromNow(), 'Ð¿ÑÐ°Ð· Ð½ÐµÐºÐ°Ð»ÑÐºÑ ÑÐµÐºÑÐ½Ð´', 'in a few seconds');
        assert.equal(moment().add({d: 5}).fromNow(), 'Ð¿ÑÐ°Ð· 5 Ð´Ð·ÑÐ½', 'in 5 days');
        assert.equal(moment().add({m: 31}).fromNow(), 'Ð¿ÑÐ°Ð· 31 ÑÐ²ÑÐ»ÑÐ½Ñ', 'in 31 minutes = in 31 minutes');
        assert.equal(moment().subtract({m: 31}).fromNow(), '31 ÑÐ²ÑÐ»ÑÐ½Ñ ÑÐ°Ð¼Ñ', '31 minutes ago = 31 minutes ago');
    });

    test('calendar day', function (assert) {
        var a = moment().hours(12).minutes(0).seconds(0);

        assert.equal(moment(a).calendar(),                   'Ð¡ÑÐ½Ð½Ñ Ñ 12:00',     'today at the same time');
        assert.equal(moment(a).add({m: 25}).calendar(),      'Ð¡ÑÐ½Ð½Ñ Ñ 12:25',     'Now plus 25 min');
        assert.equal(moment(a).add({h: 1}).calendar(),       'Ð¡ÑÐ½Ð½Ñ Ñ 13:00',     'Now plus 1 hour');
        assert.equal(moment(a).add({d: 1}).calendar(),       'ÐÐ°ÑÑÑÐ° Ñ 12:00',    'tomorrow at the same time');
        assert.equal(moment(a).subtract({h: 1}).calendar(),  'Ð¡ÑÐ½Ð½Ñ Ñ 11:00',     'Now minus 1 hour');
        assert.equal(moment(a).subtract({d: 1}).calendar(),  'Ð£ÑÐ¾ÑÐ° Ñ 12:00',     'yesterday at the same time');
    });

    test('calendar next week', function (assert) {
        var i, m;
        function makeFormat(d) {
            return '[Ð£] dddd [Ñ] LT';
        }

        for (i = 2; i < 7; i++) {
            m = moment().add({d: i});
            assert.equal(m.calendar(),       m.format(makeFormat(m)),  'Today + ' + i + ' days current time');
            m.hours(0).minutes(0).seconds(0).milliseconds(0);
            assert.equal(m.calendar(),       m.format(makeFormat(m)),  'Today + ' + i + ' days beginning of day');
            m.hours(23).minutes(59).seconds(59).milliseconds(999);
            assert.equal(m.calendar(),       m.format(makeFormat(m)),  'Today + ' + i + ' days end of day');
        }
    });

    test('calendar last week', function (assert) {
        var i, m;

        function makeFormat(d) {
            switch (d.day()) {
            case 0:
            case 3:
            case 5:
            case 6:
                return '[Ð£ Ð¼ÑÐ½ÑÐ»ÑÑ] dddd [Ñ] LT';
            case 1:
            case 2:
            case 4:
                return '[Ð£ Ð¼ÑÐ½ÑÐ»Ñ] dddd [Ñ] LT';
            }
        }

        for (i = 2; i < 7; i++) {
            m = moment().subtract({d: i});
            assert.equal(m.calendar(),       m.format(makeFormat(m)),  'Today - ' + i + ' days current time');
            m.hours(0).minutes(0).seconds(0).milliseconds(0);
            assert.equal(m.calendar(),       m.format(makeFormat(m)),  'Today - ' + i + ' days beginning of day');
            m.hours(23).minutes(59).seconds(59).milliseconds(999);
            assert.equal(m.calendar(),       m.format(makeFormat(m)),  'Today - ' + i + ' days end of day');
        }
    });

    test('calendar all else', function (assert) {
        var weeksAgo = moment().subtract({w: 1}),
            weeksFromNow = moment().add({w: 1});

        assert.equal(weeksAgo.calendar(),       weeksAgo.format('L'),  '1 week ago');
        assert.equal(weeksFromNow.calendar(),   weeksFromNow.format('L'),  'in 1 week');

        weeksAgo = moment().subtract({w: 2});
        weeksFromNow = moment().add({w: 2});

        assert.equal(weeksAgo.calendar(),       weeksAgo.format('L'),  '2 weeks ago');
        assert.equal(weeksFromNow.calendar(),   weeksFromNow.format('L'),  'in 2 weeks');
    });

    test('weeks year starting sunday formatted', function (assert) {
        assert.equal(moment([2011, 11, 26]).format('w ww wo'), '1 01 1-Ñ', 'Dec 26 2011 should be week 1');
        assert.equal(moment([2012,  0,  1]).format('w ww wo'), '1 01 1-Ñ', 'Jan  1 2012 should be week 1');
        assert.equal(moment([2012,  0,  2]).format('w ww wo'), '2 02 2-Ñ', 'Jan  2 2012 should be week 2');
        assert.equal(moment([2012,  0,  8]).format('w ww wo'), '2 02 2-Ñ', 'Jan  8 2012 should be week 2');
        assert.equal(moment([2012,  0,  9]).format('w ww wo'), '3 03 3-Ñ', 'Jan  9 2012 should be week 3');
    });

}));

;(function (global, factory) {
   typeof exports === 'object' && typeof module !== 'undefined'
       && typeof require === 'function' ? factory(require('../../moment')) :
   typeof define === 'function' && define.amd ? define(['../../moment'], factory) :
   factory(global.moment)
}(this, function (moment) { 'use strict';

    function each(array, callback) {
        var i;
        for (i = 0; i < array.length; i++) {
            callback(array[i], i, array);
        }
    }

    function objectKeys(obj) {
        if (Object.keys) {
            return Object.keys(obj);
        } else {
            // IE8
            var res = [], i;
            for (i in obj) {
                if (obj.hasOwnProperty(i)) {
                    res.push(i);
                }
            }
            return res;
        }
    }

    // Pick the first defined of two or three arguments.
    function defaults(a, b, c) {
        if (a != null) {
            return a;
        }
        if (b != null) {
            return b;
        }
        return c;
    }

    function defineCommonLocaleTests(locale, options) {
        test('lenient ordinal parsing', function (assert) {
            var i, ordinalStr, testMoment;
            for (i = 1; i <= 31; ++i) {
                ordinalStr = moment([2014, 0, i]).format('YYYY MM Do');
                testMoment = moment(ordinalStr, 'YYYY MM Do');
                assert.equal(testMoment.year(), 2014,
                        'lenient ordinal parsing ' + i + ' year check');
                assert.equal(testMoment.month(), 0,
                        'lenient ordinal parsing ' + i + ' month check');
                assert.equal(testMoment.date(), i,
                        'lenient ordinal parsing ' + i + ' date check');
            }
        });

        test('lenient ordinal parsing of number', function (assert) {
            var i, testMoment;
            for (i = 1; i <= 31; ++i) {
                testMoment = moment('2014 01 ' + i, 'YYYY MM Do');
                assert.equal(testMoment.year(), 2014,
                        'lenient ordinal parsing of number ' + i + ' year check');
                assert.equal(testMoment.month(), 0,
                        'lenient ordinal parsing of number ' + i + ' month check');
                assert.equal(testMoment.date(), i,
                        'lenient ordinal parsing of number ' + i + ' date check');
            }
        });

        test('strict ordinal parsing', function (assert) {
            var i, ordinalStr, testMoment;
            for (i = 1; i <= 31; ++i) {
                ordinalStr = moment([2014, 0, i]).format('YYYY MM Do');
                testMoment = moment(ordinalStr, 'YYYY MM Do', true);
                assert.ok(testMoment.isValid(), 'strict ordinal parsing ' + i);
            }
        });

        test('meridiem invariant', function (assert) {
            var h, m, t1, t2;
            for (h = 0; h < 24; ++h) {
                for (m = 0; m < 60; m += 15) {
                    t1 = moment.utc([2000, 0, 1, h, m]);
                    t2 = moment.utc(t1.format('A h:mm'), 'A h:mm');
                    assert.equal(t2.format('HH:mm'), t1.format('HH:mm'),
                            'meridiem at ' + t1.format('HH:mm'));
                }
            }
        });

        test('date format correctness', function (assert) {
            var data, tokens;
            data = moment.localeData()._longDateFormat;
            tokens = objectKeys(data);
            each(tokens, function (srchToken) {
                // Check each format string to make sure it does not contain any
                // tokens that need to be expanded.
                each(tokens, function (baseToken) {
                    // strip escaped sequences
                    var format = data[baseToken].replace(/(\[[^\]]*\])/g, '');
                    assert.equal(false, !!~format.indexOf(srchToken),
                            'contains ' + srchToken + ' in ' + baseToken);
                });
            });
        });

        test('month parsing correctness', function (assert) {
            var i, m;

            if (locale === 'tr') {
                // I can't fix it :(
                expect(0);
                return;
            }
            function tester(format) {
                var r;
                r = moment(m.format(format), format);
                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format);
                r = moment(m.format(format).toLocaleUpperCase(), format);
                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' upper');
                r = moment(m.format(format).toLocaleLowerCase(), format);
                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' lower');

                r = moment(m.format(format), format, true);
                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' strict');
                r = moment(m.format(format).toLocaleUpperCase(), format, true);
                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' upper strict');
                r = moment(m.format(format).toLocaleLowerCase(), format, true);
                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' lower strict');
            }

            for (i = 0; i < 12; ++i) {
                m = moment([2015, i, 15, 18]);
                tester('MMM');
                tester('MMM.');
                tester('MMMM');
                tester('MMMM.');
            }
        });

        test('weekday parsing correctness', function (assert) {
            var i, m;

            if (locale === 'tr' || locale === 'az') {
                // There is a lower-case letter (Ä±), that converted to upper then
                // lower changes to i
                expect(0);
                return;
            }
            function tester(format) {
                var r, baseMsg = 'weekday ' + m.weekday() + ' fmt ' + format;
                r = moment(m.format(format), format);
                assert.equal(r.weekday(), m.weekday(), baseMsg);
                r = moment(m.format(format).toLocaleUpperCase(), format);
                assert.equal(r.weekday(), m.weekday(), baseMsg + ' upper');
                r = moment(m.format(format).toLocaleLowerCase(), format);
                assert.equal(r.weekday(), m.weekday(), baseMsg + ' lower');

                r = moment(m.format(format), format, true);
                assert.equal(r.weekday(), m.weekday(), baseMsg + ' strict');
                r = moment(m.format(format).toLocaleUpperCase(), format, true);
                assert.equal(r.weekday(), m.weekday(), baseMsg + ' upper strict');
                r = moment(m.format(format).toLocaleLowerCase(), format, true);
                assert.equal(r.weekday(), m.weekday(), baseMsg + ' lower strict');
            }

            for (i = 0; i < 7; ++i) {
                m = moment.utc([2015, i, 15, 18]);
                tester('dd');
                tester('ddd');
                tester('dddd');
            }
        });
    }

    function setupDeprecationHandler(test, moment, scope) {
        test._expectedDeprecations = null;
        test._observedDeprecations = null;
        test._oldSupress = moment.suppressDeprecationWarnings;
        moment.suppressDeprecationWarnings = true;
        test.expectedDeprecations = function () {
            test._expectedDeprecations = arguments;
            test._observedDeprecations = [];
        };
        moment.deprecationHandler = function (name, msg) {
            var deprecationId = matchedDeprecation(name, msg, test._expectedDeprecations);
            if (deprecationId === -1) {
                throw new Error('Unexpected deprecation thrown name=' +
                        name + ' msg=' + msg);
            }
            test._observedDeprecations[deprecationId] = 1;
        };
    }

    function teardownDeprecationHandler(test, moment, scope) {
        moment.suppressDeprecationWarnings = test._oldSupress;

        if (test._expectedDeprecations != null) {
            var missedDeprecations = [];
            each(test._expectedDeprecations, function (deprecationPattern, id) {
                if (test._observedDeprecations[id] !== 1) {
                    missedDeprecations.push(deprecationPattern);
                }
            });
            if (missedDeprecations.length !== 0) {
                throw new Error('Expected deprecation warnings did not happen: ' +
                        missedDeprecations.join(' '));
            }
        }
    }

    function matchedDeprecation(name, msg, deprecations) {
        if (deprecations == null) {
            return -1;
        }
        for (var i = 0; i < deprecations.length; ++i) {
            if (name != null && name === deprecations[i]) {
                return i;
            }
            if (msg != null && msg.substring(0, deprecations[i].length) === deprecations[i]) {
                return i;
            }
        }
        return -1;
    }

    /*global QUnit:false*/

    var test = QUnit.test;

    var expect = QUnit.expect;

    function module (name, lifecycle) {
        QUnit.module(name, {
            setup : function () {
                moment.locale('en');
                moment.createFromInputFallback = function (config) {
                    throw new Error('input not handled by moment: ' + config._i);
                };
                setupDeprecationHandler(test, moment, 'core');
                if (lifecycle && lifecycle.setup) {
                    lifecycle.setup();
                }
            },
            teardown : function () {
                teardownDeprecationHandler(test, moment, 'core');
                if (lifecycle && lifecycle.teardown) {
                    lifecycle.teardown();
                }
            }
        });
    }

    function localeModule (name, lifecycle) {
        QUnit.module('locale:' + name, {
            setup : function () {
                moment.locale(name);
                moment.createFromInputFallback = function (config) {
                    throw new Error('input not handled by moment: ' + config._i);
                };
                setupDeprecationHandler(test, moment, 'locale');
                if (lifecycle && lifecycle.setup) {
                    lifecycle.setup();
                }
            },
            teardown : function () {
                moment.locale('en');
                teardownDeprecationHandler(test, moment, 'locale');
                if (lifecycle && lifecycle.teardown) {
                    lifecycle.teardown();
                }
            }
        });
        defineCommonLocaleTests(name, -1, -1);
    }

    localeModule('bg');

    test('parse', function (assert) {
        var tests = 'ÑÐ½ÑÐ°ÑÐ¸ ÑÐ½Ñ_ÑÐµÐ²ÑÑÐ°ÑÐ¸ ÑÐµÐ²_Ð¼Ð°ÑÑ Ð¼Ð°Ñ_Ð°Ð¿ÑÐ¸Ð» Ð°Ð¿Ñ_Ð¼Ð°Ð¹ Ð¼Ð°Ð¹_ÑÐ½Ð¸ ÑÐ½Ð¸_ÑÐ»Ð¸ ÑÐ»Ð¸_Ð°Ð²Ð³ÑÑÑ Ð°Ð²Ð³_ÑÐµÐ¿ÑÐµÐ¼Ð²ÑÐ¸ ÑÐµÐ¿_Ð¾ÐºÑÐ¾Ð¼Ð²ÑÐ¸ Ð¾ÐºÑ_Ð½Ð¾ÐµÐ¼Ð²ÑÐ¸ Ð½Ð¾Ðµ_Ð´ÐµÐºÐµÐ¼Ð²ÑÐ¸ Ð´ÐµÐº'.split('_'), i;
        function equalTest(input, mmm, i) {
            assert.equal(moment(input, mmm).month(), i, input + ' should be month ' + (i + 1));
        }
        for (i = 0; i < 12; i++) {
            tests[i] = tests[i].split(' ');
            equalTest(tests[i][0], 'MMM', i);
            equalTest(tests[i][1], 'MMM', i);
            equalTest(tests[i][0], 'MMMM', i);
            equalTest(tests[i][1], 'MMMM', i);
            equalTest(tests[i][0].toLocaleLowerCase(), 'MMMM', i);
            equalTest(tests[i][1].toLocaleLowerCase(), 'MMMM', i);
            equalTest(tests[i][0].toLocaleUpperCase(), 'MMMM', i);
            equalTest(tests[i][1].toLocaleUpperCase(), 'MMMM', i);
        }
    });

    test('format', function (assert) {
        var a = [
                ['dddd, MMMM Do YYYY, H:mm:ss',        'Ð½ÐµÐ´ÐµÐ»Ñ, ÑÐµÐ²ÑÑÐ°ÑÐ¸ 14-ÑÐ¸ 2010, 15:25:50'],
                ['ddd, hA',                            'Ð½ÐµÐ´, 3PM'],
                ['M Mo MM MMMM MMM',                   '2 2-ÑÐ¸ 02 ÑÐµÐ²ÑÑÐ°ÑÐ¸ ÑÐµÐ²'],
                ['YYYY YY',                            '2010 10'],
                ['D Do DD',                            '14 14-ÑÐ¸ 14'],
                ['d do dddd ddd dd',                   '0 0-ÐµÐ² Ð½ÐµÐ´ÐµÐ»Ñ Ð½ÐµÐ´ Ð½Ð´'],
                ['DDD DDDo DDDD',                      '45 45-ÑÐ¸ 045'],
                ['w wo ww',                            '7 7-Ð¼Ð¸ 07'],
                ['h hh',                               '3 03'],
                ['H HH',                               '15 15'],
                ['m mm',                               '25 25'],
                ['s ss',                               '50 50'],
                ['a A',                                'pm PM'],
                ['[the] DDDo [day of the year]',       'the 45-ÑÐ¸ day of the year'],
                ['LT',                                 '15:25'],
                ['LTS',                                '15:25:50'],
                ['L',                                  '14.02.2010'],
                ['LL',                                 '14 ÑÐµÐ²ÑÑÐ°ÑÐ¸ 2010'],
                ['LLL',                                '14 ÑÐµÐ²ÑÑÐ°ÑÐ¸ 2010 15:25'],
                ['LLLL',                               'Ð½ÐµÐ´ÐµÐ»Ñ, 14 ÑÐµÐ²ÑÑÐ°ÑÐ¸ 2010 15:25'],
                ['l',                                  '14.2.2010'],
                ['ll',                                 '14 ÑÐµÐ² 2010'],
                ['lll',                                '14 ÑÐµÐ² 2010 15:25'],
                ['llll',                               'Ð½ÐµÐ´, 14 ÑÐµÐ² 2010 15:25']
            ],
            b = moment(new Date(2010, 1, 14, 15, 25, 50, 125)),
            i;
        for (i = 0; i < a.length; i++) {
            assert.equal(b.format(a[i][0]), a[i][1], a[i][0] + ' ---> ' + a[i][1]);
        }
    });

    test('format ordinal', function (assert) {
        assert.equal(moment([2011, 0, 1]).format('DDDo'), '1-Ð²Ð¸', '1-Ð²Ð¸');
        assert.equal(moment([2011, 0, 2]).format('DDDo'), '2-ÑÐ¸', '2-ÑÐ¸');
        assert.equal(moment([2011, 0, 3]).format('DDDo'), '3-ÑÐ¸', '3-ÑÐ¸');
        assert.equal(moment([2011, 0, 4]).format('DDDo'), '4-ÑÐ¸', '4-ÑÐ¸');
        assert.equal(moment([2011, 0, 5]).format('DDDo'), '5-ÑÐ¸', '5-ÑÐ¸');
        assert.equal(moment([2011, 0, 6]).format('DDDo'), '6-ÑÐ¸', '6-ÑÐ¸');
        assert.equal(moment([2011, 0, 7]).format('DDDo'), '7-Ð¼Ð¸', '7-Ð¼Ð¸');
        assert.equal(moment([2011, 0, 8]).format('DDDo'), '8-Ð¼Ð¸', '8-Ð¼Ð¸');
        assert.equal(moment([2011, 0, 9]).format('DDDo'), '9-ÑÐ¸', '9-ÑÐ¸');
        assert.equal(moment([2011, 0, 10]).format('DDDo'), '10-ÑÐ¸', '10-ÑÐ¸');

        assert.equal(moment([2011, 0, 11]).format('DDDo'), '11-ÑÐ¸', '11-ÑÐ¸');
        assert.equal(moment([2011, 0, 12]).format('DDDo'), '12-ÑÐ¸', '12-ÑÐ¸');
        assert.equal(moment([2011, 0, 13]).format('DDDo'), '13-ÑÐ¸', '13-ÑÐ¸');
        assert.equal(moment([2011, 0, 14]).format('DDDo'), '14-ÑÐ¸', '14-ÑÐ¸');
        assert.equal(moment([2011, 0, 15]).format('DDDo'), '15-ÑÐ¸', '15-ÑÐ¸');
        assert.equal(moment([2011, 0, 16]).format('DDDo'), '16-ÑÐ¸', '16-ÑÐ¸');
        assert.equal(moment([2011, 0, 17]).format('DDDo'), '17-ÑÐ¸', '17-ÑÐ¸');
        assert.equal(moment([2011, 0, 18]).format('DDDo'), '18-ÑÐ¸', '18-ÑÐ¸');
        assert.equal(moment([2011, 0, 19]).format('DDDo'), '19-ÑÐ¸', '19-ÑÐ¸');
        assert.equal(moment([2011, 0, 20]).format('DDDo'), '20-ÑÐ¸', '20-ÑÐ¸');

        assert.equal(moment([2011, 0, 21]).format('DDDo'), '21-Ð²Ð¸', '21-Ð²Ð¸');
        assert.equal(moment([2011, 0, 22]).format('DDDo'), '22-ÑÐ¸', '22-ÑÐ¸');
        assert.equal(moment([2011, 0, 23]).format('DDDo'), '23-ÑÐ¸', '23-ÑÐ¸');
        assert.equal(moment([2011, 0, 24]).format('DDDo'), '24-ÑÐ¸', '24-ÑÐ¸');
        assert.equal(moment([2011, 0, 25]).format('DDDo'), '25-ÑÐ¸', '25-ÑÐ¸');
        assert.equal(moment([2011, 0, 26]).format('DDDo'), '26-ÑÐ¸', '26-ÑÐ¸');
        assert.equal(moment([2011, 0, 27]).format('DDDo'), '27-Ð¼Ð¸', '27-Ð¼Ð¸');
        assert.equal(moment([2011, 0, 28]).format('DDDo'), '28-Ð¼Ð¸', '28-Ð¼Ð¸');
        assert.equal(moment([2011, 0, 29]).format('DDDo'), '29-ÑÐ¸', '29-ÑÐ¸');
        assert.equal(moment([2011, 0, 30]).format('DDDo'), '30-ÑÐ¸', '30-ÑÐ¸');

        assert.equal(moment([2011, 0, 31]).format('DDDo'), '31-Ð²Ð¸', '31-Ð²Ð¸');
    });

    test('format month', function (assert) {
        var expected = 'ÑÐ½ÑÐ°ÑÐ¸ ÑÐ½Ñ_ÑÐµÐ²ÑÑÐ°ÑÐ¸ ÑÐµÐ²_Ð¼Ð°ÑÑ Ð¼Ð°Ñ_Ð°Ð¿ÑÐ¸Ð» Ð°Ð¿Ñ_Ð¼Ð°Ð¹ Ð¼Ð°Ð¹_ÑÐ½Ð¸ ÑÐ½Ð¸_ÑÐ»Ð¸ ÑÐ»Ð¸_Ð°Ð²Ð³ÑÑÑ Ð°Ð²Ð³_ÑÐµÐ¿ÑÐµÐ¼Ð²ÑÐ¸ ÑÐµÐ¿_Ð¾ÐºÑÐ¾Ð¼Ð²ÑÐ¸ Ð¾ÐºÑ_Ð½Ð¾ÐµÐ¼Ð²ÑÐ¸ Ð½Ð¾Ðµ_Ð´ÐµÐºÐµÐ¼Ð²ÑÐ¸ Ð´ÐµÐº'.split('_'), i;
        for (i = 0; i < expected.length; i++) {
            assert.equal(moment([2011, i, 1]).format('MMMM MMM'), expected[i], expected[i]);
        }
    });

    test('format week', function (assert) {
        var expected = 'Ð½ÐµÐ´ÐµÐ»Ñ Ð½ÐµÐ´ Ð½Ð´_Ð¿Ð¾Ð½ÐµÐ´ÐµÐ»Ð½Ð¸Ðº Ð¿Ð¾Ð½ Ð¿Ð½_Ð²ÑÐ¾ÑÐ½Ð¸Ðº Ð²ÑÐ¾ Ð²Ñ_ÑÑÑÐ´Ð° ÑÑÑ ÑÑ_ÑÐµÑÐ²ÑÑÑÑÐº ÑÐµÑ ÑÑ_Ð¿ÐµÑÑÐº Ð¿ÐµÑ Ð¿Ñ_ÑÑÐ±Ð¾ÑÐ° ÑÑÐ± ÑÐ±'.split('_'), i;
        for (i = 0; i < expected.length; i++) {
            assert.equal(moment([2011, 0, 2 + i]).format('dddd ddd dd'), expected[i], expected[i]);
        }
    });

    test('from', function (assert) {
        var start = moment([2007, 1, 28]);
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 44}), true),  'Ð½ÑÐºÐ¾Ð»ÐºÐ¾ ÑÐµÐºÑÐ½Ð´Ð¸', '44 seconds = a few seconds');
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 45}), true),  'Ð¼Ð¸Ð½ÑÑÐ°',          '45 seconds = a minute');
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 89}), true),  'Ð¼Ð¸Ð½ÑÑÐ°',          '89 seconds = a minute');
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 90}), true),  '2 Ð¼Ð¸Ð½ÑÑÐ¸',        '90 seconds = 2 minutes');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 44}), true),  '44 Ð¼Ð¸Ð½ÑÑÐ¸',       '44 minutes = 44 minutes');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 45}), true),  'ÑÐ°Ñ',             '45 minutes = an hour');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 89}), true),  'ÑÐ°Ñ',             '89 minutes = an hour');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 90}), true),  '2 ÑÐ°ÑÐ°',          '90 minutes = 2 hours');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 5}), true),   '5 ÑÐ°ÑÐ°',          '5 hours = 5 hours');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 21}), true),  '21 ÑÐ°ÑÐ°',         '21 hours = 21 hours');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 22}), true),  'Ð´ÐµÐ½',             '22 hours = a day');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 35}), true),  'Ð´ÐµÐ½',             '35 hours = a day');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 36}), true),  '2 Ð´Ð½Ð¸',           '36 hours = 2 days');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 1}), true),   'Ð´ÐµÐ½',             '1 day = a day');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 5}), true),   '5 Ð´Ð½Ð¸',           '5 days = 5 days');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 25}), true),  '25 Ð´Ð½Ð¸',          '25 days = 25 days');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 26}), true),  'Ð¼ÐµÑÐµÑ',           '26 days = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 30}), true),  'Ð¼ÐµÑÐµÑ',           '30 days = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 43}), true),  'Ð¼ÐµÑÐµÑ',           '43 days = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 46}), true),  '2 Ð¼ÐµÑÐµÑÐ°',        '46 days = 2 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 74}), true),  '2 Ð¼ÐµÑÐµÑÐ°',        '75 days = 2 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 76}), true),  '3 Ð¼ÐµÑÐµÑÐ°',        '76 days = 3 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({M: 1}), true),   'Ð¼ÐµÑÐµÑ',           '1 month = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({M: 5}), true),   '5 Ð¼ÐµÑÐµÑÐ°',        '5 months = 5 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 345}), true), 'Ð³Ð¾Ð´Ð¸Ð½Ð°',          '345 days = a year');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 548}), true), '2 Ð³Ð¾Ð´Ð¸Ð½Ð¸',        '548 days = 2 years');
        assert.equal(start.from(moment([2007, 1, 28]).add({y: 1}), true),   'Ð³Ð¾Ð´Ð¸Ð½Ð°',          '1 year = a year');
        assert.equal(start.from(moment([2007, 1, 28]).add({y: 5}), true),   '5 Ð³Ð¾Ð´Ð¸Ð½Ð¸',        '5 years = 5 years');
    });

    test('suffix', function (assert) {
        assert.equal(moment(30000).from(0), 'ÑÐ»ÐµÐ´ Ð½ÑÐºÐ¾Ð»ÐºÐ¾ ÑÐµÐºÑÐ½Ð´Ð¸',  'prefix');
        assert.equal(moment(0).from(30000), 'Ð¿ÑÐµÐ´Ð¸ Ð½ÑÐºÐ¾Ð»ÐºÐ¾ ÑÐµÐºÑÐ½Ð´Ð¸', 'suffix');
    });

    test('now from now', function (assert) {
        assert.equal(moment().fromNow(), 'Ð¿ÑÐµÐ´Ð¸ Ð½ÑÐºÐ¾Ð»ÐºÐ¾ ÑÐµÐºÑÐ½Ð´Ð¸',  'now from now should display as in the past');
    });

    test('fromNow', function (assert) {
        assert.equal(moment().add({s: 30}).fromNow(), 'ÑÐ»ÐµÐ´ Ð½ÑÐºÐ¾Ð»ÐºÐ¾ ÑÐµÐºÑÐ½Ð´Ð¸', 'in a few seconds');
        assert.equal(moment().add({d: 5}).fromNow(), 'ÑÐ»ÐµÐ´ 5 Ð´Ð½Ð¸', 'in 5 days');
    });

    test('calendar day', function (assert) {
        var a = moment().hours(12).minutes(0).seconds(0);

        assert.equal(moment(a).calendar(),                   'ÐÐ½ÐµÑ Ð² 12:00',  'today at the same time');
        assert.equal(moment(a).add({m: 25}).calendar(),      'ÐÐ½ÐµÑ Ð² 12:25',  'Now plus 25 min');
        assert.equal(moment(a).add({h: 1}).calendar(),       'ÐÐ½ÐµÑ Ð² 13:00',  'Now plus 1 hour');
        assert.equal(moment(a).add({d: 1}).calendar(),       'Ð£ÑÑÐµ Ð² 12:00',  'tomorrow at the same time');
        assert.equal(moment(a).subtract({h: 1}).calendar(),  'ÐÐ½ÐµÑ Ð² 11:00',  'Now minus 1 hour');
        assert.equal(moment(a).subtract({d: 1}).calendar(),  'ÐÑÐµÑÐ° Ð² 12:00', 'yesterday at the same time');
    });

    test('calendar next week', function (assert) {
        var i, m;
        for (i = 2; i < 7; i++) {
            m = moment().add({d: i});
            assert.equal(m.calendar(),       m.format('dddd [Ð²] LT'),  'Today + ' + i + ' days current time');
            m.hours(0).minutes(0).seconds(0).milliseconds(0);
            assert.equal(m.calendar(),       m.format('dddd [Ð²] LT'),  'Today + ' + i + ' days beginning of day');
            m.hours(23).minutes(59).seconds(59).milliseconds(999);
            assert.equal(m.calendar(),       m.format('dddd [Ð²] LT'),  'Today + ' + i + ' days end of day');
        }
    });

    test('calendar last week', function (assert) {
        var i, m;

        function makeFormat(d) {
            switch (d.day()) {
            case 0:
            case 3:
            case 6:
                return '[Ð Ð¸Ð·Ð¼Ð¸Ð½Ð°Ð»Ð°ÑÐ°] dddd [Ð²] LT';
            case 1:
            case 2:
            case 4:
            case 5:
                return '[Ð Ð¸Ð·Ð¼Ð¸Ð½Ð°Ð»Ð¸Ñ] dddd [Ð²] LT';
            }
        }

        for (i = 2; i < 7; i++) {
            m = moment().subtract({d: i});
            assert.equal(m.calendar(),       m.format(makeFormat(m)),  'Today - ' + i + ' days current time');
            m.hours(0).minutes(0).seconds(0).milliseconds(0);
            assert.equal(m.calendar(),       m.format(makeFormat(m)),  'Today - ' + i + ' days beginning of day');
            m.hours(23).minutes(59).seconds(59).milliseconds(999);
            assert.equal(m.calendar(),       m.format(makeFormat(m)),  'Today - ' + i + ' days end of day');
        }
    });

    test('calendar all else', function (assert) {
        var weeksAgo = moment().subtract({w: 1}),
            weeksFromNow = moment().add({w: 1});

        assert.equal(weeksAgo.calendar(),       weeksAgo.format('L'),  '1 week ago');
        assert.equal(weeksFromNow.calendar(),   weeksFromNow.format('L'),  'in 1 week');

        weeksAgo = moment().subtract({w: 2});
        weeksFromNow = moment().add({w: 2});

        assert.equal(weeksAgo.calendar(),       weeksAgo.format('L'),  '2 weeks ago');
        assert.equal(weeksFromNow.calendar(),   weeksFromNow.format('L'),  'in 2 weeks');
    });

    test('weeks year starting sunday formatted', function (assert) {
        assert.equal(moment([2011, 11, 26]).format('w ww wo'), '1 01 1-Ð²Ð¸', 'Dec 26 2011 should be week 1');
        assert.equal(moment([2012,  0,  1]).format('w ww wo'), '1 01 1-Ð²Ð¸', 'Jan  1 2012 should be week 1');
        assert.equal(moment([2012,  0,  2]).format('w ww wo'), '2 02 2-ÑÐ¸', 'Jan  2 2012 should be week 2');
        assert.equal(moment([2012,  0,  8]).format('w ww wo'), '2 02 2-ÑÐ¸', 'Jan  8 2012 should be week 2');
        assert.equal(moment([2012,  0,  9]).format('w ww wo'), '3 03 3-ÑÐ¸', 'Jan  9 2012 should be week 3');
    });

}));

;(function (global, factory) {
   typeof exports === 'object' && typeof module !== 'undefined'
       && typeof require === 'function' ? factory(require('../../moment')) :
   typeof define === 'function' && define.amd ? define(['../../moment'], factory) :
   factory(global.moment)
}(this, function (moment) { 'use strict';

    function each(array, callback) {
        var i;
        for (i = 0; i < array.length; i++) {
            callback(array[i], i, array);
        }
    }

    function objectKeys(obj) {
        if (Object.keys) {
            return Object.keys(obj);
        } else {
            // IE8
            var res = [], i;
            for (i in obj) {
                if (obj.hasOwnProperty(i)) {
                    res.push(i);
                }
            }
            return res;
        }
    }

    // Pick the first defined of two or three arguments.
    function defaults(a, b, c) {
        if (a != null) {
            return a;
        }
        if (b != null) {
            return b;
        }
        return c;
    }

    function defineCommonLocaleTests(locale, options) {
        test('lenient ordinal parsing', function (assert) {
            var i, ordinalStr, testMoment;
            for (i = 1; i <= 31; ++i) {
                ordinalStr = moment([2014, 0, i]).format('YYYY MM Do');
                testMoment = moment(ordinalStr, 'YYYY MM Do');
                assert.equal(testMoment.year(), 2014,
                        'lenient ordinal parsing ' + i + ' year check');
                assert.equal(testMoment.month(), 0,
                        'lenient ordinal parsing ' + i + ' month check');
                assert.equal(testMoment.date(), i,
                        'lenient ordinal parsing ' + i + ' date check');
            }
        });

        test('lenient ordinal parsing of number', function (assert) {
            var i, testMoment;
            for (i = 1; i <= 31; ++i) {
                testMoment = moment('2014 01 ' + i, 'YYYY MM Do');
                assert.equal(testMoment.year(), 2014,
                        'lenient ordinal parsing of number ' + i + ' year check');
                assert.equal(testMoment.month(), 0,
                        'lenient ordinal parsing of number ' + i + ' month check');
                assert.equal(testMoment.date(), i,
                        'lenient ordinal parsing of number ' + i + ' date check');
            }
        });

        test('strict ordinal parsing', function (assert) {
            var i, ordinalStr, testMoment;
            for (i = 1; i <= 31; ++i) {
                ordinalStr = moment([2014, 0, i]).format('YYYY MM Do');
                testMoment = moment(ordinalStr, 'YYYY MM Do', true);
                assert.ok(testMoment.isValid(), 'strict ordinal parsing ' + i);
            }
        });

        test('meridiem invariant', function (assert) {
            var h, m, t1, t2;
            for (h = 0; h < 24; ++h) {
                for (m = 0; m < 60; m += 15) {
                    t1 = moment.utc([2000, 0, 1, h, m]);
                    t2 = moment.utc(t1.format('A h:mm'), 'A h:mm');
                    assert.equal(t2.format('HH:mm'), t1.format('HH:mm'),
                            'meridiem at ' + t1.format('HH:mm'));
                }
            }
        });

        test('date format correctness', function (assert) {
            var data, tokens;
            data = moment.localeData()._longDateFormat;
            tokens = objectKeys(data);
            each(tokens, function (srchToken) {
                // Check each format string to make sure it does not contain any
                // tokens that need to be expanded.
                each(tokens, function (baseToken) {
                    // strip escaped sequences
                    var format = data[baseToken].replace(/(\[[^\]]*\])/g, '');
                    assert.equal(false, !!~format.indexOf(srchToken),
                            'contains ' + srchToken + ' in ' + baseToken);
                });
            });
        });

        test('month parsing correctness', function (assert) {
            var i, m;

            if (locale === 'tr') {
                // I can't fix it :(
                expect(0);
                return;
            }
            function tester(format) {
                var r;
                r = moment(m.format(format), format);
                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format);
                r = moment(m.format(format).toLocaleUpperCase(), format);
                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' upper');
                r = moment(m.format(format).toLocaleLowerCase(), format);
                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' lower');

                r = moment(m.format(format), format, true);
                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' strict');
                r = moment(m.format(format).toLocaleUpperCase(), format, true);
                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' upper strict');
                r = moment(m.format(format).toLocaleLowerCase(), format, true);
                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' lower strict');
            }

            for (i = 0; i < 12; ++i) {
                m = moment([2015, i, 15, 18]);
                tester('MMM');
                tester('MMM.');
                tester('MMMM');
                tester('MMMM.');
            }
        });

        test('weekday parsing correctness', function (assert) {
            var i, m;

            if (locale === 'tr' || locale === 'az') {
                // There is a lower-case letter (Ä±), that converted to upper then
                // lower changes to i
                expect(0);
                return;
            }
            function tester(format) {
                var r, baseMsg = 'weekday ' + m.weekday() + ' fmt ' + format;
                r = moment(m.format(format), format);
                assert.equal(r.weekday(), m.weekday(), baseMsg);
                r = moment(m.format(format).toLocaleUpperCase(), format);
                assert.equal(r.weekday(), m.weekday(), baseMsg + ' upper');
                r = moment(m.format(format).toLocaleLowerCase(), format);
                assert.equal(r.weekday(), m.weekday(), baseMsg + ' lower');

                r = moment(m.format(format), format, true);
                assert.equal(r.weekday(), m.weekday(), baseMsg + ' strict');
                r = moment(m.format(format).toLocaleUpperCase(), format, true);
                assert.equal(r.weekday(), m.weekday(), baseMsg + ' upper strict');
                r = moment(m.format(format).toLocaleLowerCase(), format, true);
                assert.equal(r.weekday(), m.weekday(), baseMsg + ' lower strict');
            }

            for (i = 0; i < 7; ++i) {
                m = moment.utc([2015, i, 15, 18]);
                tester('dd');
                tester('ddd');
                tester('dddd');
            }
        });
    }

    function setupDeprecationHandler(test, moment, scope) {
        test._expectedDeprecations = null;
        test._observedDeprecations = null;
        test._oldSupress = moment.suppressDeprecationWarnings;
        moment.suppressDeprecationWarnings = true;
        test.expectedDeprecations = function () {
            test._expectedDeprecations = arguments;
            test._observedDeprecations = [];
        };
        moment.deprecationHandler = function (name, msg) {
            var deprecationId = matchedDeprecation(name, msg, test._expectedDeprecations);
            if (deprecationId === -1) {
                throw new Error('Unexpected deprecation thrown name=' +
                        name + ' msg=' + msg);
            }
            test._observedDeprecations[deprecationId] = 1;
        };
    }

    function teardownDeprecationHandler(test, moment, scope) {
        moment.suppressDeprecationWarnings = test._oldSupress;

        if (test._expectedDeprecations != null) {
            var missedDeprecations = [];
            each(test._expectedDeprecations, function (deprecationPattern, id) {
                if (test._observedDeprecations[id] !== 1) {
                    missedDeprecations.push(deprecationPattern);
                }
            });
            if (missedDeprecations.length !== 0) {
                throw new Error('Expected deprecation warnings did not happen: ' +
                        missedDeprecations.join(' '));
            }
        }
    }

    function matchedDeprecation(name, msg, deprecations) {
        if (deprecations == null) {
            return -1;
        }
        for (var i = 0; i < deprecations.length; ++i) {
            if (name != null && name === deprecations[i]) {
                return i;
            }
            if (msg != null && msg.substring(0, deprecations[i].length) === deprecations[i]) {
                return i;
            }
        }
        return -1;
    }

    /*global QUnit:false*/

    var test = QUnit.test;

    var expect = QUnit.expect;

    function module (name, lifecycle) {
        QUnit.module(name, {
            setup : function () {
                moment.locale('en');
                moment.createFromInputFallback = function (config) {
                    throw new Error('input not handled by moment: ' + config._i);
                };
                setupDeprecationHandler(test, moment, 'core');
                if (lifecycle && lifecycle.setup) {
                    lifecycle.setup();
                }
            },
            teardown : function () {
                teardownDeprecationHandler(test, moment, 'core');
                if (lifecycle && lifecycle.teardown) {
                    lifecycle.teardown();
                }
            }
        });
    }

    function localeModule (name, lifecycle) {
        QUnit.module('locale:' + name, {
            setup : function () {
                moment.locale(name);
                moment.createFromInputFallback = function (config) {
                    throw new Error('input not handled by moment: ' + config._i);
                };
                setupDeprecationHandler(test, moment, 'locale');
                if (lifecycle && lifecycle.setup) {
                    lifecycle.setup();
                }
            },
            teardown : function () {
                moment.locale('en');
                teardownDeprecationHandler(test, moment, 'locale');
                if (lifecycle && lifecycle.teardown) {
                    lifecycle.teardown();
                }
            }
        });
        defineCommonLocaleTests(name, -1, -1);
    }

    localeModule('bn');

    test('parse', function (assert) {
        var tests = 'à¦à¦¾à¦¨à§à§à¦¾à¦°à§ à¦à¦¾à¦¨à§_à¦«à§à¦¬à§à§à¦¾à¦°à§ à¦«à§à¦¬_à¦®à¦¾à¦°à§à¦ à¦®à¦¾à¦°à§à¦_à¦à¦ªà§à¦°à¦¿à¦² à¦à¦ªà¦°_à¦®à§ à¦®à§_à¦à§à¦¨ à¦à§à¦¨_à¦à§à¦²à¦¾à¦ à¦à§à¦²_à¦à¦à¦¾à¦¸à§à¦ à¦à¦_à¦¸à§à¦ªà§à¦à§à¦®à§à¦¬à¦° à¦¸à§à¦ªà§à¦_à¦à¦à§à¦à§à¦¬à¦° à¦à¦à§à¦à§_à¦¨à¦­à§à¦®à§à¦¬à¦° à¦¨à¦­_à¦¡à¦¿à¦¸à§à¦®à§à¦¬à¦° à¦¡à¦¿à¦¸à§à¦®à§'.split('_'), i;
        function equalTest(input, mmm, i) {
            assert.equal(moment(input, mmm).month(), i, input + ' should be month ' + (i + 1));
        }
        for (i = 0; i < 12; i++) {
            tests[i] = tests[i].split(' ');
            equalTest(tests[i][0], 'MMM', i);
            equalTest(tests[i][1], 'MMM', i);
            equalTest(tests[i][0], 'MMMM', i);
            equalTest(tests[i][1], 'MMMM', i);
            equalTest(tests[i][0].toLocaleLowerCase(), 'MMMM', i);
            equalTest(tests[i][1].toLocaleLowerCase(), 'MMMM', i);
            equalTest(tests[i][0].toLocaleUpperCase(), 'MMMM', i);
            equalTest(tests[i][1].toLocaleUpperCase(), 'MMMM', i);
        }
    });

    test('format', function (assert) {
        var a = [
                ['dddd, Do MMMM YYYY, a h:mm:ss à¦¸à¦®à§',  'à¦°à¦¬à¦¿à¦¬à¦¾à¦°, à§§à§ª à¦«à§à¦¬à§à§à¦¾à¦°à§ à§¨à§¦à§§à§¦, à¦¦à§à¦ªà§à¦° à§©:à§¨à§«:à§«à§¦ à¦¸à¦®à§'],
                ['ddd, a h à¦¸à¦®à§',                       'à¦°à¦¬à¦¿, à¦¦à§à¦ªà§à¦° à§© à¦¸à¦®à§'],
                ['M Mo MM MMMM MMM',                   'à§¨ à§¨ à§¦à§¨ à¦«à§à¦¬à§à§à¦¾à¦°à§ à¦«à§à¦¬'],
                ['YYYY YY',                            'à§¨à§¦à§§à§¦ à§§à§¦'],
                ['D Do DD',                            'à§§à§ª à§§à§ª à§§à§ª'],
                ['d do dddd ddd dd',                   'à§¦ à§¦ à¦°à¦¬à¦¿à¦¬à¦¾à¦° à¦°à¦¬à¦¿ à¦°à¦¬'],
                ['DDD DDDo DDDD',                      'à§ªà§« à§ªà§« à§¦à§ªà§«'],
                ['w wo ww',                            'à§® à§® à§¦à§®'],
                ['h hh',                               'à§© à§¦à§©'],
                ['H HH',                               'à§§à§« à§§à§«'],
                ['m mm',                               'à§¨à§« à§¨à§«'],
                ['s ss',                               'à§«à§¦ à§«à§¦'],
                ['a A',                                'à¦¦à§à¦ªà§à¦° à¦¦à§à¦ªà§à¦°'],
                ['LT',                                 'à¦¦à§à¦ªà§à¦° à§©:à§¨à§« à¦¸à¦®à§'],
                ['LTS',                                'à¦¦à§à¦ªà§à¦° à§©:à§¨à§«:à§«à§¦ à¦¸à¦®à§'],
                ['L',                                  'à§§à§ª/à§¦à§¨/à§¨à§¦à§§à§¦'],
                ['LL',                                 'à§§à§ª à¦«à§à¦¬à§à§à¦¾à¦°à§ à§¨à§¦à§§à§¦'],
                ['LLL',                                'à§§à§ª à¦«à§à¦¬à§à§à¦¾à¦°à§ à§¨à§¦à§§à§¦, à¦¦à§à¦ªà§à¦° à§©:à§¨à§« à¦¸à¦®à§'],
                ['LLLL',                               'à¦°à¦¬à¦¿à¦¬à¦¾à¦°, à§§à§ª à¦«à§à¦¬à§à§à¦¾à¦°à§ à§¨à§¦à§§à§¦, à¦¦à§à¦ªà§à¦° à§©:à§¨à§« à¦¸à¦®à§'],
                ['l',                                  'à§§à§ª/à§¨/à§¨à§¦à§§à§¦'],
                ['ll',                                 'à§§à§ª à¦«à§à¦¬ à§¨à§¦à§§à§¦'],
                ['lll',                                'à§§à§ª à¦«à§à¦¬ à§¨à§¦à§§à§¦, à¦¦à§à¦ªà§à¦° à§©:à§¨à§« à¦¸à¦®à§'],
                ['llll',                               'à¦°à¦¬à¦¿, à§§à§ª à¦«à§à¦¬ à§¨à§¦à§§à§¦, à¦¦à§à¦ªà§à¦° à§©:à§¨à§« à¦¸à¦®à§']
            ],
            b = moment(new Date(2010, 1, 14, 15, 25, 50, 125)),
            i;
        for (i = 0; i < a.length; i++) {
            assert.equal(b.format(a[i][0]), a[i][1], a[i][0] + ' ---> ' + a[i][1]);
        }
    });

    test('format ordinal', function (assert) {
        assert.equal(moment([2011, 0, 1]).format('DDDo'), 'à§§', 'à§§');
        assert.equal(moment([2011, 0, 2]).format('DDDo'), 'à§¨', 'à§¨');
        assert.equal(moment([2011, 0, 3]).format('DDDo'), 'à§©', 'à§©');
        assert.equal(moment([2011, 0, 4]).format('DDDo'), 'à§ª', 'à§ª');
        assert.equal(moment([2011, 0, 5]).format('DDDo'), 'à§«', 'à§«');
        assert.equal(moment([2011, 0, 6]).format('DDDo'), 'à§¬', 'à§¬');
        assert.equal(moment([2011, 0, 7]).format('DDDo'), 'à§­', 'à§­');
        assert.equal(moment([2011, 0, 8]).format('DDDo'), 'à§®', 'à§®');
        assert.equal(moment([2011, 0, 9]).format('DDDo'), 'à§¯', 'à§¯');
        assert.equal(moment([2011, 0, 10]).format('DDDo'), 'à§§à§¦', 'à§§à§¦');

        assert.equal(moment([2011, 0, 11]).format('DDDo'), 'à§§à§§', 'à§§à§§');
        assert.equal(moment([2011, 0, 12]).format('DDDo'), 'à§§à§¨', 'à§§à§¨');
        assert.equal(moment([2011, 0, 13]).format('DDDo'), 'à§§à§©', 'à§§à§©');
        assert.equal(moment([2011, 0, 14]).format('DDDo'), 'à§§à§ª', 'à§§à§ª');
        assert.equal(moment([2011, 0, 15]).format('DDDo'), 'à§§à§«', 'à§§à§«');
        assert.equal(moment([2011, 0, 16]).format('DDDo'), 'à§§à§¬', 'à§§à§¬');
        assert.equal(moment([2011, 0, 17]).format('DDDo'), 'à§§à§­', 'à§§à§­');
        assert.equal(moment([2011, 0, 18]).format('DDDo'), 'à§§à§®', 'à§§à§®');
        assert.equal(moment([2011, 0, 19]).format('DDDo'), 'à§§à§¯', 'à§§à§¯');
        assert.equal(moment([2011, 0, 20]).format('DDDo'), 'à§¨à§¦', 'à§¨à§¦');

        assert.equal(moment([2011, 0, 21]).format('DDDo'), 'à§¨à§§', 'à§¨à§§');
        assert.equal(moment([2011, 0, 22]).format('DDDo'), 'à§¨à§¨', 'à§¨à§¨');
        assert.equal(moment([2011, 0, 23]).format('DDDo'), 'à§¨à§©', 'à§¨à§©');
        assert.equal(moment([2011, 0, 24]).format('DDDo'), 'à§¨à§ª', 'à§¨à§ª');
        assert.equal(moment([2011, 0, 25]).format('DDDo'), 'à§¨à§«', 'à§¨à§«');
        assert.equal(moment([2011, 0, 26]).format('DDDo'), 'à§¨à§¬', 'à§¨à§¬');
        assert.equal(moment([2011, 0, 27]).format('DDDo'), 'à§¨à§­', 'à§¨à§­');
        assert.equal(moment([2011, 0, 28]).format('DDDo'), 'à§¨à§®', 'à¥¨à§®');
        assert.equal(moment([2011, 0, 29]).format('DDDo'), 'à§¨à§¯', 'à§¨à§¯');
        assert.equal(moment([2011, 0, 30]).format('DDDo'), 'à§©à§¦', 'à§©à§¦');

        assert.equal(moment([2011, 0, 31]).format('DDDo'), 'à§©à§§', 'à§©à§§');
    });

    test('format month', function (assert) {
        var expected = 'à¦à¦¾à¦¨à§à§à¦¾à¦°à§ à¦à¦¾à¦¨à§_à¦«à§à¦¬à§à§à¦¾à¦°à§ à¦«à§à¦¬_à¦®à¦¾à¦°à§à¦ à¦®à¦¾à¦°à§à¦_à¦à¦ªà§à¦°à¦¿à¦² à¦à¦ªà¦°_à¦®à§ à¦®à§_à¦à§à¦¨ à¦à§à¦¨_à¦à§à¦²à¦¾à¦ à¦à§à¦²_à¦à¦à¦¾à¦¸à§à¦ à¦à¦_à¦¸à§à¦ªà§à¦à§à¦®à§à¦¬à¦° à¦¸à§à¦ªà§à¦_à¦à¦à§à¦à§à¦¬à¦° à¦à¦à§à¦à§_à¦¨à¦­à§à¦®à§à¦¬à¦° à¦¨à¦­_à¦¡à¦¿à¦¸à§à¦®à§à¦¬à¦° à¦¡à¦¿à¦¸à§à¦®à§'.split('_'), i;
        for (i = 0; i < expected.length; i++) {
            assert.equal(moment([2011, i, 1]).format('MMMM MMM'), expected[i], expected[i]);
        }
    });

    test('format week', function (assert) {
        var expected = 'à¦°à¦¬à¦¿à¦¬à¦¾à¦° à¦°à¦¬à¦¿ à¦°à¦¬_à¦¸à§à¦®à¦¬à¦¾à¦° à¦¸à§à¦® à¦¸à¦®_à¦®à¦à§à¦à¦²à¦¬à¦¾à¦° à¦®à¦à§à¦à¦² à¦®à¦à§à¦_à¦¬à§à¦§à¦¬à¦¾à¦° à¦¬à§à¦§ à¦¬à§_à¦¬à§à¦¹à¦¸à§à¦ªà¦¤à§à¦¤à¦¿à¦¬à¦¾à¦° à¦¬à§à¦¹à¦¸à§à¦ªà¦¤à§à¦¤à¦¿ à¦¬à§à¦°à¦¿à¦¹_à¦¶à§à¦à§à¦°à¦¬à¦¾à¦° à¦¶à§à¦à§à¦° à¦¶à§_à¦¶à¦¨à¦¿à¦¬à¦¾à¦° à¦¶à¦¨à¦¿ à¦¶à¦¨à¦¿'.split('_'), i;
        for (i = 0; i < expected.length; i++) {
            assert.equal(moment([2011, 0, 2 + i]).format('dddd ddd dd'), expected[i], expected[i]);
        }
    });

    test('from', function (assert) {
        var start = moment([2007, 1, 28]);
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 44}), true),  'à¦à§à§à¦ à¦¸à§à¦à§à¦¨à§à¦¡', '44 seconds = a few seconds');
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 45}), true),  'à¦à¦ à¦®à¦¿à¦¨à¦¿à¦',      '45 seconds = a minute');
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 89}), true),  'à¦à¦ à¦®à¦¿à¦¨à¦¿à¦',      '89 seconds = a minute');
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 90}), true),  'à§¨ à¦®à¦¿à¦¨à¦¿à¦',     '90 seconds = 2 minutes');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 44}), true),  'à§ªà§ª à¦®à¦¿à¦¨à¦¿à¦',    '44 minutes = 44 minutes');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 45}), true),  'à¦à¦ à¦à¦¨à§à¦à¦¾',       '45 minutes = an hour');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 89}), true),  'à¦à¦ à¦à¦¨à§à¦à¦¾',       '89 minutes = an hour');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 90}), true),  'à§¨ à¦à¦¨à§à¦à¦¾',       '90 minutes = 2 hours');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 5}), true),   'à§« à¦à¦¨à§à¦à¦¾',       '5 hours = 5 hours');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 21}), true),  'à§¨à§§ à¦à¦¨à§à¦à¦¾',      '21 hours = 21 hours');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 22}), true),  'à¦à¦ à¦¦à¦¿à¦¨',         '22 hours = a day');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 35}), true),  'à¦à¦ à¦¦à¦¿à¦¨',         '35 hours = a day');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 36}), true),  'à§¨ à¦¦à¦¿à¦¨',        '36 hours = 2 days');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 1}), true),   'à¦à¦ à¦¦à¦¿à¦¨',         '1 day = a day');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 5}), true),   'à§« à¦¦à¦¿à¦¨',        '5 days = 5 days');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 25}), true),  'à§¨à§« à¦¦à¦¿à¦¨',       '25 days = 25 days');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 26}), true),  'à¦à¦ à¦®à¦¾à¦¸',       '26 days = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 30}), true),  'à¦à¦ à¦®à¦¾à¦¸',       '30 days = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 46}), true),  'à§¨ à¦®à¦¾à¦¸',      '46 days = 2 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 74}), true),  'à§¨ à¦®à¦¾à¦¸',      '75 days = 2 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 76}), true),  'à§© à¦®à¦¾à¦¸',      '76 days = 3 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({M: 1}), true),   'à¦à¦ à¦®à¦¾à¦¸',       '1 month = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({M: 5}), true),   'à§« à¦®à¦¾à¦¸',      '5 months = 5 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 345}), true), 'à¦à¦ à¦¬à¦à¦°',        '345 days = a year');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 548}), true), 'à§¨ à¦¬à¦à¦°',       '548 days = 2 years');
        assert.equal(start.from(moment([2007, 1, 28]).add({y: 1}), true),   'à¦à¦ à¦¬à¦à¦°',        '1 year = a year');
        assert.equal(start.from(moment([2007, 1, 28]).add({y: 5}), true),   'à§« à¦¬à¦à¦°',       '5 years = 5 years');
    });

    test('suffix', function (assert) {
        assert.equal(moment(30000).from(0), 'à¦à§à§à¦ à¦¸à§à¦à§à¦¨à§à¦¡ à¦ªà¦°à§',  'prefix');
        assert.equal(moment(0).from(30000), 'à¦à§à§à¦ à¦¸à§à¦à§à¦¨à§à¦¡ à¦à¦à§', 'suffix');
    });

    test('now from now', function (assert) {
        assert.equal(moment().fromNow(), 'à¦à§à§à¦ à¦¸à§à¦à§à¦¨à§à¦¡ à¦à¦à§',  'now from now should display as in the past');
    });

    test('fromNow', function (assert) {
        assert.equal(moment().add({s: 30}).fromNow(), 'à¦à§à§à¦ à¦¸à§à¦à§à¦¨à§à¦¡ à¦ªà¦°à§', 'à¦à§à§à¦ à¦¸à§à¦à§à¦¨à§à¦¡ à¦ªà¦°à§');
        assert.equal(moment().add({d: 5}).fromNow(), 'à§« à¦¦à¦¿à¦¨ à¦ªà¦°à§', 'à§« à¦¦à¦¿à¦¨ à¦ªà¦°à§');
    });

    test('calendar day', function (assert) {
        var a = moment().hours(12).minutes(0).seconds(0);

        assert.equal(moment(a).calendar(),                   'à¦à¦ à¦¦à§à¦ªà§à¦° à§§à§¨:à§¦à§¦ à¦¸à¦®à§',       'today at the same time');
        assert.equal(moment(a).add({m: 25}).calendar(),      'à¦à¦ à¦¦à§à¦ªà§à¦° à§§à§¨:à§¨à§« à¦¸à¦®à§',       'Now plus 25 min');
        assert.equal(moment(a).add({h: 3}).calendar(),       'à¦à¦ à¦¦à§à¦ªà§à¦° à§©:à§¦à§¦ à¦¸à¦®à§',        'Now plus 3 hours');
        assert.equal(moment(a).add({d: 1}).calendar(),       'à¦à¦à¦¾à¦®à§à¦à¦¾à¦² à¦¦à§à¦ªà§à¦° à§§à§¨:à§¦à§¦ à¦¸à¦®à§', 'tomorrow at the same time');
        assert.equal(moment(a).subtract({h: 1}).calendar(),  'à¦à¦ à¦¦à§à¦ªà§à¦° à§§à§§:à§¦à§¦ à¦¸à¦®à§',       'Now minus 1 hour');
        assert.equal(moment(a).subtract({d: 1}).calendar(),  'à¦à¦¤à¦à¦¾à¦² à¦¦à§à¦ªà§à¦° à§§à§¨:à§¦à§¦ à¦¸à¦®à§',    'yesterday at the same time');
    });

    test('calendar next week', function (assert) {
        var i, m;
        for (i = 2; i < 7; i++) {
            m = moment().add({d: i});
            assert.equal(m.calendar(),       m.format('dddd[,] LT'),  'Today + ' + i + ' days current time');
            m.hours(0).minutes(0).seconds(0).milliseconds(0);
            assert.equal(m.calendar(),       m.format('dddd[,] LT'),  'Today + ' + i + ' days beginning of day');
            m.hours(23).minutes(59).seconds(59).milliseconds(999);
            assert.equal(m.calendar(),       m.format('dddd[,] LT'),  'Today + ' + i + ' days end of day');
        }
    });

    test('calendar last week', function (assert) {
        var i, m;

        for (i = 2; i < 7; i++) {
            m = moment().subtract({d: i});
            assert.equal(m.calendar(),       m.format('[à¦à¦¤] dddd[,] LT'),  'Today - ' + i + ' days current time');
            m.hours(0).minutes(0).seconds(0).milliseconds(0);
            assert.equal(m.calendar(),       m.format('[à¦à¦¤] dddd[,] LT'),  'Today - ' + i + ' days beginning of day');
            m.hours(23).minutes(59).seconds(59).milliseconds(999);
            assert.equal(m.calendar(),       m.format('[à¦à¦¤] dddd[,] LT'),  'Today - ' + i + ' days end of day');
        }
    });

    test('calendar all else', function (assert) {
        var weeksAgo = moment().subtract({w: 1}),
            weeksFromNow = moment().add({w: 1});

        assert.equal(weeksAgo.calendar(),       weeksAgo.format('L'),  '1 week ago');
        assert.equal(weeksFromNow.calendar(),   weeksFromNow.format('L'),  'in 1 week');

        weeksAgo = moment().subtract({w: 2});
        weeksFromNow = moment().add({w: 2});

        assert.equal(weeksAgo.calendar(),       weeksAgo.format('L'),  '2 weeks ago');
        assert.equal(weeksFromNow.calendar(),   weeksFromNow.format('L'),  'in 2 weeks');
    });

    test('meridiem', function (assert) {
        assert.equal(moment([2011, 2, 23,  2, 30]).format('a'), 'à¦°à¦¾à¦¤', 'before dawn');
        assert.equal(moment([2011, 2, 23,  9, 30]).format('a'), 'à¦¸à¦à¦¾à¦²', 'morning');
        assert.equal(moment([2011, 2, 23, 14, 30]).format('a'), 'à¦¦à§à¦ªà§à¦°', 'during day');
        assert.equal(moment([2011, 2, 23, 17, 30]).format('a'), 'à¦¬à¦¿à¦à¦¾à¦²', 'evening');
        assert.equal(moment([2011, 2, 23, 19, 30]).format('a'), 'à¦¬à¦¿à¦à¦¾à¦²', 'late evening');
        assert.equal(moment([2011, 2, 23, 21, 20]).format('a'), 'à¦°à¦¾à¦¤', 'night');

        assert.equal(moment([2011, 2, 23,  2, 30]).format('A'), 'à¦°à¦¾à¦¤', 'before dawn');
        assert.equal(moment([2011, 2, 23,  9, 30]).format('A'), 'à¦¸à¦à¦¾à¦²', 'morning');
        assert.equal(moment([2011, 2, 23, 14, 30]).format('A'), 'à¦¦à§à¦ªà§à¦°', ' during day');
        assert.equal(moment([2011, 2, 23, 17, 30]).format('A'), 'à¦¬à¦¿à¦à¦¾à¦²', 'evening');
        assert.equal(moment([2011, 2, 23, 19, 30]).format('A'), 'à¦¬à¦¿à¦à¦¾à¦²', 'late evening');
        assert.equal(moment([2011, 2, 23, 21, 20]).format('A'), 'à¦°à¦¾à¦¤', 'night');
    });

    test('weeks year starting sunday formatted', function (assert) {
        assert.equal(moment([2012, 0,  1]).format('w ww wo'), 'à§§ à§¦à§§ à§§', 'Jan  1 2012 should be week 1');
        assert.equal(moment([2012, 0,  7]).format('w ww wo'), 'à§§ à§¦à§§ à§§', 'Jan  7 2012 should be week 1');
        assert.equal(moment([2012, 0,  8]).format('w ww wo'), 'à§¨ à§¦à§¨ à§¨', 'Jan  8 2012 should be week 2');
        assert.equal(moment([2012, 0, 14]).format('w ww wo'), 'à§¨ à§¦à§¨ à§¨', 'Jan 14 2012 should be week 2');
        assert.equal(moment([2012, 0, 15]).format('w ww wo'), 'à§© à§¦à§© à§©', 'Jan 15 2012 should be week 3');
    });

}));

;(function (global, factory) {
   typeof exports === 'object' && typeof module !== 'undefined'
       && typeof require === 'function' ? factory(require('../../moment')) :
   typeof define === 'function' && define.amd ? define(['../../moment'], factory) :
   factory(global.moment)
}(this, function (moment) { 'use strict';

    function each(array, callback) {
        var i;
        for (i = 0; i < array.length; i++) {
            callback(array[i], i, array);
        }
    }

    function objectKeys(obj) {
        if (Object.keys) {
            return Object.keys(obj);
        } else {
            // IE8
            var res = [], i;
            for (i in obj) {
                if (obj.hasOwnProperty(i)) {
                    res.push(i);
                }
            }
            return res;
        }
    }

    // Pick the first defined of two or three arguments.
    function defaults(a, b, c) {
        if (a != null) {
            return a;
        }
        if (b != null) {
            return b;
        }
        return c;
    }

    function defineCommonLocaleTests(locale, options) {
        test('lenient ordinal parsing', function (assert) {
            var i, ordinalStr, testMoment;
            for (i = 1; i <= 31; ++i) {
                ordinalStr = moment([2014, 0, i]).format('YYYY MM Do');
                testMoment = moment(ordinalStr, 'YYYY MM Do');
                assert.equal(testMoment.year(), 2014,
                        'lenient ordinal parsing ' + i + ' year check');
                assert.equal(testMoment.month(), 0,
                        'lenient ordinal parsing ' + i + ' month check');
                assert.equal(testMoment.date(), i,
                        'lenient ordinal parsing ' + i + ' date check');
            }
        });

        test('lenient ordinal parsing of number', function (assert) {
            var i, testMoment;
            for (i = 1; i <= 31; ++i) {
                testMoment = moment('2014 01 ' + i, 'YYYY MM Do');
                assert.equal(testMoment.year(), 2014,
                        'lenient ordinal parsing of number ' + i + ' year check');
                assert.equal(testMoment.month(), 0,
                        'lenient ordinal parsing of number ' + i + ' month check');
                assert.equal(testMoment.date(), i,
                        'lenient ordinal parsing of number ' + i + ' date check');
            }
        });

        test('strict ordinal parsing', function (assert) {
            var i, ordinalStr, testMoment;
            for (i = 1; i <= 31; ++i) {
                ordinalStr = moment([2014, 0, i]).format('YYYY MM Do');
                testMoment = moment(ordinalStr, 'YYYY MM Do', true);
                assert.ok(testMoment.isValid(), 'strict ordinal parsing ' + i);
            }
        });

        test('meridiem invariant', function (assert) {
            var h, m, t1, t2;
            for (h = 0; h < 24; ++h) {
                for (m = 0; m < 60; m += 15) {
                    t1 = moment.utc([2000, 0, 1, h, m]);
                    t2 = moment.utc(t1.format('A h:mm'), 'A h:mm');
                    assert.equal(t2.format('HH:mm'), t1.format('HH:mm'),
                            'meridiem at ' + t1.format('HH:mm'));
                }
            }
        });

        test('date format correctness', function (assert) {
            var data, tokens;
            data = moment.localeData()._longDateFormat;
            tokens = objectKeys(data);
            each(tokens, function (srchToken) {
                // Check each format string to make sure it does not contain any
                // tokens that need to be expanded.
                each(tokens, function (baseToken) {
                    // strip escaped sequences
                    var format = data[baseToken].replace(/(\[[^\]]*\])/g, '');
                    assert.equal(false, !!~format.indexOf(srchToken),
                            'contains ' + srchToken + ' in ' + baseToken);
                });
            });
        });

        test('month parsing correctness', function (assert) {
            var i, m;

            if (locale === 'tr') {
                // I can't fix it :(
                expect(0);
                return;
            }
            function tester(format) {
                var r;
                r = moment(m.format(format), format);
                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format);
                r = moment(m.format(format).toLocaleUpperCase(), format);
                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' upper');
                r = moment(m.format(format).toLocaleLowerCase(), format);
                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' lower');

                r = moment(m.format(format), format, true);
                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' strict');
                r = moment(m.format(format).toLocaleUpperCase(), format, true);
                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' upper strict');
                r = moment(m.format(format).toLocaleLowerCase(), format, true);
                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' lower strict');
            }

            for (i = 0; i < 12; ++i) {
                m = moment([2015, i, 15, 18]);
                tester('MMM');
                tester('MMM.');
                tester('MMMM');
                tester('MMMM.');
            }
        });

        test('weekday parsing correctness', function (assert) {
            var i, m;

            if (locale === 'tr' || locale === 'az') {
                // There is a lower-case letter (Ä±), that converted to upper then
                // lower changes to i
                expect(0);
                return;
            }
            function tester(format) {
                var r, baseMsg = 'weekday ' + m.weekday() + ' fmt ' + format;
                r = moment(m.format(format), format);
                assert.equal(r.weekday(), m.weekday(), baseMsg);
                r = moment(m.format(format).toLocaleUpperCase(), format);
                assert.equal(r.weekday(), m.weekday(), baseMsg + ' upper');
                r = moment(m.format(format).toLocaleLowerCase(), format);
                assert.equal(r.weekday(), m.weekday(), baseMsg + ' lower');

                r = moment(m.format(format), format, true);
                assert.equal(r.weekday(), m.weekday(), baseMsg + ' strict');
                r = moment(m.format(format).toLocaleUpperCase(), format, true);
                assert.equal(r.weekday(), m.weekday(), baseMsg + ' upper strict');
                r = moment(m.format(format).toLocaleLowerCase(), format, true);
                assert.equal(r.weekday(), m.weekday(), baseMsg + ' lower strict');
            }

            for (i = 0; i < 7; ++i) {
                m = moment.utc([2015, i, 15, 18]);
                tester('dd');
                tester('ddd');
                tester('dddd');
            }
        });
    }

    function setupDeprecationHandler(test, moment, scope) {
        test._expectedDeprecations = null;
        test._observedDeprecations = null;
        test._oldSupress = moment.suppressDeprecationWarnings;
        moment.suppressDeprecationWarnings = true;
        test.expectedDeprecations = function () {
            test._expectedDeprecations = arguments;
            test._observedDeprecations = [];
        };
        moment.deprecationHandler = function (name, msg) {
            var deprecationId = matchedDeprecation(name, msg, test._expectedDeprecations);
            if (deprecationId === -1) {
                throw new Error('Unexpected deprecation thrown name=' +
                        name + ' msg=' + msg);
            }
            test._observedDeprecations[deprecationId] = 1;
        };
    }

    function teardownDeprecationHandler(test, moment, scope) {
        moment.suppressDeprecationWarnings = test._oldSupress;

        if (test._expectedDeprecations != null) {
            var missedDeprecations = [];
            each(test._expectedDeprecations, function (deprecationPattern, id) {
                if (test._observedDeprecations[id] !== 1) {
                    missedDeprecations.push(deprecationPattern);
                }
            });
            if (missedDeprecations.length !== 0) {
                throw new Error('Expected deprecation warnings did not happen: ' +
                        missedDeprecations.join(' '));
            }
        }
    }

    function matchedDeprecation(name, msg, deprecations) {
        if (deprecations == null) {
            return -1;
        }
        for (var i = 0; i < deprecations.length; ++i) {
            if (name != null && name === deprecations[i]) {
                return i;
            }
            if (msg != null && msg.substring(0, deprecations[i].length) === deprecations[i]) {
                return i;
            }
        }
        return -1;
    }

    /*global QUnit:false*/

    var test = QUnit.test;

    var expect = QUnit.expect;

    function module (name, lifecycle) {
        QUnit.module(name, {
            setup : function () {
                moment.locale('en');
                moment.createFromInputFallback = function (config) {
                    throw new Error('input not handled by moment: ' + config._i);
                };
                setupDeprecationHandler(test, moment, 'core');
                if (lifecycle && lifecycle.setup) {
                    lifecycle.setup();
                }
            },
            teardown : function () {
                teardownDeprecationHandler(test, moment, 'core');
                if (lifecycle && lifecycle.teardown) {
                    lifecycle.teardown();
                }
            }
        });
    }

    function localeModule (name, lifecycle) {
        QUnit.module('locale:' + name, {
            setup : function () {
                moment.locale(name);
                moment.createFromInputFallback = function (config) {
                    throw new Error('input not handled by moment: ' + config._i);
                };
                setupDeprecationHandler(test, moment, 'locale');
                if (lifecycle && lifecycle.setup) {
                    lifecycle.setup();
                }
            },
            teardown : function () {
                moment.locale('en');
                teardownDeprecationHandler(test, moment, 'locale');
                if (lifecycle && lifecycle.teardown) {
                    lifecycle.teardown();
                }
            }
        });
        defineCommonLocaleTests(name, -1, -1);
    }

    localeModule('bo');

    test('parse', function (assert) {
        var tests = 'à½à¾³à¼à½à¼à½à½à¼à½à½¼ à½à¾³à¼à½à¼à½à½à¼à½à½¼._à½à¾³à¼à½à¼à½à½à½²à½¦à¼à½ à½à¾³à¼à½à¼à½à½à½²à½¦à¼à½_à½à¾³à¼à½à¼à½à½¦à½´à½à¼à½ à½à¾³à¼à½à¼à½à½¦à½´à½à¼à½_à½à¾³à¼à½à¼à½à½à½²à¼à½ à½à¾³à¼à½à¼à½à½à½²à¼à½_à½à¾³à¼à½à¼à½£à¾à¼à½ à½à¾³à¼à½à¼à½£à¾à¼à½_à½à¾³à¼à½à¼à½à¾²à½´à½à¼à½ à½à¾³à¼à½à¼à½à¾²à½´à½à¼à½_à½à¾³à¼à½à¼à½à½à½´à½à¼à½ à½à¾³à¼à½à¼à½à½à½´à½à¼à½_à½à¾³à¼à½à¼à½à½¢à¾à¾±à½à¼à½ à½à¾³à¼à½à¼à½à½¢à¾à¾±à½à¼à½_à½à¾³à¼à½à¼à½à½à½´à¼à½ à½à¾³à¼à½à¼à½à½à½´à¼à½_à½à¾³à¼à½à¼à½à½à½´à¼à½ à½à¾³à¼à½à¼à½à½à½´à¼à½_à½à¾³à¼à½à¼à½à½à½´à¼à½à½à½²à½à¼à½ à½à¾³à¼à½à¼à½à½à½´à¼à½à½à½²à½à¼à½_à½à¾³à¼à½à¼à½à½à½´à¼à½à½à½²à½¦à¼à½ à½à¾³à¼à½à¼à½à½à½´à¼à½à½à½²à½¦à¼à½'.split('_'), i;
        function equalTest(input, mmm, i) {
            assert.equal(moment(input, mmm).month(), i, input + ' should be month ' + (i + 1));
        }
        for (i = 0; i < 12; i++) {
            tests[i] = tests[i].split(' ');
            equalTest(tests[i][0], 'MMM', i);
            equalTest(tests[i][1], 'MMM', i);
            equalTest(tests[i][0], 'MMMM', i);
            equalTest(tests[i][1], 'MMMM', i);
            equalTest(tests[i][0].toLocaleLowerCase(), 'MMMM', i);
            equalTest(tests[i][1].toLocaleLowerCase(), 'MMMM', i);
            equalTest(tests[i][0].toLocaleUpperCase(), 'MMMM', i);
            equalTest(tests[i][1].toLocaleUpperCase(), 'MMMM', i);
        }
    });

    test('format', function (assert) {
        var a = [
                ['dddd, Do MMMM YYYY, a h:mm:ss à½£à¼',  'à½à½à½ à¼à½à½²à¼à½à¼, à¼¡à¼¤ à½à¾³à¼à½à¼à½à½à½²à½¦à¼à½ à¼¢à¼ à¼¡à¼ , à½à½²à½à¼à½à½´à½ à¼£:à¼¢à¼¥:à¼¥à¼  à½£à¼'],
                ['ddd, a h à½£à¼',                       'à½à½²à¼à½à¼, à½à½²à½à¼à½à½´à½ à¼£ à½£à¼'],
                ['M Mo MM MMMM MMM',                   'à¼¢ à¼¢ à¼ à¼¢ à½à¾³à¼à½à¼à½à½à½²à½¦à¼à½ à½à¾³à¼à½à¼à½à½à½²à½¦à¼à½'],
                ['YYYY YY',                            'à¼¢à¼ à¼¡à¼  à¼¡à¼ '],
                ['D Do DD',                            'à¼¡à¼¤ à¼¡à¼¤ à¼¡à¼¤'],
                ['d do dddd ddd dd',                   'à¼  à¼  à½à½à½ à¼à½à½²à¼à½à¼ à½à½²à¼à½à¼ à½à½²à¼à½à¼'],
                ['DDD DDDo DDDD',                      'à¼¤à¼¥ à¼¤à¼¥ à¼ à¼¤à¼¥'],
                ['w wo ww',                            'à¼¨ à¼¨ à¼ à¼¨'],
                ['h hh',                               'à¼£ à¼ à¼£'],
                ['H HH',                               'à¼¡à¼¥ à¼¡à¼¥'],
                ['m mm',                               'à¼¢à¼¥ à¼¢à¼¥'],
                ['s ss',                               'à¼¥à¼  à¼¥à¼ '],
                ['a A',                                'à½à½²à½à¼à½à½´à½ à½à½²à½à¼à½à½´à½'],
                ['LT',                                 'à½à½²à½à¼à½à½´à½ à¼£:à¼¢à¼¥'],
                ['LTS',                                'à½à½²à½à¼à½à½´à½ à¼£:à¼¢à¼¥:à¼¥à¼ '],
                ['L',                                  'à¼¡à¼¤/à¼ à¼¢/à¼¢à¼ à¼¡à¼ '],
                ['LL',                                 'à¼¡à¼¤ à½à¾³à¼à½à¼à½à½à½²à½¦à¼à½ à¼¢à¼ à¼¡à¼ '],
                ['LLL',                                'à¼¡à¼¤ à½à¾³à¼à½à¼à½à½à½²à½¦à¼à½ à¼¢à¼ à¼¡à¼ , à½à½²à½à¼à½à½´à½ à¼£:à¼¢à¼¥'],
                ['LLLL',                               'à½à½à½ à¼à½à½²à¼à½à¼, à¼¡à¼¤ à½à¾³à¼à½à¼à½à½à½²à½¦à¼à½ à¼¢à¼ à¼¡à¼ , à½à½²à½à¼à½à½´à½ à¼£:à¼¢à¼¥'],
                ['l',                                  'à¼¡à¼¤/à¼¢/à¼¢à¼ à¼¡à¼ '],
                ['ll',                                 'à¼¡à¼¤ à½à¾³à¼à½à¼à½à½à½²à½¦à¼à½ à¼¢à¼ à¼¡à¼ '],
                ['lll',                                'à¼¡à¼¤ à½à¾³à¼à½à¼à½à½à½²à½¦à¼à½ à¼¢à¼ à¼¡à¼ , à½à½²à½à¼à½à½´à½ à¼£:à¼¢à¼¥'],
                ['llll',                               'à½à½²à¼à½à¼, à¼¡à¼¤ à½à¾³à¼à½à¼à½à½à½²à½¦à¼à½ à¼¢à¼ à¼¡à¼ , à½à½²à½à¼à½à½´à½ à¼£:à¼¢à¼¥']
            ],
            b = moment(new Date(2010, 1, 14, 15, 25, 50, 125)),
            i;
        for (i = 0; i < a.length; i++) {
            assert.equal(b.format(a[i][0]), a[i][1], a[i][0] + ' ---> ' + a[i][1]);
        }
    });

    test('format ordinal', function (assert) {
        assert.equal(moment([2011, 0, 1]).format('DDDo'), 'à¼¡', 'à¼¡');
        assert.equal(moment([2011, 0, 2]).format('DDDo'), 'à¼¢', 'à¼¢');
        assert.equal(moment([2011, 0, 3]).format('DDDo'), 'à¼£', 'à¼£');
        assert.equal(moment([2011, 0, 4]).format('DDDo'), 'à¼¤', 'à¼¤');
        assert.equal(moment([2011, 0, 5]).format('DDDo'), 'à¼¥', 'à¼¥');
        assert.equal(moment([2011, 0, 6]).format('DDDo'), 'à¼¦', 'à¼¦');
        assert.equal(moment([2011, 0, 7]).format('DDDo'), 'à¼§', 'à¼§');
        assert.equal(moment([2011, 0, 8]).format('DDDo'), 'à¼¨', 'à¼¨');
        assert.equal(moment([2011, 0, 9]).format('DDDo'), 'à¼©', 'à¼©');
        assert.equal(moment([2011, 0, 10]).format('DDDo'), 'à¼¡à¼ ', 'à¼¡à¼ ');

        assert.equal(moment([2011, 0, 11]).format('DDDo'), 'à¼¡à¼¡', 'à¼¡à¼¡');
        assert.equal(moment([2011, 0, 12]).format('DDDo'), 'à¼¡à¼¢', 'à¼¡à¼¢');
        assert.equal(moment([2011, 0, 13]).format('DDDo'), 'à¼¡à¼£', 'à¼¡à¼£');
        assert.equal(moment([2011, 0, 14]).format('DDDo'), 'à¼¡à¼¤', 'à¼¡à¼¤');
        assert.equal(moment([2011, 0, 15]).format('DDDo'), 'à¼¡à¼¥', 'à¼¡à¼¥');
        assert.equal(moment([2011, 0, 16]).format('DDDo'), 'à¼¡à¼¦', 'à¼¡à¼¦');
        assert.equal(moment([2011, 0, 17]).format('DDDo'), 'à¼¡à¼§', 'à¼¡à¼§');
        assert.equal(moment([2011, 0, 18]).format('DDDo'), 'à¼¡à¼¨', 'à¼¡à¼¨');
        assert.equal(moment([2011, 0, 19]).format('DDDo'), 'à¼¡à¼©', 'à¼¡à¼©');
        assert.equal(moment([2011, 0, 20]).format('DDDo'), 'à¼¢à¼ ', 'à¼¢à¼ ');

        assert.equal(moment([2011, 0, 21]).format('DDDo'), 'à¼¢à¼¡', 'à¼¢à¼¡');
        assert.equal(moment([2011, 0, 22]).format('DDDo'), 'à¼¢à¼¢', 'à¼¢à¼¢');
        assert.equal(moment([2011, 0, 23]).format('DDDo'), 'à¼¢à¼£', 'à¼¢à¼£');
        assert.equal(moment([2011, 0, 24]).format('DDDo'), 'à¼¢à¼¤', 'à¼¢à¼¤');
        assert.equal(moment([2011, 0, 25]).format('DDDo'), 'à¼¢à¼¥', 'à¼¢à¼¥');
        assert.equal(moment([2011, 0, 26]).format('DDDo'), 'à¼¢à¼¦', 'à¼¢à¼¦');
        assert.equal(moment([2011, 0, 27]).format('DDDo'), 'à¼¢à¼§', 'à¼¢à¼§');
        assert.equal(moment([2011, 0, 28]).format('DDDo'), 'à¼¢à¼¨', 'à¼¢à¼¨');
        assert.equal(moment([2011, 0, 29]).format('DDDo'), 'à¼¢à¼©', 'à¼¢à¼©');
        assert.equal(moment([2011, 0, 30]).format('DDDo'), 'à¼£à¼ ', 'à¼£à¼ ');

        assert.equal(moment([2011, 0, 31]).format('DDDo'), 'à¼£à¼¡', 'à¼£à¼¡');
    });

    test('format month', function (assert) {
        var expected = 'à½à¾³à¼à½à¼à½à½à¼à½à½¼ à½à¾³à¼à½à¼à½à½à¼à½à½¼_à½à¾³à¼à½à¼à½à½à½²à½¦à¼à½ à½à¾³à¼à½à¼à½à½à½²à½¦à¼à½_à½à¾³à¼à½à¼à½à½¦à½´à½à¼à½ à½à¾³à¼à½à¼à½à½¦à½´à½à¼à½_à½à¾³à¼à½à¼à½à½à½²à¼à½ à½à¾³à¼à½à¼à½à½à½²à¼à½_à½à¾³à¼à½à¼à½£à¾à¼à½ à½à¾³à¼à½à¼à½£à¾à¼à½_à½à¾³à¼à½à¼à½à¾²à½´à½à¼à½ à½à¾³à¼à½à¼à½à¾²à½´à½à¼à½_à½à¾³à¼à½à¼à½à½à½´à½à¼à½ à½à¾³à¼à½à¼à½à½à½´à½à¼à½_à½à¾³à¼à½à¼à½à½¢à¾à¾±à½à¼à½ à½à¾³à¼à½à¼à½à½¢à¾à¾±à½à¼à½_à½à¾³à¼à½à¼à½à½à½´à¼à½ à½à¾³à¼à½à¼à½à½à½´à¼à½_à½à¾³à¼à½à¼à½à½à½´à¼à½ à½à¾³à¼à½à¼à½à½à½´à¼à½_à½à¾³à¼à½à¼à½à½à½´à¼à½à½à½²à½à¼à½ à½à¾³à¼à½à¼à½à½à½´à¼à½à½à½²à½à¼à½_à½à¾³à¼à½à¼à½à½à½´à¼à½à½à½²à½¦à¼à½ à½à¾³à¼à½à¼à½à½à½´à¼à½à½à½²à½¦à¼à½'.split('_'), i;
        for (i = 0; i < expected.length; i++) {
            assert.equal(moment([2011, i, 1]).format('MMMM MMM'), expected[i], expected[i]);
        }
    });

    test('format week', function (assert) {
        var expected = 'à½à½à½ à¼à½à½²à¼à½à¼ à½à½²à¼à½à¼ à½à½²à¼à½à¼_à½à½à½ à¼à½à¾³à¼à½à¼ à½à¾³à¼à½à¼ à½à¾³à¼à½à¼_à½à½à½ à¼à½à½²à½à¼à½à½à½¢à¼ à½à½²à½à¼à½à½à½¢à¼ à½à½²à½à¼à½à½à½¢à¼_à½à½à½ à¼à½£à¾·à½à¼à½à¼ à½£à¾·à½à¼à½à¼ à½£à¾·à½à¼à½à¼_à½à½à½ à¼à½à½´à½¢à¼à½à½´ à½à½´à½¢à¼à½à½´ à½à½´à½¢à¼à½à½´_à½à½à½ à¼à½à¼à½¦à½à½¦à¼ à½à¼à½¦à½à½¦à¼ à½à¼à½¦à½à½¦à¼_à½à½à½ à¼à½¦à¾¤à½ºà½à¼à½à¼ à½¦à¾¤à½ºà½à¼à½à¼ à½¦à¾¤à½ºà½à¼à½à¼'.split('_'), i;
        for (i = 0; i < expected.length; i++) {
            assert.equal(moment([2011, 0, 2 + i]).format('dddd ddd dd'), expected[i], expected[i]);
        }
    });

    test('from', function (assert) {
        var start = moment([2007, 1, 28]);
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 44}), true),  'à½£à½à¼à½¦à½', '44 seconds = a few seconds');
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 45}), true),  'à½¦à¾à½¢à¼à½à¼à½à½à½²à½',      '45 seconds = a minute');
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 89}), true),  'à½¦à¾à½¢à¼à½à¼à½à½à½²à½',      '89 seconds = a minute');
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 90}), true),  'à¼¢ à½¦à¾à½¢à¼à½',     '90 seconds = 2 minutes');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 44}), true),  'à¼¤à¼¤ à½¦à¾à½¢à¼à½',    '44 minutes = 44 minutes');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 45}), true),  'à½à½´à¼à½à½¼à½à¼à½à½à½²à½',       '45 minutes = an hour');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 89}), true),  'à½à½´à¼à½à½¼à½à¼à½à½à½²à½',       '89 minutes = an hour');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 90}), true),  'à¼¢ à½à½´à¼à½à½¼à½',       '90 minutes = 2 hours');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 5}), true),   'à¼¥ à½à½´à¼à½à½¼à½',       '5 hours = 5 hours');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 21}), true),  'à¼¢à¼¡ à½à½´à¼à½à½¼à½',      '21 hours = 21 hours');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 22}), true),  'à½à½²à½à¼à½à½à½²à½',         '22 hours = a day');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 35}), true),  'à½à½²à½à¼à½à½à½²à½',         '35 hours = a day');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 36}), true),  'à¼¢ à½à½²à½à¼',        '36 hours = 2 days');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 1}), true),   'à½à½²à½à¼à½à½à½²à½',         '1 day = a day');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 5}), true),   'à¼¥ à½à½²à½à¼',        '5 days = 5 days');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 25}), true),  'à¼¢à¼¥ à½à½²à½à¼',       '25 days = 25 days');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 26}), true),  'à½à¾³à¼à½à¼à½à½à½²à½',       '26 days = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 30}), true),  'à½à¾³à¼à½à¼à½à½à½²à½',       '30 days = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 43}), true),  'à½à¾³à¼à½à¼à½à½à½²à½',       '43 days = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 46}), true),  'à¼¢ à½à¾³à¼à½',      '46 days = 2 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 74}), true),  'à¼¢ à½à¾³à¼à½',      '75 days = 2 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 76}), true),  'à¼£ à½à¾³à¼à½',      '76 days = 3 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({M: 1}), true),   'à½à¾³à¼à½à¼à½à½à½²à½',       '1 month = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({M: 5}), true),   'à¼¥ à½à¾³à¼à½',      '5 months = 5 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 345}), true), 'à½£à½¼à¼à½à½à½²à½',        '345 days = a year');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 548}), true), 'à¼¢ à½£à½¼',       '548 days = 2 years');
        assert.equal(start.from(moment([2007, 1, 28]).add({y: 1}), true),   'à½£à½¼à¼à½à½à½²à½',        '1 year = a year');
        assert.equal(start.from(moment([2007, 1, 28]).add({y: 5}), true),   'à¼¥ à½£à½¼',       '5 years = 5 years');
    });

    test('suffix', function (assert) {
        assert.equal(moment(30000).from(0), 'à½£à½à¼à½¦à½ à½£à¼',  'prefix');
        assert.equal(moment(0).from(30000), 'à½£à½à¼à½¦à½ à½¦à¾à½à¼à½£', 'suffix');
    });

    test('now from now', function (assert) {
        assert.equal(moment().fromNow(), 'à½£à½à¼à½¦à½ à½¦à¾à½à¼à½£',  'now from now should display as in the past');
    });

    test('fromNow', function (assert) {
        assert.equal(moment().add({s: 30}).fromNow(), 'à½£à½à¼à½¦à½ à½£à¼', 'à½£à½à¼à½¦à½ à½£à¼');
        assert.equal(moment().add({d: 5}).fromNow(), 'à¼¥ à½à½²à½à¼ à½£à¼', 'à¼¥ à½à½²à½à¼ à½£à¼');
    });

    test('calendar day', function (assert) {
        var a = moment().hours(12).minutes(0).seconds(0);

        assert.equal(moment(a).calendar(),                   'à½à½²à¼à½¢à½²à½ à½à½²à½à¼à½à½´à½ à¼¡à¼¢:à¼ à¼ ',  'today at the same time');
        assert.equal(moment(a).add({m: 25}).calendar(),      'à½à½²à¼à½¢à½²à½ à½à½²à½à¼à½à½´à½ à¼¡à¼¢:à¼¢à¼¥',  'Now plus 25 min');
        assert.equal(moment(a).add({h: 3}).calendar(),       'à½à½²à¼à½¢à½²à½ à½à½²à½à¼à½à½´à½ à¼£:à¼ à¼ ',   'Now plus 3 hours');
        assert.equal(moment(a).add({d: 1}).calendar(),       'à½¦à½à¼à½à½²à½ à½à½²à½à¼à½à½´à½ à¼¡à¼¢:à¼ à¼ ',  'tomorrow at the same time');
        assert.equal(moment(a).subtract({h: 1}).calendar(),  'à½à½²à¼à½¢à½²à½ à½à½²à½à¼à½à½´à½ à¼¡à¼¡:à¼ à¼ ',  'Now minus 1 hour');
        assert.equal(moment(a).subtract({d: 1}).calendar(),  'à½à¼à½¦à½ à½à½²à½à¼à½à½´à½ à¼¡à¼¢:à¼ à¼ ',    'yesterday at the same time');
    });

    test('calendar next week', function (assert) {
        var i, m;
        for (i = 2; i < 7; i++) {
            m = moment().add({d: i});
            assert.equal(m.calendar(),       m.format('[à½à½à½´à½à¼à½à¾²à½à¼à½¢à¾à½ºà½¦à¼à½][,] LT'),  'Today + ' + i + ' days current time');
            m.hours(0).minutes(0).seconds(0).milliseconds(0);
            assert.equal(m.calendar(),       m.format('[à½à½à½´à½à¼à½à¾²à½à¼à½¢à¾à½ºà½¦à¼à½][,] LT'),  'Today + ' + i + ' days beginning of day');
            m.hours(23).minutes(59).seconds(59).milliseconds(999);
            assert.equal(m.calendar(),       m.format('[à½à½à½´à½à¼à½à¾²à½à¼à½¢à¾à½ºà½¦à¼à½][,] LT'),  'Today + ' + i + ' days end of day');
        }
    });

    test('calendar last week', function (assert) {
        var i, m;

        for (i = 2; i < 7; i++) {
            m = moment().subtract({d: i});
            assert.equal(m.calendar(),       m.format('[à½à½à½´à½à¼à½à¾²à½à¼à½à½à½ à¼à½] dddd[,] LT'),  'Today - ' + i + ' days current time');
            m.hours(0).minutes(0).seconds(0).milliseconds(0);
            assert.equal(m.calendar(),       m.format('[à½à½à½´à½à¼à½à¾²à½à¼à½à½à½ à¼à½] dddd[,] LT'),  'Today - ' + i + ' days beginning of day');
            m.hours(23).minutes(59).seconds(59).milliseconds(999);
            assert.equal(m.calendar(),       m.format('[à½à½à½´à½à¼à½à¾²à½à¼à½à½à½ à¼à½] dddd[,] LT'),  'Today - ' + i + ' days end of day');
        }
    });

    test('calendar all else', function (assert) {
        var weeksAgo = moment().subtract({w: 1}),
            weeksFromNow = moment().add({w: 1});

        assert.equal(weeksAgo.calendar(),       weeksAgo.format('L'),  '1 week ago');
        assert.equal(weeksFromNow.calendar(),   weeksFromNow.format('L'),  'in 1 week');

        weeksAgo = moment().subtract({w: 2});
        weeksFromNow = moment().add({w: 2});

        assert.equal(weeksAgo.calendar(),       weeksAgo.format('L'),  '2 weeks ago');
        assert.equal(weeksFromNow.calendar(),   weeksFromNow.format('L'),  'in 2 weeks');
    });

    test('meridiem', function (assert) {
        assert.equal(moment([2011, 2, 23,  2, 30]).format('a'), 'à½à½à½à¼à½à½¼', 'before dawn');
        assert.equal(moment([2011, 2, 23,  9, 30]).format('a'), 'à½à½¼à½à½¦à¼à½à½¦', 'morning');
        assert.equal(moment([2011, 2, 23, 14, 30]).format('a'), 'à½à½²à½à¼à½à½´à½', 'during day');
        assert.equal(moment([2011, 2, 23, 17, 30]).format('a'), 'à½à½à½¼à½à¼à½à½', 'evening');
        assert.equal(moment([2011, 2, 23, 19, 30]).format('a'), 'à½à½à½¼à½à¼à½à½', 'late evening');
        assert.equal(moment([2011, 2, 23, 21, 20]).format('a'), 'à½à½à½à¼à½à½¼', 'night');

        assert.equal(moment([2011, 2, 23,  2, 30]).format('A'), 'à½à½à½à¼à½à½¼', 'before dawn');
        assert.equal(moment([2011, 2, 23,  9, 30]).format('A'), 'à½à½¼à½à½¦à¼à½à½¦', 'morning');
        assert.equal(moment([2011, 2, 23, 14, 30]).format('A'), 'à½à½²à½à¼à½à½´à½', ' during day');
        assert.equal(moment([2011, 2, 23, 17, 30]).format('A'), 'à½à½à½¼à½à¼à½à½', 'evening');
        assert.equal(moment([2011, 2, 23, 19, 30]).format('A'), 'à½à½à½¼à½à¼à½à½', 'late evening');
        assert.equal(moment([2011, 2, 23, 21, 20]).format('A'), 'à½à½à½à¼à½à½¼', 'night');
    });

    test('weeks year starting sunday formatted', function (assert) {
        assert.equal(moment([2012, 0,  1]).format('w ww wo'), 'à¼¡ à¼ à¼¡ à¼¡', 'Jan  1 2012 should be week 1');
        assert.equal(moment([2012, 0,  7]).format('w ww wo'), 'à¼¡ à¼ à¼¡ à¼¡', 'Jan  7 2012 should be week 1');
        assert.equal(moment([2012, 0,  8]).format('w ww wo'), 'à¼¢ à¼ à¼¢ à¼¢', 'Jan  8 2012 should be week 2');
        assert.equal(moment([2012, 0, 14]).format('w ww wo'), 'à¼¢ à¼ à¼¢ à¼¢', 'Jan 14 2012 should be week 2');
        assert.equal(moment([2012, 0, 15]).format('w ww wo'), 'à¼£ à¼ à¼£ à¼£', 'Jan 15 2012 should be week 3');
    });

}));

;(function (global, factory) {
   typeof exports === 'object' && typeof module !== 'undefined'
       && typeof require === 'function' ? factory(require('../../moment')) :
   typeof define === 'function' && define.amd ? define(['../../moment'], factory) :
   factory(global.moment)
}(this, function (moment) { 'use strict';

    function each(array, callback) {
        var i;
        for (i = 0; i < array.length; i++) {
            callback(array[i], i, array);
        }
    }

    function objectKeys(obj) {
        if (Object.keys) {
            return Object.keys(obj);
        } else {
            // IE8
            var res = [], i;
            for (i in obj) {
                if (obj.hasOwnProperty(i)) {
                    res.push(i);
                }
            }
            return res;
        }
    }

    // Pick the first defined of two or three arguments.
    function defaults(a, b, c) {
        if (a != null) {
            return a;
        }
        if (b != null) {
            return b;
        }
        return c;
    }

    function defineCommonLocaleTests(locale, options) {
        test('lenient ordinal parsing', function (assert) {
            var i, ordinalStr, testMoment;
            for (i = 1; i <= 31; ++i) {
                ordinalStr = moment([2014, 0, i]).format('YYYY MM Do');
                testMoment = moment(ordinalStr, 'YYYY MM Do');
                assert.equal(testMoment.year(), 2014,
                        'lenient ordinal parsing ' + i + ' year check');
                assert.equal(testMoment.month(), 0,
                        'lenient ordinal parsing ' + i + ' month check');
                assert.equal(testMoment.date(), i,
                        'lenient ordinal parsing ' + i + ' date check');
            }
        });

        test('lenient ordinal parsing of number', function (assert) {
            var i, testMoment;
            for (i = 1; i <= 31; ++i) {
                testMoment = moment('2014 01 ' + i, 'YYYY MM Do');
                assert.equal(testMoment.year(), 2014,
                        'lenient ordinal parsing of number ' + i + ' year check');
                assert.equal(testMoment.month(), 0,
                        'lenient ordinal parsing of number ' + i + ' month check');
                assert.equal(testMoment.date(), i,
                        'lenient ordinal parsing of number ' + i + ' date check');
            }
        });

        test('strict ordinal parsing', function (assert) {
            var i, ordinalStr, testMoment;
            for (i = 1; i <= 31; ++i) {
                ordinalStr = moment([2014, 0, i]).format('YYYY MM Do');
                testMoment = moment(ordinalStr, 'YYYY MM Do', true);
                assert.ok(testMoment.isValid(), 'strict ordinal parsing ' + i);
            }
        });

        test('meridiem invariant', function (assert) {
            var h, m, t1, t2;
            for (h = 0; h < 24; ++h) {
                for (m = 0; m < 60; m += 15) {
                    t1 = moment.utc([2000, 0, 1, h, m]);
                    t2 = moment.utc(t1.format('A h:mm'), 'A h:mm');
                    assert.equal(t2.format('HH:mm'), t1.format('HH:mm'),
                            'meridiem at ' + t1.format('HH:mm'));
                }
            }
        });

        test('date format correctness', function (assert) {
            var data, tokens;
            data = moment.localeData()._longDateFormat;
            tokens = objectKeys(data);
            each(tokens, function (srchToken) {
                // Check each format string to make sure it does not contain any
                // tokens that need to be expanded.
                each(tokens, function (baseToken) {
                    // strip escaped sequences
                    var format = data[baseToken].replace(/(\[[^\]]*\])/g, '');
                    assert.equal(false, !!~format.indexOf(srchToken),
                            'contains ' + srchToken + ' in ' + baseToken);
                });
            });
        });

        test('month parsing correctness', function (assert) {
            var i, m;

            if (locale === 'tr') {
                // I can't fix it :(
                expect(0);
                return;
            }
            function tester(format) {
                var r;
                r = moment(m.format(format), format);
                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format);
                r = moment(m.format(format).toLocaleUpperCase(), format);
                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' upper');
                r = moment(m.format(format).toLocaleLowerCase(), format);
                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' lower');

                r = moment(m.format(format), format, true);
                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' strict');
                r = moment(m.format(format).toLocaleUpperCase(), format, true);
                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' upper strict');
                r = moment(m.format(format).toLocaleLowerCase(), format, true);
                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' lower strict');
            }

            for (i = 0; i < 12; ++i) {
                m = moment([2015, i, 15, 18]);
                tester('MMM');
                tester('MMM.');
                tester('MMMM');
                tester('MMMM.');
            }
        });

        test('weekday parsing correctness', function (assert) {
            var i, m;

            if (locale === 'tr' || locale === 'az') {
                // There is a lower-case letter (Ä±), that converted to upper then
                // lower changes to i
                expect(0);
                return;
            }
            function tester(format) {
                var r, baseMsg = 'weekday ' + m.weekday() + ' fmt ' + format;
                r = moment(m.format(format), format);
                assert.equal(r.weekday(), m.weekday(), baseMsg);
                r = moment(m.format(format).toLocaleUpperCase(), format);
                assert.equal(r.weekday(), m.weekday(), baseMsg + ' upper');
                r = moment(m.format(format).toLocaleLowerCase(), format);
                assert.equal(r.weekday(), m.weekday(), baseMsg + ' lower');

                r = moment(m.format(format), format, true);
                assert.equal(r.weekday(), m.weekday(), baseMsg + ' strict');
                r = moment(m.format(format).toLocaleUpperCase(), format, true);
                assert.equal(r.weekday(), m.weekday(), baseMsg + ' upper strict');
                r = moment(m.format(format).toLocaleLowerCase(), format, true);
                assert.equal(r.weekday(), m.weekday(), baseMsg + ' lower strict');
            }

            for (i = 0; i < 7; ++i) {
                m = moment.utc([2015, i, 15, 18]);
                tester('dd');
                tester('ddd');
                tester('dddd');
            }
        });
    }

    function setupDeprecationHandler(test, moment, scope) {
        test._expectedDeprecations = null;
        test._observedDeprecations = null;
        test._oldSupress = moment.suppressDeprecationWarnings;
        moment.suppressDeprecationWarnings = true;
        test.expectedDeprecations = function () {
            test._expectedDeprecations = arguments;
            test._observedDeprecations = [];
        };
        moment.deprecationHandler = function (name, msg) {
            var deprecationId = matchedDeprecation(name, msg, test._expectedDeprecations);
            if (deprecationId === -1) {
                throw new Error('Unexpected deprecation thrown name=' +
                        name + ' msg=' + msg);
            }
            test._observedDeprecations[deprecationId] = 1;
        };
    }

    function teardownDeprecationHandler(test, moment, scope) {
        moment.suppressDeprecationWarnings = test._oldSupress;

        if (test._expectedDeprecations != null) {
            var missedDeprecations = [];
            each(test._expectedDeprecations, function (deprecationPattern, id) {
                if (test._observedDeprecations[id] !== 1) {
                    missedDeprecations.push(deprecationPattern);
                }
            });
            if (missedDeprecations.length !== 0) {
                throw new Error('Expected deprecation warnings did not happen: ' +
                        missedDeprecations.join(' '));
            }
        }
    }

    function matchedDeprecation(name, msg, deprecations) {
        if (deprecations == null) {
            return -1;
        }
        for (var i = 0; i < deprecations.length; ++i) {
            if (name != null && name === deprecations[i]) {
                return i;
            }
            if (msg != null && msg.substring(0, deprecations[i].length) === deprecations[i]) {
                return i;
            }
        }
        return -1;
    }

    /*global QUnit:false*/

    var test = QUnit.test;

    var expect = QUnit.expect;

    function module (name, lifecycle) {
        QUnit.module(name, {
            setup : function () {
                moment.locale('en');
                moment.createFromInputFallback = function (config) {
                    throw new Error('input not handled by moment: ' + config._i);
                };
                setupDeprecationHandler(test, moment, 'core');
                if (lifecycle && lifecycle.setup) {
                    lifecycle.setup();
                }
            },
            teardown : function () {
                teardownDeprecationHandler(test, moment, 'core');
                if (lifecycle && lifecycle.teardown) {
                    lifecycle.teardown();
                }
            }
        });
    }

    function localeModule (name, lifecycle) {
        QUnit.module('locale:' + name, {
            setup : function () {
                moment.locale(name);
                moment.createFromInputFallback = function (config) {
                    throw new Error('input not handled by moment: ' + config._i);
                };
                setupDeprecationHandler(test, moment, 'locale');
                if (lifecycle && lifecycle.setup) {
                    lifecycle.setup();
                }
            },
            teardown : function () {
                moment.locale('en');
                teardownDeprecationHandler(test, moment, 'locale');
                if (lifecycle && lifecycle.teardown) {
                    lifecycle.teardown();
                }
            }
        });
        defineCommonLocaleTests(name, -1, -1);
    }

    localeModule('br');

    test('parse', function (assert) {
        var tests = 'Genver Gen_C\'hwevrer C\'hwe_Meurzh Meu_Ebrel Ebr_Mae Mae_Mezheven Eve_Gouere Gou_Eost Eos_Gwengolo Gwe_Here Her_Du Du_Kerzu Ker'.split('_'), i;
        function equalTest(input, mmm, i) {
            assert.equal(moment(input, mmm).month(), i, input + ' should be month ' + (i + 1));
        }
        for (i = 0; i < 12; i++) {
            tests[i] = tests[i].split(' ');
            equalTest(tests[i][0], 'MMM', i);
            equalTest(tests[i][1], 'MMM', i);
            equalTest(tests[i][0], 'MMMM', i);
            equalTest(tests[i][1], 'MMMM', i);
            equalTest(tests[i][0].toLocaleLowerCase(), 'MMMM', i);
            equalTest(tests[i][1].toLocaleLowerCase(), 'MMMM', i);
            equalTest(tests[i][0].toLocaleUpperCase(), 'MMMM', i);
            equalTest(tests[i][1].toLocaleUpperCase(), 'MMMM', i);
        }
    });

    test('format', function (assert) {
        moment.locale('br');
        var a = [
                ['dddd, MMMM Do YYYY, h:mm:ss a',      'Sul, C\'hwevrer 14vet 2010, 3:25:50 pm'],
                ['ddd, h A',                            'Sul, 3 PM'],
                ['M Mo MM MMMM MMM',                   '2 2vet 02 C\'hwevrer C\'hwe'],
                ['YYYY YY',                            '2010 10'],
                ['D Do DD',                            '14 14vet 14'],
                ['d do dddd ddd dd',                   '0 0vet Sul Sul Su'],
                ['DDD DDDo DDDD',                      '45 45vet 045'],
                ['w wo ww',                            '6 6vet 06'],
                ['h hh',                               '3 03'],
                ['H HH',                               '15 15'],
                ['m mm',                               '25 25'],
                ['s ss',                               '50 50'],
                ['DDDo [devezh] [ar] [vloaz]',       '45vet devezh ar vloaz'],
                ['L',                                  '14/02/2010'],
                ['LL',                                 '14 a viz C\'hwevrer 2010'],
                ['LLL',                                '14 a viz C\'hwevrer 2010 3e25 PM'],
                ['LLLL',                               'Sul, 14 a viz C\'hwevrer 2010 3e25 PM']
            ],
            b = moment(new Date(2010, 1, 14, 15, 25, 50, 125)),
            i;
        for (i = 0; i < a.length; i++) {
            assert.equal(b.format(a[i][0]), a[i][1], a[i][0] + ' ---> ' + a[i][1]);
        }
    });

    test('format ordinal', function (assert) {
        moment.locale('br');
        assert.equal(moment([2011, 0, 1]).format('DDDo'), '1aÃ±', '1aÃ±');
        assert.equal(moment([2011, 0, 2]).format('DDDo'), '2vet', '2vet');
        assert.equal(moment([2011, 0, 3]).format('DDDo'), '3vet', '3vet');
        assert.equal(moment([2011, 0, 4]).format('DDDo'), '4vet', '4vet');
        assert.equal(moment([2011, 0, 5]).format('DDDo'), '5vet', '5vet');
        assert.equal(moment([2011, 0, 6]).format('DDDo'), '6vet', '6vet');
        assert.equal(moment([2011, 0, 7]).format('DDDo'), '7vet', '7vet');
        assert.equal(moment([2011, 0, 8]).format('DDDo'), '8vet', '8vet');
        assert.equal(moment([2011, 0, 9]).format('DDDo'), '9vet', '9vet');
        assert.equal(moment([2011, 0, 10]).format('DDDo'), '10vet', '10vet');

        assert.equal(moment([2011, 0, 11]).format('DDDo'), '11vet', '11vet');
        assert.equal(moment([2011, 0, 12]).format('DDDo'), '12vet', '12vet');
        assert.equal(moment([2011, 0, 13]).format('DDDo'), '13vet', '13vet');
        assert.equal(moment([2011, 0, 14]).format('DDDo'), '14vet', '14vet');
        assert.equal(moment([2011, 0, 15]).format('DDDo'), '15vet', '15vet');
        assert.equal(moment([2011, 0, 16]).format('DDDo'), '16vet', '16vet');
        assert.equal(moment([2011, 0, 17]).format('DDDo'), '17vet', '17vet');
        assert.equal(moment([2011, 0, 18]).format('DDDo'), '18vet', '18vet');
        assert.equal(moment([2011, 0, 19]).format('DDDo'), '19vet', '19vet');
        assert.equal(moment([2011, 0, 20]).format('DDDo'), '20vet', '20vet');

        assert.equal(moment([2011, 0, 21]).format('DDDo'), '21vet', '21vet');
        assert.equal(moment([2011, 0, 22]).format('DDDo'), '22vet', '22vet');
        assert.equal(moment([2011, 0, 23]).format('DDDo'), '23vet', '23vet');
        assert.equal(moment([2011, 0, 24]).format('DDDo'), '24vet', '24vet');
        assert.equal(moment([2011, 0, 25]).format('DDDo'), '25vet', '25vet');
        assert.equal(moment([2011, 0, 26]).format('DDDo'), '26vet', '26vet');
        assert.equal(moment([2011, 0, 27]).format('DDDo'), '27vet', '27vet');
        assert.equal(moment([2011, 0, 28]).format('DDDo'), '28vet', '28vet');
        assert.equal(moment([2011, 0, 29]).format('DDDo'), '29vet', '29vet');
        assert.equal(moment([2011, 0, 30]).format('DDDo'), '30vet', '30vet');

        assert.equal(moment([2011, 0, 31]).format('DDDo'), '31vet', '31vet');
    });

    test('format month', function (assert) {
        moment.locale('br');
        var expected = 'Genver Gen_C\'hwevrer C\'hwe_Meurzh Meu_Ebrel Ebr_Mae Mae_Mezheven Eve_Gouere Gou_Eost Eos_Gwengolo Gwe_Here Her_Du Du_Kerzu Ker'.split('_'), i;
        for (i = 0; i < expected.length; i++) {
            assert.equal(moment([2011, i, 1]).format('MMMM MMM'), expected[i], expected[i]);
        }
    });

    test('format week', function (assert) {
        moment.locale('br');
        var expected = 'Sul Sul Su_Lun Lun Lu_Meurzh Meu Me_Merc\'her Mer Mer_Yaou Yao Ya_Gwener Gwe Gw_Sadorn Sad Sa'.split('_'), i;
        for (i = 0; i < expected.length; i++) {
            assert.equal(moment([2011, 0, 2 + i]).format('dddd ddd dd'), expected[i], expected[i]);
        }
    });

    test('from', function (assert) {
        moment.locale('br');
        var start = moment([2007, 1, 28]);
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 44}), true),  'un nebeud segondennoÃ¹', '44 seconds = a few seconds');
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 45}), true),  'ur vunutenn',      '45 seconds = a minute');
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 89}), true),  'ur vunutenn',      '89 seconds = a minute');
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 90}), true),  '2 vunutenn',     '90 seconds = 2 minutes');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 44}), true),  '44 munutenn',    '44 minutes = 44 minutes');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 45}), true),  'un eur',       '45 minutes = an hour');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 89}), true),  'un eur',       '89 minutes = an hour');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 90}), true),  '2 eur',       '90 minutes = 2 hours');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 5}), true),   '5 eur',       '5 hours = 5 hours');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 21}), true),  '21 eur',      '21 hours = 21 hours');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 22}), true),  'un devezh',         '22 hours = a day');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 35}), true),  'un devezh',         '35 hours = a day');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 36}), true),  '2 zevezh',        '36 hours = 2 days');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 1}), true),   'un devezh',         '1 day = a day');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 5}), true),   '5 devezh',        '5 days = 5 days');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 25}), true),  '25 devezh',       '25 days = 25 days');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 26}), true),  'ur miz',       '26 days = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 30}), true),  'ur miz',       '30 days = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 43}), true),  'ur miz',       '43 days = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 46}), true),  '2 viz',      '46 days = 2 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 74}), true),  '2 viz',      '75 days = 2 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 76}), true),  '3 miz',      '76 days = 3 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({M: 1}), true),   'ur miz',       '1 month = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({M: 5}), true),   '5 miz',      '5 months = 5 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 345}), true), 'ur bloaz',        '345 days = a year');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 548}), true), '2 vloaz',       '548 days = 2 years');
        assert.equal(start.from(moment([2007, 1, 28]).add({y: 1}), true),   'ur bloaz',        '1 year = a year');
        assert.equal(start.from(moment([2007, 1, 28]).add({y: 5}), true),   '5 bloaz',       '5 years = 5 years');
    });

    test('suffix', function (assert) {
        moment.locale('br');
        assert.equal(moment(30000).from(0), 'a-benn un nebeud segondennoÃ¹',  'prefix');
        assert.equal(moment(0).from(30000), 'un nebeud segondennoÃ¹ \'zo', 'suffix');
    });

    test('now from now', function (assert) {
        moment.locale('br');
        assert.equal(moment().fromNow(), 'un nebeud segondennoÃ¹ \'zo',  'now from now should display as in the past');
    });

    test('fromNow', function (assert) {
        moment.locale('br');
        assert.equal(moment().add({s: 30}).fromNow(), 'a-benn un nebeud segondennoÃ¹', 'in a few seconds');
        assert.equal(moment().add({d: 5}).fromNow(), 'a-benn 5 devezh', 'in 5 days');
    });

    test('calendar day', function (assert) {
        moment.locale('br');

        var a = moment().hours(12).minutes(0).seconds(0);

        assert.equal(moment(a).calendar(),                   'Hiziv da 12e00 PM',        'today at the same time');
        assert.equal(moment(a).add({m: 25}).calendar(),      'Hiziv da 12e25 PM',        'Now plus 25 min');
        assert.equal(moment(a).add({h: 1}).calendar(),       'Hiziv da 1e00 PM',         'Now plus 1 hour');
        assert.equal(moment(a).add({d: 1}).calendar(),       'Warc\'hoazh da 12e00 PM',  'tomorrow at the same time');
        assert.equal(moment(a).subtract({h: 1}).calendar(),  'Hiziv da 11e00 AM',        'Now minus 1 hour');
        assert.equal(moment(a).subtract({d: 1}).calendar(),  'Dec\'h da 12e00 PM',       'yesterday at the same time');
    });

    test('calendar next week', function (assert) {
        moment.locale('br');

        var i, m;
        for (i = 2; i < 7; i++) {
            m = moment().add({d: i});
            assert.equal(m.calendar(),       m.format('dddd [da] LT'),  'Today + ' + i + ' days current time');
            m.hours(0).minutes(0).seconds(0).milliseconds(0);
            assert.equal(m.calendar(),       m.format('dddd [da] LT'),  'Today + ' + i + ' days beginning of day');
            m.hours(23).minutes(59).seconds(59).milliseconds(999);
            assert.equal(m.calendar(),       m.format('dddd [da] LT'),  'Today + ' + i + ' days end of day');
        }
    });

    test('calendar last week', function (assert) {
        moment.locale('br');

        var i, m;
        for (i = 2; i < 7; i++) {
            m = moment().subtract({d: i});
            assert.equal(m.calendar(),       m.format('dddd [paset da] LT'),  'Today - ' + i + ' days current time');
            m.hours(0).minutes(0).seconds(0).milliseconds(0);
            assert.equal(m.calendar(),       m.format('dddd [paset da] LT'),  'Today - ' + i + ' days beginning of day');
            m.hours(23).minutes(59).seconds(59).milliseconds(999);
            assert.equal(m.calendar(),       m.format('dddd [paset da] LT'),  'Today - ' + i + ' days end of day');
        }
    });

    test('calendar all else', function (assert) {
        moment.locale('br');
        var weeksAgo = moment().subtract({w: 1}),
            weeksFromNow = moment().add({w: 1});

        assert.equal(weeksAgo.calendar(),       weeksAgo.format('L'),  '1 week ago');
        assert.equal(weeksFromNow.calendar(),   weeksFromNow.format('L'),  'in 1 week');

        weeksAgo = moment().subtract({w: 2});
        weeksFromNow = moment().add({w: 2});

        assert.equal(weeksAgo.calendar(),       weeksAgo.format('L'),  '2 weeks ago');
        assert.equal(weeksFromNow.calendar(),   weeksFromNow.format('L'),  'in 2 weeks');
    });

    test('special mutations for years', function (assert) {
        moment.locale('br');
        var start = moment([2007, 1, 28]);
        assert.equal(start.from(moment([2007, 1, 28]).add({y: 1}), true), 'ur bloaz', 'mutation 1 year');
        assert.equal(start.from(moment([2007, 1, 28]).add({y: 2}), true), '2 vloaz', 'mutation 2 years');
        assert.equal(start.from(moment([2007, 1, 28]).add({y: 3}), true), '3 bloaz', 'mutation 3 years');
        assert.equal(start.from(moment([2007, 1, 28]).add({y: 4}), true), '4 bloaz', 'mutation 4 years');
        assert.equal(start.from(moment([2007, 1, 28]).add({y: 5}), true), '5 bloaz', 'mutation 5 years');
        assert.equal(start.from(moment([2007, 1, 28]).add({y: 9}), true), '9 bloaz', 'mutation 9 years');
        assert.equal(start.from(moment([2007, 1, 28]).add({y: 10}), true), '10 vloaz', 'mutation 10 years');
        assert.equal(start.from(moment([2007, 1, 28]).add({y: 21}), true), '21 bloaz', 'mutation 21 years');
        assert.equal(start.from(moment([2007, 1, 28]).add({y: 22}), true), '22 vloaz', 'mutation 22 years');
        assert.equal(start.from(moment([2007, 1, 28]).add({y: 133}), true), '133 bloaz', 'mutation 133 years');
        assert.equal(start.from(moment([2007, 1, 28]).add({y: 148}), true), '148 vloaz', 'mutation 148 years');
        assert.equal(start.from(moment([2007, 1, 28]).add({y: 261}), true), '261 bloaz', 'mutation 261 years');
    });

}));

;(function (global, factory) {
   typeof exports === 'object' && typeof module !== 'undefined'
       && typeof require === 'function' ? factory(require('../../moment')) :
   typeof define === 'function' && define.amd ? define(['../../moment'], factory) :
   factory(global.moment)
}(this, function (moment) { 'use strict';

    function each(array, callback) {
        var i;
        for (i = 0; i < array.length; i++) {
            callback(array[i], i, array);
        }
    }

    function objectKeys(obj) {
        if (Object.keys) {
            return Object.keys(obj);
        } else {
            // IE8
            var res = [], i;
            for (i in obj) {
                if (obj.hasOwnProperty(i)) {
                    res.push(i);
                }
            }
            return res;
        }
    }

    // Pick the first defined of two or three arguments.
    function defaults(a, b, c) {
        if (a != null) {
            return a;
        }
        if (b != null) {
            return b;
        }
        return c;
    }

    function defineCommonLocaleTests(locale, options) {
        test('lenient ordinal parsing', function (assert) {
            var i, ordinalStr, testMoment;
            for (i = 1; i <= 31; ++i) {
                ordinalStr = moment([2014, 0, i]).format('YYYY MM Do');
                testMoment = moment(ordinalStr, 'YYYY MM Do');
                assert.equal(testMoment.year(), 2014,
                        'lenient ordinal parsing ' + i + ' year check');
                assert.equal(testMoment.month(), 0,
                        'lenient ordinal parsing ' + i + ' month check');
                assert.equal(testMoment.date(), i,
                        'lenient ordinal parsing ' + i + ' date check');
            }
        });

        test('lenient ordinal parsing of number', function (assert) {
            var i, testMoment;
            for (i = 1; i <= 31; ++i) {
                testMoment = moment('2014 01 ' + i, 'YYYY MM Do');
                assert.equal(testMoment.year(), 2014,
                        'lenient ordinal parsing of number ' + i + ' year check');
                assert.equal(testMoment.month(), 0,
                        'lenient ordinal parsing of number ' + i + ' month check');
                assert.equal(testMoment.date(), i,
                        'lenient ordinal parsing of number ' + i + ' date check');
            }
        });

        test('strict ordinal parsing', function (assert) {
            var i, ordinalStr, testMoment;
            for (i = 1; i <= 31; ++i) {
                ordinalStr = moment([2014, 0, i]).format('YYYY MM Do');
                testMoment = moment(ordinalStr, 'YYYY MM Do', true);
                assert.ok(testMoment.isValid(), 'strict ordinal parsing ' + i);
            }
        });

        test('meridiem invariant', function (assert) {
            var h, m, t1, t2;
            for (h = 0; h < 24; ++h) {
                for (m = 0; m < 60; m += 15) {
                    t1 = moment.utc([2000, 0, 1, h, m]);
                    t2 = moment.utc(t1.format('A h:mm'), 'A h:mm');
                    assert.equal(t2.format('HH:mm'), t1.format('HH:mm'),
                            'meridiem at ' + t1.format('HH:mm'));
                }
            }
        });

        test('date format correctness', function (assert) {
            var data, tokens;
            data = moment.localeData()._longDateFormat;
            tokens = objectKeys(data);
            each(tokens, function (srchToken) {
                // Check each format string to make sure it does not contain any
                // tokens that need to be expanded.
                each(tokens, function (baseToken) {
                    // strip escaped sequences
                    var format = data[baseToken].replace(/(\[[^\]]*\])/g, '');
                    assert.equal(false, !!~format.indexOf(srchToken),
                            'contains ' + srchToken + ' in ' + baseToken);
                });
            });
        });

        test('month parsing correctness', function (assert) {
            var i, m;

            if (locale === 'tr') {
                // I can't fix it :(
                expect(0);
                return;
            }
            function tester(format) {
                var r;
                r = moment(m.format(format), format);
                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format);
                r = moment(m.format(format).toLocaleUpperCase(), format);
                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' upper');
                r = moment(m.format(format).toLocaleLowerCase(), format);
                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' lower');

                r = moment(m.format(format), format, true);
                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' strict');
                r = moment(m.format(format).toLocaleUpperCase(), format, true);
                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' upper strict');
                r = moment(m.format(format).toLocaleLowerCase(), format, true);
                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' lower strict');
            }

            for (i = 0; i < 12; ++i) {
                m = moment([2015, i, 15, 18]);
                tester('MMM');
                tester('MMM.');
                tester('MMMM');
                tester('MMMM.');
            }
        });

        test('weekday parsing correctness', function (assert) {
            var i, m;

            if (locale === 'tr' || locale === 'az') {
                // There is a lower-case letter (Ä±), that converted to upper then
                // lower changes to i
                expect(0);
                return;
            }
            function tester(format) {
                var r, baseMsg = 'weekday ' + m.weekday() + ' fmt ' + format;
                r = moment(m.format(format), format);
                assert.equal(r.weekday(), m.weekday(), baseMsg);
                r = moment(m.format(format).toLocaleUpperCase(), format);
                assert.equal(r.weekday(), m.weekday(), baseMsg + ' upper');
                r = moment(m.format(format).toLocaleLowerCase(), format);
                assert.equal(r.weekday(), m.weekday(), baseMsg + ' lower');

                r = moment(m.format(format), format, true);
                assert.equal(r.weekday(), m.weekday(), baseMsg + ' strict');
                r = moment(m.format(format).toLocaleUpperCase(), format, true);
                assert.equal(r.weekday(), m.weekday(), baseMsg + ' upper strict');
                r = moment(m.format(format).toLocaleLowerCase(), format, true);
                assert.equal(r.weekday(), m.weekday(), baseMsg + ' lower strict');
            }

            for (i = 0; i < 7; ++i) {
                m = moment.utc([2015, i, 15, 18]);
                tester('dd');
                tester('ddd');
                tester('dddd');
            }
        });
    }

    function setupDeprecationHandler(test, moment, scope) {
        test._expectedDeprecations = null;
        test._observedDeprecations = null;
        test._oldSupress = moment.suppressDeprecationWarnings;
        moment.suppressDeprecationWarnings = true;
        test.expectedDeprecations = function () {
            test._expectedDeprecations = arguments;
            test._observedDeprecations = [];
        };
        moment.deprecationHandler = function (name, msg) {
            var deprecationId = matchedDeprecation(name, msg, test._expectedDeprecations);
            if (deprecationId === -1) {
                throw new Error('Unexpected deprecation thrown name=' +
                        name + ' msg=' + msg);
            }
            test._observedDeprecations[deprecationId] = 1;
        };
    }

    function teardownDeprecationHandler(test, moment, scope) {
        moment.suppressDeprecationWarnings = test._oldSupress;

        if (test._expectedDeprecations != null) {
            var missedDeprecations = [];
            each(test._expectedDeprecations, function (deprecationPattern, id) {
                if (test._observedDeprecations[id] !== 1) {
                    missedDeprecations.push(deprecationPattern);
                }
            });
            if (missedDeprecations.length !== 0) {
                throw new Error('Expected deprecation warnings did not happen: ' +
                        missedDeprecations.join(' '));
            }
        }
    }

    function matchedDeprecation(name, msg, deprecations) {
        if (deprecations == null) {
            return -1;
        }
        for (var i = 0; i < deprecations.length; ++i) {
            if (name != null && name === deprecations[i]) {
                return i;
            }
            if (msg != null && msg.substring(0, deprecations[i].length) === deprecations[i]) {
                return i;
            }
        }
        return -1;
    }

    /*global QUnit:false*/

    var test = QUnit.test;

    var expect = QUnit.expect;

    function module (name, lifecycle) {
        QUnit.module(name, {
            setup : function () {
                moment.locale('en');
                moment.createFromInputFallback = function (config) {
                    throw new Error('input not handled by moment: ' + config._i);
                };
                setupDeprecationHandler(test, moment, 'core');
                if (lifecycle && lifecycle.setup) {
                    lifecycle.setup();
                }
            },
            teardown : function () {
                teardownDeprecationHandler(test, moment, 'core');
                if (lifecycle && lifecycle.teardown) {
                    lifecycle.teardown();
                }
            }
        });
    }

    function localeModule (name, lifecycle) {
        QUnit.module('locale:' + name, {
            setup : function () {
                moment.locale(name);
                moment.createFromInputFallback = function (config) {
                    throw new Error('input not handled by moment: ' + config._i);
                };
                setupDeprecationHandler(test, moment, 'locale');
                if (lifecycle && lifecycle.setup) {
                    lifecycle.setup();
                }
            },
            teardown : function () {
                moment.locale('en');
                teardownDeprecationHandler(test, moment, 'locale');
                if (lifecycle && lifecycle.teardown) {
                    lifecycle.teardown();
                }
            }
        });
        defineCommonLocaleTests(name, -1, -1);
    }

    localeModule('bs');

    test('parse', function (assert) {
        var tests = 'januar jan._februar feb._mart mar._april apr._maj maj._juni jun._juli jul._august aug._septembar sep._oktobar okt._novembar nov._decembar dec.'.split('_'), i;
        function equalTest(input, mmm, i) {
            assert.equal(moment(input, mmm).month(), i, input + ' should be month ' + (i + 1) + ' inp ' + mmm);
        }
        for (i = 0; i < 12; i++) {
            tests[i] = tests[i].split(' ');
            equalTest(tests[i][0], 'MMM', i);
            equalTest(tests[i][1], 'MMM', i);
            equalTest(tests[i][0], 'MMMM', i);
            equalTest(tests[i][1], 'MMMM', i);
            equalTest(tests[i][0].toLocaleLowerCase(), 'MMMM', i);
            equalTest(tests[i][1].toLocaleLowerCase(), 'MMMM', i);
            equalTest(tests[i][0].toLocaleUpperCase(), 'MMMM', i);
            equalTest(tests[i][1].toLocaleUpperCase(), 'MMMM', i);
        }
    });

    test('format', function (assert) {
        var a = [
                ['dddd, Do MMMM YYYY, h:mm:ss a',      'nedjelja, 14. februar 2010, 3:25:50 pm'],
                ['ddd, hA',                            'ned., 3PM'],
                ['M Mo MM MMMM MMM',                   '2 2. 02 februar feb.'],
                ['YYYY YY',                            '2010 10'],
                ['D Do DD',                            '14 14. 14'],
                ['d do dddd ddd dd',                   '0 0. nedjelja ned. ne'],
                ['DDD DDDo DDDD',                      '45 45. 045'],
                ['w wo ww',                            '7 7. 07'],
                ['h hh',                               '3 03'],
                ['H HH',                               '15 15'],
                ['m mm',                               '25 25'],
                ['s ss',                               '50 50'],
                ['a A',                                'pm PM'],
                ['[the] DDDo [day of the year]',       'the 45. day of the year'],
                ['LTS',                                '15:25:50'],
                ['L',                                  '14. 02. 2010'],
                ['LL',                                 '14. februar 2010'],
                ['LLL',                                '14. februar 2010 15:25'],
                ['LLLL',                               'nedjelja, 14. februar 2010 15:25'],
                ['l',                                  '14. 2. 2010'],
                ['ll',                                 '14. feb. 2010'],
                ['lll',                                '14. feb. 2010 15:25'],
                ['llll',                               'ned., 14. feb. 2010 15:25']
            ],
            b = moment(new Date(2010, 1, 14, 15, 25, 50, 125)),
            i;
        for (i = 0; i < a.length; i++) {
            assert.equal(b.format(a[i][0]), a[i][1], a[i][0] + ' ---> ' + a[i][1]);
        }
    });

    test('format ordinal', function (assert) {
        assert.equal(moment([2011, 0, 1]).format('DDDo'), '1.', '1.');
        assert.equal(moment([2011, 0, 2]).format('DDDo'), '2.', '2.');
        assert.equal(moment([2011, 0, 3]).format('DDDo'), '3.', '3.');
        assert.equal(moment([2011, 0, 4]).format('DDDo'), '4.', '4.');
        assert.equal(moment([2011, 0, 5]).format('DDDo'), '5.', '5.');
        assert.equal(moment([2011, 0, 6]).format('DDDo'), '6.', '6.');
        assert.equal(moment([2011, 0, 7]).format('DDDo'), '7.', '7.');
        assert.equal(moment([2011, 0, 8]).format('DDDo'), '8.', '8.');
        assert.equal(moment([2011, 0, 9]).format('DDDo'), '9.', '9.');
        assert.equal(moment([2011, 0, 10]).format('DDDo'), '10.', '10.');

        assert.equal(moment([2011, 0, 11]).format('DDDo'), '11.', '11.');
        assert.equal(moment([2011, 0, 12]).format('DDDo'), '12.', '12.');
        assert.equal(moment([2011, 0, 13]).format('DDDo'), '13.', '13.');
        assert.equal(moment([2011, 0, 14]).format('DDDo'), '14.', '14.');
        assert.equal(moment([2011, 0, 15]).format('DDDo'), '15.', '15.');
        assert.equal(moment([2011, 0, 16]).format('DDDo'), '16.', '16.');
        assert.equal(moment([2011, 0, 17]).format('DDDo'), '17.', '17.');
        assert.equal(moment([2011, 0, 18]).format('DDDo'), '18.', '18.');
        assert.equal(moment([2011, 0, 19]).format('DDDo'), '19.', '19.');
        assert.equal(moment([2011, 0, 20]).format('DDDo'), '20.', '20.');

        assert.equal(moment([2011, 0, 21]).format('DDDo'), '21.', '21.');
        assert.equal(moment([2011, 0, 22]).format('DDDo'), '22.', '22.');
        assert.equal(moment([2011, 0, 23]).format('DDDo'), '23.', '23.');
        assert.equal(moment([2011, 0, 24]).format('DDDo'), '24.', '24.');
        assert.equal(moment([2011, 0, 25]).format('DDDo'), '25.', '25.');
        assert.equal(moment([2011, 0, 26]).format('DDDo'), '26.', '26.');
        assert.equal(moment([2011, 0, 27]).format('DDDo'), '27.', '27.');
        assert.equal(moment([2011, 0, 28]).format('DDDo'), '28.', '28.');
        assert.equal(moment([2011, 0, 29]).format('DDDo'), '29.', '29.');
        assert.equal(moment([2011, 0, 30]).format('DDDo'), '30.', '30.');

        assert.equal(moment([2011, 0, 31]).format('DDDo'), '31.', '31.');
    });

    test('format month', function (assert) {
        var expected = 'januar jan._februar feb._mart mar._april apr._maj maj._juni jun._juli jul._august aug._septembar sep._oktobar okt._novembar nov._decembar dec.'.split('_'), i;
        for (i = 0; i < expected.length; i++) {
            assert.equal(moment([2011, i, 1]).format('MMMM MMM'), expected[i], expected[i]);
        }
    });

    test('format week', function (assert) {
        var expected = 'nedjelja ned. ne_ponedjeljak pon. po_utorak uto. ut_srijeda sri. sr_Äetvrtak Äet. Äe_petak pet. pe_subota sub. su'.split('_'), i;
        for (i = 0; i < expected.length; i++) {
            assert.equal(moment([2011, 0, 2 + i]).format('dddd ddd dd'), expected[i], expected[i]);
        }
    });

    test('from', function (assert) {
        var start = moment([2007, 1, 28]);
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 44}), true),  'par sekundi', '44 seconds = a few seconds');
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 45}), true),  'jedna minuta',   '45 seconds = a minute');
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 89}), true),  'jedna minuta',   '89 seconds = a minute');
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 90}), true),  '2 minute',     '90 seconds = 2 minutes');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 44}), true),  '44 minuta',     '44 minutes = 44 minutes');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 45}), true),  'jedan sat',      '45 minutes = an hour');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 89}), true),  'jedan sat',      '89 minutes = an hour');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 90}), true),  '2 sata',        '90 minutes = 2 hours');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 5}), true),   '5 sati',         '5 hours = 5 hours');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 21}), true),  '21 sati',        '21 hours = 21 hours');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 22}), true),  'dan',       '22 hours = a day');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 35}), true),  'dan',       '35 hours = a day');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 36}), true),  '2 dana',        '36 hours = 2 days');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 1}), true),   'dan',       '1 day = a day');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 5}), true),   '5 dana',        '5 days = 5 days');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 25}), true),  '25 dana',       '25 days = 25 days');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 26}), true),  'mjesec',     '26 days = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 30}), true),  'mjesec',     '30 days = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 43}), true),  'mjesec',     '43 days = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 46}), true),  '2 mjeseca',     '46 days = 2 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 74}), true),  '2 mjeseca',     '75 days = 2 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 76}), true),  '3 mjeseca',     '76 days = 3 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({M: 1}), true),   'mjesec',     '1 month = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({M: 5}), true),   '5 mjeseci',    '5 months = 5 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 345}), true), 'godinu',     '345 days = a year');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 548}), true), '2 godine',       '548 days = 2 years');
        assert.equal(start.from(moment([2007, 1, 28]).add({y: 1}), true),   'godinu',     '1 year = a year');
        assert.equal(start.from(moment([2007, 1, 28]).add({y: 5}), true),   '5 godina',        '5 years = 5 years');
    });

    test('suffix', function (assert) {
        assert.equal(moment(30000).from(0), 'za par sekundi',  'prefix');
        assert.equal(moment(0).from(30000), 'prije par sekundi', 'prefix');
    });

    test('now from now', function (assert) {
        assert.equal(moment().fromNow(), 'prije par sekundi',  'now from now should display as in the past');
    });

    test('fromNow', function (assert) {
        assert.equal(moment().add({s: 30}).fromNow(), 'za par sekundi', 'in a few seconds');
        assert.equal(moment().add({d: 5}).fromNow(), 'za 5 dana', 'in 5 days');
    });

    test('calendar day', function (assert) {
        var a = moment().hours(12).minutes(0).seconds(0);

        assert.equal(moment(a).calendar(),                   'danas u 12:00',  'today at the same time');
        assert.equal(moment(a).add({m: 25}).calendar(),      'danas u 12:25',  'Now plus 25 min');
        assert.equal(moment(a).add({h: 1}).calendar(),       'danas u 13:00',  'Now plus 1 hour');
        assert.equal(moment(a).add({d: 1}).calendar(),       'sutra u 12:00',  'tomorrow at the same time');
        assert.equal(moment(a).subtract({h: 1}).calendar(),  'danas u 11:00',  'Now minus 1 hour');
        assert.equal(moment(a).subtract({d: 1}).calendar(),  'juÄer u 12:00',  'yesterday at the same time');
    });

    test('calendar next week', function (assert) {
        var i, m;

        function makeFormat(d) {
            switch (d.day()) {
            case 0:
                return '[u] [nedjelju] [u] LT';
            case 3:
                return '[u] [srijedu] [u] LT';
            case 6:
                return '[u] [subotu] [u] LT';
            case 1:
            case 2:
            case 4:
            case 5:
                return '[u] dddd [u] LT';
            }
        }

        for (i = 2; i < 7; i++) {
            m = moment().add({d: i});
            assert.equal(m.calendar(),       m.format(makeFormat(m)),  'Today + ' + i + ' days current time');
            m.hours(0).minutes(0).seconds(0).milliseconds(0);
            assert.equal(m.calendar(),       m.format(makeFormat(m)),  'Today + ' + i + ' days beginning of day');
            m.hours(23).minutes(59).seconds(59).milliseconds(999);
            assert.equal(m.calendar(),       m.format(makeFormat(m)),  'Today + ' + i + ' days end of day');
        }
    });

    test('calendar last week', function (assert) {
        var i, m;

        function makeFormat(d) {
            switch (d.day()) {
            case 0:
            case 3:
                return '[proÅ¡lu] dddd [u] LT';
            case 6:
                return '[proÅ¡le] [subote] [u] LT';
            case 1:
            case 2:
            case 4:
            case 5:
                return '[proÅ¡li] dddd [u] LT';
            }
        }

        for (i = 2; i < 7; i++) {
            m = moment().subtract({d: i});
            assert.equal(m.calendar(),       m.format(makeFormat(m)),  'Today - ' + i + ' days current time');
            m.hours(0).minutes(0).seconds(0).milliseconds(0);
            assert.equal(m.calendar(),       m.format(makeFormat(m)),  'Today - ' + i + ' days beginning of day');
            m.hours(23).minutes(59).seconds(59).milliseconds(999);
            assert.equal(m.calendar(),       m.format(makeFormat(m)),  'Today - ' + i + ' days end of day');
        }
    });

    test('calendar all else', function (assert) {
        var weeksAgo = moment().subtract({w: 1}),
            weeksFromNow = moment().add({w: 1});

        assert.equal(weeksAgo.calendar(),       weeksAgo.format('L'),  '1 week ago');
        assert.equal(weeksFromNow.calendar(),   weeksFromNow.format('L'),  'in 1 week');

        weeksAgo = moment().subtract({w: 2});
        weeksFromNow = moment().add({w: 2});

        assert.equal(weeksAgo.calendar(),       weeksAgo.format('L'),  '2 weeks ago');
        assert.equal(weeksFromNow.calendar(),   weeksFromNow.format('L'),  'in 2 weeks');
    });

    test('weeks year starting sunday formatted', function (assert) {
        assert.equal(moment([2011, 11, 26]).format('w ww wo'), '1 01 1.', 'Dec 26 2011 should be week 1');
        assert.equal(moment([2012,  0,  1]).format('w ww wo'), '1 01 1.', 'Jan  1 2012 should be week 1');
        assert.equal(moment([2012,  0,  2]).format('w ww wo'), '2 02 2.', 'Jan  2 2012 should be week 2');
        assert.equal(moment([2012,  0,  8]).format('w ww wo'), '2 02 2.', 'Jan  8 2012 should be week 2');
        assert.equal(moment([2012,  0,  9]).format('w ww wo'), '3 03 3.', 'Jan  9 2012 should be week 3');
    });

}));

;(function (global, factory) {
   typeof exports === 'object' && typeof module !== 'undefined'
       && typeof require === 'function' ? factory(require('../../moment')) :
   typeof define === 'function' && define.amd ? define(['../../moment'], factory) :
   factory(global.moment)
}(this, function (moment) { 'use strict';

    function each(array, callback) {
        var i;
        for (i = 0; i < array.length; i++) {
            callback(array[i], i, array);
        }
    }

    function objectKeys(obj) {
        if (Object.keys) {
            return Object.keys(obj);
        } else {
            // IE8
            var res = [], i;
            for (i in obj) {
                if (obj.hasOwnProperty(i)) {
                    res.push(i);
                }
            }
            return res;
        }
    }

    // Pick the first defined of two or three arguments.
    function defaults(a, b, c) {
        if (a != null) {
            return a;
        }
        if (b != null) {
            return b;
        }
        return c;
    }

    function defineCommonLocaleTests(locale, options) {
        test('lenient ordinal parsing', function (assert) {
            var i, ordinalStr, testMoment;
            for (i = 1; i <= 31; ++i) {
                ordinalStr = moment([2014, 0, i]).format('YYYY MM Do');
                testMoment = moment(ordinalStr, 'YYYY MM Do');
                assert.equal(testMoment.year(), 2014,
                        'lenient ordinal parsing ' + i + ' year check');
                assert.equal(testMoment.month(), 0,
                        'lenient ordinal parsing ' + i + ' month check');
                assert.equal(testMoment.date(), i,
                        'lenient ordinal parsing ' + i + ' date check');
            }
        });

        test('lenient ordinal parsing of number', function (assert) {
            var i, testMoment;
            for (i = 1; i <= 31; ++i) {
                testMoment = moment('2014 01 ' + i, 'YYYY MM Do');
                assert.equal(testMoment.year(), 2014,
                        'lenient ordinal parsing of number ' + i + ' year check');
                assert.equal(testMoment.month(), 0,
                        'lenient ordinal parsing of number ' + i + ' month check');
                assert.equal(testMoment.date(), i,
                        'lenient ordinal parsing of number ' + i + ' date check');
            }
        });

        test('strict ordinal parsing', function (assert) {
            var i, ordinalStr, testMoment;
            for (i = 1; i <= 31; ++i) {
                ordinalStr = moment([2014, 0, i]).format('YYYY MM Do');
                testMoment = moment(ordinalStr, 'YYYY MM Do', true);
                assert.ok(testMoment.isValid(), 'strict ordinal parsing ' + i);
            }
        });

        test('meridiem invariant', function (assert) {
            var h, m, t1, t2;
            for (h = 0; h < 24; ++h) {
                for (m = 0; m < 60; m += 15) {
                    t1 = moment.utc([2000, 0, 1, h, m]);
                    t2 = moment.utc(t1.format('A h:mm'), 'A h:mm');
                    assert.equal(t2.format('HH:mm'), t1.format('HH:mm'),
                            'meridiem at ' + t1.format('HH:mm'));
                }
            }
        });

        test('date format correctness', function (assert) {
            var data, tokens;
            data = moment.localeData()._longDateFormat;
            tokens = objectKeys(data);
            each(tokens, function (srchToken) {
                // Check each format string to make sure it does not contain any
                // tokens that need to be expanded.
                each(tokens, function (baseToken) {
                    // strip escaped sequences
                    var format = data[baseToken].replace(/(\[[^\]]*\])/g, '');
                    assert.equal(false, !!~format.indexOf(srchToken),
                            'contains ' + srchToken + ' in ' + baseToken);
                });
            });
        });

        test('month parsing correctness', function (assert) {
            var i, m;

            if (locale === 'tr') {
                // I can't fix it :(
                expect(0);
                return;
            }
            function tester(format) {
                var r;
                r = moment(m.format(format), format);
                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format);
                r = moment(m.format(format).toLocaleUpperCase(), format);
                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' upper');
                r = moment(m.format(format).toLocaleLowerCase(), format);
                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' lower');

                r = moment(m.format(format), format, true);
                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' strict');
                r = moment(m.format(format).toLocaleUpperCase(), format, true);
                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' upper strict');
                r = moment(m.format(format).toLocaleLowerCase(), format, true);
                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' lower strict');
            }

            for (i = 0; i < 12; ++i) {
                m = moment([2015, i, 15, 18]);
                tester('MMM');
                tester('MMM.');
                tester('MMMM');
                tester('MMMM.');
            }
        });

        test('weekday parsing correctness', function (assert) {
            var i, m;

            if (locale === 'tr' || locale === 'az') {
                // There is a lower-case letter (Ä±), that converted to upper then
                // lower changes to i
                expect(0);
                return;
            }
            function tester(format) {
                var r, baseMsg = 'weekday ' + m.weekday() + ' fmt ' + format;
                r = moment(m.format(format), format);
                assert.equal(r.weekday(), m.weekday(), baseMsg);
                r = moment(m.format(format).toLocaleUpperCase(), format);
                assert.equal(r.weekday(), m.weekday(), baseMsg + ' upper');
                r = moment(m.format(format).toLocaleLowerCase(), format);
                assert.equal(r.weekday(), m.weekday(), baseMsg + ' lower');

                r = moment(m.format(format), format, true);
                assert.equal(r.weekday(), m.weekday(), baseMsg + ' strict');
                r = moment(m.format(format).toLocaleUpperCase(), format, true);
                assert.equal(r.weekday(), m.weekday(), baseMsg + ' upper strict');
                r = moment(m.format(format).toLocaleLowerCase(), format, true);
                assert.equal(r.weekday(), m.weekday(), baseMsg + ' lower strict');
            }

            for (i = 0; i < 7; ++i) {
                m = moment.utc([2015, i, 15, 18]);
                tester('dd');
                tester('ddd');
                tester('dddd');
            }
        });
    }

    function setupDeprecationHandler(test, moment, scope) {
        test._expectedDeprecations = null;
        test._observedDeprecations = null;
        test._oldSupress = moment.suppressDeprecationWarnings;
        moment.suppressDeprecationWarnings = true;
        test.expectedDeprecations = function () {
            test._expectedDeprecations = arguments;
            test._observedDeprecations = [];
        };
        moment.deprecationHandler = function (name, msg) {
            var deprecationId = matchedDeprecation(name, msg, test._expectedDeprecations);
            if (deprecationId === -1) {
                throw new Error('Unexpected deprecation thrown name=' +
                        name + ' msg=' + msg);
            }
            test._observedDeprecations[deprecationId] = 1;
        };
    }

    function teardownDeprecationHandler(test, moment, scope) {
        moment.suppressDeprecationWarnings = test._oldSupress;

        if (test._expectedDeprecations != null) {
            var missedDeprecations = [];
            each(test._expectedDeprecations, function (deprecationPattern, id) {
                if (test._observedDeprecations[id] !== 1) {
                    missedDeprecations.push(deprecationPattern);
                }
            });
            if (missedDeprecations.length !== 0) {
                throw new Error('Expected deprecation warnings did not happen: ' +
                        missedDeprecations.join(' '));
            }
        }
    }

    function matchedDeprecation(name, msg, deprecations) {
        if (deprecations == null) {
            return -1;
        }
        for (var i = 0; i < deprecations.length; ++i) {
            if (name != null && name === deprecations[i]) {
                return i;
            }
            if (msg != null && msg.substring(0, deprecations[i].length) === deprecations[i]) {
                return i;
            }
        }
        return -1;
    }

    /*global QUnit:false*/

    var test = QUnit.test;

    var expect = QUnit.expect;

    function module (name, lifecycle) {
        QUnit.module(name, {
            setup : function () {
                moment.locale('en');
                moment.createFromInputFallback = function (config) {
                    throw new Error('input not handled by moment: ' + config._i);
                };
                setupDeprecationHandler(test, moment, 'core');
                if (lifecycle && lifecycle.setup) {
                    lifecycle.setup();
                }
            },
            teardown : function () {
                teardownDeprecationHandler(test, moment, 'core');
                if (lifecycle && lifecycle.teardown) {
                    lifecycle.teardown();
                }
            }
        });
    }

    function localeModule (name, lifecycle) {
        QUnit.module('locale:' + name, {
            setup : function () {
                moment.locale(name);
                moment.createFromInputFallback = function (config) {
                    throw new Error('input not handled by moment: ' + config._i);
                };
                setupDeprecationHandler(test, moment, 'locale');
                if (lifecycle && lifecycle.setup) {
                    lifecycle.setup();
                }
            },
            teardown : function () {
                moment.locale('en');
                teardownDeprecationHandler(test, moment, 'locale');
                if (lifecycle && lifecycle.teardown) {
                    lifecycle.teardown();
                }
            }
        });
        defineCommonLocaleTests(name, -1, -1);
    }

    localeModule('ca');

    test('parse', function (assert) {
        var tests = 'gener gen._febrer febr._marÃ§ mar._abril abr._maig mai._juny jun._juliol jul._agost ag._setembre set._octubre oct._novembre nov._desembre des.'.split('_'), i;
        function equalTest(input, mmm, i) {
            assert.equal(moment(input, mmm).month(), i, input + ' should be month ' + (i + 1));
        }
        for (i = 0; i < 12; i++) {
            tests[i] = tests[i].split(' ');
            equalTest(tests[i][0], 'MMM', i);
            equalTest(tests[i][1], 'MMM', i);
            equalTest(tests[i][0], 'MMMM', i);
            equalTest(tests[i][1], 'MMMM', i);
            equalTest(tests[i][0].toLocaleLowerCase(), 'MMMM', i);
            equalTest(tests[i][1].toLocaleLowerCase(), 'MMMM', i);
            equalTest(tests[i][0].toLocaleUpperCase(), 'MMMM', i);
            equalTest(tests[i][1].toLocaleUpperCase(), 'MMMM', i);
        }
    });

    test('format', function (assert) {
        var a = [
                ['dddd, Do MMMM YYYY, h:mm:ss a',      'diumenge, 14Ã¨ febrer 2010, 3:25:50 pm'],
                ['ddd, hA',                            'dg., 3PM'],
                ['M Mo MM MMMM MMM',                   '2 2n 02 febrer febr.'],
                ['YYYY YY',                            '2010 10'],
                ['D Do DD',                            '14 14Ã¨ 14'],
                ['d do dddd ddd dd',                   '0 0Ã¨ diumenge dg. Dg'],
                ['DDD DDDo DDDD',                      '45 45Ã¨ 045'],
                ['w wo ww',                            '6 6a 06'],
                ['h hh',                               '3 03'],
                ['H HH',                               '15 15'],
                ['m mm',                               '25 25'],
                ['s ss',                               '50 50'],
                ['a A',                                'pm PM'],
                ['[the] DDDo [day of the year]',       'the 45Ã¨ day of the year'],
                ['LTS',                                '15:25:50'],
                ['L',                                  '14/02/2010'],
                ['LL',                                 '14 febrer 2010'],
                ['LLL',                                '14 febrer 2010 15:25'],
                ['LLLL',                               'diumenge 14 febrer 2010 15:25'],
                ['l',                                  '14/2/2010'],
                ['ll',                                 '14 febr. 2010'],
                ['lll',                                '14 febr. 2010 15:25'],
                ['llll',                               'dg. 14 febr. 2010 15:25']
            ],
            b = moment(new Date(2010, 1, 14, 15, 25, 50, 125)),
            i;
        for (i = 0; i < a.length; i++) {
            assert.equal(b.format(a[i][0]), a[i][1], a[i][0] + ' ---> ' + a[i][1]);
        }
    });

    test('format ordinal', function (assert) {
        assert.equal(moment([2011, 0, 1]).format('DDDo'), '1r', '1r');
        assert.equal(moment([2011, 0, 2]).format('DDDo'), '2n', '2n');
        assert.equal(moment([2011, 0, 3]).format('DDDo'), '3r', '3r');
        assert.equal(moment([2011, 0, 4]).format('DDDo'), '4t', '4t');
        assert.equal(moment([2011, 0, 5]).format('DDDo'), '5Ã¨', '5Ã¨');
        assert.equal(moment([2011, 0, 6]).format('DDDo'), '6Ã¨', '6Ã¨');
        assert.equal(moment([2011, 0, 7]).format('DDDo'), '7Ã¨', '7Ã¨');
        assert.equal(moment([2011, 0, 8]).format('DDDo'), '8Ã¨', '8Ã¨');
        assert.equal(moment([2011, 0, 9]).format('DDDo'), '9Ã¨', '9Ã¨');
        assert.equal(moment([2011, 0, 10]).format('DDDo'), '10Ã¨', '10Ã¨');

        assert.equal(moment([2011, 0, 11]).format('DDDo'), '11Ã¨', '11Ã¨');
        assert.equal(moment([2011, 0, 12]).format('DDDo'), '12Ã¨', '12Ã¨');
        assert.equal(moment([2011, 0, 13]).format('DDDo'), '13Ã¨', '13Ã¨');
        assert.equal(moment([2011, 0, 14]).format('DDDo'), '14Ã¨', '14Ã¨');
        assert.equal(moment([2011, 0, 15]).format('DDDo'), '15Ã¨', '15Ã¨');
        assert.equal(moment([2011, 0, 16]).format('DDDo'), '16Ã¨', '16Ã¨');
        assert.equal(moment([2011, 0, 17]).format('DDDo'), '17Ã¨', '17Ã¨');
        assert.equal(moment([2011, 0, 18]).format('DDDo'), '18Ã¨', '18Ã¨');
        assert.equal(moment([2011, 0, 19]).format('DDDo'), '19Ã¨', '19Ã¨');
        assert.equal(moment([2011, 0, 20]).format('DDDo'), '20Ã¨', '20Ã¨');

        assert.equal(moment([2011, 0, 21]).format('DDDo'), '21Ã¨', '21Ã¨');
        assert.equal(moment([2011, 0, 22]).format('DDDo'), '22Ã¨', '22Ã¨');
        assert.equal(moment([2011, 0, 23]).format('DDDo'), '23Ã¨', '23Ã¨');
        assert.equal(moment([2011, 0, 24]).format('DDDo'), '24Ã¨', '24Ã¨');
        assert.equal(moment([2011, 0, 25]).format('DDDo'), '25Ã¨', '25Ã¨');
        assert.equal(moment([2011, 0, 26]).format('DDDo'), '26Ã¨', '26Ã¨');
        assert.equal(moment([2011, 0, 27]).format('DDDo'), '27Ã¨', '27Ã¨');
        assert.equal(moment([2011, 0, 28]).format('DDDo'), '28Ã¨', '28Ã¨');
        assert.equal(moment([2011, 0, 29]).format('DDDo'), '29Ã¨', '29Ã¨');
        assert.equal(moment([2011, 0, 30]).format('DDDo'), '30Ã¨', '30Ã¨');

        assert.equal(moment([2011, 0, 31]).format('DDDo'), '31Ã¨', '31Ã¨');
    });

    test('format month', function (assert) {
        var expected = 'gener gen._febrer febr._marÃ§ mar._abril abr._maig mai._juny jun._juliol jul._agost ag._setembre set._octubre oct._novembre nov._desembre des.'.split('_'), i;
        for (i = 0; i < expected.length; i++) {
            assert.equal(moment([2011, i, 1]).format('MMMM MMM'), expected[i], expected[i]);
        }
    });

    test('format week', function (assert) {
        var expected = 'diumenge dg. Dg_dilluns dl. Dl_dimarts dt. Dt_dimecres dc. Dc_dijous dj. Dj_divendres dv. Dv_dissabte ds. Ds'.split('_'), i;
        for (i = 0; i < expected.length; i++) {
            assert.equal(moment([2011, 0, 2 + i]).format('dddd ddd dd'), expected[i], expected[i]);
        }
    });

    test('from', function (assert) {
        var start = moment([2007, 1, 28]);
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 44}), true),  'uns segons', '44 seconds = a few seconds');
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 45}), true),  'un minut',      '45 seconds = a minute');
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 89}), true),  'un minut',      '89 seconds = a minute');
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 90}), true),  '2 minuts',     '90 seconds = 2 minutes');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 44}), true),  '44 minuts',    '44 minutes = 44 minutes');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 45}), true),  'una hora',       '45 minutes = an hour');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 89}), true),  'una hora',       '89 minutes = an hour');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 90}), true),  '2 hores',       '90 minutes = 2 hours');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 5}), true),   '5 hores',       '5 hours = 5 hours');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 21}), true),  '21 hores',      '21 hours = 21 hours');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 22}), true),  'un dia',         '22 hours = a day');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 35}), true),  'un dia',         '35 hours = a day');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 36}), true),  '2 dies',        '36 hours = 2 days');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 1}), true),   'un dia',         '1 day = a day');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 5}), true),   '5 dies',        '5 days = 5 days');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 25}), true),  '25 dies',       '25 days = 25 days');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 26}), true),  'un mes',       '26 days = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 30}), true),  'un mes',       '30 days = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 43}), true),  'un mes',       '43 days = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 46}), true),  '2 mesos',      '46 days = 2 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 74}), true),  '2 mesos',      '75 days = 2 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 76}), true),  '3 mesos',      '76 days = 3 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({M: 1}), true),   'un mes',       '1 month = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({M: 5}), true),   '5 mesos',      '5 months = 5 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 345}), true), 'un any',        '345 days = a year');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 548}), true), '2 anys',       '548 days = 2 years');
        assert.equal(start.from(moment([2007, 1, 28]).add({y: 1}), true),   'un any',        '1 year = a year');
        assert.equal(start.from(moment([2007, 1, 28]).add({y: 5}), true),   '5 anys',       '5 years = 5 years');
    });

    test('suffix', function (assert) {
        assert.equal(moment(30000).from(0), 'en uns segons',  'prefix');
        assert.equal(moment(0).from(30000), 'fa uns segons', 'suffix');
    });

    test('now from now', function (assert) {
        assert.equal(moment().fromNow(), 'fa uns segons',  'now from now should display as in the past');
    });

    test('fromNow', function (assert) {
        assert.equal(moment().add({s: 30}).fromNow(), 'en uns segons', 'en uns segons');
        assert.equal(moment().add({d: 5}).fromNow(), 'en 5 dies', 'en 5 dies');
    });

    test('calendar day', function (assert) {
        var a = moment().hours(12).minutes(0).seconds(0);

        assert.equal(moment(a).calendar(),                       'avui a les 12:00',     'today at the same time');
        assert.equal(moment(a).add({m: 25}).calendar(),          'avui a les 12:25',     'Now plus 25 min');
        assert.equal(moment(a).add({h: 1}).calendar(),           'avui a les 13:00',     'Now plus 1 hour');
        assert.equal(moment(a).add({d: 1}).calendar(),           'demÃ  a les 12:00',     'tomorrow at the same time');
        assert.equal(moment(a).add({d: 1, h : -1}).calendar(),   'demÃ  a les 11:00',     'tomorrow minus 1 hour');
        assert.equal(moment(a).subtract({h: 1}).calendar(),      'avui a les 11:00',     'Now minus 1 hour');
        assert.equal(moment(a).subtract({d: 1}).calendar(),      'ahir a les 12:00',     'yesterday at the same time');
    });

    test('calendar next week', function (assert) {
        var i, m;
        for (i = 2; i < 7; i++) {
            m = moment().add({d: i});
            assert.equal(m.calendar(),       m.format('dddd [a ' + ((m.hours() !== 1) ? 'les' : 'la') + '] LT'),  'Today + ' + i + ' days current time');
            m.hours(0).minutes(0).seconds(0).milliseconds(0);
            assert.equal(m.calendar(),       m.format('dddd [a ' + ((m.hours() !== 1) ? 'les' : 'la') + '] LT'),  'Today + ' + i + ' days beginning of day');
            m.hours(23).minutes(59).seconds(59).milliseconds(999);
            assert.equal(m.calendar(),       m.format('dddd [a ' + ((m.hours() !== 1) ? 'les' : 'la') + '] LT'),  'Today + ' + i + ' days end of day');
        }
    });

    test('calendar last week', function (assert) {
        var i, m;
        for (i = 2; i < 7; i++) {
            m = moment().subtract({d: i});
            assert.equal(m.calendar(),       m.format('[el] dddd [passat a ' + ((m.hours() !== 1) ? 'les' : 'la') + '] LT'),  'Today - ' + i + ' days current time');
            m.hours(0).minutes(0).seconds(0).milliseconds(0);
            assert.equal(m.calendar(),       m.format('[el] dddd [passat a ' + ((m.hours() !== 1) ? 'les' : 'la') + '] LT'),  'Today - ' + i + ' days beginning of day');
            m.hours(23).minutes(59).seconds(59).milliseconds(999);
            assert.equal(m.calendar(),       m.format('[el] dddd [passat a ' + ((m.hours() !== 1) ? 'les' : 'la') + '] LT'),  'Today - ' + i + ' days end of day');
        }
    });

    test('calendar all else', function (assert) {
        var weeksAgo = moment().subtract({w: 1}),
            weeksFromNow = moment().add({w: 1});

        assert.equal(weeksAgo.calendar(),       weeksAgo.format('L'),  '1 week ago');
        assert.equal(weeksFromNow.calendar(),   weeksFromNow.format('L'),  'in 1 week');

        weeksAgo = moment().subtract({w: 2});
        weeksFromNow = moment().add({w: 2});

        assert.equal(weeksAgo.calendar(),       weeksAgo.format('L'),  '2 weeks ago');
        assert.equal(weeksFromNow.calendar(),   weeksFromNow.format('L'),  'in 2 weeks');
    });

    test('weeks year starting sunday formatted', function (assert) {
        assert.equal(moment([2012, 0,  1]).format('w ww wo'), '52 52 52a', 'Jan  1 2012 should be week 52');
        assert.equal(moment([2012, 0,  2]).format('w ww wo'),   '1 01 1a', 'Jan  2 2012 should be week 1');
        assert.equal(moment([2012, 0,  8]).format('w ww wo'),   '1 01 1a', 'Jan  8 2012 should be week 1');
        assert.equal(moment([2012, 0,  9]).format('w ww wo'),   '2 02 2a', 'Jan  9 2012 should be week 2');
        assert.equal(moment([2012, 0, 15]).format('w ww wo'),   '2 02 2a', 'Jan 15 2012 should be week 2');
    });

}));

;(function (global, factory) {
   typeof exports === 'object' && typeof module !== 'undefined'
       && typeof require === 'function' ? factory(require('../../moment')) :
   typeof define === 'function' && define.amd ? define(['../../moment'], factory) :
   factory(global.moment)
}(this, function (moment) { 'use strict';

    function each(array, callback) {
        var i;
        for (i = 0; i < array.length; i++) {
            callback(array[i], i, array);
        }
    }

    function objectKeys(obj) {
        if (Object.keys) {
            return Object.keys(obj);
        } else {
            // IE8
            var res = [], i;
            for (i in obj) {
                if (obj.hasOwnProperty(i)) {
                    res.push(i);
                }
            }
            return res;
        }
    }

    // Pick the first defined of two or three arguments.
    function defaults(a, b, c) {
        if (a != null) {
            return a;
        }
        if (b != null) {
            return b;
        }
        return c;
    }

    function defineCommonLocaleTests(locale, options) {
        test('lenient ordinal parsing', function (assert) {
            var i, ordinalStr, testMoment;
            for (i = 1; i <= 31; ++i) {
                ordinalStr = moment([2014, 0, i]).format('YYYY MM Do');
                testMoment = moment(ordinalStr, 'YYYY MM Do');
                assert.equal(testMoment.year(), 2014,
                        'lenient ordinal parsing ' + i + ' year check');
                assert.equal(testMoment.month(), 0,
                        'lenient ordinal parsing ' + i + ' month check');
                assert.equal(testMoment.date(), i,
                        'lenient ordinal parsing ' + i + ' date check');
            }
        });

        test('lenient ordinal parsing of number', function (assert) {
            var i, testMoment;
            for (i = 1; i <= 31; ++i) {
                testMoment = moment('2014 01 ' + i, 'YYYY MM Do');
                assert.equal(testMoment.year(), 2014,
                        'lenient ordinal parsing of number ' + i + ' year check');
                assert.equal(testMoment.month(), 0,
                        'lenient ordinal parsing of number ' + i + ' month check');
                assert.equal(testMoment.date(), i,
                        'lenient ordinal parsing of number ' + i + ' date check');
            }
        });

        test('strict ordinal parsing', function (assert) {
            var i, ordinalStr, testMoment;
            for (i = 1; i <= 31; ++i) {
                ordinalStr = moment([2014, 0, i]).format('YYYY MM Do');
                testMoment = moment(ordinalStr, 'YYYY MM Do', true);
                assert.ok(testMoment.isValid(), 'strict ordinal parsing ' + i);
            }
        });

        test('meridiem invariant', function (assert) {
            var h, m, t1, t2;
            for (h = 0; h < 24; ++h) {
                for (m = 0; m < 60; m += 15) {
                    t1 = moment.utc([2000, 0, 1, h, m]);
                    t2 = moment.utc(t1.format('A h:mm'), 'A h:mm');
                    assert.equal(t2.format('HH:mm'), t1.format('HH:mm'),
                            'meridiem at ' + t1.format('HH:mm'));
                }
            }
        });

        test('date format correctness', function (assert) {
            var data, tokens;
            data = moment.localeData()._longDateFormat;
            tokens = objectKeys(data);
            each(tokens, function (srchToken) {
                // Check each format string to make sure it does not contain any
                // tokens that need to be expanded.
                each(tokens, function (baseToken) {
                    // strip escaped sequences
                    var format = data[baseToken].replace(/(\[[^\]]*\])/g, '');
                    assert.equal(false, !!~format.indexOf(srchToken),
                            'contains ' + srchToken + ' in ' + baseToken);
                });
            });
        });

        test('month parsing correctness', function (assert) {
            var i, m;

            if (locale === 'tr') {
                // I can't fix it :(
                expect(0);
                return;
            }
            function tester(format) {
                var r;
                r = moment(m.format(format), format);
                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format);
                r = moment(m.format(format).toLocaleUpperCase(), format);
                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' upper');
                r = moment(m.format(format).toLocaleLowerCase(), format);
                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' lower');

                r = moment(m.format(format), format, true);
                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' strict');
                r = moment(m.format(format).toLocaleUpperCase(), format, true);
                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' upper strict');
                r = moment(m.format(format).toLocaleLowerCase(), format, true);
                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' lower strict');
            }

            for (i = 0; i < 12; ++i) {
                m = moment([2015, i, 15, 18]);
                tester('MMM');
                tester('MMM.');
                tester('MMMM');
                tester('MMMM.');
            }
        });

        test('weekday parsing correctness', function (assert) {
            var i, m;

            if (locale === 'tr' || locale === 'az') {
                // There is a lower-case letter (Ä±), that converted to upper then
                // lower changes to i
                expect(0);
                return;
            }
            function tester(format) {
                var r, baseMsg = 'weekday ' + m.weekday() + ' fmt ' + format;
                r = moment(m.format(format), format);
                assert.equal(r.weekday(), m.weekday(), baseMsg);
                r = moment(m.format(format).toLocaleUpperCase(), format);
                assert.equal(r.weekday(), m.weekday(), baseMsg + ' upper');
                r = moment(m.format(format).toLocaleLowerCase(), format);
                assert.equal(r.weekday(), m.weekday(), baseMsg + ' lower');

                r = moment(m.format(format), format, true);
                assert.equal(r.weekday(), m.weekday(), baseMsg + ' strict');
                r = moment(m.format(format).toLocaleUpperCase(), format, true);
                assert.equal(r.weekday(), m.weekday(), baseMsg + ' upper strict');
                r = moment(m.format(format).toLocaleLowerCase(), format, true);
                assert.equal(r.weekday(), m.weekday(), baseMsg + ' lower strict');
            }

            for (i = 0; i < 7; ++i) {
                m = moment.utc([2015, i, 15, 18]);
                tester('dd');
                tester('ddd');
                tester('dddd');
            }
        });
    }

    function setupDeprecationHandler(test, moment, scope) {
        test._expectedDeprecations = null;
        test._observedDeprecations = null;
        test._oldSupress = moment.suppressDeprecationWarnings;
        moment.suppressDeprecationWarnings = true;
        test.expectedDeprecations = function () {
            test._expectedDeprecations = arguments;
            test._observedDeprecations = [];
        };
        moment.deprecationHandler = function (name, msg) {
            var deprecationId = matchedDeprecation(name, msg, test._expectedDeprecations);
            if (deprecationId === -1) {
                throw new Error('Unexpected deprecation thrown name=' +
                        name + ' msg=' + msg);
            }
            test._observedDeprecations[deprecationId] = 1;
        };
    }

    function teardownDeprecationHandler(test, moment, scope) {
        moment.suppressDeprecationWarnings = test._oldSupress;

        if (test._expectedDeprecations != null) {
            var missedDeprecations = [];
            each(test._expectedDeprecations, function (deprecationPattern, id) {
                if (test._observedDeprecations[id] !== 1) {
                    missedDeprecations.push(deprecationPattern);
                }
            });
            if (missedDeprecations.length !== 0) {
                throw new Error('Expected deprecation warnings did not happen: ' +
                        missedDeprecations.join(' '));
            }
        }
    }

    function matchedDeprecation(name, msg, deprecations) {
        if (deprecations == null) {
            return -1;
        }
        for (var i = 0; i < deprecations.length; ++i) {
            if (name != null && name === deprecations[i]) {
                return i;
            }
            if (msg != null && msg.substring(0, deprecations[i].length) === deprecations[i]) {
                return i;
            }
        }
        return -1;
    }

    /*global QUnit:false*/

    var test = QUnit.test;

    var expect = QUnit.expect;

    function module (name, lifecycle) {
        QUnit.module(name, {
            setup : function () {
                moment.locale('en');
                moment.createFromInputFallback = function (config) {
                    throw new Error('input not handled by moment: ' + config._i);
                };
                setupDeprecationHandler(test, moment, 'core');
                if (lifecycle && lifecycle.setup) {
                    lifecycle.setup();
                }
            },
            teardown : function () {
                teardownDeprecationHandler(test, moment, 'core');
                if (lifecycle && lifecycle.teardown) {
                    lifecycle.teardown();
                }
            }
        });
    }

    function localeModule (name, lifecycle) {
        QUnit.module('locale:' + name, {
            setup : function () {
                moment.locale(name);
                moment.createFromInputFallback = function (config) {
                    throw new Error('input not handled by moment: ' + config._i);
                };
                setupDeprecationHandler(test, moment, 'locale');
                if (lifecycle && lifecycle.setup) {
                    lifecycle.setup();
                }
            },
            teardown : function () {
                moment.locale('en');
                teardownDeprecationHandler(test, moment, 'locale');
                if (lifecycle && lifecycle.teardown) {
                    lifecycle.teardown();
                }
            }
        });
        defineCommonLocaleTests(name, -1, -1);
    }

    localeModule('cs');

    test('parse', function (assert) {
        var tests = 'leden led_Ãºnor Ãºno_bÅezen bÅe_duben dub_kvÄten kvÄ_Äerven Ävn_Äervenec Ävc_srpen srp_zÃ¡ÅÃ­ zÃ¡Å_ÅÃ­jen ÅÃ­j_listopad lis_prosinec pro'.split('_'), i;
        function equalTest(input, mmm, monthIndex) {
            assert.equal(moment(input, mmm).month(), monthIndex, input + ' ' + mmm + ' should be month ' + (monthIndex + 1));
        }
        function equalTestStrict(input, mmm, monthIndex) {
            assert.equal(moment(input, mmm, true).month(), monthIndex, input + ' ' + mmm + ' should be strict month ' + (monthIndex + 1));
        }
        for (i = 0; i < 12; i++) {
            tests[i] = tests[i].split(' ');
            equalTest(tests[i][0], 'MMM', i);
            equalTest(tests[i][1], 'MMM', i);
            equalTest(tests[i][0], 'MMMM', i);
            equalTest(tests[i][1], 'MMMM', i);
            equalTest(tests[i][0].toLocaleLowerCase(), 'MMMM', i);
            equalTest(tests[i][1].toLocaleLowerCase(), 'MMMM', i);
            equalTest(tests[i][0].toLocaleUpperCase(), 'MMMM', i);
            equalTest(tests[i][1].toLocaleUpperCase(), 'MMMM', i);

            equalTestStrict(tests[i][1], 'MMM', i);
            equalTestStrict(tests[i][0], 'MMMM', i);
            equalTestStrict(tests[i][1].toLocaleLowerCase(), 'MMM', i);
            equalTestStrict(tests[i][1].toLocaleUpperCase(), 'MMM', i);
            equalTestStrict(tests[i][0].toLocaleLowerCase(), 'MMMM', i);
            equalTestStrict(tests[i][0].toLocaleUpperCase(), 'MMMM', i);
        }
    });

    test('format', function (assert) {
        var a = [
                ['dddd, MMMM Do YYYY, h:mm:ss',  'nedÄle, Ãºnor 14. 2010, 3:25:50'],
                ['ddd, h',                       'ne, 3'],
                ['M Mo MM MMMM MMM',             '2 2. 02 Ãºnor Ãºno'],
                ['YYYY YY',                      '2010 10'],
                ['D Do DD',                      '14 14. 14'],
                ['d do dddd ddd dd',             '0 0. nedÄle ne ne'],
                ['DDD DDDo DDDD',                '45 45. 045'],
                ['w wo ww',                      '6 6. 06'],
                ['h hh',                         '3 03'],
                ['H HH',                         '15 15'],
                ['m mm',                         '25 25'],
                ['s ss',                         '50 50'],
                ['a A',                          'pm PM'],
                ['DDDo [den v roce]',            '45. den v roce'],
                ['LTS',                          '15:25:50'],
                ['L',                            '14.02.2010'],
                ['LL',                           '14. Ãºnor 2010'],
                ['LLL',                          '14. Ãºnor 2010 15:25'],
                ['LLLL',                         'nedÄle 14. Ãºnor 2010 15:25'],
                ['l',                            '14.2.2010'],
                ['ll',                           '14. Ãºno 2010'],
                ['lll',                          '14. Ãºno 2010 15:25'],
                ['llll',                         'ne 14. Ãºno 2010 15:25']
            ],
            b = moment(new Date(2010, 1, 14, 15, 25, 50, 125)),
            i;
        for (i = 0; i < a.length; i++) {
            assert.equal(b.format(a[i][0]), a[i][1], a[i][0] + ' ---> ' + a[i][1]);
        }
    });

    test('format ordinal', function (assert) {
        assert.equal(moment([2011, 0, 1]).format('DDDo'), '1.', '1.');
        assert.equal(moment([2011, 0, 2]).format('DDDo'), '2.', '2.');
        assert.equal(moment([2011, 0, 3]).format('DDDo'), '3.', '3.');
        assert.equal(moment([2011, 0, 4]).format('DDDo'), '4.', '4.');
        assert.equal(moment([2011, 0, 5]).format('DDDo'), '5.', '5.');
        assert.equal(moment([2011, 0, 6]).format('DDDo'), '6.', '6.');
        assert.equal(moment([2011, 0, 7]).format('DDDo'), '7.', '7.');
        assert.equal(moment([2011, 0, 8]).format('DDDo'), '8.', '8.');
        assert.equal(moment([2011, 0, 9]).format('DDDo'), '9.', '9.');
        assert.equal(moment([2011, 0, 10]).format('DDDo'), '10.', '10.');

        assert.equal(moment([2011, 0, 11]).format('DDDo'), '11.', '11.');
        assert.equal(moment([2011, 0, 12]).format('DDDo'), '12.', '12.');
        assert.equal(moment([2011, 0, 13]).format('DDDo'), '13.', '13.');
        assert.equal(moment([2011, 0, 14]).format('DDDo'), '14.', '14.');
        assert.equal(moment([2011, 0, 15]).format('DDDo'), '15.', '15.');
        assert.equal(moment([2011, 0, 16]).format('DDDo'), '16.', '16.');
        assert.equal(moment([2011, 0, 17]).format('DDDo'), '17.', '17.');
        assert.equal(moment([2011, 0, 18]).format('DDDo'), '18.', '18.');
        assert.equal(moment([2011, 0, 19]).format('DDDo'), '19.', '19.');
        assert.equal(moment([2011, 0, 20]).format('DDDo'), '20.', '20.');

        assert.equal(moment([2011, 0, 21]).format('DDDo'), '21.', '21.');
        assert.equal(moment([2011, 0, 22]).format('DDDo'), '22.', '22.');
        assert.equal(moment([2011, 0, 23]).format('DDDo'), '23.', '23.');
        assert.equal(moment([2011, 0, 24]).format('DDDo'), '24.', '24.');
        assert.equal(moment([2011, 0, 25]).format('DDDo'), '25.', '25.');
        assert.equal(moment([2011, 0, 26]).format('DDDo'), '26.', '26.');
        assert.equal(moment([2011, 0, 27]).format('DDDo'), '27.', '27.');
        assert.equal(moment([2011, 0, 28]).format('DDDo'), '28.', '28.');
        assert.equal(moment([2011, 0, 29]).format('DDDo'), '29.', '29.');
        assert.equal(moment([2011, 0, 30]).format('DDDo'), '30.', '30.');

        assert.equal(moment([2011, 0, 31]).format('DDDo'), '31.', '31.');
    });

    test('format month', function (assert) {
        var expected = 'leden led_Ãºnor Ãºno_bÅezen bÅe_duben dub_kvÄten kvÄ_Äerven Ävn_Äervenec Ävc_srpen srp_zÃ¡ÅÃ­ zÃ¡Å_ÅÃ­jen ÅÃ­j_listopad lis_prosinec pro'.split('_'), i;
        for (i = 0; i < expected.length; i++) {
            assert.equal(moment([2011, i, 1]).format('MMMM MMM'), expected[i], expected[i]);
        }
    });

    test('format week', function (assert) {
        var expected = 'nedÄle ne ne_pondÄlÃ­ po po_ÃºterÃ½ Ãºt Ãºt_stÅeda st st_Ätvrtek Ät Ät_pÃ¡tek pÃ¡ pÃ¡_sobota so so'.split('_'), i;
        for (i = 0; i < expected.length; i++) {
            assert.equal(moment([2011, 0, 2 + i]).format('dddd ddd dd'), expected[i], expected[i]);
        }
    });

    test('from', function (assert) {
        var start = moment([2007, 1, 28]);
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 44}), true),  'pÃ¡r sekund',  '44 seconds = a few seconds');
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 45}), true),  'minuta',        '45 seconds = a minute');
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 89}), true),  'minuta',        '89 seconds = a minute');
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 90}), true),  '2 minuty',      '90 seconds = 2 minutes');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 44}), true),  '44 minut',     '44 minutes = 44 minutes');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 45}), true),  'hodina',       '45 minutes = an hour');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 89}), true),  'hodina',       '89 minutes = an hour');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 90}), true),  '2 hodiny',     '90 minutes = 2 hours');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 5}), true),   '5 hodin',      '5 hours = 5 hours');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 21}), true),  '21 hodin',     '21 hours = 21 hours');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 22}), true),  'den',       '22 hours = a day');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 35}), true),  'den',       '35 hours = a day');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 36}), true),  '2 dny',         '36 hours = 2 days');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 1}), true),   'den',       '1 day = a day');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 5}), true),   '5 dnÃ­',         '5 days = 5 days');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 25}), true),  '25 dnÃ­',        '25 days = 25 days');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 26}), true),  'mÄsÃ­c',       '26 days = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 30}), true),  'mÄsÃ­c',       '30 days = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 43}), true),  'mÄsÃ­c',       '43 days = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 46}), true),  '2 mÄsÃ­ce',    '46 days = 2 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 74}), true),  '2 mÄsÃ­ce',    '75 days = 2 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 76}), true),  '3 mÄsÃ­ce',    '76 days = 3 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({M: 1}), true),   'mÄsÃ­c',       '1 month = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({M: 5}), true),   '5 mÄsÃ­cÅ¯',    '5 months = 5 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 345}), true), 'rok',           '345 days = a year');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 548}), true), '2 roky',        '548 days = 2 years');
        assert.equal(start.from(moment([2007, 1, 28]).add({y: 1}), true),   'rok',           '1 year = a year');
        assert.equal(start.from(moment([2007, 1, 28]).add({y: 5}), true),   '5 let',         '5 years = 5 years');
    });

    test('suffix', function (assert) {
        assert.equal(moment(30000).from(0), 'za pÃ¡r sekund',  'prefix');
        assert.equal(moment(0).from(30000), 'pÅed pÃ¡r sekundami', 'suffix');
    });

    test('now from now', function (assert) {
        assert.equal(moment().fromNow(), 'pÅed pÃ¡r sekundami',  'now from now should display as in the past');
    });

    test('fromNow (future)', function (assert) {
        assert.equal(moment().add({s: 30}).fromNow(), 'za pÃ¡r sekund', 'in a few seconds');
        assert.equal(moment().add({m: 1}).fromNow(), 'za minutu', 'in a minute');
        assert.equal(moment().add({m: 3}).fromNow(), 'za 3 minuty', 'in 3 minutes');
        assert.equal(moment().add({m: 10}).fromNow(), 'za 10 minut', 'in 10 minutes');
        assert.equal(moment().add({h: 1}).fromNow(), 'za hodinu', 'in an hour');
        assert.equal(moment().add({h: 3}).fromNow(), 'za 3 hodiny', 'in 3 hours');
        assert.equal(moment().add({h: 10}).fromNow(), 'za 10 hodin', 'in 10 hours');
        assert.equal(moment().add({d: 1}).fromNow(), 'za den', 'in a day');
        assert.equal(moment().add({d: 3}).fromNow(), 'za 3 dny', 'in 3 days');
        assert.equal(moment().add({d: 10}).fromNow(), 'za 10 dnÃ­', 'in 10 days');
        assert.equal(moment().add({M: 1}).fromNow(), 'za mÄsÃ­c', 'in a month');
        assert.equal(moment().add({M: 3}).fromNow(), 'za 3 mÄsÃ­ce', 'in 3 months');
        assert.equal(moment().add({M: 10}).fromNow(), 'za 10 mÄsÃ­cÅ¯', 'in 10 months');
        assert.equal(moment().add({y: 1}).fromNow(), 'za rok', 'in a year');
        assert.equal(moment().add({y: 3}).fromNow(), 'za 3 roky', 'in 3 years');
        assert.equal(moment().add({y: 10}).fromNow(), 'za 10 let', 'in 10 years');
    });

    test('fromNow (past)', function (assert) {
        assert.equal(moment().subtract({s: 30}).fromNow(), 'pÅed pÃ¡r sekundami', 'a few seconds ago');
        assert.equal(moment().subtract({m: 1}).fromNow(), 'pÅed minutou', 'a minute ago');
        assert.equal(moment().subtract({m: 3}).fromNow(), 'pÅed 3 minutami', '3 minutes ago');
        assert.equal(moment().subtract({m: 10}).fromNow(), 'pÅed 10 minutami', '10 minutes ago');
        assert.equal(moment().subtract({h: 1}).fromNow(), 'pÅed hodinou', 'an hour ago');
        assert.equal(moment().subtract({h: 3}).fromNow(), 'pÅed 3 hodinami', '3 hours ago');
        assert.equal(moment().subtract({h: 10}).fromNow(), 'pÅed 10 hodinami', '10 hours ago');
        assert.equal(moment().subtract({d: 1}).fromNow(), 'pÅed dnem', 'a day ago');
        assert.equal(moment().subtract({d: 3}).fromNow(), 'pÅed 3 dny', '3 days ago');
        assert.equal(moment().subtract({d: 10}).fromNow(), 'pÅed 10 dny', '10 days ago');
        assert.equal(moment().subtract({M: 1}).fromNow(), 'pÅed mÄsÃ­cem', 'a month ago');
        assert.equal(moment().subtract({M: 3}).fromNow(), 'pÅed 3 mÄsÃ­ci', '3 months ago');
        assert.equal(moment().subtract({M: 10}).fromNow(), 'pÅed 10 mÄsÃ­ci', '10 months ago');
        assert.equal(moment().subtract({y: 1}).fromNow(), 'pÅed rokem', 'a year ago');
        assert.equal(moment().subtract({y: 3}).fromNow(), 'pÅed 3 lety', '3 years ago');
        assert.equal(moment().subtract({y: 10}).fromNow(), 'pÅed 10 lety', '10 years ago');
    });

    test('calendar day', function (assert) {
        var a = moment().hours(12).minutes(0).seconds(0);

        assert.equal(moment(a).calendar(),                   'dnes v 12:00',     'today at the same time');
        assert.equal(moment(a).add({m: 25}).calendar(),      'dnes v 12:25',     'Now plus 25 min');
        assert.equal(moment(a).add({h: 1}).calendar(),       'dnes v 13:00',     'Now plus 1 hour');
        assert.equal(moment(a).add({d: 1}).calendar(),       'zÃ­tra v 12:00',    'tomorrow at the same time');
        assert.equal(moment(a).subtract({h: 1}).calendar(),  'dnes v 11:00',     'Now minus 1 hour');
        assert.equal(moment(a).subtract({d: 1}).calendar(),  'vÄera v 12:00',    'yesterday at the same time');
    });

    test('calendar next week', function (assert) {
        var i, m, nextDay;
        for (i = 2; i < 7; i++) {
            m = moment().add({d: i});
            nextDay = '';
            switch (m.day()) {
            case 0:
                nextDay = 'v nedÄli';
                break;
            case 1:
                nextDay = 'v pondÄlÃ­';
                break;
            case 2:
                nextDay = 'v ÃºterÃ½';
                break;
            case 3:
                nextDay = 've stÅedu';
                break;
            case 4:
                nextDay = 've Ätvrtek';
                break;
            case 5:
                nextDay = 'v pÃ¡tek';
                break;
            case 6:
                nextDay = 'v sobotu';
                break;
            }
            assert.equal(m.calendar(),       m.format('[' + nextDay + '] [v] LT'),  'Today + ' + i + ' days current time');
            m.hours(0).minutes(0).seconds(0).milliseconds(0);
            assert.equal(m.calendar(),       m.format('[' + nextDay + '] [v] LT'),  'Today + ' + i + ' days beginning of day');
            m.hours(23).minutes(59).seconds(59).milliseconds(999);
            assert.equal(m.calendar(),       m.format('[' + nextDay + '] [v] LT'),  'Today + ' + i + ' days end of day');
        }
    });

    test('calendar last week', function (assert) {
        var i, m, lastDay;
        for (i = 2; i < 7; i++) {
            m = moment().subtract({d: i});
            lastDay = '';
            switch (m.day()) {
            case 0:
                lastDay = 'minulou nedÄli';
                break;
            case 1:
                lastDay = 'minulÃ© pondÄlÃ­';
                break;
            case 2:
                lastDay = 'minulÃ© ÃºterÃ½';
                break;
            case 3:
                lastDay = 'minulou stÅedu';
                break;
            case 4:
                lastDay = 'minulÃ½ Ätvrtek';
                break;
            case 5:
                lastDay = 'minulÃ½ pÃ¡tek';
                break;
            case 6:
                lastDay = 'minulou sobotu';
                break;
            }
            assert.equal(m.calendar(),       m.format('[' + lastDay + '] [v] LT'),  'Today - ' + i + ' days current time');
            m.hours(0).minutes(0).seconds(0).milliseconds(0);
            assert.equal(m.calendar(),       m.format('[' + lastDay + '] [v] LT'),  'Today - ' + i + ' days beginning of day');
            m.hours(23).minutes(59).seconds(59).milliseconds(999);
            assert.equal(m.calendar(),       m.format('[' + lastDay + '] [v] LT'),  'Today - ' + i + ' days end of day');
        }
    });

    test('calendar all else', function (assert) {
        var weeksAgo = moment().subtract({w: 1}),
            weeksFromNow = moment().add({w: 1});

        assert.equal(weeksAgo.calendar(),       weeksAgo.format('L'),  '1 week ago');
        assert.equal(weeksFromNow.calendar(),   weeksFromNow.format('L'),  'in 1 week');

        weeksAgo = moment().subtract({w: 2});
        weeksFromNow = moment().add({w: 2});

        assert.equal(weeksAgo.calendar(),       weeksAgo.format('L'),  '2 weeks ago');
        assert.equal(weeksFromNow.calendar(),   weeksFromNow.format('L'),  'in 2 weeks');
    });

    test('humanize duration', function (assert) {
        assert.equal(moment.duration(1, 'minutes').humanize(), 'minuta', 'a minute (future)');
        assert.equal(moment.duration(1, 'minutes').humanize(true), 'za minutu', 'in a minute');
        assert.equal(moment.duration(-1, 'minutes').humanize(), 'minuta', 'a minute (past)');
        assert.equal(moment.duration(-1, 'minutes').humanize(true), 'pÅed minutou', 'a minute ago');
    });

    test('weeks year starting sunday formatted', function (assert) {
        assert.equal(moment([2012, 0,  1]).format('w ww wo'), '52 52 52.', 'Jan  1 2012 should be week 52');
        assert.equal(moment([2012, 0,  2]).format('w ww wo'),   '1 01 1.', 'Jan  2 2012 should be week 1');
        assert.equal(moment([2012, 0,  8]).format('w ww wo'),   '1 01 1.', 'Jan  8 2012 should be week 1');
        assert.equal(moment([2012, 0,  9]).format('w ww wo'),   '2 02 2.', 'Jan  9 2012 should be week 2');
        assert.equal(moment([2012, 0, 15]).format('w ww wo'),   '2 02 2.', 'Jan 15 2012 should be week 2');
    });

}));

;(function (global, factory) {
   typeof exports === 'object' && typeof module !== 'undefined'
       && typeof require === 'function' ? factory(require('../../moment')) :
   typeof define === 'function' && define.amd ? define(['../../moment'], factory) :
   factory(global.moment)
}(this, function (moment) { 'use strict';

    function each(array, callback) {
        var i;
        for (i = 0; i < array.length; i++) {
            callback(array[i], i, array);
        }
    }

    function objectKeys(obj) {
        if (Object.keys) {
            return Object.keys(obj);
        } else {
            // IE8
            var res = [], i;
            for (i in obj) {
                if (obj.hasOwnProperty(i)) {
                    res.push(i);
                }
            }
            return res;
        }
    }

    // Pick the first defined of two or three arguments.
    function defaults(a, b, c) {
        if (a != null) {
            return a;
        }
        if (b != null) {
            return b;
        }
        return c;
    }

    function defineCommonLocaleTests(locale, options) {
        test('lenient ordinal parsing', function (assert) {
            var i, ordinalStr, testMoment;
            for (i = 1; i <= 31; ++i) {
                ordinalStr = moment([2014, 0, i]).format('YYYY MM Do');
                testMoment = moment(ordinalStr, 'YYYY MM Do');
                assert.equal(testMoment.year(), 2014,
                        'lenient ordinal parsing ' + i + ' year check');
                assert.equal(testMoment.month(), 0,
                        'lenient ordinal parsing ' + i + ' month check');
                assert.equal(testMoment.date(), i,
                        'lenient ordinal parsing ' + i + ' date check');
            }
        });

        test('lenient ordinal parsing of number', function (assert) {
            var i, testMoment;
            for (i = 1; i <= 31; ++i) {
                testMoment = moment('2014 01 ' + i, 'YYYY MM Do');
                assert.equal(testMoment.year(), 2014,
                        'lenient ordinal parsing of number ' + i + ' year check');
                assert.equal(testMoment.month(), 0,
                        'lenient ordinal parsing of number ' + i + ' month check');
                assert.equal(testMoment.date(), i,
                        'lenient ordinal parsing of number ' + i + ' date check');
            }
        });

        test('strict ordinal parsing', function (assert) {
            var i, ordinalStr, testMoment;
            for (i = 1; i <= 31; ++i) {
                ordinalStr = moment([2014, 0, i]).format('YYYY MM Do');
                testMoment = moment(ordinalStr, 'YYYY MM Do', true);
                assert.ok(testMoment.isValid(), 'strict ordinal parsing ' + i);
            }
        });

        test('meridiem invariant', function (assert) {
            var h, m, t1, t2;
            for (h = 0; h < 24; ++h) {
                for (m = 0; m < 60; m += 15) {
                    t1 = moment.utc([2000, 0, 1, h, m]);
                    t2 = moment.utc(t1.format('A h:mm'), 'A h:mm');
                    assert.equal(t2.format('HH:mm'), t1.format('HH:mm'),
                            'meridiem at ' + t1.format('HH:mm'));
                }
            }
        });

        test('date format correctness', function (assert) {
            var data, tokens;
            data = moment.localeData()._longDateFormat;
            tokens = objectKeys(data);
            each(tokens, function (srchToken) {
                // Check each format string to make sure it does not contain any
                // tokens that need to be expanded.
                each(tokens, function (baseToken) {
                    // strip escaped sequences
                    var format = data[baseToken].replace(/(\[[^\]]*\])/g, '');
                    assert.equal(false, !!~format.indexOf(srchToken),
                            'contains ' + srchToken + ' in ' + baseToken);
                });
            });
        });

        test('month parsing correctness', function (assert) {
            var i, m;

            if (locale === 'tr') {
                // I can't fix it :(
                expect(0);
                return;
            }
            function tester(format) {
                var r;
                r = moment(m.format(format), format);
                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format);
                r = moment(m.format(format).toLocaleUpperCase(), format);
                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' upper');
                r = moment(m.format(format).toLocaleLowerCase(), format);
                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' lower');

                r = moment(m.format(format), format, true);
                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' strict');
                r = moment(m.format(format).toLocaleUpperCase(), format, true);
                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' upper strict');
                r = moment(m.format(format).toLocaleLowerCase(), format, true);
                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' lower strict');
            }

            for (i = 0; i < 12; ++i) {
                m = moment([2015, i, 15, 18]);
                tester('MMM');
                tester('MMM.');
                tester('MMMM');
                tester('MMMM.');
            }
        });

        test('weekday parsing correctness', function (assert) {
            var i, m;

            if (locale === 'tr' || locale === 'az') {
                // There is a lower-case letter (Ä±), that converted to upper then
                // lower changes to i
                expect(0);
                return;
            }
            function tester(format) {
                var r, baseMsg = 'weekday ' + m.weekday() + ' fmt ' + format;
                r = moment(m.format(format), format);
                assert.equal(r.weekday(), m.weekday(), baseMsg);
                r = moment(m.format(format).toLocaleUpperCase(), format);
                assert.equal(r.weekday(), m.weekday(), baseMsg + ' upper');
                r = moment(m.format(format).toLocaleLowerCase(), format);
                assert.equal(r.weekday(), m.weekday(), baseMsg + ' lower');

                r = moment(m.format(format), format, true);
                assert.equal(r.weekday(), m.weekday(), baseMsg + ' strict');
                r = moment(m.format(format).toLocaleUpperCase(), format, true);
                assert.equal(r.weekday(), m.weekday(), baseMsg + ' upper strict');
                r = moment(m.format(format).toLocaleLowerCase(), format, true);
                assert.equal(r.weekday(), m.weekday(), baseMsg + ' lower strict');
            }

            for (i = 0; i < 7; ++i) {
                m = moment.utc([2015, i, 15, 18]);
                tester('dd');
                tester('ddd');
                tester('dddd');
            }
        });
    }

    function setupDeprecationHandler(test, moment, scope) {
        test._expectedDeprecations = null;
        test._observedDeprecations = null;
        test._oldSupress = moment.suppressDeprecationWarnings;
        moment.suppressDeprecationWarnings = true;
        test.expectedDeprecations = function () {
            test._expectedDeprecations = arguments;
            test._observedDeprecations = [];
        };
        moment.deprecationHandler = function (name, msg) {
            var deprecationId = matchedDeprecation(name, msg, test._expectedDeprecations);
            if (deprecationId === -1) {
                throw new Error('Unexpected deprecation thrown name=' +
                        name + ' msg=' + msg);
            }
            test._observedDeprecations[deprecationId] = 1;
        };
    }

    function teardownDeprecationHandler(test, moment, scope) {
        moment.suppressDeprecationWarnings = test._oldSupress;

        if (test._expectedDeprecations != null) {
            var missedDeprecations = [];
            each(test._expectedDeprecations, function (deprecationPattern, id) {
                if (test._observedDeprecations[id] !== 1) {
                    missedDeprecations.push(deprecationPattern);
                }
            });
            if (missedDeprecations.length !== 0) {
                throw new Error('Expected deprecation warnings did not happen: ' +
                        missedDeprecations.join(' '));
            }
        }
    }

    function matchedDeprecation(name, msg, deprecations) {
        if (deprecations == null) {
            return -1;
        }
        for (var i = 0; i < deprecations.length; ++i) {
            if (name != null && name === deprecations[i]) {
                return i;
            }
            if (msg != null && msg.substring(0, deprecations[i].length) === deprecations[i]) {
                return i;
            }
        }
        return -1;
    }

    /*global QUnit:false*/

    var test = QUnit.test;

    var expect = QUnit.expect;

    function module (name, lifecycle) {
        QUnit.module(name, {
            setup : function () {
                moment.locale('en');
                moment.createFromInputFallback = function (config) {
                    throw new Error('input not handled by moment: ' + config._i);
                };
                setupDeprecationHandler(test, moment, 'core');
                if (lifecycle && lifecycle.setup) {
                    lifecycle.setup();
                }
            },
            teardown : function () {
                teardownDeprecationHandler(test, moment, 'core');
                if (lifecycle && lifecycle.teardown) {
                    lifecycle.teardown();
                }
            }
        });
    }

    function localeModule (name, lifecycle) {
        QUnit.module('locale:' + name, {
            setup : function () {
                moment.locale(name);
                moment.createFromInputFallback = function (config) {
                    throw new Error('input not handled by moment: ' + config._i);
                };
                setupDeprecationHandler(test, moment, 'locale');
                if (lifecycle && lifecycle.setup) {
                    lifecycle.setup();
                }
            },
            teardown : function () {
                moment.locale('en');
                teardownDeprecationHandler(test, moment, 'locale');
                if (lifecycle && lifecycle.teardown) {
                    lifecycle.teardown();
                }
            }
        });
        defineCommonLocaleTests(name, -1, -1);
    }

    localeModule('cv');

    test('parse', function (assert) {
        var tests = 'ÐºÓÑÐ»Ð°Ñ ÐºÓÑ_Ð½Ð°ÑÓÑ Ð½Ð°Ñ_Ð¿ÑÑ Ð¿ÑÑ_Ð°ÐºÐ° Ð°ÐºÐ°_Ð¼Ð°Ð¹ Ð¼Ð°Ð¹_Ò«ÓÑÑÐ¼Ðµ Ò«ÓÑ_ÑÑÓ ÑÑÓ_Ò«ÑÑÐ»Ð° Ò«ÑÑ_Ð°Ð²ÓÐ½ Ð°Ð²Ð½_ÑÐ¿Ð° ÑÐ¿Ð°_ÑÓ³Ðº ÑÓ³Ðº_ÑÐ°ÑÑÐ°Ð² ÑÐ°Ñ'.split('_'), i;
        function equalTest(input, mmm, i) {
            assert.equal(moment(input, mmm).month(), i, input + ' should be month ' + (i + 1));
        }
        for (i = 0; i < 12; i++) {
            tests[i] = tests[i].split(' ');
            equalTest(tests[i][0], 'MMM', i);
            equalTest(tests[i][1], 'MMM', i);
            equalTest(tests[i][0], 'MMMM', i);
            equalTest(tests[i][1], 'MMMM', i);
            equalTest(tests[i][0].toLocaleLowerCase(), 'MMMM', i);
            equalTest(tests[i][1].toLocaleLowerCase(), 'MMMM', i);
            equalTest(tests[i][0].toLocaleUpperCase(), 'MMMM', i);
            equalTest(tests[i][1].toLocaleUpperCase(), 'MMMM', i);
        }
    });

    test('format', function (assert) {
        var a = [
                ['dddd, MMMM Do YYYY, h:mm:ss a',      'Ð²ÑÑÑÐ°ÑÐ½Ð¸ÐºÑÐ½, Ð½Ð°ÑÓÑ 14-Ð¼ÓÑ 2010, 3:25:50 pm'],
                ['ddd, hA',                            'Ð²ÑÑ, 3PM'],
                ['M Mo MM MMMM MMM',                   '2 2-Ð¼ÓÑ 02 Ð½Ð°ÑÓÑ Ð½Ð°Ñ'],
                ['YYYY YY',                            '2010 10'],
                ['D Do DD',                            '14 14-Ð¼ÓÑ 14'],
                ['d do dddd ddd dd',                   '0 0-Ð¼ÓÑ Ð²ÑÑÑÐ°ÑÐ½Ð¸ÐºÑÐ½ Ð²ÑÑ Ð²Ñ'],
                ['DDD DDDo DDDD',                      '45 45-Ð¼ÓÑ 045'],
                ['w wo ww',                            '7 7-Ð¼ÓÑ 07'],
                ['h hh',                               '3 03'],
                ['H HH',                               '15 15'],
                ['m mm',                               '25 25'],
                ['s ss',                               '50 50'],
                ['a A',                                'pm PM'],
                ['ÒªÑÐ»ÓÐ½ DDDo ÐºÑÐ½Ó',                    'ÒªÑÐ»ÓÐ½ 45-Ð¼ÓÑ ÐºÑÐ½Ó'],
                ['LTS',                                '15:25:50'],
                ['L',                                  '14-02-2010'],
                ['LL',                                 '2010 Ò«ÑÐ»ÑÐ¸ Ð½Ð°ÑÓÑ ÑÐ¹ÓÑÓÐ½ 14-Ð¼ÓÑÓ'],
                ['LLL',                                '2010 Ò«ÑÐ»ÑÐ¸ Ð½Ð°ÑÓÑ ÑÐ¹ÓÑÓÐ½ 14-Ð¼ÓÑÓ, 15:25'],
                ['LLLL',                               'Ð²ÑÑÑÐ°ÑÐ½Ð¸ÐºÑÐ½, 2010 Ò«ÑÐ»ÑÐ¸ Ð½Ð°ÑÓÑ ÑÐ¹ÓÑÓÐ½ 14-Ð¼ÓÑÓ, 15:25'],
                ['l',                                  '14-2-2010'],
                ['ll',                                 '2010 Ò«ÑÐ»ÑÐ¸ Ð½Ð°Ñ ÑÐ¹ÓÑÓÐ½ 14-Ð¼ÓÑÓ'],
                ['lll',                                '2010 Ò«ÑÐ»ÑÐ¸ Ð½Ð°Ñ ÑÐ¹ÓÑÓÐ½ 14-Ð¼ÓÑÓ, 15:25'],
                ['llll',                               'Ð²ÑÑ, 2010 Ò«ÑÐ»ÑÐ¸ Ð½Ð°Ñ ÑÐ¹ÓÑÓÐ½ 14-Ð¼ÓÑÓ, 15:25']
            ],
            b = moment(new Date(2010, 1, 14, 15, 25, 50, 125)),
            i;
        for (i = 0; i < a.length; i++) {
            assert.equal(b.format(a[i][0]), a[i][1], a[i][0] + ' ---> ' + a[i][1]);
        }
    });

    test('format ordinal', function (assert) {
        assert.equal(moment([2011, 0, 1]).format('DDDo'), '1-Ð¼ÓÑ', '1-Ð¼ÓÑ');
        assert.equal(moment([2011, 0, 2]).format('DDDo'), '2-Ð¼ÓÑ', '2-Ð¼ÓÑ');
        assert.equal(moment([2011, 0, 3]).format('DDDo'), '3-Ð¼ÓÑ', '3-Ð¼ÓÑ');
        assert.equal(moment([2011, 0, 4]).format('DDDo'), '4-Ð¼ÓÑ', '4-Ð¼ÓÑ');
        assert.equal(moment([2011, 0, 5]).format('DDDo'), '5-Ð¼ÓÑ', '5-Ð¼ÓÑ');
        assert.equal(moment([2011, 0, 6]).format('DDDo'), '6-Ð¼ÓÑ', '6-Ð¼ÓÑ');
        assert.equal(moment([2011, 0, 7]).format('DDDo'), '7-Ð¼ÓÑ', '7-Ð¼ÓÑ');
        assert.equal(moment([2011, 0, 8]).format('DDDo'), '8-Ð¼ÓÑ', '8-Ð¼ÓÑ');
        assert.equal(moment([2011, 0, 9]).format('DDDo'), '9-Ð¼ÓÑ', '9-Ð¼ÓÑ');
        assert.equal(moment([2011, 0, 10]).format('DDDo'), '10-Ð¼ÓÑ', '10-Ð¼ÓÑ');

        assert.equal(moment([2011, 0, 11]).format('DDDo'), '11-Ð¼ÓÑ', '11-Ð¼ÓÑ');
        assert.equal(moment([2011, 0, 12]).format('DDDo'), '12-Ð¼ÓÑ', '12-Ð¼ÓÑ');
        assert.equal(moment([2011, 0, 13]).format('DDDo'), '13-Ð¼ÓÑ', '13-Ð¼ÓÑ');
        assert.equal(moment([2011, 0, 14]).format('DDDo'), '14-Ð¼ÓÑ', '14-Ð¼ÓÑ');
        assert.equal(moment([2011, 0, 15]).format('DDDo'), '15-Ð¼ÓÑ', '15-Ð¼ÓÑ');
        assert.equal(moment([2011, 0, 16]).format('DDDo'), '16-Ð¼ÓÑ', '16-Ð¼ÓÑ');
        assert.equal(moment([2011, 0, 17]).format('DDDo'), '17-Ð¼ÓÑ', '17-Ð¼ÓÑ');
        assert.equal(moment([2011, 0, 18]).format('DDDo'), '18-Ð¼ÓÑ', '18-Ð¼ÓÑ');
        assert.equal(moment([2011, 0, 19]).format('DDDo'), '19-Ð¼ÓÑ', '19-Ð¼ÓÑ');
        assert.equal(moment([2011, 0, 20]).format('DDDo'), '20-Ð¼ÓÑ', '20-Ð¼ÓÑ');

        assert.equal(moment([2011, 0, 21]).format('DDDo'), '21-Ð¼ÓÑ', '21-Ð¼ÓÑ');
        assert.equal(moment([2011, 0, 22]).format('DDDo'), '22-Ð¼ÓÑ', '22-Ð¼ÓÑ');
        assert.equal(moment([2011, 0, 23]).format('DDDo'), '23-Ð¼ÓÑ', '23-Ð¼ÓÑ');
        assert.equal(moment([2011, 0, 24]).format('DDDo'), '24-Ð¼ÓÑ', '24-Ð¼ÓÑ');
        assert.equal(moment([2011, 0, 25]).format('DDDo'), '25-Ð¼ÓÑ', '25-Ð¼ÓÑ');
        assert.equal(moment([2011, 0, 26]).format('DDDo'), '26-Ð¼ÓÑ', '26-Ð¼ÓÑ');
        assert.equal(moment([2011, 0, 27]).format('DDDo'), '27-Ð¼ÓÑ', '27-Ð¼ÓÑ');
        assert.equal(moment([2011, 0, 28]).format('DDDo'), '28-Ð¼ÓÑ', '28-Ð¼ÓÑ');
        assert.equal(moment([2011, 0, 29]).format('DDDo'), '29-Ð¼ÓÑ', '29-Ð¼ÓÑ');
        assert.equal(moment([2011, 0, 30]).format('DDDo'), '30-Ð¼ÓÑ', '30-Ð¼ÓÑ');

        assert.equal(moment([2011, 0, 31]).format('DDDo'), '31-Ð¼ÓÑ', '31-Ð¼ÓÑ');
    });

    test('format month', function (assert) {
        var expected = 'ÐºÓÑÐ»Ð°Ñ ÐºÓÑ_Ð½Ð°ÑÓÑ Ð½Ð°Ñ_Ð¿ÑÑ Ð¿ÑÑ_Ð°ÐºÐ° Ð°ÐºÐ°_Ð¼Ð°Ð¹ Ð¼Ð°Ð¹_Ò«ÓÑÑÐ¼Ðµ Ò«ÓÑ_ÑÑÓ ÑÑÓ_Ò«ÑÑÐ»Ð° Ò«ÑÑ_Ð°Ð²ÓÐ½ Ð°Ð²Ð½_ÑÐ¿Ð° ÑÐ¿Ð°_ÑÓ³Ðº ÑÓ³Ðº_ÑÐ°ÑÑÐ°Ð² ÑÐ°Ñ'.split('_'), i;
        for (i = 0; i < expected.length; i++) {
            assert.equal(moment([2011, i, 1]).format('MMMM MMM'), expected[i], expected[i]);
        }
    });

    test('format week', function (assert) {
        var expected = 'Ð²ÑÑÑÐ°ÑÐ½Ð¸ÐºÑÐ½ Ð²ÑÑ Ð²Ñ_ÑÑÐ½ÑÐ¸ÐºÑÐ½ ÑÑÐ½ ÑÐ½_ÑÑÐ»Ð°ÑÐ¸ÐºÑÐ½ ÑÑÐ» ÑÑ_ÑÐ½ÐºÑÐ½ ÑÐ½ ÑÐ½_ÐºÓÒ«Ð½ÐµÑÐ½Ð¸ÐºÑÐ½ ÐºÓÒ« ÐºÒ«_ÑÑÐ½ÐµÐºÑÐ½ ÑÑÐ½ ÑÑ_ÑÓÐ¼Ð°ÑÐºÑÐ½ ÑÓÐ¼ ÑÐ¼'.split('_'), i;
        for (i = 0; i < expected.length; i++) {
            assert.equal(moment([2011, 0, 2 + i]).format('dddd ddd dd'), expected[i], expected[i]);
        }
    });

    test('from', function (assert) {
        var start = moment([2007, 1, 28]);
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 44}), true),  'Ð¿ÓÑ-Ð¸Ðº Ò«ÐµÐºÐºÑÐ½Ñ', '44 sekunder = a few seconds');
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 45}), true),  'Ð¿ÓÑ Ð¼Ð¸Ð½ÑÑ',      '45 seconds = a minute');
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 89}), true),  'Ð¿ÓÑ Ð¼Ð¸Ð½ÑÑ',      '89 seconds = a minute');
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 90}), true),  '2 Ð¼Ð¸Ð½ÑÑ',     '90 seconds = 2 minutes');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 44}), true),  '44 Ð¼Ð¸Ð½ÑÑ',    '44 minutes = 44 minutes');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 45}), true),  'Ð¿ÓÑ ÑÐµÑÐµÑ',       '45 minutes = an hour');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 89}), true),  'Ð¿ÓÑ ÑÐµÑÐµÑ',       '89 minutes = an hour');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 90}), true),  '2 ÑÐµÑÐµÑ',       '90 minutes = 2 hours');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 5}), true),   '5 ÑÐµÑÐµÑ',       '5 hours = 5 hours');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 21}), true),  '21 ÑÐµÑÐµÑ',      '21 hours = 21 hours');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 22}), true),  'Ð¿ÓÑ ÐºÑÐ½',         '22 hours = a day');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 35}), true),  'Ð¿ÓÑ ÐºÑÐ½',         '35 hours = a day');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 36}), true),  '2 ÐºÑÐ½',        '36 hours = 2 days');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 1}), true),   'Ð¿ÓÑ ÐºÑÐ½',         '1 day = a day');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 5}), true),   '5 ÐºÑÐ½',        '5 days = 5 days');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 25}), true),  '25 ÐºÑÐ½',       '25 days = 25 days');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 26}), true),  'Ð¿ÓÑ ÑÐ¹ÓÑ',       '26 days = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 30}), true),  'Ð¿ÓÑ ÑÐ¹ÓÑ',       '30 days = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 43}), true),  'Ð¿ÓÑ ÑÐ¹ÓÑ',       '43 days = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 46}), true),  '2 ÑÐ¹ÓÑ',      '46 days = 2 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 74}), true),  '2 ÑÐ¹ÓÑ',      '75 days = 2 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 76}), true),  '3 ÑÐ¹ÓÑ',      '76 days = 3 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({M: 1}), true),   'Ð¿ÓÑ ÑÐ¹ÓÑ',       '1 month = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({M: 5}), true),   '5 ÑÐ¹ÓÑ',      '5 months = 5 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 345}), true), 'Ð¿ÓÑ Ò«ÑÐ»',        '345 days = a year');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 548}), true), '2 Ò«ÑÐ»',       '548 days = 2 years');
        assert.equal(start.from(moment([2007, 1, 28]).add({y: 1}), true),   'Ð¿ÓÑ Ò«ÑÐ»',        '1 year = a year');
        assert.equal(start.from(moment([2007, 1, 28]).add({y: 5}), true),   '5 Ò«ÑÐ»',       '5 years = 5 years');
    });

    test('suffix', function (assert) {
        assert.equal(moment(30000).from(0), 'Ð¿ÓÑ-Ð¸Ðº Ò«ÐµÐºÐºÑÐ½ÑÑÐ°Ð½',  'prefix');
        assert.equal(moment(0).from(30000), 'Ð¿ÓÑ-Ð¸Ðº Ò«ÐµÐºÐºÑÐ½Ñ ÐºÐ°ÑÐ»Ð»Ð°', 'suffix');
    });

    test('now from now', function (assert) {
        assert.equal(moment().fromNow(), 'Ð¿ÓÑ-Ð¸Ðº Ò«ÐµÐºÐºÑÐ½Ñ ÐºÐ°ÑÐ»Ð»Ð°',  'now from now should display as in the past');
    });

    test('fromNow', function (assert) {
        assert.equal(moment().add({s: 30}).fromNow(), 'Ð¿ÓÑ-Ð¸Ðº Ò«ÐµÐºÐºÑÐ½ÑÑÐ°Ð½', 'in a few seconds');
        assert.equal(moment().add({d: 5}).fromNow(), '5 ÐºÑÐ½ÑÐ°Ð½', 'in 5 days');
        assert.equal(moment().add({h: 2}).fromNow(), '2 ÑÐµÑÐµÑÑÐµÐ½', 'in 2 hours, the right suffix!');
        assert.equal(moment().add({y: 3}).fromNow(), '3 Ò«ÑÐ»ÑÐ°Ð½', 'in 3 years, the right suffix!');
    });

    test('calendar day', function (assert) {
        var a = moment().hours(12).minutes(0).seconds(0);
        assert.equal(moment(a).calendar(),                   'ÐÐ°ÑÐ½ 12:00 ÑÐµÑÐµÑÑÐµ',     'today at the same time');
        assert.equal(moment(a).add({m: 25}).calendar(),      'ÐÐ°ÑÐ½ 12:25 ÑÐµÑÐµÑÑÐµ',     'Now plus 25 min');
        assert.equal(moment(a).add({h: 1}).calendar(),       'ÐÐ°ÑÐ½ 13:00 ÑÐµÑÐµÑÑÐµ',     'Now plus 1 hour');
        assert.equal(moment(a).add({d: 1}).calendar(),       'Ð«ÑÐ°Ð½ 12:00 ÑÐµÑÐµÑÑÐµ',     'tomorrow at the same time');
        assert.equal(moment(a).subtract({h: 1}).calendar(),  'ÐÐ°ÑÐ½ 11:00 ÑÐµÑÐµÑÑÐµ',     'Now minus 1 hour');
        assert.equal(moment(a).subtract({d: 1}).calendar(),  'ÓÐ½ÐµÑ 12:00 ÑÐµÑÐµÑÑÐµ',     'yesterday at the same time');
    });

    test('calendar next week', function (assert) {
        var i, m;

        for (i = 2; i < 7; i++) {
            m = moment().add({d: i});
            assert.equal(m.calendar(),       m.format('[ÒªÐ¸ÑÐµÑ] dddd LT [ÑÐµÑÐµÑÑÐµ]'),  'Today + ' + i + ' days current time');
            m.hours(0).minutes(0).seconds(0).milliseconds(0);
            assert.equal(m.calendar(),       m.format('[ÒªÐ¸ÑÐµÑ] dddd LT [ÑÐµÑÐµÑÑÐµ]'),  'Today + ' + i + ' days beginning of day');
            m.hours(23).minutes(59).seconds(59).milliseconds(999);
            assert.equal(m.calendar(),       m.format('[ÒªÐ¸ÑÐµÑ] dddd LT [ÑÐµÑÐµÑÑÐµ]'),  'Today + ' + i + ' days end of day');
        }
    });

    test('calendar last week', function (assert) {
        var i, m;

        for (i = 2; i < 7; i++) {
            m = moment().subtract({d: i});
            assert.equal(m.calendar(),       m.format('[ÐÑÑÐ½Ó] dddd LT [ÑÐµÑÐµÑÑÐµ]'),  'Today - ' + i + ' days current time');
            m.hours(0).minutes(0).seconds(0).milliseconds(0);
            assert.equal(m.calendar(),       m.format('[ÐÑÑÐ½Ó] dddd LT [ÑÐµÑÐµÑÑÐµ]'),  'Today - ' + i + ' days beginning of day');
            m.hours(23).minutes(59).seconds(59).milliseconds(999);
            assert.equal(m.calendar(),       m.format('[ÐÑÑÐ½Ó] dddd LT [ÑÐµÑÐµÑÑÐµ]'),  'Today - ' + i + ' days end of day');
        }
    });

    test('calendar all else', function (assert) {
        var weeksAgo = moment().subtract({w: 1}),
            weeksFromNow = moment().add({w: 1});

        assert.equal(weeksAgo.calendar(),       weeksAgo.format('L'),  '1 week ago');
        assert.equal(weeksFromNow.calendar(),   weeksFromNow.format('L'),  'in 1 week');

        weeksAgo = moment().subtract({w: 2});
        weeksFromNow = moment().add({w: 2});

        assert.equal(weeksAgo.calendar(),       weeksAgo.format('L'),  '2 weeks ago');
        assert.equal(weeksFromNow.calendar(),   weeksFromNow.format('L'),  'in 2 weeks');
    });

    // Monday is the first day of the week.
    // The week that contains Jan 1st is the first week of the year.

    test('weeks year starting sunday formatted', function (assert) {
        assert.equal(moment([2011, 11, 26]).format('w ww wo'), '1 01 1-Ð¼ÓÑ', 'Dec 26 2011 should be week 1');
        assert.equal(moment([2012,  0,  1]).format('w ww wo'), '1 01 1-Ð¼ÓÑ', 'Jan  1 2012 should be week 1');
        assert.equal(moment([2012,  0,  2]).format('w ww wo'), '2 02 2-Ð¼ÓÑ', 'Jan  2 2012 should be week 2');
        assert.equal(moment([2012,  0,  8]).format('w ww wo'), '2 02 2-Ð¼ÓÑ', 'Jan  8 2012 should be week 2');
        assert.equal(moment([2012,  0,  9]).format('w ww wo'), '3 03 3-Ð¼ÓÑ', 'Jan  9 2012 should be week 3');
    });

}));

;(function (global, factory) {
   typeof exports === 'object' && typeof module !== 'undefined'
       && typeof require === 'function' ? factory(require('../../moment')) :
   typeof define === 'function' && define.amd ? define(['../../moment'], factory) :
   factory(global.moment)
}(this, function (moment) { 'use strict';

    function each(array, callback) {
        var i;
        for (i = 0; i < array.length; i++) {
            callback(array[i], i, array);
        }
    }

    function objectKeys(obj) {
        if (Object.keys) {
            return Object.keys(obj);
        } else {
            // IE8
            var res = [], i;
            for (i in obj) {
                if (obj.hasOwnProperty(i)) {
                    res.push(i);
                }
            }
            return res;
        }
    }

    // Pick the first defined of two or three arguments.
    function defaults(a, b, c) {
        if (a != null) {
            return a;
        }
        if (b != null) {
            return b;
        }
        return c;
    }

    function defineCommonLocaleTests(locale, options) {
        test('lenient ordinal parsing', function (assert) {
            var i, ordinalStr, testMoment;
            for (i = 1; i <= 31; ++i) {
                ordinalStr = moment([2014, 0, i]).format('YYYY MM Do');
                testMoment = moment(ordinalStr, 'YYYY MM Do');
                assert.equal(testMoment.year(), 2014,
                        'lenient ordinal parsing ' + i + ' year check');
                assert.equal(testMoment.month(), 0,
                        'lenient ordinal parsing ' + i + ' month check');
                assert.equal(testMoment.date(), i,
                        'lenient ordinal parsing ' + i + ' date check');
            }
        });

        test('lenient ordinal parsing of number', function (assert) {
            var i, testMoment;
            for (i = 1; i <= 31; ++i) {
                testMoment = moment('2014 01 ' + i, 'YYYY MM Do');
                assert.equal(testMoment.year(), 2014,
                        'lenient ordinal parsing of number ' + i + ' year check');
                assert.equal(testMoment.month(), 0,
                        'lenient ordinal parsing of number ' + i + ' month check');
                assert.equal(testMoment.date(), i,
                        'lenient ordinal parsing of number ' + i + ' date check');
            }
        });

        test('strict ordinal parsing', function (assert) {
            var i, ordinalStr, testMoment;
            for (i = 1; i <= 31; ++i) {
                ordinalStr = moment([2014, 0, i]).format('YYYY MM Do');
                testMoment = moment(ordinalStr, 'YYYY MM Do', true);
                assert.ok(testMoment.isValid(), 'strict ordinal parsing ' + i);
            }
        });

        test('meridiem invariant', function (assert) {
            var h, m, t1, t2;
            for (h = 0; h < 24; ++h) {
                for (m = 0; m < 60; m += 15) {
                    t1 = moment.utc([2000, 0, 1, h, m]);
                    t2 = moment.utc(t1.format('A h:mm'), 'A h:mm');
                    assert.equal(t2.format('HH:mm'), t1.format('HH:mm'),
                            'meridiem at ' + t1.format('HH:mm'));
                }
            }
        });

        test('date format correctness', function (assert) {
            var data, tokens;
            data = moment.localeData()._longDateFormat;
            tokens = objectKeys(data);
            each(tokens, function (srchToken) {
                // Check each format string to make sure it does not contain any
                // tokens that need to be expanded.
                each(tokens, function (baseToken) {
                    // strip escaped sequences
                    var format = data[baseToken].replace(/(\[[^\]]*\])/g, '');
                    assert.equal(false, !!~format.indexOf(srchToken),
                            'contains ' + srchToken + ' in ' + baseToken);
                });
            });
        });

        test('month parsing correctness', function (assert) {
            var i, m;

            if (locale === 'tr') {
                // I can't fix it :(
                expect(0);
                return;
            }
            function tester(format) {
                var r;
                r = moment(m.format(format), format);
                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format);
                r = moment(m.format(format).toLocaleUpperCase(), format);
                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' upper');
                r = moment(m.format(format).toLocaleLowerCase(), format);
                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' lower');

                r = moment(m.format(format), format, true);
                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' strict');
                r = moment(m.format(format).toLocaleUpperCase(), format, true);
                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' upper strict');
                r = moment(m.format(format).toLocaleLowerCase(), format, true);
                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' lower strict');
            }

            for (i = 0; i < 12; ++i) {
                m = moment([2015, i, 15, 18]);
                tester('MMM');
                tester('MMM.');
                tester('MMMM');
                tester('MMMM.');
            }
        });

        test('weekday parsing correctness', function (assert) {
            var i, m;

            if (locale === 'tr' || locale === 'az') {
                // There is a lower-case letter (Ä±), that converted to upper then
                // lower changes to i
                expect(0);
                return;
            }
            function tester(format) {
                var r, baseMsg = 'weekday ' + m.weekday() + ' fmt ' + format;
                r = moment(m.format(format), format);
                assert.equal(r.weekday(), m.weekday(), baseMsg);
                r = moment(m.format(format).toLocaleUpperCase(), format);
                assert.equal(r.weekday(), m.weekday(), baseMsg + ' upper');
                r = moment(m.format(format).toLocaleLowerCase(), format);
                assert.equal(r.weekday(), m.weekday(), baseMsg + ' lower');

                r = moment(m.format(format), format, true);
                assert.equal(r.weekday(), m.weekday(), baseMsg + ' strict');
                r = moment(m.format(format).toLocaleUpperCase(), format, true);
                assert.equal(r.weekday(), m.weekday(), baseMsg + ' upper strict');
                r = moment(m.format(format).toLocaleLowerCase(), format, true);
                assert.equal(r.weekday(), m.weekday(), baseMsg + ' lower strict');
            }

            for (i = 0; i < 7; ++i) {
                m = moment.utc([2015, i, 15, 18]);
                tester('dd');
                tester('ddd');
                tester('dddd');
            }
        });
    }

    function setupDeprecationHandler(test, moment, scope) {
        test._expectedDeprecations = null;
        test._observedDeprecations = null;
        test._oldSupress = moment.suppressDeprecationWarnings;
        moment.suppressDeprecationWarnings = true;
        test.expectedDeprecations = function () {
            test._expectedDeprecations = arguments;
            test._observedDeprecations = [];
        };
        moment.deprecationHandler = function (name, msg) {
            var deprecationId = matchedDeprecation(name, msg, test._expectedDeprecations);
            if (deprecationId === -1) {
                throw new Error('Unexpected deprecation thrown name=' +
                        name + ' msg=' + msg);
            }
            test._observedDeprecations[deprecationId] = 1;
        };
    }

    function teardownDeprecationHandler(test, moment, scope) {
        moment.suppressDeprecationWarnings = test._oldSupress;

        if (test._expectedDeprecations != null) {
            var missedDeprecations = [];
            each(test._expectedDeprecations, function (deprecationPattern, id) {
                if (test._observedDeprecations[id] !== 1) {
                    missedDeprecations.push(deprecationPattern);
                }
            });
            if (missedDeprecations.length !== 0) {
                throw new Error('Expected deprecation warnings did not happen: ' +
                        missedDeprecations.join(' '));
            }
        }
    }

    function matchedDeprecation(name, msg, deprecations) {
        if (deprecations == null) {
            return -1;
        }
        for (var i = 0; i < deprecations.length; ++i) {
            if (name != null && name === deprecations[i]) {
                return i;
            }
            if (msg != null && msg.substring(0, deprecations[i].length) === deprecations[i]) {
                return i;
            }
        }
        return -1;
    }

    /*global QUnit:false*/

    var test = QUnit.test;

    var expect = QUnit.expect;

    function module (name, lifecycle) {
        QUnit.module(name, {
            setup : function () {
                moment.locale('en');
                moment.createFromInputFallback = function (config) {
                    throw new Error('input not handled by moment: ' + config._i);
                };
                setupDeprecationHandler(test, moment, 'core');
                if (lifecycle && lifecycle.setup) {
                    lifecycle.setup();
                }
            },
            teardown : function () {
                teardownDeprecationHandler(test, moment, 'core');
                if (lifecycle && lifecycle.teardown) {
                    lifecycle.teardown();
                }
            }
        });
    }

    function localeModule (name, lifecycle) {
        QUnit.module('locale:' + name, {
            setup : function () {
                moment.locale(name);
                moment.createFromInputFallback = function (config) {
                    throw new Error('input not handled by moment: ' + config._i);
                };
                setupDeprecationHandler(test, moment, 'locale');
                if (lifecycle && lifecycle.setup) {
                    lifecycle.setup();
                }
            },
            teardown : function () {
                moment.locale('en');
                teardownDeprecationHandler(test, moment, 'locale');
                if (lifecycle && lifecycle.teardown) {
                    lifecycle.teardown();
                }
            }
        });
        defineCommonLocaleTests(name, -1, -1);
    }

    localeModule('cy');

    test('parse', function (assert) {
        var tests = 'Ionawr Ion_Chwefror Chwe_Mawrth Maw_Ebrill Ebr_Mai Mai_Mehefin Meh_Gorffennaf Gor_Awst Aws_Medi Med_Hydref Hyd_Tachwedd Tach_Rhagfyr Rhag'.split('_'),
            i;
        function equalTest(input, mmm, i) {
            assert.equal(moment(input, mmm).month(), i, input + ' should be month ' + (i + 1));
        }
        for (i = 0; i < 12; i++) {
            tests[i] = tests[i].split(' ');
            equalTest(tests[i][0], 'MMM', i);
            equalTest(tests[i][1], 'MMM', i);
            equalTest(tests[i][0], 'MMMM', i);
            equalTest(tests[i][1], 'MMMM', i);
            equalTest(tests[i][0].toLocaleLowerCase(), 'MMMM', i);
            equalTest(tests[i][1].toLocaleLowerCase(), 'MMMM', i);
            equalTest(tests[i][0].toLocaleUpperCase(), 'MMMM', i);
            equalTest(tests[i][1].toLocaleUpperCase(), 'MMMM', i);
        }
    });

    test('format', function (assert) {
        var a = [
                ['dddd, MMMM Do YYYY, h:mm:ss a',      'Dydd Sul, Chwefror 14eg 2010, 3:25:50 pm'],
                ['ddd, hA',                            'Sul, 3PM'],
                ['M Mo MM MMMM MMM',                   '2 2il 02 Chwefror Chwe'],
                ['YYYY YY',                            '2010 10'],
                ['D Do DD',                            '14 14eg 14'],
                ['d do dddd ddd dd',                   '0 0 Dydd Sul Sul Su'],
                ['DDD DDDo DDDD',                      '45 45ain 045'],
                ['w wo ww',                            '6 6ed 06'],
                ['h hh',                               '3 03'],
                ['H HH',                               '15 15'],
                ['m mm',                               '25 25'],
                ['s ss',                               '50 50'],
                ['a A',                                'pm PM'],
                ['[the] DDDo [day of the year]',       'the 45ain day of the year'],
                ['LTS',                                '15:25:50'],
                ['L',                                  '14/02/2010'],
                ['LL',                                 '14 Chwefror 2010'],
                ['LLL',                                '14 Chwefror 2010 15:25'],
                ['LLLL',                               'Dydd Sul, 14 Chwefror 2010 15:25'],
                ['l',                                  '14/2/2010'],
                ['ll',                                 '14 Chwe 2010'],
                ['lll',                                '14 Chwe 2010 15:25'],
                ['llll',                               'Sul, 14 Chwe 2010 15:25']
            ],
            b = moment(new Date(2010, 1, 14, 15, 25, 50, 125)),
            i;
        for (i = 0; i < a.length; i++) {
            assert.equal(b.format(a[i][0]), a[i][1], a[i][0] + ' ---> ' + a[i][1]);
        }
    });

    test('format ordinal', function (assert) {
        assert.equal(moment([2011, 0, 1]).format('DDDo'), '1af', '1af');
        assert.equal(moment([2011, 0, 2]).format('DDDo'), '2il', '2il');
        assert.equal(moment([2011, 0, 3]).format('DDDo'), '3ydd', '3ydd');
        assert.equal(moment([2011, 0, 4]).format('DDDo'), '4ydd', '4ydd');
        assert.equal(moment([2011, 0, 5]).format('DDDo'), '5ed', '5ed');
        assert.equal(moment([2011, 0, 6]).format('DDDo'), '6ed', '6ed');
        assert.equal(moment([2011, 0, 7]).format('DDDo'), '7ed', '7ed');
        assert.equal(moment([2011, 0, 8]).format('DDDo'), '8fed', '8fed');
        assert.equal(moment([2011, 0, 9]).format('DDDo'), '9fed', '9fed');
        assert.equal(moment([2011, 0, 10]).format('DDDo'), '10fed', '10fed');

        assert.equal(moment([2011, 0, 11]).format('DDDo'), '11eg', '11eg');
        assert.equal(moment([2011, 0, 12]).format('DDDo'), '12fed', '12fed');
        assert.equal(moment([2011, 0, 13]).format('DDDo'), '13eg', '13eg');
        assert.equal(moment([2011, 0, 14]).format('DDDo'), '14eg', '14eg');
        assert.equal(moment([2011, 0, 15]).format('DDDo'), '15fed', '15fed');
        assert.equal(moment([2011, 0, 16]).format('DDDo'), '16eg', '16eg');
        assert.equal(moment([2011, 0, 17]).format('DDDo'), '17eg', '17eg');
        assert.equal(moment([2011, 0, 18]).format('DDDo'), '18fed', '18fed');
        assert.equal(moment([2011, 0, 19]).format('DDDo'), '19eg', '19eg');
        assert.equal(moment([2011, 0, 20]).format('DDDo'), '20fed', '20fed');

        assert.equal(moment([2011, 0, 21]).format('DDDo'), '21ain', '21ain');
        assert.equal(moment([2011, 0, 22]).format('DDDo'), '22ain', '22ain');
        assert.equal(moment([2011, 0, 23]).format('DDDo'), '23ain', '23ain');
        assert.equal(moment([2011, 0, 24]).format('DDDo'), '24ain', '24ain');
        assert.equal(moment([2011, 0, 25]).format('DDDo'), '25ain', '25ain');
        assert.equal(moment([2011, 0, 26]).format('DDDo'), '26ain', '26ain');
        assert.equal(moment([2011, 0, 27]).format('DDDo'), '27ain', '27ain');
        assert.equal(moment([2011, 0, 28]).format('DDDo'), '28ain', '28ain');
        assert.equal(moment([2011, 0, 29]).format('DDDo'), '29ain', '29ain');
        assert.equal(moment([2011, 0, 30]).format('DDDo'), '30ain', '30ain');

        assert.equal(moment([2011, 0, 31]).format('DDDo'), '31ain', '31ain');
    });

    test('format month', function (assert) {
        var expected = 'Ionawr Ion_Chwefror Chwe_Mawrth Maw_Ebrill Ebr_Mai Mai_Mehefin Meh_Gorffennaf Gor_Awst Aws_Medi Med_Hydref Hyd_Tachwedd Tach_Rhagfyr Rhag'.split('_'), i;
        for (i = 0; i < expected.length; i++) {
            assert.equal(moment([2011, i, 1]).format('MMMM MMM'), expected[i], expected[i]);
        }
    });

    test('format week', function (assert) {
        var expected = 'Dydd Sul Sul Su_Dydd Llun Llun Ll_Dydd Mawrth Maw Ma_Dydd Mercher Mer Me_Dydd Iau Iau Ia_Dydd Gwener Gwe Gw_Dydd Sadwrn Sad Sa'.split('_'), i;
        for (i = 0; i < expected.length; i++) {
            assert.equal(moment([2011, 0, 2 + i]).format('dddd ddd dd'), expected[i], expected[i]);
        }
    });

    test('from', function (assert) {
        var start = moment([2007, 1, 28]);
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 44}), true),  'ychydig eiliadau', '44 seconds = a few seconds');
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 45}), true),  'munud',   '45 seconds = a minute');
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 89}), true),  'munud',   '89 seconds = a minute');
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 90}), true),  '2 munud',  '90 seconds = 2 minutes');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 44}), true),  '44 munud', '44 minutes = 44 minutes');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 45}), true),  'awr',    '45 minutes = an hour');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 89}), true),  'awr',    '89 minutes = an hour');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 90}), true),  '2 awr',    '90 minutes = 2 hours');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 5}), true),   '5 awr',    '5 hours = 5 hours');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 21}), true),  '21 awr',   '21 hours = 21 hours');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 22}), true),  'diwrnod',      '22 hours = a day');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 35}), true),  'diwrnod',      '35 hours = a day');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 36}), true),  '2 diwrnod',     '36 hours = 2 days');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 1}), true),   'diwrnod',      '1 day = a day');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 5}), true),   '5 diwrnod',     '5 days = 5 days');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 25}), true),  '25 diwrnod',    '25 days = 25 days');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 26}), true),  'mis',    '26 days = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 30}), true),  'mis',    '30 days = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 43}), true),  'mis',    '43 days = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 46}), true),  '2 mis',   '46 days = 2 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 74}), true),  '2 mis',   '75 days = 2 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 76}), true),  '3 mis',   '76 days = 3 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({M: 1}), true),   'mis',    '1 month = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({M: 5}), true),   '5 mis',   '5 months = 5 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 345}), true), 'blwyddyn',     '345 days = a year');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 548}), true), '2 flynedd',    '548 days = 2 years');
        assert.equal(start.from(moment([2007, 1, 28]).add({y: 1}), true),   'blwyddyn',     '1 year = a year');
        assert.equal(start.from(moment([2007, 1, 28]).add({y: 5}), true),   '5 flynedd',    '5 years = 5 years');
    });

    test('suffix', function (assert) {
        assert.equal(moment(30000).from(0), 'mewn ychydig eiliadau', 'prefix');
        assert.equal(moment(0).from(30000), 'ychydig eiliadau yn Ã´l', 'suffix');
    });

    test('fromNow', function (assert) {
        assert.equal(moment().add({s: 30}).fromNow(), 'mewn ychydig eiliadau', 'in a few seconds');
        assert.equal(moment().add({d: 5}).fromNow(), 'mewn 5 diwrnod', 'in 5 days');
    });

    test('calendar day', function (assert) {
        var a = moment().hours(12).minutes(0).seconds(0);

        assert.equal(moment(a).calendar(),                   'Heddiw am 12:00',    'today at the same time');
        assert.equal(moment(a).add({m: 25}).calendar(),      'Heddiw am 12:25',    'Now plus 25 min');
        assert.equal(moment(a).add({h: 1}).calendar(),       'Heddiw am 13:00',    'Now plus 1 hour');
        assert.equal(moment(a).add({d: 1}).calendar(),       'Yfory am 12:00',     'tomorrow at the same time');
        assert.equal(moment(a).subtract({h: 1}).calendar(),  'Heddiw am 11:00',    'Now minus 1 hour');
        assert.equal(moment(a).subtract({d: 1}).calendar(),  'Ddoe am 12:00',      'yesterday at the same time');
    });

    test('calendar next week', function (assert) {
        var i, m;

        for (i = 2; i < 7; i++) {
            m = moment().add({d: i});
            assert.equal(m.calendar(),       m.format('dddd [am] LT'),  'Today + ' + i + ' days current time');
            m.hours(0).minutes(0).seconds(0).milliseconds(0);
            assert.equal(m.calendar(),       m.format('dddd [am] LT'),  'Today + ' + i + ' days beginning of day');
            m.hours(23).minutes(59).seconds(59).milliseconds(999);
            assert.equal(m.calendar(),       m.format('dddd [am] LT'),  'Today + ' + i + ' days end of day');
        }
    });

    test('calendar last week', function (assert) {
        var i, m;

        for (i = 2; i < 7; i++) {
            m = moment().subtract({d: i});
            assert.equal(m.calendar(),       m.format('dddd [diwethaf am] LT'),  'Today - ' + i + ' days current time');
            m.hours(0).minutes(0).seconds(0).milliseconds(0);
            assert.equal(m.calendar(),       m.format('dddd [diwethaf am] LT'),  'Today - ' + i + ' days beginning of day');
            m.hours(23).minutes(59).seconds(59).milliseconds(999);
            assert.equal(m.calendar(),       m.format('dddd [diwethaf am] LT'),  'Today - ' + i + ' days end of day');
        }
    });

    test('calendar all else', function (assert) {
        var weeksAgo = moment().subtract({w: 1}),
            weeksFromNow = moment().add({w: 1});

        assert.equal(weeksAgo.calendar(),       weeksAgo.format('L'),  '1 week ago');
        assert.equal(weeksFromNow.calendar(),   weeksFromNow.format('L'),  'in 1 week');

        weeksAgo = moment().subtract({w: 2});
        weeksFromNow = moment().add({w: 2});

        assert.equal(weeksAgo.calendar(),       weeksAgo.format('L'),  '2 weeks ago');
        assert.equal(weeksFromNow.calendar(),   weeksFromNow.format('L'),  'in 2 weeks');
    });

    test('weeks year starting sunday formatted', function (assert) {
        assert.equal(moment([2012, 0,  1]).format('w ww wo'), '52 52 52ain', 'Jan  1 2012 should be week 52');
        assert.equal(moment([2012, 0,  2]).format('w ww wo'), '1 01 1af', 'Jan  2 2012 should be week 1');
        assert.equal(moment([2012, 0,  8]).format('w ww wo'), '1 01 1af', 'Jan  8 2012 should be week 1');
        assert.equal(moment([2012, 0,  9]).format('w ww wo'),   '2 02 2il', 'Jan  9 2012 should be week 2');
        assert.equal(moment([2012, 0, 15]).format('w ww wo'),   '2 02 2il', 'Jan 15 2012 should be week 2');
    });

}));

;(function (global, factory) {
   typeof exports === 'object' && typeof module !== 'undefined'
       && typeof require === 'function' ? factory(require('../../moment')) :
   typeof define === 'function' && define.amd ? define(['../../moment'], factory) :
   factory(global.moment)
}(this, function (moment) { 'use strict';

    function each(array, callback) {
        var i;
        for (i = 0; i < array.length; i++) {
            callback(array[i], i, array);
        }
    }

    function objectKeys(obj) {
        if (Object.keys) {
            return Object.keys(obj);
        } else {
            // IE8
            var res = [], i;
            for (i in obj) {
                if (obj.hasOwnProperty(i)) {
                    res.push(i);
                }
            }
            return res;
        }
    }

    // Pick the first defined of two or three arguments.
    function defaults(a, b, c) {
        if (a != null) {
            return a;
        }
        if (b != null) {
            return b;
        }
        return c;
    }

    function defineCommonLocaleTests(locale, options) {
        test('lenient ordinal parsing', function (assert) {
            var i, ordinalStr, testMoment;
            for (i = 1; i <= 31; ++i) {
                ordinalStr = moment([2014, 0, i]).format('YYYY MM Do');
                testMoment = moment(ordinalStr, 'YYYY MM Do');
                assert.equal(testMoment.year(), 2014,
                        'lenient ordinal parsing ' + i + ' year check');
                assert.equal(testMoment.month(), 0,
                        'lenient ordinal parsing ' + i + ' month check');
                assert.equal(testMoment.date(), i,
                        'lenient ordinal parsing ' + i + ' date check');
            }
        });

        test('lenient ordinal parsing of number', function (assert) {
            var i, testMoment;
            for (i = 1; i <= 31; ++i) {
                testMoment = moment('2014 01 ' + i, 'YYYY MM Do');
                assert.equal(testMoment.year(), 2014,
                        'lenient ordinal parsing of number ' + i + ' year check');
                assert.equal(testMoment.month(), 0,
                        'lenient ordinal parsing of number ' + i + ' month check');
                assert.equal(testMoment.date(), i,
                        'lenient ordinal parsing of number ' + i + ' date check');
            }
        });

        test('strict ordinal parsing', function (assert) {
            var i, ordinalStr, testMoment;
            for (i = 1; i <= 31; ++i) {
                ordinalStr = moment([2014, 0, i]).format('YYYY MM Do');
                testMoment = moment(ordinalStr, 'YYYY MM Do', true);
                assert.ok(testMoment.isValid(), 'strict ordinal parsing ' + i);
            }
        });

        test('meridiem invariant', function (assert) {
            var h, m, t1, t2;
            for (h = 0; h < 24; ++h) {
                for (m = 0; m < 60; m += 15) {
                    t1 = moment.utc([2000, 0, 1, h, m]);
                    t2 = moment.utc(t1.format('A h:mm'), 'A h:mm');
                    assert.equal(t2.format('HH:mm'), t1.format('HH:mm'),
                            'meridiem at ' + t1.format('HH:mm'));
                }
            }
        });

        test('date format correctness', function (assert) {
            var data, tokens;
            data = moment.localeData()._longDateFormat;
            tokens = objectKeys(data);
            each(tokens, function (srchToken) {
                // Check each format string to make sure it does not contain any
                // tokens that need to be expanded.
                each(tokens, function (baseToken) {
                    // strip escaped sequences
                    var format = data[baseToken].replace(/(\[[^\]]*\])/g, '');
                    assert.equal(false, !!~format.indexOf(srchToken),
                            'contains ' + srchToken + ' in ' + baseToken);
                });
            });
        });

        test('month parsing correctness', function (assert) {
            var i, m;

            if (locale === 'tr') {
                // I can't fix it :(
                expect(0);
                return;
            }
            function tester(format) {
                var r;
                r = moment(m.format(format), format);
                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format);
                r = moment(m.format(format).toLocaleUpperCase(), format);
                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' upper');
                r = moment(m.format(format).toLocaleLowerCase(), format);
                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' lower');

                r = moment(m.format(format), format, true);
                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' strict');
                r = moment(m.format(format).toLocaleUpperCase(), format, true);
                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' upper strict');
                r = moment(m.format(format).toLocaleLowerCase(), format, true);
                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' lower strict');
            }

            for (i = 0; i < 12; ++i) {
                m = moment([2015, i, 15, 18]);
                tester('MMM');
                tester('MMM.');
                tester('MMMM');
                tester('MMMM.');
            }
        });

        test('weekday parsing correctness', function (assert) {
            var i, m;

            if (locale === 'tr' || locale === 'az') {
                // There is a lower-case letter (Ä±), that converted to upper then
                // lower changes to i
                expect(0);
                return;
            }
            function tester(format) {
                var r, baseMsg = 'weekday ' + m.weekday() + ' fmt ' + format;
                r = moment(m.format(format), format);
                assert.equal(r.weekday(), m.weekday(), baseMsg);
                r = moment(m.format(format).toLocaleUpperCase(), format);
                assert.equal(r.weekday(), m.weekday(), baseMsg + ' upper');
                r = moment(m.format(format).toLocaleLowerCase(), format);
                assert.equal(r.weekday(), m.weekday(), baseMsg + ' lower');

                r = moment(m.format(format), format, true);
                assert.equal(r.weekday(), m.weekday(), baseMsg + ' strict');
                r = moment(m.format(format).toLocaleUpperCase(), format, true);
                assert.equal(r.weekday(), m.weekday(), baseMsg + ' upper strict');
                r = moment(m.format(format).toLocaleLowerCase(), format, true);
                assert.equal(r.weekday(), m.weekday(), baseMsg + ' lower strict');
            }

            for (i = 0; i < 7; ++i) {
                m = moment.utc([2015, i, 15, 18]);
                tester('dd');
                tester('ddd');
                tester('dddd');
            }
        });
    }

    function setupDeprecationHandler(test, moment, scope) {
        test._expectedDeprecations = null;
        test._observedDeprecations = null;
        test._oldSupress = moment.suppressDeprecationWarnings;
        moment.suppressDeprecationWarnings = true;
        test.expectedDeprecations = function () {
            test._expectedDeprecations = arguments;
            test._observedDeprecations = [];
        };
        moment.deprecationHandler = function (name, msg) {
            var deprecationId = matchedDeprecation(name, msg, test._expectedDeprecations);
            if (deprecationId === -1) {
                throw new Error('Unexpected deprecation thrown name=' +
                        name + ' msg=' + msg);
            }
            test._observedDeprecations[deprecationId] = 1;
        };
    }

    function teardownDeprecationHandler(test, moment, scope) {
        moment.suppressDeprecationWarnings = test._oldSupress;

        if (test._expectedDeprecations != null) {
            var missedDeprecations = [];
            each(test._expectedDeprecations, function (deprecationPattern, id) {
                if (test._observedDeprecations[id] !== 1) {
                    missedDeprecations.push(deprecationPattern);
                }
            });
            if (missedDeprecations.length !== 0) {
                throw new Error('Expected deprecation warnings did not happen: ' +
                        missedDeprecations.join(' '));
            }
        }
    }

    function matchedDeprecation(name, msg, deprecations) {
        if (deprecations == null) {
            return -1;
        }
        for (var i = 0; i < deprecations.length; ++i) {
            if (name != null && name === deprecations[i]) {
                return i;
            }
            if (msg != null && msg.substring(0, deprecations[i].length) === deprecations[i]) {
                return i;
            }
        }
        return -1;
    }

    /*global QUnit:false*/

    var test = QUnit.test;

    var expect = QUnit.expect;

    function module (name, lifecycle) {
        QUnit.module(name, {
            setup : function () {
                moment.locale('en');
                moment.createFromInputFallback = function (config) {
                    throw new Error('input not handled by moment: ' + config._i);
                };
                setupDeprecationHandler(test, moment, 'core');
                if (lifecycle && lifecycle.setup) {
                    lifecycle.setup();
                }
            },
            teardown : function () {
                teardownDeprecationHandler(test, moment, 'core');
                if (lifecycle && lifecycle.teardown) {
                    lifecycle.teardown();
                }
            }
        });
    }

    function localeModule (name, lifecycle) {
        QUnit.module('locale:' + name, {
            setup : function () {
                moment.locale(name);
                moment.createFromInputFallback = function (config) {
                    throw new Error('input not handled by moment: ' + config._i);
                };
                setupDeprecationHandler(test, moment, 'locale');
                if (lifecycle && lifecycle.setup) {
                    lifecycle.setup();
                }
            },
            teardown : function () {
                moment.locale('en');
                teardownDeprecationHandler(test, moment, 'locale');
                if (lifecycle && lifecycle.teardown) {
                    lifecycle.teardown();
                }
            }
        });
        defineCommonLocaleTests(name, -1, -1);
    }

    localeModule('da');

    test('parse', function (assert) {
        var tests = 'januar jan_februar feb_marts mar_april apr_maj maj_juni jun_juli jul_august aug_september sep_oktober okt_november nov_december dec'.split('_'), i;
        function equalTest(input, mmm, i) {
            assert.equal(moment(input, mmm).month(), i, input + ' should be month ' + (i + 1));
        }
        for (i = 0; i < 12; i++) {
            tests[i] = tests[i].split(' ');
            equalTest(tests[i][0], 'MMM', i);
            equalTest(tests[i][1], 'MMM', i);
            equalTest(tests[i][0], 'MMMM', i);
            equalTest(tests[i][1], 'MMMM', i);
            equalTest(tests[i][0].toLocaleLowerCase(), 'MMMM', i);
            equalTest(tests[i][1].toLocaleLowerCase(), 'MMMM', i);
            equalTest(tests[i][0].toLocaleUpperCase(), 'MMMM', i);
            equalTest(tests[i][1].toLocaleUpperCase(), 'MMMM', i);
        }
    });

    test('format', function (assert) {
        var a = [
                ['dddd [den] Do MMMM YYYY, h:mm:ss a', 'sÃ¸ndag den 14. februar 2010, 3:25:50 pm'],
                ['ddd hA',                             'sÃ¸n 3PM'],
                ['M Mo MM MMMM MMM',                   '2 2. 02 februar feb'],
                ['YYYY YY',                            '2010 10'],
                ['D Do DD',                            '14 14. 14'],
                ['d do dddd ddd dd',                   '0 0. sÃ¸ndag sÃ¸n sÃ¸'],
                ['DDD DDDo DDDD',                      '45 45. 045'],
                ['w wo ww',                            '6 6. 06'],
                ['h hh',                               '3 03'],
                ['H HH',                               '15 15'],
                ['m mm',                               '25 25'],
                ['s ss',                               '50 50'],
                ['a A',                                'pm PM'],
                ['[den] DDDo [dag pÃ¥ Ã¥ret]',           'den 45. dag pÃ¥ Ã¥ret'],
                ['LTS',                                '15:25:50'],
                ['L',                                  '14/02/2010'],
                ['LL',                                 '14. februar 2010'],
                ['LLL',                                '14. februar 2010 15:25'],
                ['LLLL',                               'sÃ¸ndag d. 14. februar 2010 15:25'],
                ['l',                                  '14/2/2010'],
                ['ll',                                 '14. feb 2010'],
                ['lll',                                '14. feb 2010 15:25'],
                ['llll',                               'sÃ¸n d. 14. feb 2010 15:25']
            ],
            b = moment(new Date(2010, 1, 14, 15, 25, 50, 125)),
            i;
        for (i = 0; i < a.length; i++) {
            assert.equal(b.format(a[i][0]), a[i][1], a[i][0] + ' ---> ' + a[i][1]);
        }
    });

    test('format ordinal', function (assert) {
        assert.equal(moment([2011, 0, 1]).format('DDDo'), '1.', '1.');
        assert.equal(moment([2011, 0, 2]).format('DDDo'), '2.', '2.');
        assert.equal(moment([2011, 0, 3]).format('DDDo'), '3.', '3.');
        assert.equal(moment([2011, 0, 4]).format('DDDo'), '4.', '4.');
        assert.equal(moment([2011, 0, 5]).format('DDDo'), '5.', '5.');
        assert.equal(moment([2011, 0, 6]).format('DDDo'), '6.', '6.');
        assert.equal(moment([2011, 0, 7]).format('DDDo'), '7.', '7.');
        assert.equal(moment([2011, 0, 8]).format('DDDo'), '8.', '8.');
        assert.equal(moment([2011, 0, 9]).format('DDDo'), '9.', '9.');
        assert.equal(moment([2011, 0, 10]).format('DDDo'), '10.', '10.');

        assert.equal(moment([2011, 0, 11]).format('DDDo'), '11.', '11.');
        assert.equal(moment([2011, 0, 12]).format('DDDo'), '12.', '12.');
        assert.equal(moment([2011, 0, 13]).format('DDDo'), '13.', '13.');
        assert.equal(moment([2011, 0, 14]).format('DDDo'), '14.', '14.');
        assert.equal(moment([2011, 0, 15]).format('DDDo'), '15.', '15.');
        assert.equal(moment([2011, 0, 16]).format('DDDo'), '16.', '16.');
        assert.equal(moment([2011, 0, 17]).format('DDDo'), '17.', '17.');
        assert.equal(moment([2011, 0, 18]).format('DDDo'), '18.', '18.');
        assert.equal(moment([2011, 0, 19]).format('DDDo'), '19.', '19.');
        assert.equal(moment([2011, 0, 20]).format('DDDo'), '20.', '20.');

        assert.equal(moment([2011, 0, 21]).format('DDDo'), '21.', '21.');
        assert.equal(moment([2011, 0, 22]).format('DDDo'), '22.', '22.');
        assert.equal(moment([2011, 0, 23]).format('DDDo'), '23.', '23.');
        assert.equal(moment([2011, 0, 24]).format('DDDo'), '24.', '24.');
        assert.equal(moment([2011, 0, 25]).format('DDDo'), '25.', '25.');
        assert.equal(moment([2011, 0, 26]).format('DDDo'), '26.', '26.');
        assert.equal(moment([2011, 0, 27]).format('DDDo'), '27.', '27.');
        assert.equal(moment([2011, 0, 28]).format('DDDo'), '28.', '28.');
        assert.equal(moment([2011, 0, 29]).format('DDDo'), '29.', '29.');
        assert.equal(moment([2011, 0, 30]).format('DDDo'), '30.', '30.');

        assert.equal(moment([2011, 0, 31]).format('DDDo'), '31.', '31.');
    });

    test('format month', function (assert) {
        var expected = 'januar jan_februar feb_marts mar_april apr_maj maj_juni jun_juli jul_august aug_september sep_oktober okt_november nov_december dec'.split('_'), i;
        for (i = 0; i < expected.length; i++) {
            assert.equal(moment([2011, i, 1]).format('MMMM MMM'), expected[i], expected[i]);
        }
    });

    test('format week', function (assert) {
        var expected = 'sÃ¸ndag sÃ¸n sÃ¸_mandag man ma_tirsdag tir ti_onsdag ons on_torsdag tor to_fredag fre fr_lÃ¸rdag lÃ¸r lÃ¸'.split('_'), i;
        for (i = 0; i < expected.length; i++) {
            assert.equal(moment([2011, 0, 2 + i]).format('dddd ddd dd'), expected[i], expected[i]);
        }
    });

    test('from', function (assert) {
        var start = moment([2007, 1, 28]);
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 44}), true),  'fÃ¥ sekunder', '44 seconds = a few seconds');
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 45}), true),  'et minut',    '45 seconds = a minute');
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 89}), true),  'et minut',    '89 seconds = a minute');
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 90}), true),  '2 minutter',  '90 seconds = 2 minutes');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 44}), true),  '44 minutter', '44 minutes = 44 minutes');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 45}), true),  'en time',     '45 minutes = an hour');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 89}), true),  'en time',     '89 minutes = an hour');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 90}), true),  '2 timer',     '90 minutes = 2 hours');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 5}), true),   '5 timer',     '5 hours = 5 hours');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 21}), true),  '21 timer',    '21 hours = 21 hours');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 22}), true),  'en dag',      '22 hours = a day');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 35}), true),  'en dag',      '35 hours = a day');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 36}), true),  '2 dage',      '36 hours = 2 days');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 1}), true),   'en dag',      '1 day = a day');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 5}), true),   '5 dage',      '5 days = 5 days');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 25}), true),  '25 dage',     '25 days = 25 days');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 26}), true),  'en mÃ¥ned',    '26 days = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 30}), true),  'en mÃ¥ned',    '30 days = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 43}), true),  'en mÃ¥ned',    '43 days = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 46}), true),  '2 mÃ¥neder',   '46 days = 2 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 74}), true),  '2 mÃ¥neder',   '75 days = 2 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 76}), true),  '3 mÃ¥neder',   '76 days = 3 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({M: 1}), true),   'en mÃ¥ned',    '1 month = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({M: 5}), true),   '5 mÃ¥neder',   '5 months = 5 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 345}), true), 'et Ã¥r',       '345 days = a year');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 548}), true), '2 Ã¥r',        '548 days = 2 years');
        assert.equal(start.from(moment([2007, 1, 28]).add({y: 1}), true),   'et Ã¥r',       '1 year = a year');
        assert.equal(start.from(moment([2007, 1, 28]).add({y: 5}), true),   '5 Ã¥r',        '5 years = 5 years');
    });

    test('suffix', function (assert) {
        assert.equal(moment(30000).from(0), 'om fÃ¥ sekunder',  'prefix');
        assert.equal(moment(0).from(30000), 'fÃ¥ sekunder siden', 'suffix');
    });

    test('now from now', function (assert) {
        assert.equal(moment().fromNow(), 'fÃ¥ sekunder siden',  'now from now should display as in the past');
    });

    test('fromNow', function (assert) {
        assert.equal(moment().add({s: 30}).fromNow(), 'om fÃ¥ sekunder', 'in a few seconds');
        assert.equal(moment().add({d: 5}).fromNow(), 'om 5 dage', 'in 5 days');
    });


    test('calendar day', function (assert) {
        var a = moment().hours(12).minutes(0).seconds(0);

        assert.equal(moment(a).calendar(),                   'I dag kl. 12:00',    'today at the same time');
        assert.equal(moment(a).add({m: 25}).calendar(),      'I dag kl. 12:25',    'Now plus 25 min');
        assert.equal(moment(a).add({h: 1}).calendar(),       'I dag kl. 13:00',    'Now plus 1 hour');
        assert.equal(moment(a).add({d: 1}).calendar(),       'I morgen kl. 12:00', 'tomorrow at the same time');
        assert.equal(moment(a).subtract({h: 1}).calendar(),  'I dag kl. 11:00',    'Now minus 1 hour');
        assert.equal(moment(a).subtract({d: 1}).calendar(),  'I gÃ¥r kl. 12:00',    'yesterday at the same time');
    });

    test('calendar next week', function (assert) {
        var i, m;

        for (i = 2; i < 7; i++) {
            m = moment().add({d: i});
            assert.equal(m.calendar(),       m.format('dddd [kl.] LT'),  'Today + ' + i + ' days current time');
            m.hours(0).minutes(0).seconds(0).milliseconds(0);
            assert.equal(m.calendar(),       m.format('dddd [kl.] LT'),  'Today + ' + i + ' days beginning of day');
            m.hours(23).minutes(59).seconds(59).milliseconds(999);
            assert.equal(m.calendar(),       m.format('dddd [kl.] LT'),  'Today + ' + i + ' days end of day');
        }
    });

    test('calendar last week', function (assert) {
        var i, m;

        for (i = 2; i < 7; i++) {
            m = moment().subtract({d: i});
            assert.equal(m.calendar(),       m.format('[sidste] dddd [kl] LT'),  'Today - ' + i + ' days current time');
            m.hours(0).minutes(0).seconds(0).milliseconds(0);
            assert.equal(m.calendar(),       m.format('[sidste] dddd [kl] LT'),  'Today - ' + i + ' days beginning of day');
            m.hours(23).minutes(59).seconds(59).milliseconds(999);
            assert.equal(m.calendar(),       m.format('[sidste] dddd [kl] LT'),  'Today - ' + i + ' days end of day');
        }
    });

    test('calendar all else', function (assert) {
        var weeksAgo = moment().subtract({w: 1}),
            weeksFromNow = moment().add({w: 1});

        assert.equal(weeksAgo.calendar(),       weeksAgo.format('L'),  '1 week ago');
        assert.equal(weeksFromNow.calendar(),   weeksFromNow.format('L'),  'in 1 week');

        weeksAgo = moment().subtract({w: 2});
        weeksFromNow = moment().add({w: 2});

        assert.equal(weeksAgo.calendar(),       weeksAgo.format('L'),  '2 weeks ago');
        assert.equal(weeksFromNow.calendar(),   weeksFromNow.format('L'),  'in 2 weeks');
    });

    test('weeks year starting sunday formatted', function (assert) {
        assert.equal(moment([2012, 0,  1]).format('w ww wo'), '52 52 52.', 'Jan  1 2012 should be week 52');
        assert.equal(moment([2012, 0,  2]).format('w ww wo'),   '1 01 1.', 'Jan  2 2012 should be week 1');
        assert.equal(moment([2012, 0,  8]).format('w ww wo'),   '1 01 1.', 'Jan  8 2012 should be week 1');
        assert.equal(moment([2012, 0,  9]).format('w ww wo'),   '2 02 2.', 'Jan  9 2012 should be week 2');
        assert.equal(moment([2012, 0, 15]).format('w ww wo'),   '2 02 2.', 'Jan 15 2012 should be week 2');
    });

}));

;(function (global, factory) {
   typeof exports === 'object' && typeof module !== 'undefined'
       && typeof require === 'function' ? factory(require('../../moment')) :
   typeof define === 'function' && define.amd ? define(['../../moment'], factory) :
   factory(global.moment)
}(this, function (moment) { 'use strict';

    function each(array, callback) {
        var i;
        for (i = 0; i < array.length; i++) {
            callback(array[i], i, array);
        }
    }

    function objectKeys(obj) {
        if (Object.keys) {
            return Object.keys(obj);
        } else {
            // IE8
            var res = [], i;
            for (i in obj) {
                if (obj.hasOwnProperty(i)) {
                    res.push(i);
                }
            }
            return res;
        }
    }

    // Pick the first defined of two or three arguments.
    function defaults(a, b, c) {
        if (a != null) {
            return a;
        }
        if (b != null) {
            return b;
        }
        return c;
    }

    function defineCommonLocaleTests(locale, options) {
        test('lenient ordinal parsing', function (assert) {
            var i, ordinalStr, testMoment;
            for (i = 1; i <= 31; ++i) {
                ordinalStr = moment([2014, 0, i]).format('YYYY MM Do');
                testMoment = moment(ordinalStr, 'YYYY MM Do');
                assert.equal(testMoment.year(), 2014,
                        'lenient ordinal parsing ' + i + ' year check');
                assert.equal(testMoment.month(), 0,
                        'lenient ordinal parsing ' + i + ' month check');
                assert.equal(testMoment.date(), i,
                        'lenient ordinal parsing ' + i + ' date check');
            }
        });

        test('lenient ordinal parsing of number', function (assert) {
            var i, testMoment;
            for (i = 1; i <= 31; ++i) {
                testMoment = moment('2014 01 ' + i, 'YYYY MM Do');
                assert.equal(testMoment.year(), 2014,
                        'lenient ordinal parsing of number ' + i + ' year check');
                assert.equal(testMoment.month(), 0,
                        'lenient ordinal parsing of number ' + i + ' month check');
                assert.equal(testMoment.date(), i,
                        'lenient ordinal parsing of number ' + i + ' date check');
            }
        });

        test('strict ordinal parsing', function (assert) {
            var i, ordinalStr, testMoment;
            for (i = 1; i <= 31; ++i) {
                ordinalStr = moment([2014, 0, i]).format('YYYY MM Do');
                testMoment = moment(ordinalStr, 'YYYY MM Do', true);
                assert.ok(testMoment.isValid(), 'strict ordinal parsing ' + i);
            }
        });

        test('meridiem invariant', function (assert) {
            var h, m, t1, t2;
            for (h = 0; h < 24; ++h) {
                for (m = 0; m < 60; m += 15) {
                    t1 = moment.utc([2000, 0, 1, h, m]);
                    t2 = moment.utc(t1.format('A h:mm'), 'A h:mm');
                    assert.equal(t2.format('HH:mm'), t1.format('HH:mm'),
                            'meridiem at ' + t1.format('HH:mm'));
                }
            }
        });

        test('date format correctness', function (assert) {
            var data, tokens;
            data = moment.localeData()._longDateFormat;
            tokens = objectKeys(data);
            each(tokens, function (srchToken) {
                // Check each format string to make sure it does not contain any
                // tokens that need to be expanded.
                each(tokens, function (baseToken) {
                    // strip escaped sequences
                    var format = data[baseToken].replace(/(\[[^\]]*\])/g, '');
                    assert.equal(false, !!~format.indexOf(srchToken),
                            'contains ' + srchToken + ' in ' + baseToken);
                });
            });
        });

        test('month parsing correctness', function (assert) {
            var i, m;

            if (locale === 'tr') {
                // I can't fix it :(
                expect(0);
                return;
            }
            function tester(format) {
                var r;
                r = moment(m.format(format), format);
                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format);
                r = moment(m.format(format).toLocaleUpperCase(), format);
                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' upper');
                r = moment(m.format(format).toLocaleLowerCase(), format);
                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' lower');

                r = moment(m.format(format), format, true);
                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' strict');
                r = moment(m.format(format).toLocaleUpperCase(), format, true);
                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' upper strict');
                r = moment(m.format(format).toLocaleLowerCase(), format, true);
                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' lower strict');
            }

            for (i = 0; i < 12; ++i) {
                m = moment([2015, i, 15, 18]);
                tester('MMM');
                tester('MMM.');
                tester('MMMM');
                tester('MMMM.');
            }
        });

        test('weekday parsing correctness', function (assert) {
            var i, m;

            if (locale === 'tr' || locale === 'az') {
                // There is a lower-case letter (Ä±), that converted to upper then
                // lower changes to i
                expect(0);
                return;
            }
            function tester(format) {
                var r, baseMsg = 'weekday ' + m.weekday() + ' fmt ' + format;
                r = moment(m.format(format), format);
                assert.equal(r.weekday(), m.weekday(), baseMsg);
                r = moment(m.format(format).toLocaleUpperCase(), format);
                assert.equal(r.weekday(), m.weekday(), baseMsg + ' upper');
                r = moment(m.format(format).toLocaleLowerCase(), format);
                assert.equal(r.weekday(), m.weekday(), baseMsg + ' lower');

                r = moment(m.format(format), format, true);
                assert.equal(r.weekday(), m.weekday(), baseMsg + ' strict');
                r = moment(m.format(format).toLocaleUpperCase(), format, true);
                assert.equal(r.weekday(), m.weekday(), baseMsg + ' upper strict');
                r = moment(m.format(format).toLocaleLowerCase(), format, true);
                assert.equal(r.weekday(), m.weekday(), baseMsg + ' lower strict');
            }

            for (i = 0; i < 7; ++i) {
                m = moment.utc([2015, i, 15, 18]);
                tester('dd');
                tester('ddd');
                tester('dddd');
            }
        });
    }

    function setupDeprecationHandler(test, moment, scope) {
        test._expectedDeprecations = null;
        test._observedDeprecations = null;
        test._oldSupress = moment.suppressDeprecationWarnings;
        moment.suppressDeprecationWarnings = true;
        test.expectedDeprecations = function () {
            test._expectedDeprecations = arguments;
            test._observedDeprecations = [];
        };
        moment.deprecationHandler = function (name, msg) {
            var deprecationId = matchedDeprecation(name, msg, test._expectedDeprecations);
            if (deprecationId === -1) {
                throw new Error('Unexpected deprecation thrown name=' +
                        name + ' msg=' + msg);
            }
            test._observedDeprecations[deprecationId] = 1;
        };
    }

    function teardownDeprecationHandler(test, moment, scope) {
        moment.suppressDeprecationWarnings = test._oldSupress;

        if (test._expectedDeprecations != null) {
            var missedDeprecations = [];
            each(test._expectedDeprecations, function (deprecationPattern, id) {
                if (test._observedDeprecations[id] !== 1) {
                    missedDeprecations.push(deprecationPattern);
                }
            });
            if (missedDeprecations.length !== 0) {
                throw new Error('Expected deprecation warnings did not happen: ' +
                        missedDeprecations.join(' '));
            }
        }
    }

    function matchedDeprecation(name, msg, deprecations) {
        if (deprecations == null) {
            return -1;
        }
        for (var i = 0; i < deprecations.length; ++i) {
            if (name != null && name === deprecations[i]) {
                return i;
            }
            if (msg != null && msg.substring(0, deprecations[i].length) === deprecations[i]) {
                return i;
            }
        }
        return -1;
    }

    /*global QUnit:false*/

    var test = QUnit.test;

    var expect = QUnit.expect;

    function module (name, lifecycle) {
        QUnit.module(name, {
            setup : function () {
                moment.locale('en');
                moment.createFromInputFallback = function (config) {
                    throw new Error('input not handled by moment: ' + config._i);
                };
                setupDeprecationHandler(test, moment, 'core');
                if (lifecycle && lifecycle.setup) {
                    lifecycle.setup();
                }
            },
            teardown : function () {
                teardownDeprecationHandler(test, moment, 'core');
                if (lifecycle && lifecycle.teardown) {
                    lifecycle.teardown();
                }
            }
        });
    }

    function localeModule (name, lifecycle) {
        QUnit.module('locale:' + name, {
            setup : function () {
                moment.locale(name);
                moment.createFromInputFallback = function (config) {
                    throw new Error('input not handled by moment: ' + config._i);
                };
                setupDeprecationHandler(test, moment, 'locale');
                if (lifecycle && lifecycle.setup) {
                    lifecycle.setup();
                }
            },
            teardown : function () {
                moment.locale('en');
                teardownDeprecationHandler(test, moment, 'locale');
                if (lifecycle && lifecycle.teardown) {
                    lifecycle.teardown();
                }
            }
        });
        defineCommonLocaleTests(name, -1, -1);
    }

    localeModule('de-at');

    test('parse', function (assert) {
        var tests = 'JÃ¤nner JÃ¤n._Februar Febr._MÃ¤rz Mrz._April Apr._Mai Mai_Juni Jun._Juli Jul._August Aug._September Sept._Oktober Okt._November Nov._Dezember Dez.'.split('_'), i;

        function equalTest(input, mmm, i) {
            assert.equal(moment(input, mmm).month(), i, input + ' should be month ' + (i + 1));
        }

        for (i = 0; i < 12; i++) {
            tests[i] = tests[i].split(' ');
            equalTest(tests[i][0], 'MMM', i);
            equalTest(tests[i][1], 'MMM', i);
            equalTest(tests[i][0], 'MMMM', i);
            equalTest(tests[i][1], 'MMMM', i);
            equalTest(tests[i][0].toLocaleLowerCase(), 'MMMM', i);
            equalTest(tests[i][1].toLocaleLowerCase(), 'MMMM', i);
            equalTest(tests[i][0].toLocaleUpperCase(), 'MMMM', i);
            equalTest(tests[i][1].toLocaleUpperCase(), 'MMMM', i);
        }
    });

    test('format', function (assert) {
        var a = [
                ['dddd, Do MMMM YYYY, h:mm:ss a', 'Sonntag, 14. Februar 2010, 3:25:50 pm'],
                ['ddd, hA', 'So., 3PM'],
                ['M Mo MM MMMM MMM', '2 2. 02 Februar Febr.'],
                ['YYYY YY', '2010 10'],
                ['D Do DD', '14 14. 14'],
                ['d do dddd ddd dd', '0 0. Sonntag So. So'],
                ['DDD DDDo DDDD', '45 45. 045'],
                ['w wo ww', '6 6. 06'],
                ['h hh', '3 03'],
                ['H HH', '15 15'],
                ['m mm', '25 25'],
                ['s ss', '50 50'],
                ['a A', 'pm PM'],
                ['[the] DDDo [day of the year]', 'the 45. day of the year'],
                ['LTS', '15:25:50'],
                ['L', '14.02.2010'],
                ['LL', '14. Februar 2010'],
                ['LLL', '14. Februar 2010 15:25'],
                ['LLLL', 'Sonntag, 14. Februar 2010 15:25'],
                ['l', '14.2.2010'],
                ['ll', '14. Febr. 2010'],
                ['lll', '14. Febr. 2010 15:25'],
                ['llll', 'So., 14. Febr. 2010 15:25']
            ],
            b = moment(new Date(2010, 1, 14, 15, 25, 50, 125)),
            i;
        for (i = 0; i < a.length; i++) {
            assert.equal(b.format(a[i][0]), a[i][1], a[i][0] + ' ---> ' + a[i][1]);
        }
    });

    test('format ordinal', function (assert) {
        assert.equal(moment([2011, 0, 1]).format('DDDo'), '1.', '1.');
        assert.equal(moment([2011, 0, 2]).format('DDDo'), '2.', '2.');
        assert.equal(moment([2011, 0, 3]).format('DDDo'), '3.', '3.');
        assert.equal(moment([2011, 0, 4]).format('DDDo'), '4.', '4.');
        assert.equal(moment([2011, 0, 5]).format('DDDo'), '5.', '5.');
        assert.equal(moment([2011, 0, 6]).format('DDDo'), '6.', '6.');
        assert.equal(moment([2011, 0, 7]).format('DDDo'), '7.', '7.');
        assert.equal(moment([2011, 0, 8]).format('DDDo'), '8.', '8.');
        assert.equal(moment([2011, 0, 9]).format('DDDo'), '9.', '9.');
        assert.equal(moment([2011, 0, 10]).format('DDDo'), '10.', '10.');

        assert.equal(moment([2011, 0, 11]).format('DDDo'), '11.', '11.');
        assert.equal(moment([2011, 0, 12]).format('DDDo'), '12.', '12.');
        assert.equal(moment([2011, 0, 13]).format('DDDo'), '13.', '13.');
        assert.equal(moment([2011, 0, 14]).format('DDDo'), '14.', '14.');
        assert.equal(moment([2011, 0, 15]).format('DDDo'), '15.', '15.');
        assert.equal(moment([2011, 0, 16]).format('DDDo'), '16.', '16.');
        assert.equal(moment([2011, 0, 17]).format('DDDo'), '17.', '17.');
        assert.equal(moment([2011, 0, 18]).format('DDDo'), '18.', '18.');
        assert.equal(moment([2011, 0, 19]).format('DDDo'), '19.', '19.');
        assert.equal(moment([2011, 0, 20]).format('DDDo'), '20.', '20.');

        assert.equal(moment([2011, 0, 21]).format('DDDo'), '21.', '21.');
        assert.equal(moment([2011, 0, 22]).format('DDDo'), '22.', '22.');
        assert.equal(moment([2011, 0, 23]).format('DDDo'), '23.', '23.');
        assert.equal(moment([2011, 0, 24]).format('DDDo'), '24.', '24.');
        assert.equal(moment([2011, 0, 25]).format('DDDo'), '25.', '25.');
        assert.equal(moment([2011, 0, 26]).format('DDDo'), '26.', '26.');
        assert.equal(moment([2011, 0, 27]).format('DDDo'), '27.', '27.');
        assert.equal(moment([2011, 0, 28]).format('DDDo'), '28.', '28.');
        assert.equal(moment([2011, 0, 29]).format('DDDo'), '29.', '29.');
        assert.equal(moment([2011, 0, 30]).format('DDDo'), '30.', '30.');

        assert.equal(moment([2011, 0, 31]).format('DDDo'), '31.', '31.');
    });

    test('format month', function (assert) {
        var expected = 'JÃ¤nner JÃ¤n._Februar Febr._MÃ¤rz Mrz._April Apr._Mai Mai_Juni Jun._Juli Jul._August Aug._September Sept._Oktober Okt._November Nov._Dezember Dez.'.split('_'), i;
        for (i = 0; i < expected.length; i++) {
            assert.equal(moment([2011, i, 1]).format('MMMM MMM'), expected[i], expected[i]);
        }
    });

    test('format week', function (assert) {
        var expected = 'Sonntag So. So_Montag Mo. Mo_Dienstag Di. Di_Mittwoch Mi. Mi_Donnerstag Do. Do_Freitag Fr. Fr_Samstag Sa. Sa'.split('_'), i;
        for (i = 0; i < expected.length; i++) {
            assert.equal(moment([2011, 0, 2 + i]).format('dddd ddd dd'), expected[i], expected[i]);
        }
    });

    test('from', function (assert) {
        var start = moment([2007, 1, 28]);
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 44}), true), 'ein paar Sekunden', '44 seconds = a few seconds');
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 45}), true), 'eine Minute', '45 seconds = a minute');
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 89}), true), 'eine Minute', '89 seconds = a minute');
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 90}), true), '2 Minuten', '90 seconds = 2 minutes');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 44}), true), '44 Minuten', '44 minutes = 44 minutes');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 45}), true), 'eine Stunde', '45 minutes = an hour');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 89}), true), 'eine Stunde', '89 minutes = an hour');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 90}), true), '2 Stunden', '90 minutes = 2 hours');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 5}), true), '5 Stunden', '5 hours = 5 hours');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 21}), true), '21 Stunden', '21 hours = 21 hours');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 22}), true), 'ein Tag', '22 hours = a day');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 35}), true), 'ein Tag', '35 hours = a day');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 36}), true), '2 Tage', '36 hours = 2 days');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 1}), true), 'ein Tag', '1 day = a day');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 5}), true), '5 Tage', '5 days = 5 days');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 25}), true), '25 Tage', '25 days = 25 days');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 26}), true), 'ein Monat', '26 days = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 30}), true), 'ein Monat', '30 days = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 46}), true), '2 Monate', '46 days = 2 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 74}), true), '2 Monate', '75 days = 2 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 76}), true), '3 Monate', '76 days = 3 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({M: 1}), true), 'ein Monat', '1 month = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({M: 5}), true), '5 Monate', '5 months = 5 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 345}), true), 'ein Jahr', '345 days = a year');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 548}), true), '2 Jahre', '548 days = 2 years');
        assert.equal(start.from(moment([2007, 1, 28]).add({y: 1}), true), 'ein Jahr', '1 year = a year');
        assert.equal(start.from(moment([2007, 1, 28]).add({y: 5}), true), '5 Jahre', '5 years = 5 years');
    });

    test('suffix', function (assert) {
        assert.equal(moment(30000).from(0), 'in ein paar Sekunden', 'prefix');
        assert.equal(moment(0).from(30000), 'vor ein paar Sekunden', 'suffix');
    });

    test('fromNow', function (assert) {
        assert.equal(moment().add({s: 30}).fromNow(), 'in ein paar Sekunden', 'in a few seconds');
        assert.equal(moment().add({d: 5}).fromNow(), 'in 5 Tagen', 'in 5 days');
    });

    test('calendar day', function (assert) {
        var a = moment().hours(12).minutes(0).seconds(0);

        assert.equal(moment(a).calendar(),                  'heute um 12:00 Uhr',   'today at the same time');
        assert.equal(moment(a).add({m: 25}).calendar(),     'heute um 12:25 Uhr',   'Now plus 25 min');
        assert.equal(moment(a).add({h: 1}).calendar(),      'heute um 13:00 Uhr',   'Now plus 1 hour');
        assert.equal(moment(a).add({d: 1}).calendar(),      'morgen um 12:00 Uhr',  'tomorrow at the same time');
        assert.equal(moment(a).subtract({h: 1}).calendar(), 'heute um 11:00 Uhr',   'Now minus 1 hour');
        assert.equal(moment(a).subtract({d: 1}).calendar(), 'gestern um 12:00 Uhr', 'yesterday at the same time');
    });

    test('calendar next week', function (assert) {
        var i, m;
        for (i = 2; i < 7; i++) {
            m = moment().add({d: i});
            assert.equal(m.calendar(), m.format('dddd [um] LT [Uhr]'), 'Today + ' + i + ' days current time');
            m.hours(0).minutes(0).seconds(0).milliseconds(0);
            assert.equal(m.calendar(), m.format('dddd [um] LT [Uhr]'), 'Today + ' + i + ' days beginning of day');
            m.hours(23).minutes(59).seconds(59).milliseconds(999);
            assert.equal(m.calendar(), m.format('dddd [um] LT [Uhr]'), 'Today + ' + i + ' days end of day');
        }
    });

    test('calendar last week', function (assert) {
        var i, m;
        for (i = 2; i < 7; i++) {
            m = moment().subtract({d: i});
            assert.equal(m.calendar(), m.format('[letzten] dddd [um] LT [Uhr]'), 'Today + ' + i + ' days current time');
            m.hours(0).minutes(0).seconds(0).milliseconds(0);
            assert.equal(m.calendar(), m.format('[letzten] dddd [um] LT [Uhr]'), 'Today + ' + i + ' days beginning of day');
            m.hours(23).minutes(59).seconds(59).milliseconds(999);
            assert.equal(m.calendar(), m.format('[letzten] dddd [um] LT [Uhr]'), 'Today + ' + i + ' days end of day');
        }
    });

    test('calendar all else', function (assert) {
        var weeksAgo = moment().subtract({w: 1}),
            weeksFromNow = moment().add({w: 1});

        assert.equal(weeksAgo.calendar(), weeksAgo.format('L'), '1 week ago');
        assert.equal(weeksFromNow.calendar(), weeksFromNow.format('L'), 'in 1 week');

        weeksAgo = moment().subtract({w: 2});
        weeksFromNow = moment().add({w: 2});

        assert.equal(weeksAgo.calendar(), weeksAgo.format('L'), '2 weeks ago');
        assert.equal(weeksFromNow.calendar(), weeksFromNow.format('L'), 'in 2 weeks');
    });

    test('weeks year starting sunday formatted', function (assert) {
        assert.equal(moment([2012, 0, 1]).format('w ww wo'), '52 52 52.', 'Jan  1 2012 should be week 52');
        assert.equal(moment([2012, 0, 2]).format('w ww wo'), '1 01 1.', 'Jan  2 2012 should be week 1');
        assert.equal(moment([2012, 0, 8]).format('w ww wo'), '1 01 1.', 'Jan  8 2012 should be week 1');
        assert.equal(moment([2012, 0, 9]).format('w ww wo'), '2 02 2.', 'Jan  9 2012 should be week 2');
        assert.equal(moment([2012, 0, 15]).format('w ww wo'), '2 02 2.', 'Jan 15 2012 should be week 2');
    });

}));

;(function (global, factory) {
   typeof exports === 'object' && typeof module !== 'undefined'
       && typeof require === 'function' ? factory(require('../../moment')) :
   typeof define === 'function' && define.amd ? define(['../../moment'], factory) :
   factory(global.moment)
}(this, function (moment) { 'use strict';

    function each(array, callback) {
        var i;
        for (i = 0; i < array.length; i++) {
            callback(array[i], i, array);
        }
    }

    function objectKeys(obj) {
        if (Object.keys) {
            return Object.keys(obj);
        } else {
            // IE8
            var res = [], i;
            for (i in obj) {
                if (obj.hasOwnProperty(i)) {
                    res.push(i);
                }
            }
            return res;
        }
    }

    // Pick the first defined of two or three arguments.
    function defaults(a, b, c) {
        if (a != null) {
            return a;
        }
        if (b != null) {
            return b;
        }
        return c;
    }

    function defineCommonLocaleTests(locale, options) {
        test('lenient ordinal parsing', function (assert) {
            var i, ordinalStr, testMoment;
            for (i = 1; i <= 31; ++i) {
                ordinalStr = moment([2014, 0, i]).format('YYYY MM Do');
                testMoment = moment(ordinalStr, 'YYYY MM Do');
                assert.equal(testMoment.year(), 2014,
                        'lenient ordinal parsing ' + i + ' year check');
                assert.equal(testMoment.month(), 0,
                        'lenient ordinal parsing ' + i + ' month check');
                assert.equal(testMoment.date(), i,
                        'lenient ordinal parsing ' + i + ' date check');
            }
        });

        test('lenient ordinal parsing of number', function (assert) {
            var i, testMoment;
            for (i = 1; i <= 31; ++i) {
                testMoment = moment('2014 01 ' + i, 'YYYY MM Do');
                assert.equal(testMoment.year(), 2014,
                        'lenient ordinal parsing of number ' + i + ' year check');
                assert.equal(testMoment.month(), 0,
                        'lenient ordinal parsing of number ' + i + ' month check');
                assert.equal(testMoment.date(), i,
                        'lenient ordinal parsing of number ' + i + ' date check');
            }
        });

        test('strict ordinal parsing', function (assert) {
            var i, ordinalStr, testMoment;
            for (i = 1; i <= 31; ++i) {
                ordinalStr = moment([2014, 0, i]).format('YYYY MM Do');
                testMoment = moment(ordinalStr, 'YYYY MM Do', true);
                assert.ok(testMoment.isValid(), 'strict ordinal parsing ' + i);
            }
        });

        test('meridiem invariant', function (assert) {
            var h, m, t1, t2;
            for (h = 0; h < 24; ++h) {
                for (m = 0; m < 60; m += 15) {
                    t1 = moment.utc([2000, 0, 1, h, m]);
                    t2 = moment.utc(t1.format('A h:mm'), 'A h:mm');
                    assert.equal(t2.format('HH:mm'), t1.format('HH:mm'),
                            'meridiem at ' + t1.format('HH:mm'));
                }
            }
        });

        test('date format correctness', function (assert) {
            var data, tokens;
            data = moment.localeData()._longDateFormat;
            tokens = objectKeys(data);
            each(tokens, function (srchToken) {
                // Check each format string to make sure it does not contain any
                // tokens that need to be expanded.
                each(tokens, function (baseToken) {
                    // strip escaped sequences
                    var format = data[baseToken].replace(/(\[[^\]]*\])/g, '');
                    assert.equal(false, !!~format.indexOf(srchToken),
                            'contains ' + srchToken + ' in ' + baseToken);
                });
            });
        });

        test('month parsing correctness', function (assert) {
            var i, m;

            if (locale === 'tr') {
                // I can't fix it :(
                expect(0);
                return;
            }
            function tester(format) {
                var r;
                r = moment(m.format(format), format);
                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format);
                r = moment(m.format(format).toLocaleUpperCase(), format);
                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' upper');
                r = moment(m.format(format).toLocaleLowerCase(), format);
                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' lower');

                r = moment(m.format(format), format, true);
                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' strict');
                r = moment(m.format(format).toLocaleUpperCase(), format, true);
                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' upper strict');
                r = moment(m.format(format).toLocaleLowerCase(), format, true);
                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' lower strict');
            }

            for (i = 0; i < 12; ++i) {
                m = moment([2015, i, 15, 18]);
                tester('MMM');
                tester('MMM.');
                tester('MMMM');
                tester('MMMM.');
            }
        });

        test('weekday parsing correctness', function (assert) {
            var i, m;

            if (locale === 'tr' || locale === 'az') {
                // There is a lower-case letter (Ä±), that converted to upper then
                // lower changes to i
                expect(0);
                return;
            }
            function tester(format) {
                var r, baseMsg = 'weekday ' + m.weekday() + ' fmt ' + format;
                r = moment(m.format(format), format);
                assert.equal(r.weekday(), m.weekday(), baseMsg);
                r = moment(m.format(format).toLocaleUpperCase(), format);
                assert.equal(r.weekday(), m.weekday(), baseMsg + ' upper');
                r = moment(m.format(format).toLocaleLowerCase(), format);
                assert.equal(r.weekday(), m.weekday(), baseMsg + ' lower');

                r = moment(m.format(format), format, true);
                assert.equal(r.weekday(), m.weekday(), baseMsg + ' strict');
                r = moment(m.format(format).toLocaleUpperCase(), format, true);
                assert.equal(r.weekday(), m.weekday(), baseMsg + ' upper strict');
                r = moment(m.format(format).toLocaleLowerCase(), format, true);
                assert.equal(r.weekday(), m.weekday(), baseMsg + ' lower strict');
            }

            for (i = 0; i < 7; ++i) {
                m = moment.utc([2015, i, 15, 18]);
                tester('dd');
                tester('ddd');
                tester('dddd');
            }
        });
    }

    function setupDeprecationHandler(test, moment, scope) {
        test._expectedDeprecations = null;
        test._observedDeprecations = null;
        test._oldSupress = moment.suppressDeprecationWarnings;
        moment.suppressDeprecationWarnings = true;
        test.expectedDeprecations = function () {
            test._expectedDeprecations = arguments;
            test._observedDeprecations = [];
        };
        moment.deprecationHandler = function (name, msg) {
            var deprecationId = matchedDeprecation(name, msg, test._expectedDeprecations);
            if (deprecationId === -1) {
                throw new Error('Unexpected deprecation thrown name=' +
                        name + ' msg=' + msg);
            }
            test._observedDeprecations[deprecationId] = 1;
        };
    }

    function teardownDeprecationHandler(test, moment, scope) {
        moment.suppressDeprecationWarnings = test._oldSupress;

        if (test._expectedDeprecations != null) {
            var missedDeprecations = [];
            each(test._expectedDeprecations, function (deprecationPattern, id) {
                if (test._observedDeprecations[id] !== 1) {
                    missedDeprecations.push(deprecationPattern);
                }
            });
            if (missedDeprecations.length !== 0) {
                throw new Error('Expected deprecation warnings did not happen: ' +
                        missedDeprecations.join(' '));
            }
        }
    }

    function matchedDeprecation(name, msg, deprecations) {
        if (deprecations == null) {
            return -1;
        }
        for (var i = 0; i < deprecations.length; ++i) {
            if (name != null && name === deprecations[i]) {
                return i;
            }
            if (msg != null && msg.substring(0, deprecations[i].length) === deprecations[i]) {
                return i;
            }
        }
        return -1;
    }

    /*global QUnit:false*/

    var test = QUnit.test;

    var expect = QUnit.expect;

    function module (name, lifecycle) {
        QUnit.module(name, {
            setup : function () {
                moment.locale('en');
                moment.createFromInputFallback = function (config) {
                    throw new Error('input not handled by moment: ' + config._i);
                };
                setupDeprecationHandler(test, moment, 'core');
                if (lifecycle && lifecycle.setup) {
                    lifecycle.setup();
                }
            },
            teardown : function () {
                teardownDeprecationHandler(test, moment, 'core');
                if (lifecycle && lifecycle.teardown) {
                    lifecycle.teardown();
                }
            }
        });
    }

    function localeModule (name, lifecycle) {
        QUnit.module('locale:' + name, {
            setup : function () {
                moment.locale(name);
                moment.createFromInputFallback = function (config) {
                    throw new Error('input not handled by moment: ' + config._i);
                };
                setupDeprecationHandler(test, moment, 'locale');
                if (lifecycle && lifecycle.setup) {
                    lifecycle.setup();
                }
            },
            teardown : function () {
                moment.locale('en');
                teardownDeprecationHandler(test, moment, 'locale');
                if (lifecycle && lifecycle.teardown) {
                    lifecycle.teardown();
                }
            }
        });
        defineCommonLocaleTests(name, -1, -1);
    }

    localeModule('de');

    test('parse', function (assert) {
        var tests = 'Januar Jan._Februar Febr._MÃ¤rz Mrz._April Apr._Mai Mai_Juni Jun._Juli Jul._August Aug._September Sept._Oktober Okt._November Nov._Dezember Dez.'.split('_'), i;
        function equalTest(input, mmm, i) {
            assert.equal(moment(input, mmm).month(), i, input + ' should be month ' + (i + 1));
        }
        for (i = 0; i < 12; i++) {
            tests[i] = tests[i].split(' ');
            equalTest(tests[i][0], 'MMM', i);
            equalTest(tests[i][1], 'MMM', i);
            equalTest(tests[i][0], 'MMMM', i);
            equalTest(tests[i][1], 'MMMM', i);
            equalTest(tests[i][0].toLocaleLowerCase(), 'MMMM', i);
            equalTest(tests[i][1].toLocaleLowerCase(), 'MMMM', i);
            equalTest(tests[i][0].toLocaleUpperCase(), 'MMMM', i);
            equalTest(tests[i][1].toLocaleUpperCase(), 'MMMM', i);
        }
    });

    test('format', function (assert) {
        var a = [
                ['dddd, Do MMMM YYYY, h:mm:ss a',      'Sonntag, 14. Februar 2010, 3:25:50 pm'],
                ['ddd, hA',                            'So., 3PM'],
                ['M Mo MM MMMM MMM',                   '2 2. 02 Februar Febr.'],
                ['YYYY YY',                            '2010 10'],
                ['D Do DD',                            '14 14. 14'],
                ['d do dddd ddd dd',                   '0 0. Sonntag So. So'],
                ['DDD DDDo DDDD',                      '45 45. 045'],
                ['w wo ww',                            '6 6. 06'],
                ['h hh',                               '3 03'],
                ['H HH',                               '15 15'],
                ['m mm',                               '25 25'],
                ['s ss',                               '50 50'],
                ['a A',                                'pm PM'],
                ['[the] DDDo [day of the year]',       'the 45. day of the year'],
                ['LTS',                                '15:25:50'],
                ['L',                                  '14.02.2010'],
                ['LL',                                 '14. Februar 2010'],
                ['LLL',                                '14. Februar 2010 15:25'],
                ['LLLL',                               'Sonntag, 14. Februar 2010 15:25'],
                ['l',                                  '14.2.2010'],
                ['ll',                                 '14. Febr. 2010'],
                ['lll',                                '14. Febr. 2010 15:25'],
                ['llll',                               'So., 14. Febr. 2010 15:25']
            ],
            b = moment(new Date(2010, 1, 14, 15, 25, 50, 125)),
            i;
        for (i = 0; i < a.length; i++) {
            assert.equal(b.format(a[i][0]), a[i][1], a[i][0] + ' ---> ' + a[i][1]);
        }
    });

    test('format ordinal', function (assert) {
        assert.equal(moment([2011, 0, 1]).format('DDDo'), '1.', '1.');
        assert.equal(moment([2011, 0, 2]).format('DDDo'), '2.', '2.');
        assert.equal(moment([2011, 0, 3]).format('DDDo'), '3.', '3.');
        assert.equal(moment([2011, 0, 4]).format('DDDo'), '4.', '4.');
        assert.equal(moment([2011, 0, 5]).format('DDDo'), '5.', '5.');
        assert.equal(moment([2011, 0, 6]).format('DDDo'), '6.', '6.');
        assert.equal(moment([2011, 0, 7]).format('DDDo'), '7.', '7.');
        assert.equal(moment([2011, 0, 8]).format('DDDo'), '8.', '8.');
        assert.equal(moment([2011, 0, 9]).format('DDDo'), '9.', '9.');
        assert.equal(moment([2011, 0, 10]).format('DDDo'), '10.', '10.');

        assert.equal(moment([2011, 0, 11]).format('DDDo'), '11.', '11.');
        assert.equal(moment([2011, 0, 12]).format('DDDo'), '12.', '12.');
        assert.equal(moment([2011, 0, 13]).format('DDDo'), '13.', '13.');
        assert.equal(moment([2011, 0, 14]).format('DDDo'), '14.', '14.');
        assert.equal(moment([2011, 0, 15]).format('DDDo'), '15.', '15.');
        assert.equal(moment([2011, 0, 16]).format('DDDo'), '16.', '16.');
        assert.equal(moment([2011, 0, 17]).format('DDDo'), '17.', '17.');
        assert.equal(moment([2011, 0, 18]).format('DDDo'), '18.', '18.');
        assert.equal(moment([2011, 0, 19]).format('DDDo'), '19.', '19.');
        assert.equal(moment([2011, 0, 20]).format('DDDo'), '20.', '20.');

        assert.equal(moment([2011, 0, 21]).format('DDDo'), '21.', '21.');
        assert.equal(moment([2011, 0, 22]).format('DDDo'), '22.', '22.');
        assert.equal(moment([2011, 0, 23]).format('DDDo'), '23.', '23.');
        assert.equal(moment([2011, 0, 24]).format('DDDo'), '24.', '24.');
        assert.equal(moment([2011, 0, 25]).format('DDDo'), '25.', '25.');
        assert.equal(moment([2011, 0, 26]).format('DDDo'), '26.', '26.');
        assert.equal(moment([2011, 0, 27]).format('DDDo'), '27.', '27.');
        assert.equal(moment([2011, 0, 28]).format('DDDo'), '28.', '28.');
        assert.equal(moment([2011, 0, 29]).format('DDDo'), '29.', '29.');
        assert.equal(moment([2011, 0, 30]).format('DDDo'), '30.', '30.');

        assert.equal(moment([2011, 0, 31]).format('DDDo'), '31.', '31.');
    });

    test('format month', function (assert) {
        var expected = 'Januar Jan._Februar Febr._MÃ¤rz Mrz._April Apr._Mai Mai_Juni Jun._Juli Jul._August Aug._September Sept._Oktober Okt._November Nov._Dezember Dez.'.split('_'), i;
        for (i = 0; i < expected.length; i++) {
            assert.equal(moment([2011, i, 1]).format('MMMM MMM'), expected[i], expected[i]);
        }
    });

    test('format week', function (assert) {
        var expected = 'Sonntag So. So_Montag Mo. Mo_Dienstag Di. Di_Mittwoch Mi. Mi_Donnerstag Do. Do_Freitag Fr. Fr_Samstag Sa. Sa'.split('_'), i;
        for (i = 0; i < expected.length; i++) {
            assert.equal(moment([2011, 0, 2 + i]).format('dddd ddd dd'), expected[i], expected[i]);
        }
    });

    test('from', function (assert) {
        var start = moment([2007, 1, 28]);
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 44}), true),  'ein paar Sekunden',  '44 seconds = a few seconds');
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 45}), true),  'eine Minute',       '45 seconds = a minute');
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 89}), true),  'eine Minute',       '89 seconds = a minute');
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 90}), true),  '2 Minuten',          '90 seconds = 2 minutes');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 44}), true),  '44 Minuten',         '44 minutes = 44 minutes');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 45}), true),  'eine Stunde',       '45 minutes = an hour');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 89}), true),  'eine Stunde',       '89 minutes = an hour');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 90}), true),  '2 Stunden',          '90 minutes = 2 hours');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 5}), true),   '5 Stunden',          '5 hours = 5 hours');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 21}), true),  '21 Stunden',         '21 hours = 21 hours');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 22}), true),  'ein Tag',          '22 hours = a day');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 35}), true),  'ein Tag',          '35 hours = a day');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 36}), true),  '2 Tage',            '36 hours = 2 days');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 1}), true),   'ein Tag',          '1 day = a day');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 5}), true),   '5 Tage',            '5 days = 5 days');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 25}), true),  '25 Tage',           '25 days = 25 days');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 26}), true),  'ein Monat',        '26 days = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 30}), true),  'ein Monat',        '30 days = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 43}), true),  'ein Monat',        '43 days = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 46}), true),  '2 Monate',          '46 days = 2 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 74}), true),  '2 Monate',          '75 days = 2 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 76}), true),  '3 Monate',          '76 days = 3 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({M: 1}), true),   'ein Monat',        '1 month = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({M: 5}), true),   '5 Monate',          '5 months = 5 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 345}), true), 'ein Jahr',         '345 days = a year');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 548}), true), '2 Jahre',           '548 days = 2 years');
        assert.equal(start.from(moment([2007, 1, 28]).add({y: 1}), true),   'ein Jahr',         '1 year = a year');
        assert.equal(start.from(moment([2007, 1, 28]).add({y: 5}), true),   '5 Jahre',           '5 years = 5 years');
    });

    test('suffix', function (assert) {
        assert.equal(moment(30000).from(0), 'in ein paar Sekunden', 'prefix');
        assert.equal(moment(0).from(30000), 'vor ein paar Sekunden', 'suffix');
    });

    test('fromNow', function (assert) {
        assert.equal(moment().add({s: 30}).fromNow(), 'in ein paar Sekunden', 'in a few seconds');
        assert.equal(moment().add({d: 5}).fromNow(), 'in 5 Tagen', 'in 5 days');
    });

    test('calendar day', function (assert) {
        var a = moment().hours(12).minutes(0).seconds(0);

        assert.equal(moment(a).calendar(),                   'heute um 12:00 Uhr',   'today at the same time');
        assert.equal(moment(a).add({m: 25}).calendar(),      'heute um 12:25 Uhr',   'Now plus 25 min');
        assert.equal(moment(a).add({h: 1}).calendar(),       'heute um 13:00 Uhr',   'Now plus 1 hour');
        assert.equal(moment(a).add({d: 1}).calendar(),       'morgen um 12:00 Uhr',  'tomorrow at the same time');
        assert.equal(moment(a).subtract({h: 1}).calendar(),  'heute um 11:00 Uhr',   'Now minus 1 hour');
        assert.equal(moment(a).subtract({d: 1}).calendar(),  'gestern um 12:00 Uhr', 'yesterday at the same time');
    });

    test('calendar next week', function (assert) {
        var i, m;
        for (i = 2; i < 7; i++) {
            m = moment().add({d: i});
            assert.equal(m.calendar(),       m.format('dddd [um] LT [Uhr]'),  'Today + ' + i + ' days current time');
            m.hours(0).minutes(0).seconds(0).milliseconds(0);
            assert.equal(m.calendar(),       m.format('dddd [um] LT [Uhr]'),  'Today + ' + i + ' days beginning of day');
            m.hours(23).minutes(59).seconds(59).milliseconds(999);
            assert.equal(m.calendar(),       m.format('dddd [um] LT [Uhr]'),  'Today + ' + i + ' days end of day');
        }
    });

    test('calendar last week', function (assert) {
        var i, m;
        for (i = 2; i < 7; i++) {
            m = moment().subtract({d: i});
            assert.equal(m.calendar(),       m.format('[letzten] dddd [um] LT [Uhr]'),  'Today + ' + i + ' days current time');
            m.hours(0).minutes(0).seconds(0).milliseconds(0);
            assert.equal(m.calendar(),       m.format('[letzten] dddd [um] LT [Uhr]'),  'Today + ' + i + ' days beginning of day');
            m.hours(23).minutes(59).seconds(59).milliseconds(999);
            assert.equal(m.calendar(),       m.format('[letzten] dddd [um] LT [Uhr]'),  'Today + ' + i + ' days end of day');
        }
    });

    test('calendar all else', function (assert) {
        var weeksAgo = moment().subtract({w: 1}),
            weeksFromNow = moment().add({w: 1});

        assert.equal(weeksAgo.calendar(),       weeksAgo.format('L'),  '1 week ago');
        assert.equal(weeksFromNow.calendar(),   weeksFromNow.format('L'),  'in 1 week');

        weeksAgo = moment().subtract({w: 2});
        weeksFromNow = moment().add({w: 2});

        assert.equal(weeksAgo.calendar(),       weeksAgo.format('L'),  '2 weeks ago');
        assert.equal(weeksFromNow.calendar(),   weeksFromNow.format('L'),  'in 2 weeks');
    });

    test('weeks year starting sunday formatted', function (assert) {
        assert.equal(moment([2012, 0,  1]).format('w ww wo'), '52 52 52.', 'Jan  1 2012 should be week 52');
        assert.equal(moment([2012, 0,  2]).format('w ww wo'),   '1 01 1.', 'Jan  2 2012 should be week 1');
        assert.equal(moment([2012, 0,  8]).format('w ww wo'),   '1 01 1.', 'Jan  8 2012 should be week 1');
        assert.equal(moment([2012, 0,  9]).format('w ww wo'),   '2 02 2.', 'Jan  9 2012 should be week 2');
        assert.equal(moment([2012, 0, 15]).format('w ww wo'),   '2 02 2.', 'Jan 15 2012 should be week 2');
    });

}));

;(function (global, factory) {
   typeof exports === 'object' && typeof module !== 'undefined'
       && typeof require === 'function' ? factory(require('../../moment')) :
   typeof define === 'function' && define.amd ? define(['../../moment'], factory) :
   factory(global.moment)
}(this, function (moment) { 'use strict';

    function each(array, callback) {
        var i;
        for (i = 0; i < array.length; i++) {
            callback(array[i], i, array);
        }
    }

    function objectKeys(obj) {
        if (Object.keys) {
            return Object.keys(obj);
        } else {
            // IE8
            var res = [], i;
            for (i in obj) {
                if (obj.hasOwnProperty(i)) {
                    res.push(i);
                }
            }
            return res;
        }
    }

    // Pick the first defined of two or three arguments.
    function defaults(a, b, c) {
        if (a != null) {
            return a;
        }
        if (b != null) {
            return b;
        }
        return c;
    }

    function defineCommonLocaleTests(locale, options) {
        test('lenient ordinal parsing', function (assert) {
            var i, ordinalStr, testMoment;
            for (i = 1; i <= 31; ++i) {
                ordinalStr = moment([2014, 0, i]).format('YYYY MM Do');
                testMoment = moment(ordinalStr, 'YYYY MM Do');
                assert.equal(testMoment.year(), 2014,
                        'lenient ordinal parsing ' + i + ' year check');
                assert.equal(testMoment.month(), 0,
                        'lenient ordinal parsing ' + i + ' month check');
                assert.equal(testMoment.date(), i,
                        'lenient ordinal parsing ' + i + ' date check');
            }
        });

        test('lenient ordinal parsing of number', function (assert) {
            var i, testMoment;
            for (i = 1; i <= 31; ++i) {
                testMoment = moment('2014 01 ' + i, 'YYYY MM Do');
                assert.equal(testMoment.year(), 2014,
                        'lenient ordinal parsing of number ' + i + ' year check');
                assert.equal(testMoment.month(), 0,
                        'lenient ordinal parsing of number ' + i + ' month check');
                assert.equal(testMoment.date(), i,
                        'lenient ordinal parsing of number ' + i + ' date check');
            }
        });

        test('strict ordinal parsing', function (assert) {
            var i, ordinalStr, testMoment;
            for (i = 1; i <= 31; ++i) {
                ordinalStr = moment([2014, 0, i]).format('YYYY MM Do');
                testMoment = moment(ordinalStr, 'YYYY MM Do', true);
                assert.ok(testMoment.isValid(), 'strict ordinal parsing ' + i);
            }
        });

        test('meridiem invariant', function (assert) {
            var h, m, t1, t2;
            for (h = 0; h < 24; ++h) {
                for (m = 0; m < 60; m += 15) {
                    t1 = moment.utc([2000, 0, 1, h, m]);
                    t2 = moment.utc(t1.format('A h:mm'), 'A h:mm');
                    assert.equal(t2.format('HH:mm'), t1.format('HH:mm'),
                            'meridiem at ' + t1.format('HH:mm'));
                }
            }
        });

        test('date format correctness', function (assert) {
            var data, tokens;
            data = moment.localeData()._longDateFormat;
            tokens = objectKeys(data);
            each(tokens, function (srchToken) {
                // Check each format string to make sure it does not contain any
                // tokens that need to be expanded.
                each(tokens, function (baseToken) {
                    // strip escaped sequences
                    var format = data[baseToken].replace(/(\[[^\]]*\])/g, '');
                    assert.equal(false, !!~format.indexOf(srchToken),
                            'contains ' + srchToken + ' in ' + baseToken);
                });
            });
        });

        test('month parsing correctness', function (assert) {
            var i, m;

            if (locale === 'tr') {
                // I can't fix it :(
                expect(0);
                return;
            }
            function tester(format) {
                var r;
                r = moment(m.format(format), format);
                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format);
                r = moment(m.format(format).toLocaleUpperCase(), format);
                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' upper');
                r = moment(m.format(format).toLocaleLowerCase(), format);
                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' lower');

                r = moment(m.format(format), format, true);
                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' strict');
                r = moment(m.format(format).toLocaleUpperCase(), format, true);
                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' upper strict');
                r = moment(m.format(format).toLocaleLowerCase(), format, true);
                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' lower strict');
            }

            for (i = 0; i < 12; ++i) {
                m = moment([2015, i, 15, 18]);
                tester('MMM');
                tester('MMM.');
                tester('MMMM');
                tester('MMMM.');
            }
        });

        test('weekday parsing correctness', function (assert) {
            var i, m;

            if (locale === 'tr' || locale === 'az') {
                // There is a lower-case letter (Ä±), that converted to upper then
                // lower changes to i
                expect(0);
                return;
            }
            function tester(format) {
                var r, baseMsg = 'weekday ' + m.weekday() + ' fmt ' + format;
                r = moment(m.format(format), format);
                assert.equal(r.weekday(), m.weekday(), baseMsg);
                r = moment(m.format(format).toLocaleUpperCase(), format);
                assert.equal(r.weekday(), m.weekday(), baseMsg + ' upper');
                r = moment(m.format(format).toLocaleLowerCase(), format);
                assert.equal(r.weekday(), m.weekday(), baseMsg + ' lower');

                r = moment(m.format(format), format, true);
                assert.equal(r.weekday(), m.weekday(), baseMsg + ' strict');
                r = moment(m.format(format).toLocaleUpperCase(), format, true);
                assert.equal(r.weekday(), m.weekday(), baseMsg + ' upper strict');
                r = moment(m.format(format).toLocaleLowerCase(), format, true);
                assert.equal(r.weekday(), m.weekday(), baseMsg + ' lower strict');
            }

            for (i = 0; i < 7; ++i) {
                m = moment.utc([2015, i, 15, 18]);
                tester('dd');
                tester('ddd');
                tester('dddd');
            }
        });
    }

    function setupDeprecationHandler(test, moment, scope) {
        test._expectedDeprecations = null;
        test._observedDeprecations = null;
        test._oldSupress = moment.suppressDeprecationWarnings;
        moment.suppressDeprecationWarnings = true;
        test.expectedDeprecations = function () {
            test._expectedDeprecations = arguments;
            test._observedDeprecations = [];
        };
        moment.deprecationHandler = function (name, msg) {
            var deprecationId = matchedDeprecation(name, msg, test._expectedDeprecations);
            if (deprecationId === -1) {
                throw new Error('Unexpected deprecation thrown name=' +
                        name + ' msg=' + msg);
            }
            test._observedDeprecations[deprecationId] = 1;
        };
    }

    function teardownDeprecationHandler(test, moment, scope) {
        moment.suppressDeprecationWarnings = test._oldSupress;

        if (test._expectedDeprecations != null) {
            var missedDeprecations = [];
            each(test._expectedDeprecations, function (deprecationPattern, id) {
                if (test._observedDeprecations[id] !== 1) {
                    missedDeprecations.push(deprecationPattern);
                }
            });
            if (missedDeprecations.length !== 0) {
                throw new Error('Expected deprecation warnings did not happen: ' +
                        missedDeprecations.join(' '));
            }
        }
    }

    function matchedDeprecation(name, msg, deprecations) {
        if (deprecations == null) {
            return -1;
        }
        for (var i = 0; i < deprecations.length; ++i) {
            if (name != null && name === deprecations[i]) {
                return i;
            }
            if (msg != null && msg.substring(0, deprecations[i].length) === deprecations[i]) {
                return i;
            }
        }
        return -1;
    }

    /*global QUnit:false*/

    var test = QUnit.test;

    var expect = QUnit.expect;

    function module (name, lifecycle) {
        QUnit.module(name, {
            setup : function () {
                moment.locale('en');
                moment.createFromInputFallback = function (config) {
                    throw new Error('input not handled by moment: ' + config._i);
                };
                setupDeprecationHandler(test, moment, 'core');
                if (lifecycle && lifecycle.setup) {
                    lifecycle.setup();
                }
            },
            teardown : function () {
                teardownDeprecationHandler(test, moment, 'core');
                if (lifecycle && lifecycle.teardown) {
                    lifecycle.teardown();
                }
            }
        });
    }

    function localeModule (name, lifecycle) {
        QUnit.module('locale:' + name, {
            setup : function () {
                moment.locale(name);
                moment.createFromInputFallback = function (config) {
                    throw new Error('input not handled by moment: ' + config._i);
                };
                setupDeprecationHandler(test, moment, 'locale');
                if (lifecycle && lifecycle.setup) {
                    lifecycle.setup();
                }
            },
            teardown : function () {
                moment.locale('en');
                teardownDeprecationHandler(test, moment, 'locale');
                if (lifecycle && lifecycle.teardown) {
                    lifecycle.teardown();
                }
            }
        });
        defineCommonLocaleTests(name, -1, -1);
    }

    localeModule('dv');

    test('parse', function (assert) {
        var i,
            tests = [
                'ÞÞ¬ÞÞªÞÞ¦ÞÞ©',
                'ÞÞ¬ÞÞ°ÞÞªÞÞ¦ÞÞ©',
                'ÞÞ§ÞÞ¨ÞÞª',
                'ÞÞ­ÞÞ°ÞÞ©ÞÞª',
                'ÞÞ­',
                'ÞÞ«ÞÞ°',
                'ÞÞªÞÞ¦ÞÞ¨',
                'ÞÞ¯ÞÞ¦ÞÞ°ÞÞª',
                'ÞÞ¬ÞÞ°ÞÞ¬ÞÞ°ÞÞ¦ÞÞª',
                'ÞÞ®ÞÞ°ÞÞ¯ÞÞ¦ÞÞª',
                'ÞÞ®ÞÞ¬ÞÞ°ÞÞ¦ÞÞª',
                'ÞÞ¨ÞÞ¬ÞÞ°ÞÞ¦ÞÞª'
            ];

        function equalTest(input, mmm, i) {
            assert.equal(moment(input, mmm).month(), i, input + ' should be month ' + (i + 1));
        }

        for (i = 0; i < 12; i++) {
            equalTest(tests[i], 'MMM', i);
            equalTest(tests[i], 'MMMM', i);
            equalTest(tests[i].toLocaleLowerCase(), 'MMMM', i);
            equalTest(tests[i].toLocaleUpperCase(), 'MMMM', i);
        }
    });

    test('format', function (assert) {
        var a = [
                ['dddd, MMMM Do YYYY, h:mm:ss a',      'ÞÞ§ÞÞ¨ÞÞ°ÞÞ¦Ø ÞÞ¬ÞÞ°ÞÞªÞÞ¦ÞÞ© 14 2010Ø 3:25:50 ÞÞ'],
                ['ddd, hA',                            'ÞÞ§ÞÞ¨ÞÞ°ÞÞ¦Ø 3ÞÞ'],
                ['M Mo MM MMMM MMM',                   '2 2 02 ÞÞ¬ÞÞ°ÞÞªÞÞ¦ÞÞ© ÞÞ¬ÞÞ°ÞÞªÞÞ¦ÞÞ©'],
                ['YYYY YY',                            '2010 10'],
                ['D Do DD',                            '14 14 14'],
                ['d do dddd ddd dd',                   '0 0 ÞÞ§ÞÞ¨ÞÞ°ÞÞ¦ ÞÞ§ÞÞ¨ÞÞ°ÞÞ¦ ÞÞ§ÞÞ¨'],
                ['DDD DDDo DDDD',                      '45 45 045'],
                ['w wo ww',                            '8 8 08'],
                ['h hh',                               '3 03'],
                ['H HH',                               '15 15'],
                ['m mm',                               '25 25'],
                ['s ss',                               '50 50'],
                ['a A',                                'ÞÞ ÞÞ'],
                ['LTS',                                '15:25:50'],
                ['L',                                  '14/2/2010'],
                ['LL',                                 '14 ÞÞ¬ÞÞ°ÞÞªÞÞ¦ÞÞ© 2010'],
                ['LLL',                                '14 ÞÞ¬ÞÞ°ÞÞªÞÞ¦ÞÞ© 2010 15:25'],
                ['LLLL',                               'ÞÞ§ÞÞ¨ÞÞ°ÞÞ¦ 14 ÞÞ¬ÞÞ°ÞÞªÞÞ¦ÞÞ© 2010 15:25'],
                ['l',                                  '14/2/2010'],
                ['ll',                                 '14 ÞÞ¬ÞÞ°ÞÞªÞÞ¦ÞÞ© 2010'],
                ['lll',                                '14 ÞÞ¬ÞÞ°ÞÞªÞÞ¦ÞÞ© 2010 15:25'],
                ['llll',                               'ÞÞ§ÞÞ¨ÞÞ°ÞÞ¦ 14 ÞÞ¬ÞÞ°ÞÞªÞÞ¦ÞÞ© 2010 15:25']
            ],
            b = moment(new Date(2010, 1, 14, 15, 25, 50, 125)),
            i;

        for (i = 0; i < a.length; i++) {
            assert.equal(b.format(a[i][0]), a[i][1], a[i][0] + ' ---> ' + a[i][1]);
        }
    });

    test('format month', function (assert) {
        var i,
            expected = [
                'ÞÞ¬ÞÞªÞÞ¦ÞÞ©',
                'ÞÞ¬ÞÞ°ÞÞªÞÞ¦ÞÞ©',
                'ÞÞ§ÞÞ¨ÞÞª',
                'ÞÞ­ÞÞ°ÞÞ©ÞÞª',
                'ÞÞ­',
                'ÞÞ«ÞÞ°',
                'ÞÞªÞÞ¦ÞÞ¨',
                'ÞÞ¯ÞÞ¦ÞÞ°ÞÞª',
                'ÞÞ¬ÞÞ°ÞÞ¬ÞÞ°ÞÞ¦ÞÞª',
                'ÞÞ®ÞÞ°ÞÞ¯ÞÞ¦ÞÞª',
                'ÞÞ®ÞÞ¬ÞÞ°ÞÞ¦ÞÞª',
                'ÞÞ¨ÞÞ¬ÞÞ°ÞÞ¦ÞÞª'
            ];

        for (i = 0; i < expected.length; i++) {
            assert.equal(moment([2011, i, 1]).format('MMMM'), expected[i]);
        }
    });

    test('format week', function (assert) {
        var i,
            expected = [
                'ÞÞ§ÞÞ¨ÞÞ°ÞÞ¦',
                'ÞÞ¯ÞÞ¦',
                'ÞÞ¦ÞÞ°ÞÞ§ÞÞ¦',
                'ÞÞªÞÞ¦',
                'ÞÞªÞÞ§ÞÞ°ÞÞ¦ÞÞ¨',
                'ÞÞªÞÞªÞÞª',
                'ÞÞ®ÞÞ¨ÞÞ¨ÞÞª'
            ];

        for (i = 0; i < expected.length; i++) {
            assert.equal(moment([2011, 0, 2 + i]).format('dddd'), expected[i]);
        }
    });


    test('from', function (assert) {
        var start = moment([2007, 1, 28]);
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 44}), true),  'ÞÞ¨ÞÞªÞÞ°ÞÞªÞÞ®ÞÞ¬ÞÞ°',  '44 seconds = a few seconds');
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 45}), true),  'ÞÞ¨ÞÞ¨ÞÞ¬ÞÞ°',        '45 seconds = a minute');
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 89}), true),  'ÞÞ¨ÞÞ¨ÞÞ¬ÞÞ°',        '89 seconds = a minute');
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 90}), true),  'ÞÞ¨ÞÞ¨ÞÞª 2',        '90 seconds = 2 minutes');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 44}), true),  'ÞÞ¨ÞÞ¨ÞÞª 44',       '44 minutes = 44 minutes');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 45}), true),  'ÞÞ¦ÞÞ¨ÞÞ¨ÞÞ¬ÞÞ°',      '45 minutes = an hour');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 89}), true),  'ÞÞ¦ÞÞ¨ÞÞ¨ÞÞ¬ÞÞ°',      '89 minutes = an hour');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 90}), true),  'ÞÞ¦ÞÞ¨ÞÞ¨ÞÞª 2',      '90 minutes = 2 hours');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 5}), true),   'ÞÞ¦ÞÞ¨ÞÞ¨ÞÞª 5',      '5 hours = 5 hours');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 21}), true),  'ÞÞ¦ÞÞ¨ÞÞ¨ÞÞª 21',     '21 hours = 21 hours');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 22}), true),  'ÞÞªÞÞ¦ÞÞ¬ÞÞ°',        '22 hours = a day');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 35}), true),  'ÞÞªÞÞ¦ÞÞ¬ÞÞ°',        '35 hours = a day');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 36}), true),  'ÞÞªÞÞ¦ÞÞ° 2',        '36 hours = 2 days');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 1}), true),   'ÞÞªÞÞ¦ÞÞ¬ÞÞ°',        '1 day = a day');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 5}), true),   'ÞÞªÞÞ¦ÞÞ° 5',        '5 days = 5 days');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 25}), true),  'ÞÞªÞÞ¦ÞÞ° 25',       '25 days = 25 days');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 26}), true),  'ÞÞ¦ÞÞ¬ÞÞ°',          '26 days = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 30}), true),  'ÞÞ¦ÞÞ¬ÞÞ°',          '30 days = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 43}), true),  'ÞÞ¦ÞÞ¬ÞÞ°',          '43 days = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 46}), true),  'ÞÞ¦ÞÞ° 2',          '46 days = 2 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 74}), true),  'ÞÞ¦ÞÞ° 2',          '75 days = 2 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 76}), true),  'ÞÞ¦ÞÞ° 3',          '76 days = 3 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({M: 1}), true),   'ÞÞ¦ÞÞ¬ÞÞ°',          '1 month = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({M: 5}), true),   'ÞÞ¦ÞÞ° 5',          '5 months = 5 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 345}), true), 'ÞÞ¦ÞÞ¦ÞÞ¬ÞÞ°',        '345 days = a year');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 548}), true), 'ÞÞ¦ÞÞ¦ÞÞª 2',        '548 days = 2 years');
        assert.equal(start.from(moment([2007, 1, 28]).add({y: 1}), true),   'ÞÞ¦ÞÞ¦ÞÞ¬ÞÞ°',        '1 year = a year');
        assert.equal(start.from(moment([2007, 1, 28]).add({y: 5}), true),   'ÞÞ¦ÞÞ¦ÞÞª 5',        '5 years = 5 years');
    });

    test('suffix', function (assert) {
        assert.equal(moment(30000).from(0), 'ÞÞ¬ÞÞ­ÞÞ¦ÞÞ¨ ÞÞ¨ÞÞªÞÞ°ÞÞªÞÞ®ÞÞ¬ÞÞ°', 'prefix');
        assert.equal(moment(0).from(30000), 'ÞÞªÞÞ¨ÞÞ° ÞÞ¨ÞÞªÞÞ°ÞÞªÞÞ®ÞÞ¬ÞÞ°', 'suffix');
    });

    test('fromNow', function (assert) {
        assert.equal(moment().add({s: 30}).fromNow(), 'ÞÞ¬ÞÞ­ÞÞ¦ÞÞ¨ ÞÞ¨ÞÞªÞÞ°ÞÞªÞÞ®ÞÞ¬ÞÞ°', 'in a few seconds');
        assert.equal(moment().add({d: 5}).fromNow(), 'ÞÞ¬ÞÞ­ÞÞ¦ÞÞ¨ ÞÞªÞÞ¦ÞÞ° 5', 'in 5 days');
    });

    test('calendar day', function (assert) {
        var a = moment().hours(12).minutes(0).seconds(0);

        assert.equal(moment(a).calendar(),                   'ÞÞ¨ÞÞ¦ÞÞª 12:00',  'today at the same time');
        assert.equal(moment(a).add({m: 25}).calendar(),      'ÞÞ¨ÞÞ¦ÞÞª 12:25',  'Now plus 25 min');
        assert.equal(moment(a).add({h: 1}).calendar(),       'ÞÞ¨ÞÞ¦ÞÞª 13:00',  'Now plus 1 hour');
        assert.equal(moment(a).add({d: 1}).calendar(),       'ÞÞ§ÞÞ¦ÞÞ§ 12:00',  'tomorrow at the same time');
        assert.equal(moment(a).subtract({h: 1}).calendar(),  'ÞÞ¨ÞÞ¦ÞÞª 11:00',  'Now minus 1 hour');
        assert.equal(moment(a).subtract({d: 1}).calendar(),  'ÞÞ¨ÞÞ°ÞÞ¬ 12:00',  'yesterday at the same time');
    });

    test('calendar next week', function (assert) {
        var i, m;
        for (i = 2; i < 7; i++) {
            m = moment().add({d: i});
            assert.equal(m.calendar(),       m.format('dddd LT'),  'Today + ' + i + ' days current time');
            m.hours(0).minutes(0).seconds(0).milliseconds(0);
            assert.equal(m.calendar(),       m.format('dddd LT'),  'Today + ' + i + ' days beginning of day');
            m.hours(23).minutes(59).seconds(59).milliseconds(999);
            assert.equal(m.calendar(),       m.format('dddd LT'),  'Today + ' + i + ' days end of day');
        }
    });

    test('calendar last week', function (assert) {
        var i, m;
        for (i = 2; i < 7; i++) {
            m = moment().subtract({d: i});
            assert.equal(m.calendar(),       m.format('[ÞÞ§ÞÞ¨ÞÞªÞÞ¨] dddd LT'),  'Today + ' + i + ' days current time');
            m.hours(0).minutes(0).seconds(0).milliseconds(0);
            assert.equal(m.calendar(),       m.format('[ÞÞ§ÞÞ¨ÞÞªÞÞ¨] dddd LT'),  'Today + ' + i + ' days beginning of day');
            m.hours(23).minutes(59).seconds(59).milliseconds(999);
            assert.equal(m.calendar(),       m.format('[ÞÞ§ÞÞ¨ÞÞªÞÞ¨] dddd LT'),  'Today + ' + i + ' days end of day');
        }
    });

    test('calendar all else', function (assert) {
        var weeksAgo = moment().subtract({w: 1}),
            weeksFromNow = moment().add({w: 1});

        assert.equal(weeksAgo.calendar(),       weeksAgo.format('L'),  '1 week ago');
        assert.equal(weeksFromNow.calendar(),   weeksFromNow.format('L'),  'in 1 week');

        weeksAgo = moment().subtract({w: 2});
        weeksFromNow = moment().add({w: 2});

        assert.equal(weeksAgo.calendar(),       weeksAgo.format('L'),  '2 weeks ago');
        assert.equal(weeksFromNow.calendar(),   weeksFromNow.format('L'),  'in 2 weeks');
    });

    test('weeks year starting sunday formatted', function (assert) {
        assert.equal(moment([2012, 0,  1]).format('w ww wo'),   '1 01 1', 'Jan  1 2012 should be week 1');
        assert.equal(moment([2012, 0,  2]).format('w ww wo'),   '1 01 1', 'Jan  2 2012 should be week 1');
        assert.equal(moment([2012, 0,  8]).format('w ww wo'),   '2 02 2', 'Jan  8 2012 should be week 2');
        assert.equal(moment([2012, 0,  9]).format('w ww wo'),   '2 02 2', 'Jan  9 2012 should be week 2');
        assert.equal(moment([2012, 0, 15]).format('w ww wo'),   '3 03 3', 'Jan 15 2012 should be week 3');
    });

}));

;(function (global, factory) {
   typeof exports === 'object' && typeof module !== 'undefined'
       && typeof require === 'function' ? factory(require('../../moment')) :
   typeof define === 'function' && define.amd ? define(['../../moment'], factory) :
   factory(global.moment)
}(this, function (moment) { 'use strict';

    function each(array, callback) {
        var i;
        for (i = 0; i < array.length; i++) {
            callback(array[i], i, array);
        }
    }

    function objectKeys(obj) {
        if (Object.keys) {
            return Object.keys(obj);
        } else {
            // IE8
            var res = [], i;
            for (i in obj) {
                if (obj.hasOwnProperty(i)) {
                    res.push(i);
                }
            }
            return res;
        }
    }

    // Pick the first defined of two or three arguments.
    function defaults(a, b, c) {
        if (a != null) {
            return a;
        }
        if (b != null) {
            return b;
        }
        return c;
    }

    function defineCommonLocaleTests(locale, options) {
        test('lenient ordinal parsing', function (assert) {
            var i, ordinalStr, testMoment;
            for (i = 1; i <= 31; ++i) {
                ordinalStr = moment([2014, 0, i]).format('YYYY MM Do');
                testMoment = moment(ordinalStr, 'YYYY MM Do');
                assert.equal(testMoment.year(), 2014,
                        'lenient ordinal parsing ' + i + ' year check');
                assert.equal(testMoment.month(), 0,
                        'lenient ordinal parsing ' + i + ' month check');
                assert.equal(testMoment.date(), i,
                        'lenient ordinal parsing ' + i + ' date check');
            }
        });

        test('lenient ordinal parsing of number', function (assert) {
            var i, testMoment;
            for (i = 1; i <= 31; ++i) {
                testMoment = moment('2014 01 ' + i, 'YYYY MM Do');
                assert.equal(testMoment.year(), 2014,
                        'lenient ordinal parsing of number ' + i + ' year check');
                assert.equal(testMoment.month(), 0,
                        'lenient ordinal parsing of number ' + i + ' month check');
                assert.equal(testMoment.date(), i,
                        'lenient ordinal parsing of number ' + i + ' date check');
            }
        });

        test('strict ordinal parsing', function (assert) {
            var i, ordinalStr, testMoment;
            for (i = 1; i <= 31; ++i) {
                ordinalStr = moment([2014, 0, i]).format('YYYY MM Do');
                testMoment = moment(ordinalStr, 'YYYY MM Do', true);
                assert.ok(testMoment.isValid(), 'strict ordinal parsing ' + i);
            }
        });

        test('meridiem invariant', function (assert) {
            var h, m, t1, t2;
            for (h = 0; h < 24; ++h) {
                for (m = 0; m < 60; m += 15) {
                    t1 = moment.utc([2000, 0, 1, h, m]);
                    t2 = moment.utc(t1.format('A h:mm'), 'A h:mm');
                    assert.equal(t2.format('HH:mm'), t1.format('HH:mm'),
                            'meridiem at ' + t1.format('HH:mm'));
                }
            }
        });

        test('date format correctness', function (assert) {
            var data, tokens;
            data = moment.localeData()._longDateFormat;
            tokens = objectKeys(data);
            each(tokens, function (srchToken) {
                // Check each format string to make sure it does not contain any
                // tokens that need to be expanded.
                each(tokens, function (baseToken) {
                    // strip escaped sequences
                    var format = data[baseToken].replace(/(\[[^\]]*\])/g, '');
                    assert.equal(false, !!~format.indexOf(srchToken),
                            'contains ' + srchToken + ' in ' + baseToken);
                });
            });
        });

        test('month parsing correctness', function (assert) {
            var i, m;

            if (locale === 'tr') {
                // I can't fix it :(
                expect(0);
                return;
            }
            function tester(format) {
                var r;
                r = moment(m.format(format), format);
                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format);
                r = moment(m.format(format).toLocaleUpperCase(), format);
                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' upper');
                r = moment(m.format(format).toLocaleLowerCase(), format);
                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' lower');

                r = moment(m.format(format), format, true);
                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' strict');
                r = moment(m.format(format).toLocaleUpperCase(), format, true);
                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' upper strict');
                r = moment(m.format(format).toLocaleLowerCase(), format, true);
                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' lower strict');
            }

            for (i = 0; i < 12; ++i) {
                m = moment([2015, i, 15, 18]);
                tester('MMM');
                tester('MMM.');
                tester('MMMM');
                tester('MMMM.');
            }
        });

        test('weekday parsing correctness', function (assert) {
            var i, m;

            if (locale === 'tr' || locale === 'az') {
                // There is a lower-case letter (Ä±), that converted to upper then
                // lower changes to i
                expect(0);
                return;
            }
            function tester(format) {
                var r, baseMsg = 'weekday ' + m.weekday() + ' fmt ' + format;
                r = moment(m.format(format), format);
                assert.equal(r.weekday(), m.weekday(), baseMsg);
                r = moment(m.format(format).toLocaleUpperCase(), format);
                assert.equal(r.weekday(), m.weekday(), baseMsg + ' upper');
                r = moment(m.format(format).toLocaleLowerCase(), format);
                assert.equal(r.weekday(), m.weekday(), baseMsg + ' lower');

                r = moment(m.format(format), format, true);
                assert.equal(r.weekday(), m.weekday(), baseMsg + ' strict');
                r = moment(m.format(format).toLocaleUpperCase(), format, true);
                assert.equal(r.weekday(), m.weekday(), baseMsg + ' upper strict');
                r = moment(m.format(format).toLocaleLowerCase(), format, true);
                assert.equal(r.weekday(), m.weekday(), baseMsg + ' lower strict');
            }

            for (i = 0; i < 7; ++i) {
                m = moment.utc([2015, i, 15, 18]);
                tester('dd');
                tester('ddd');
                tester('dddd');
            }
        });
    }

    function setupDeprecationHandler(test, moment, scope) {
        test._expectedDeprecations = null;
        test._observedDeprecations = null;
        test._oldSupress = moment.suppressDeprecationWarnings;
        moment.suppressDeprecationWarnings = true;
        test.expectedDeprecations = function () {
            test._expectedDeprecations = arguments;
            test._observedDeprecations = [];
        };
        moment.deprecationHandler = function (name, msg) {
            var deprecationId = matchedDeprecation(name, msg, test._expectedDeprecations);
            if (deprecationId === -1) {
                throw new Error('Unexpected deprecation thrown name=' +
                        name + ' msg=' + msg);
            }
            test._observedDeprecations[deprecationId] = 1;
        };
    }

    function teardownDeprecationHandler(test, moment, scope) {
        moment.suppressDeprecationWarnings = test._oldSupress;

        if (test._expectedDeprecations != null) {
            var missedDeprecations = [];
            each(test._expectedDeprecations, function (deprecationPattern, id) {
                if (test._observedDeprecations[id] !== 1) {
                    missedDeprecations.push(deprecationPattern);
                }
            });
            if (missedDeprecations.length !== 0) {
                throw new Error('Expected deprecation warnings did not happen: ' +
                        missedDeprecations.join(' '));
            }
        }
    }

    function matchedDeprecation(name, msg, deprecations) {
        if (deprecations == null) {
            return -1;
        }
        for (var i = 0; i < deprecations.length; ++i) {
            if (name != null && name === deprecations[i]) {
                return i;
            }
            if (msg != null && msg.substring(0, deprecations[i].length) === deprecations[i]) {
                return i;
            }
        }
        return -1;
    }

    /*global QUnit:false*/

    var test = QUnit.test;

    var expect = QUnit.expect;

    function module (name, lifecycle) {
        QUnit.module(name, {
            setup : function () {
                moment.locale('en');
                moment.createFromInputFallback = function (config) {
                    throw new Error('input not handled by moment: ' + config._i);
                };
                setupDeprecationHandler(test, moment, 'core');
                if (lifecycle && lifecycle.setup) {
                    lifecycle.setup();
                }
            },
            teardown : function () {
                teardownDeprecationHandler(test, moment, 'core');
                if (lifecycle && lifecycle.teardown) {
                    lifecycle.teardown();
                }
            }
        });
    }

    function localeModule (name, lifecycle) {
        QUnit.module('locale:' + name, {
            setup : function () {
                moment.locale(name);
                moment.createFromInputFallback = function (config) {
                    throw new Error('input not handled by moment: ' + config._i);
                };
                setupDeprecationHandler(test, moment, 'locale');
                if (lifecycle && lifecycle.setup) {
                    lifecycle.setup();
                }
            },
            teardown : function () {
                moment.locale('en');
                teardownDeprecationHandler(test, moment, 'locale');
                if (lifecycle && lifecycle.teardown) {
                    lifecycle.teardown();
                }
            }
        });
        defineCommonLocaleTests(name, -1, -1);
    }

    localeModule('el');

    test('parse', function (assert) {
        var i,
            tests = 'ÎÎ±Î½Î¿ÏÎ¬ÏÎ¹Î¿Ï ÎÎ±Î½_Î¦ÎµÎ²ÏÎ¿ÏÎ¬ÏÎ¹Î¿Ï Î¦ÎµÎ²_ÎÎ¬ÏÏÎ¹Î¿Ï ÎÎ±Ï_ÎÏÏÎ¯Î»Î¹Î¿Ï ÎÏÏ_ÎÎ¬Î¹Î¿Ï ÎÎ±Ï_ÎÎ¿ÏÎ½Î¹Î¿Ï ÎÎ¿ÏÎ½_ÎÎ¿ÏÎ»Î¹Î¿Ï ÎÎ¿ÏÎ»_ÎÏÎ³Î¿ÏÏÏÎ¿Ï ÎÏÎ³_Î£ÎµÏÏÎ­Î¼Î²ÏÎ¹Î¿Ï Î£ÎµÏ_ÎÎºÏÏÎ²ÏÎ¹Î¿Ï ÎÎºÏ_ÎÎ¿Î­Î¼Î²ÏÎ¹Î¿Ï ÎÎ¿Îµ_ÎÎµÎºÎ­Î¼Î²ÏÎ¹Î¿Ï ÎÎµÎº'.split('_');

        function equalTest(input, mmm, i) {
            assert.equal(moment(input, mmm).month(), i, input + ' should be month ' + (i + 1));
        }

        for (i = 0; i < 12; i++) {
            tests[i] = tests[i].split(' ');
            equalTest(tests[i][0], 'MMM', i);
            equalTest(tests[i][1], 'MMM', i);
            equalTest(tests[i][0], 'MMMM', i);
            equalTest(tests[i][1], 'MMMM', i);
            equalTest(tests[i][0].toLocaleLowerCase(), 'MMMM', i);
            equalTest(tests[i][1].toLocaleLowerCase(), 'MMMM', i);
            equalTest(tests[i][0].toLocaleUpperCase(), 'MMMM', i);
            equalTest(tests[i][1].toLocaleUpperCase(), 'MMMM', i);
        }
    });

    test('parse meridiem', function (assert) {
        var i,
            b = moment(),
            meridiemTests = [
                // h a patterns, expected hours, isValid
                ['10 ÏÎ¼',   10, true],
                ['10 Î¼Î¼',   22, true],
                ['10 Ï.Î¼.', 10, true],
                ['10 Î¼.Î¼.', 22, true],
                ['10 Ï',    10, true],
                ['10 Î¼',    22, true],
                ['10 Î Î',   10, true],
                ['10 ÎÎ',   22, true],
                ['10 Î .Î.', 10, true],
                ['10 Î.Î.', 22, true],
                ['10 Î ',    10, true],
                ['10 Î',    22, true],
                ['10 am',   10, false],
                ['10 pm',   10, false]
            ],
            parsed;

        // test that a formatted moment including meridiem string can be parsed back to the same moment
        assert.ok(b.isSame(moment(b.format('h:mm:ss a'), 'h:mm:ss a', 'el', true), 'seconds'), b.format('h:mm:ss a') + ' should be equal to ' + moment(b.format('h:mm:ss a'), 'h:mm:ss a', 'el', true).format('h:mm:ss a'));

        // test that a formatted moment having a meridiem string can be parsed with strict flag
        assert.ok(moment(b.format('h:mm:ss a'), 'h:mm:ss a', 'el', true).isValid(), b.format('h:mm:ss a') + ' should be parsed as valid');

        for (i = 0; i < meridiemTests.length; i++) {
            parsed = moment(meridiemTests[i][0], 'h a', 'el', true);
            assert.equal(parsed.isValid(), meridiemTests[i][2], 'validity for ' + meridiemTests[i][0]);
            if (parsed.isValid()) {
                assert.equal(parsed.hours(), meridiemTests[i][1], 'hours for ' + meridiemTests[i][0]);
            }
        }
    });

    test('format', function (assert) {
        var a = [
                ['dddd, MMMM Do YYYY, h:mm:ss a',      'ÎÏÏÎ¹Î±ÎºÎ®, Î¦ÎµÎ²ÏÎ¿ÏÎ¬ÏÎ¹Î¿Ï 14Î· 2010, 3:25:50 Î¼Î¼'],
                ['dddd, D MMMM YYYY, h:mm:ss a',       'ÎÏÏÎ¹Î±ÎºÎ®, 14 Î¦ÎµÎ²ÏÎ¿ÏÎ±ÏÎ¯Î¿Ï 2010, 3:25:50 Î¼Î¼'],
                ['ddd, hA',                            'ÎÏÏ, 3ÎÎ'],
                ['dddd, MMMM YYYY',                    'ÎÏÏÎ¹Î±ÎºÎ®, Î¦ÎµÎ²ÏÎ¿ÏÎ¬ÏÎ¹Î¿Ï 2010'],
                ['M Mo MM MMMM MMM',                   '2 2Î· 02 Î¦ÎµÎ²ÏÎ¿ÏÎ¬ÏÎ¹Î¿Ï Î¦ÎµÎ²'],
                ['YYYY YY',                            '2010 10'],
                ['D Do DD',                            '14 14Î· 14'],
                ['d do dddd ddd dd',                   '0 0Î· ÎÏÏÎ¹Î±ÎºÎ® ÎÏÏ ÎÏ'],
                ['DDD DDDo DDDD',                      '45 45Î· 045'],
                ['w wo ww',                            '6 6Î· 06'],
                ['h hh',                               '3 03'],
                ['H HH',                               '15 15'],
                ['m mm',                               '25 25'],
                ['s ss',                               '50 50'],
                ['a A',                                'Î¼Î¼ ÎÎ'],
                ['[the] DDDo [day of the year]',       'the 45Î· day of the year'],
                ['LTS',                                '3:25:50 ÎÎ'],
                ['L',                                  '14/02/2010'],
                ['LL',                                 '14 Î¦ÎµÎ²ÏÎ¿ÏÎ±ÏÎ¯Î¿Ï 2010'],
                ['LLL',                                '14 Î¦ÎµÎ²ÏÎ¿ÏÎ±ÏÎ¯Î¿Ï 2010 3:25 ÎÎ'],
                ['LLLL',                               'ÎÏÏÎ¹Î±ÎºÎ®, 14 Î¦ÎµÎ²ÏÎ¿ÏÎ±ÏÎ¯Î¿Ï 2010 3:25 ÎÎ'],
                ['l',                                  '14/2/2010'],
                ['ll',                                 '14 Î¦ÎµÎ² 2010'],
                ['lll',                                '14 Î¦ÎµÎ² 2010 3:25 ÎÎ'],
                ['llll',                               'ÎÏÏ, 14 Î¦ÎµÎ² 2010 3:25 ÎÎ']
            ],
            b = moment(new Date(2010, 1, 14, 15, 25, 50, 125)),
            i;

        for (i = 0; i < a.length; i++) {
            assert.equal(b.format(a[i][0]), a[i][1], a[i][0] + ' ---> ' + a[i][1]);
        }
    });

    test('format ordinal', function (assert) {
        assert.equal(moment([2011, 0, 1]).format('DDDo'), '1Î·', '1Î·');
        assert.equal(moment([2011, 0, 2]).format('DDDo'), '2Î·', '2Î·');
        assert.equal(moment([2011, 0, 3]).format('DDDo'), '3Î·', '3Î·');
        assert.equal(moment([2011, 0, 4]).format('DDDo'), '4Î·', '4Î·');
        assert.equal(moment([2011, 0, 5]).format('DDDo'), '5Î·', '5Î·');
        assert.equal(moment([2011, 0, 6]).format('DDDo'), '6Î·', '6Î·');
        assert.equal(moment([2011, 0, 7]).format('DDDo'), '7Î·', '7Î·');
        assert.equal(moment([2011, 0, 8]).format('DDDo'), '8Î·', '8Î·');
        assert.equal(moment([2011, 0, 9]).format('DDDo'), '9Î·', '9Î·');
        assert.equal(moment([2011, 0, 10]).format('DDDo'), '10Î·', '10Î·');

        assert.equal(moment([2011, 0, 11]).format('DDDo'), '11Î·', '11Î·');
        assert.equal(moment([2011, 0, 12]).format('DDDo'), '12Î·', '12Î·');
        assert.equal(moment([2011, 0, 13]).format('DDDo'), '13Î·', '13Î·');
        assert.equal(moment([2011, 0, 14]).format('DDDo'), '14Î·', '14Î·');
        assert.equal(moment([2011, 0, 15]).format('DDDo'), '15Î·', '15Î·');
        assert.equal(moment([2011, 0, 16]).format('DDDo'), '16Î·', '16Î·');
        assert.equal(moment([2011, 0, 17]).format('DDDo'), '17Î·', '17Î·');
        assert.equal(moment([2011, 0, 18]).format('DDDo'), '18Î·', '18Î·');
        assert.equal(moment([2011, 0, 19]).format('DDDo'), '19Î·', '19Î·');
        assert.equal(moment([2011, 0, 20]).format('DDDo'), '20Î·', '20Î·');

        assert.equal(moment([2011, 0, 21]).format('DDDo'), '21Î·', '21Î·');
        assert.equal(moment([2011, 0, 22]).format('DDDo'), '22Î·', '22Î·');
        assert.equal(moment([2011, 0, 23]).format('DDDo'), '23Î·', '23Î·');
        assert.equal(moment([2011, 0, 24]).format('DDDo'), '24Î·', '24Î·');
        assert.equal(moment([2011, 0, 25]).format('DDDo'), '25Î·', '25Î·');
        assert.equal(moment([2011, 0, 26]).format('DDDo'), '26Î·', '26Î·');
        assert.equal(moment([2011, 0, 27]).format('DDDo'), '27Î·', '27Î·');
        assert.equal(moment([2011, 0, 28]).format('DDDo'), '28Î·', '28Î·');
        assert.equal(moment([2011, 0, 29]).format('DDDo'), '29Î·', '29Î·');
        assert.equal(moment([2011, 0, 30]).format('DDDo'), '30Î·', '30Î·');

        assert.equal(moment([2011, 0, 31]).format('DDDo'), '31Î·', '31Î·');
    });

    test('format month', function (assert) {
        var i,
            expected = 'ÎÎ±Î½Î¿ÏÎ¬ÏÎ¹Î¿Ï ÎÎ±Î½_Î¦ÎµÎ²ÏÎ¿ÏÎ¬ÏÎ¹Î¿Ï Î¦ÎµÎ²_ÎÎ¬ÏÏÎ¹Î¿Ï ÎÎ±Ï_ÎÏÏÎ¯Î»Î¹Î¿Ï ÎÏÏ_ÎÎ¬Î¹Î¿Ï ÎÎ±Ï_ÎÎ¿ÏÎ½Î¹Î¿Ï ÎÎ¿ÏÎ½_ÎÎ¿ÏÎ»Î¹Î¿Ï ÎÎ¿ÏÎ»_ÎÏÎ³Î¿ÏÏÏÎ¿Ï ÎÏÎ³_Î£ÎµÏÏÎ­Î¼Î²ÏÎ¹Î¿Ï Î£ÎµÏ_ÎÎºÏÏÎ²ÏÎ¹Î¿Ï ÎÎºÏ_ÎÎ¿Î­Î¼Î²ÏÎ¹Î¿Ï ÎÎ¿Îµ_ÎÎµÎºÎ­Î¼Î²ÏÎ¹Î¿Ï ÎÎµÎº'.split('_');

        for (i = 0; i < expected.length; i++) {
            assert.equal(moment([2011, i, 1]).format('MMMM MMM'), expected[i], expected[i]);
        }
    });

    test('format week', function (assert) {
        var i,
            expected = 'ÎÏÏÎ¹Î±ÎºÎ® ÎÏÏ ÎÏ_ÎÎµÏÏÎ­ÏÎ± ÎÎµÏ ÎÎµ_Î¤ÏÎ¯ÏÎ· Î¤ÏÎ¹ Î¤Ï_Î¤ÎµÏÎ¬ÏÏÎ· Î¤ÎµÏ Î¤Îµ_Î Î­Î¼ÏÏÎ· Î ÎµÎ¼ Î Îµ_Î Î±ÏÎ±ÏÎºÎµÏÎ® Î Î±Ï Î Î±_Î£Î¬Î²Î²Î±ÏÎ¿ Î£Î±Î² Î£Î±'.split('_');

        for (i = 0; i < expected.length; i++) {
            assert.equal(moment([2011, 0, 2 + i]).format('dddd ddd dd'), expected[i], expected[i]);
        }
    });

    test('from', function (assert) {
        var start = moment([2007, 1, 28]);

        assert.equal(start.from(moment([2007, 1, 28]).add({s: 44}), true),  'Î»Î¯Î³Î± Î´ÎµÏÏÎµÏÏÎ»ÎµÏÏÎ±',   '44 seconds = a few seconds');
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 45}), true),  'Î­Î½Î± Î»ÎµÏÏÏ',           '45 seconds = a minute');
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 89}), true),  'Î­Î½Î± Î»ÎµÏÏÏ',           '89 seconds = a minute');
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 90}), true),  '2 Î»ÎµÏÏÎ¬',             '90 seconds = 2 minutes');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 44}), true),  '44 Î»ÎµÏÏÎ¬',            '44 minutes = 44 minutes');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 45}), true),  'Î¼Î¯Î± ÏÏÎ±',             '45 minutes = an hour');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 89}), true),  'Î¼Î¯Î± ÏÏÎ±',             '89 minutes = an hour');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 90}), true),  '2 ÏÏÎµÏ',              '90 minutes = 2 hours');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 5}), true),   '5 ÏÏÎµÏ',              '5 hours = 5 hours');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 21}), true),  '21 ÏÏÎµÏ',             '21 hours = 21 hours');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 22}), true),  'Î¼Î¯Î± Î¼Î­ÏÎ±',            '22 hours = a day');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 35}), true),  'Î¼Î¯Î± Î¼Î­ÏÎ±',            '35 hours = a day');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 36}), true),  '2 Î¼Î­ÏÎµÏ',             '36 hours = 2 days');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 1}), true),   'Î¼Î¯Î± Î¼Î­ÏÎ±',            '1 day = a day');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 5}), true),   '5 Î¼Î­ÏÎµÏ',             '5 days = 5 days');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 25}), true),  '25 Î¼Î­ÏÎµÏ',            '25 days = 25 days');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 26}), true),  'Î­Î½Î±Ï Î¼Î®Î½Î±Ï',          '26 days = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 30}), true),  'Î­Î½Î±Ï Î¼Î®Î½Î±Ï',          '30 days = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 43}), true),  'Î­Î½Î±Ï Î¼Î®Î½Î±Ï',          '43 days = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 46}), true),  '2 Î¼Î®Î½ÎµÏ',             '46 days = 2 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 74}), true),  '2 Î¼Î®Î½ÎµÏ',             '75 days = 2 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 76}), true),  '3 Î¼Î®Î½ÎµÏ',             '76 days = 3 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({M: 1}), true),   'Î­Î½Î±Ï Î¼Î®Î½Î±Ï',          '1 month = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({M: 5}), true),   '5 Î¼Î®Î½ÎµÏ',             '5 months = 5 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 345}), true), 'Î­Î½Î±Ï ÏÏÏÎ½Î¿Ï',         '345 days = a year');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 548}), true), '2 ÏÏÏÎ½Î¹Î±',            '548 days = 2 years');
        assert.equal(start.from(moment([2007, 1, 28]).add({y: 1}), true),   'Î­Î½Î±Ï ÏÏÏÎ½Î¿Ï',         '1 year = a year');
        assert.equal(start.from(moment([2007, 1, 28]).add({y: 5}), true),   '5 ÏÏÏÎ½Î¹Î±',            '5 years = 5 years');
    });

    test('suffix', function (assert) {
        assert.equal(moment(30000).from(0), 'ÏÎµ Î»Î¯Î³Î± Î´ÎµÏÏÎµÏÏÎ»ÎµÏÏÎ±',  'prefix');
        assert.equal(moment(0).from(30000), 'Î»Î¯Î³Î± Î´ÎµÏÏÎµÏÏÎ»ÎµÏÏÎ± ÏÏÎ¹Î½', 'suffix');
    });

    test('now from now', function (assert) {
        assert.equal(moment().fromNow(), 'Î»Î¯Î³Î± Î´ÎµÏÏÎµÏÏÎ»ÎµÏÏÎ± ÏÏÎ¹Î½',  'now from now should display as in the past');
    });

    test('fromNow', function (assert) {
        assert.equal(moment().add({s: 30}).fromNow(), 'ÏÎµ Î»Î¯Î³Î± Î´ÎµÏÏÎµÏÏÎ»ÎµÏÏÎ±', 'in a few seconds');
        assert.equal(moment().add({d: 5}).fromNow(), 'ÏÎµ 5 Î¼Î­ÏÎµÏ', 'in 5 days');
    });

    test('calendar day', function (assert) {
        var a = moment().hours(12).minutes(0).seconds(0);

        assert.equal(moment(a).calendar(),                   'Î£Î®Î¼ÎµÏÎ± ÏÏÎ¹Ï 12:00 ÎÎ',     'today at the same time');
        assert.equal(moment(a).add({m: 25}).calendar(),      'Î£Î®Î¼ÎµÏÎ± ÏÏÎ¹Ï 12:25 ÎÎ',     'Now plus 25 min');
        assert.equal(moment(a).add({h: 1}).calendar(),       'Î£Î®Î¼ÎµÏÎ± ÏÏÎ· 1:00 ÎÎ',      'Now plus 1 hour');
        assert.equal(moment(a).add({d: 1}).calendar(),       'ÎÏÏÎ¹Î¿ ÏÏÎ¹Ï 12:00 ÎÎ',      'tomorrow at the same time');
        assert.equal(moment(a).subtract({h: 1}).calendar(),  'Î£Î®Î¼ÎµÏÎ± ÏÏÎ¹Ï 11:00 Î Î',      'Now minus 1 hour');
        assert.equal(moment(a).subtract({d: 1}).calendar(),  'Î§Î¸ÎµÏ ÏÏÎ¹Ï 12:00 ÎÎ',       'yesterday at the same time');
    });

    test('calendar next week', function (assert) {
        var i, m;
        for (i = 2; i < 7; i++) {
            m = moment().add({d: i});
            assert.equal(m.calendar(),       m.format('dddd [' + (m.hours() % 12 === 1 ? 'ÏÏÎ·' : 'ÏÏÎ¹Ï') + '] LT'),  'Today + ' + i + ' days current time');
            m.hours(0).minutes(0).seconds(0).milliseconds(0);
            assert.equal(m.calendar(),       m.format('dddd [ÏÏÎ¹Ï] LT'),  'Today + ' + i + ' days beginning of day');
            m.hours(23).minutes(59).seconds(59).milliseconds(999);
            assert.equal(m.calendar(),       m.format('dddd [ÏÏÎ¹Ï] LT'),  'Today + ' + i + ' days end of day');
        }
    });

    test('calendar last week', function (assert) {
        var i, m, dayString;
        for (i = 2; i < 7; i++) {
            m = moment().subtract({d: i});
            dayString = m.day() === 6 ? '[ÏÎ¿ ÏÏÎ¿Î·Î³Î¿ÏÎ¼ÎµÎ½Î¿ Î£Î¬Î²Î²Î±ÏÎ¿]' : '[ÏÎ·Î½ ÏÏÎ¿Î·Î³Î¿ÏÎ¼ÎµÎ½Î·] dddd';
            assert.equal(m.calendar(),       m.format(dayString + ' [' + (m.hours() % 12 === 1 ? 'ÏÏÎ·' : 'ÏÏÎ¹Ï') + '] LT'),  'Today - ' + i + ' days current time');
            m.hours(1).minutes(30).seconds(0).milliseconds(0);
            assert.equal(m.calendar(),       m.format(dayString + ' [ÏÏÎ·] LT'),  'Today - ' + i + ' days one o clock');
            m.hours(0).minutes(0).seconds(0).milliseconds(0);
            assert.equal(m.calendar(),       m.format(dayString + ' [ÏÏÎ¹Ï] LT'),  'Today - ' + i + ' days beginning of day');
            m.hours(23).minutes(59).seconds(59).milliseconds(999);
            assert.equal(m.calendar(),       m.format(dayString + ' [ÏÏÎ¹Ï] LT'),  'Today - ' + i + ' days end of day');
        }
    });

    test('calendar all else', function (assert) {
        var weeksAgo = moment().subtract({w: 1}),
            weeksFromNow = moment().add({w: 1});

        assert.equal(weeksAgo.calendar(),       weeksAgo.format('L'),  '1 week ago');
        assert.equal(weeksFromNow.calendar(),   weeksFromNow.format('L'),  'in 1 week');

        weeksAgo = moment().subtract({w: 2});
        weeksFromNow = moment().add({w: 2});

        assert.equal(weeksAgo.calendar(),       weeksAgo.format('L'),  '2 weeks ago');
        assert.equal(weeksFromNow.calendar(),   weeksFromNow.format('L'),  'in 2 weeks');
    });

    test('weeks year starting sunday format', function (assert) {
        assert.equal(moment([2012, 0,  1]).format('w ww wo'), '52 52 52Î·', 'Jan  1 2012 should be week 52');
        assert.equal(moment([2012, 0,  7]).format('w ww wo'),   '1 01 1Î·', 'Jan  7 2012 should be week 1');
        assert.equal(moment([2012, 0,  8]).format('w ww wo'),   '1 01 1Î·', 'Jan  8 2012 should be week 1');
        assert.equal(moment([2012, 0, 14]).format('w ww wo'),   '2 02 2Î·', 'Jan 14 2012 should be week 2');
        assert.equal(moment([2012, 0, 15]).format('w ww wo'),   '2 02 2Î·', 'Jan 15 2012 should be week 2');
    });

}));

;(function (global, factory) {
   typeof exports === 'object' && typeof module !== 'undefined'
       && typeof require === 'function' ? factory(require('../../moment')) :
   typeof define === 'function' && define.amd ? define(['../../moment'], factory) :
   factory(global.moment)
}(this, function (moment) { 'use strict';

    function each(array, callback) {
        var i;
        for (i = 0; i < array.length; i++) {
            callback(array[i], i, array);
        }
    }

    function objectKeys(obj) {
        if (Object.keys) {
            return Object.keys(obj);
        } else {
            // IE8
            var res = [], i;
            for (i in obj) {
                if (obj.hasOwnProperty(i)) {
                    res.push(i);
                }
            }
            return res;
        }
    }

    // Pick the first defined of two or three arguments.
    function defaults(a, b, c) {
        if (a != null) {
            return a;
        }
        if (b != null) {
            return b;
        }
        return c;
    }

    function defineCommonLocaleTests(locale, options) {
        test('lenient ordinal parsing', function (assert) {
            var i, ordinalStr, testMoment;
            for (i = 1; i <= 31; ++i) {
                ordinalStr = moment([2014, 0, i]).format('YYYY MM Do');
                testMoment = moment(ordinalStr, 'YYYY MM Do');
                assert.equal(testMoment.year(), 2014,
                        'lenient ordinal parsing ' + i + ' year check');
                assert.equal(testMoment.month(), 0,
                        'lenient ordinal parsing ' + i + ' month check');
                assert.equal(testMoment.date(), i,
                        'lenient ordinal parsing ' + i + ' date check');
            }
        });

        test('lenient ordinal parsing of number', function (assert) {
            var i, testMoment;
            for (i = 1; i <= 31; ++i) {
                testMoment = moment('2014 01 ' + i, 'YYYY MM Do');
                assert.equal(testMoment.year(), 2014,
                        'lenient ordinal parsing of number ' + i + ' year check');
                assert.equal(testMoment.month(), 0,
                        'lenient ordinal parsing of number ' + i + ' month check');
                assert.equal(testMoment.date(), i,
                        'lenient ordinal parsing of number ' + i + ' date check');
            }
        });

        test('strict ordinal parsing', function (assert) {
            var i, ordinalStr, testMoment;
            for (i = 1; i <= 31; ++i) {
                ordinalStr = moment([2014, 0, i]).format('YYYY MM Do');
                testMoment = moment(ordinalStr, 'YYYY MM Do', true);
                assert.ok(testMoment.isValid(), 'strict ordinal parsing ' + i);
            }
        });

        test('meridiem invariant', function (assert) {
            var h, m, t1, t2;
            for (h = 0; h < 24; ++h) {
                for (m = 0; m < 60; m += 15) {
                    t1 = moment.utc([2000, 0, 1, h, m]);
                    t2 = moment.utc(t1.format('A h:mm'), 'A h:mm');
                    assert.equal(t2.format('HH:mm'), t1.format('HH:mm'),
                            'meridiem at ' + t1.format('HH:mm'));
                }
            }
        });

        test('date format correctness', function (assert) {
            var data, tokens;
            data = moment.localeData()._longDateFormat;
            tokens = objectKeys(data);
            each(tokens, function (srchToken) {
                // Check each format string to make sure it does not contain any
                // tokens that need to be expanded.
                each(tokens, function (baseToken) {
                    // strip escaped sequences
                    var format = data[baseToken].replace(/(\[[^\]]*\])/g, '');
                    assert.equal(false, !!~format.indexOf(srchToken),
                            'contains ' + srchToken + ' in ' + baseToken);
                });
            });
        });

        test('month parsing correctness', function (assert) {
            var i, m;

            if (locale === 'tr') {
                // I can't fix it :(
                expect(0);
                return;
            }
            function tester(format) {
                var r;
                r = moment(m.format(format), format);
                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format);
                r = moment(m.format(format).toLocaleUpperCase(), format);
                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' upper');
                r = moment(m.format(format).toLocaleLowerCase(), format);
                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' lower');

                r = moment(m.format(format), format, true);
                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' strict');
                r = moment(m.format(format).toLocaleUpperCase(), format, true);
                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' upper strict');
                r = moment(m.format(format).toLocaleLowerCase(), format, true);
                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' lower strict');
            }

            for (i = 0; i < 12; ++i) {
                m = moment([2015, i, 15, 18]);
                tester('MMM');
                tester('MMM.');
                tester('MMMM');
                tester('MMMM.');
            }
        });

        test('weekday parsing correctness', function (assert) {
            var i, m;

            if (locale === 'tr' || locale === 'az') {
                // There is a lower-case letter (Ä±), that converted to upper then
                // lower changes to i
                expect(0);
                return;
            }
            function tester(format) {
                var r, baseMsg = 'weekday ' + m.weekday() + ' fmt ' + format;
                r = moment(m.format(format), format);
                assert.equal(r.weekday(), m.weekday(), baseMsg);
                r = moment(m.format(format).toLocaleUpperCase(), format);
                assert.equal(r.weekday(), m.weekday(), baseMsg + ' upper');
                r = moment(m.format(format).toLocaleLowerCase(), format);
                assert.equal(r.weekday(), m.weekday(), baseMsg + ' lower');

                r = moment(m.format(format), format, true);
                assert.equal(r.weekday(), m.weekday(), baseMsg + ' strict');
                r = moment(m.format(format).toLocaleUpperCase(), format, true);
                assert.equal(r.weekday(), m.weekday(), baseMsg + ' upper strict');
                r = moment(m.format(format).toLocaleLowerCase(), format, true);
                assert.equal(r.weekday(), m.weekday(), baseMsg + ' lower strict');
            }

            for (i = 0; i < 7; ++i) {
                m = moment.utc([2015, i, 15, 18]);
                tester('dd');
                tester('ddd');
                tester('dddd');
            }
        });
    }

    function setupDeprecationHandler(test, moment, scope) {
        test._expectedDeprecations = null;
        test._observedDeprecations = null;
        test._oldSupress = moment.suppressDeprecationWarnings;
        moment.suppressDeprecationWarnings = true;
        test.expectedDeprecations = function () {
            test._expectedDeprecations = arguments;
            test._observedDeprecations = [];
        };
        moment.deprecationHandler = function (name, msg) {
            var deprecationId = matchedDeprecation(name, msg, test._expectedDeprecations);
            if (deprecationId === -1) {
                throw new Error('Unexpected deprecation thrown name=' +
                        name + ' msg=' + msg);
            }
            test._observedDeprecations[deprecationId] = 1;
        };
    }

    function teardownDeprecationHandler(test, moment, scope) {
        moment.suppressDeprecationWarnings = test._oldSupress;

        if (test._expectedDeprecations != null) {
            var missedDeprecations = [];
            each(test._expectedDeprecations, function (deprecationPattern, id) {
                if (test._observedDeprecations[id] !== 1) {
                    missedDeprecations.push(deprecationPattern);
                }
            });
            if (missedDeprecations.length !== 0) {
                throw new Error('Expected deprecation warnings did not happen: ' +
                        missedDeprecations.join(' '));
            }
        }
    }

    function matchedDeprecation(name, msg, deprecations) {
        if (deprecations == null) {
            return -1;
        }
        for (var i = 0; i < deprecations.length; ++i) {
            if (name != null && name === deprecations[i]) {
                return i;
            }
            if (msg != null && msg.substring(0, deprecations[i].length) === deprecations[i]) {
                return i;
            }
        }
        return -1;
    }

    /*global QUnit:false*/

    var test = QUnit.test;

    var expect = QUnit.expect;

    function module (name, lifecycle) {
        QUnit.module(name, {
            setup : function () {
                moment.locale('en');
                moment.createFromInputFallback = function (config) {
                    throw new Error('input not handled by moment: ' + config._i);
                };
                setupDeprecationHandler(test, moment, 'core');
                if (lifecycle && lifecycle.setup) {
                    lifecycle.setup();
                }
            },
            teardown : function () {
                teardownDeprecationHandler(test, moment, 'core');
                if (lifecycle && lifecycle.teardown) {
                    lifecycle.teardown();
                }
            }
        });
    }

    function localeModule (name, lifecycle) {
        QUnit.module('locale:' + name, {
            setup : function () {
                moment.locale(name);
                moment.createFromInputFallback = function (config) {
                    throw new Error('input not handled by moment: ' + config._i);
                };
                setupDeprecationHandler(test, moment, 'locale');
                if (lifecycle && lifecycle.setup) {
                    lifecycle.setup();
                }
            },
            teardown : function () {
                moment.locale('en');
                teardownDeprecationHandler(test, moment, 'locale');
                if (lifecycle && lifecycle.teardown) {
                    lifecycle.teardown();
                }
            }
        });
        defineCommonLocaleTests(name, -1, -1);
    }

    localeModule('en-au');

    test('parse', function (assert) {
        var tests = 'January Jan_February Feb_March Mar_April Apr_May May_June Jun_July Jul_August Aug_September Sep_October Oct_November Nov_December Dec'.split('_'), i;
        function equalTest(input, mmm, i) {
            assert.equal(moment(input, mmm).month(), i, input + ' should be month ' + (i + 1));
        }
        for (i = 0; i < 12; i++) {
            tests[i] = tests[i].split(' ');
            equalTest(tests[i][0], 'MMM', i);
            equalTest(tests[i][1], 'MMM', i);
            equalTest(tests[i][0], 'MMMM', i);
            equalTest(tests[i][1], 'MMMM', i);
            equalTest(tests[i][0].toLocaleLowerCase(), 'MMMM', i);
            equalTest(tests[i][1].toLocaleLowerCase(), 'MMMM', i);
            equalTest(tests[i][0].toLocaleUpperCase(), 'MMMM', i);
            equalTest(tests[i][1].toLocaleUpperCase(), 'MMMM', i);
        }
    });

    test('format', function (assert) {
        var a = [
                ['dddd, MMMM Do YYYY, h:mm:ss a',      'Sunday, February 14th 2010, 3:25:50 pm'],
                ['ddd, hA',                            'Sun, 3PM'],
                ['M Mo MM MMMM MMM',                   '2 2nd 02 February Feb'],
                ['YYYY YY',                            '2010 10'],
                ['D Do DD',                            '14 14th 14'],
                ['d do dddd ddd dd',                   '0 0th Sunday Sun Su'],
                ['DDD DDDo DDDD',                      '45 45th 045'],
                ['w wo ww',                            '6 6th 06'],
                ['h hh',                               '3 03'],
                ['H HH',                               '15 15'],
                ['m mm',                               '25 25'],
                ['s ss',                               '50 50'],
                ['a A',                                'pm PM'],
                ['[the] DDDo [day of the year]',       'the 45th day of the year'],
                ['LTS',                                '3:25:50 PM'],
                ['L',                                  '14/02/2010'],
                ['LL',                                 '14 February 2010'],
                ['LLL',                                '14 February 2010 3:25 PM'],
                ['LLLL',                               'Sunday, 14 February 2010 3:25 PM'],
                ['l',                                  '14/2/2010'],
                ['ll',                                 '14 Feb 2010'],
                ['lll',                                '14 Feb 2010 3:25 PM'],
                ['llll',                               'Sun, 14 Feb 2010 3:25 PM']
            ],
            b = moment(new Date(2010, 1, 14, 15, 25, 50, 125)),
            i;
        for (i = 0; i < a.length; i++) {
            assert.equal(b.format(a[i][0]), a[i][1], a[i][0] + ' ---> ' + a[i][1]);
        }
    });

    test('format ordinal', function (assert) {
        assert.equal(moment([2011, 0, 1]).format('DDDo'), '1st', '1st');
        assert.equal(moment([2011, 0, 2]).format('DDDo'), '2nd', '2nd');
        assert.equal(moment([2011, 0, 3]).format('DDDo'), '3rd', '3rd');
        assert.equal(moment([2011, 0, 4]).format('DDDo'), '4th', '4th');
        assert.equal(moment([2011, 0, 5]).format('DDDo'), '5th', '5th');
        assert.equal(moment([2011, 0, 6]).format('DDDo'), '6th', '6th');
        assert.equal(moment([2011, 0, 7]).format('DDDo'), '7th', '7th');
        assert.equal(moment([2011, 0, 8]).format('DDDo'), '8th', '8th');
        assert.equal(moment([2011, 0, 9]).format('DDDo'), '9th', '9th');
        assert.equal(moment([2011, 0, 10]).format('DDDo'), '10th', '10th');

        assert.equal(moment([2011, 0, 11]).format('DDDo'), '11th', '11th');
        assert.equal(moment([2011, 0, 12]).format('DDDo'), '12th', '12th');
        assert.equal(moment([2011, 0, 13]).format('DDDo'), '13th', '13th');
        assert.equal(moment([2011, 0, 14]).format('DDDo'), '14th', '14th');
        assert.equal(moment([2011, 0, 15]).format('DDDo'), '15th', '15th');
        assert.equal(moment([2011, 0, 16]).format('DDDo'), '16th', '16th');
        assert.equal(moment([2011, 0, 17]).format('DDDo'), '17th', '17th');
        assert.equal(moment([2011, 0, 18]).format('DDDo'), '18th', '18th');
        assert.equal(moment([2011, 0, 19]).format('DDDo'), '19th', '19th');
        assert.equal(moment([2011, 0, 20]).format('DDDo'), '20th', '20th');

        assert.equal(moment([2011, 0, 21]).format('DDDo'), '21st', '21st');
        assert.equal(moment([2011, 0, 22]).format('DDDo'), '22nd', '22nd');
        assert.equal(moment([2011, 0, 23]).format('DDDo'), '23rd', '23rd');
        assert.equal(moment([2011, 0, 24]).format('DDDo'), '24th', '24th');
        assert.equal(moment([2011, 0, 25]).format('DDDo'), '25th', '25th');
        assert.equal(moment([2011, 0, 26]).format('DDDo'), '26th', '26th');
        assert.equal(moment([2011, 0, 27]).format('DDDo'), '27th', '27th');
        assert.equal(moment([2011, 0, 28]).format('DDDo'), '28th', '28th');
        assert.equal(moment([2011, 0, 29]).format('DDDo'), '29th', '29th');
        assert.equal(moment([2011, 0, 30]).format('DDDo'), '30th', '30th');

        assert.equal(moment([2011, 0, 31]).format('DDDo'), '31st', '31st');
    });

    test('format month', function (assert) {
        var expected = 'January Jan_February Feb_March Mar_April Apr_May May_June Jun_July Jul_August Aug_September Sep_October Oct_November Nov_December Dec'.split('_'), i;
        for (i = 0; i < expected.length; i++) {
            assert.equal(moment([2011, i, 1]).format('MMMM MMM'), expected[i], expected[i]);
        }
    });

    test('format week', function (assert) {
        var expected = 'Sunday Sun Su_Monday Mon Mo_Tuesday Tue Tu_Wednesday Wed We_Thursday Thu Th_Friday Fri Fr_Saturday Sat Sa'.split('_'), i;
        for (i = 0; i < expected.length; i++) {
            assert.equal(moment([2011, 0, 2 + i]).format('dddd ddd dd'), expected[i], expected[i]);
        }
    });

    test('from', function (assert) {
        var start = moment([2007, 1, 28]);
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 44}), true),  'a few seconds', '44 seconds = a few seconds');
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 45}), true),  'a minute',      '45 seconds = a minute');
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 89}), true),  'a minute',      '89 seconds = a minute');
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 90}), true),  '2 minutes',     '90 seconds = 2 minutes');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 44}), true),  '44 minutes',    '44 minutes = 44 minutes');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 45}), true),  'an hour',       '45 minutes = an hour');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 89}), true),  'an hour',       '89 minutes = an hour');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 90}), true),  '2 hours',       '90 minutes = 2 hours');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 5}), true),   '5 hours',       '5 hours = 5 hours');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 21}), true),  '21 hours',      '21 hours = 21 hours');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 22}), true),  'a day',         '22 hours = a day');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 35}), true),  'a day',         '35 hours = a day');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 36}), true),  '2 days',        '36 hours = 2 days');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 1}), true),   'a day',         '1 day = a day');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 5}), true),   '5 days',        '5 days = 5 days');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 25}), true),  '25 days',       '25 days = 25 days');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 26}), true),  'a month',       '26 days = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 30}), true),  'a month',       '30 days = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 43}), true),  'a month',       '43 days = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 46}), true),  '2 months',      '46 days = 2 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 74}), true),  '2 months',      '75 days = 2 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 76}), true),  '3 months',      '76 days = 3 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({M: 1}), true),   'a month',       '1 month = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({M: 5}), true),   '5 months',      '5 months = 5 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 345}), true), 'a year',        '345 days = a year');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 548}), true), '2 years',       '548 days = 2 years');
        assert.equal(start.from(moment([2007, 1, 28]).add({y: 1}), true),   'a year',        '1 year = a year');
        assert.equal(start.from(moment([2007, 1, 28]).add({y: 5}), true),   '5 years',       '5 years = 5 years');
    });

    test('suffix', function (assert) {
        assert.equal(moment(30000).from(0), 'in a few seconds',  'prefix');
        assert.equal(moment(0).from(30000), 'a few seconds ago', 'suffix');
    });

    test('now from now', function (assert) {
        assert.equal(moment().fromNow(), 'a few seconds ago',  'now from now should display as in the past');
    });

    test('fromNow', function (assert) {
        assert.equal(moment().add({s: 30}).fromNow(), 'in a few seconds', 'in a few seconds');
        assert.equal(moment().add({d: 5}).fromNow(), 'in 5 days', 'in 5 days');
    });

    test('calendar day', function (assert) {
        var a = moment().hours(12).minutes(0).seconds(0);

        assert.equal(moment(a).calendar(),                   'Today at 12:00 PM',     'today at the same time');
        assert.equal(moment(a).add({m: 25}).calendar(),      'Today at 12:25 PM',     'Now plus 25 min');
        assert.equal(moment(a).add({h: 1}).calendar(),       'Today at 1:00 PM',      'Now plus 1 hour');
        assert.equal(moment(a).add({d: 1}).calendar(),       'Tomorrow at 12:00 PM',  'tomorrow at the same time');
        assert.equal(moment(a).subtract({h: 1}).calendar(),  'Today at 11:00 AM',     'Now minus 1 hour');
        assert.equal(moment(a).subtract({d: 1}).calendar(),  'Yesterday at 12:00 PM', 'yesterday at the same time');
    });

    test('calendar next week', function (assert) {
        var i, m;
        for (i = 2; i < 7; i++) {
            m = moment().add({d: i});
            assert.equal(m.calendar(),       m.format('dddd [at] LT'),  'Today + ' + i + ' days current time');
            m.hours(0).minutes(0).seconds(0).milliseconds(0);
            assert.equal(m.calendar(),       m.format('dddd [at] LT'),  'Today + ' + i + ' days beginning of day');
            m.hours(23).minutes(59).seconds(59).milliseconds(999);
            assert.equal(m.calendar(),       m.format('dddd [at] LT'),  'Today + ' + i + ' days end of day');
        }
    });

    test('calendar last week', function (assert) {
        var i, m;

        for (i = 2; i < 7; i++) {
            m = moment().subtract({d: i});
            assert.equal(m.calendar(),       m.format('[Last] dddd [at] LT'),  'Today - ' + i + ' days current time');
            m.hours(0).minutes(0).seconds(0).milliseconds(0);
            assert.equal(m.calendar(),       m.format('[Last] dddd [at] LT'),  'Today - ' + i + ' days beginning of day');
            m.hours(23).minutes(59).seconds(59).milliseconds(999);
            assert.equal(m.calendar(),       m.format('[Last] dddd [at] LT'),  'Today - ' + i + ' days end of day');
        }
    });

    test('calendar all else', function (assert) {
        var weeksAgo = moment().subtract({w: 1}),
            weeksFromNow = moment().add({w: 1});

        assert.equal(weeksAgo.calendar(),       weeksAgo.format('L'),  '1 week ago');
        assert.equal(weeksFromNow.calendar(),   weeksFromNow.format('L'),  'in 1 week');

        weeksAgo = moment().subtract({w: 2});
        weeksFromNow = moment().add({w: 2});

        assert.equal(weeksAgo.calendar(),       weeksAgo.format('L'),  '2 weeks ago');
        assert.equal(weeksFromNow.calendar(),   weeksFromNow.format('L'),  'in 2 weeks');
    });

    test('weeks year starting sunday formatted', function (assert) {
        assert.equal(moment([2012, 0,  1]).format('w ww wo'), '52 52 52nd', 'Jan  1 2012 should be week 52');
        assert.equal(moment([2012, 0,  2]).format('w ww wo'),   '1 01 1st', 'Jan  2 2012 should be week 1');
        assert.equal(moment([2012, 0,  8]).format('w ww wo'),   '1 01 1st', 'Jan  8 2012 should be week 1');
        assert.equal(moment([2012, 0,  9]).format('w ww wo'),   '2 02 2nd', 'Jan  9 2012 should be week 2');
        assert.equal(moment([2012, 0, 15]).format('w ww wo'),   '2 02 2nd', 'Jan 15 2012 should be week 2');
    });

}));

;(function (global, factory) {
   typeof exports === 'object' && typeof module !== 'undefined'
       && typeof require === 'function' ? factory(require('../../moment')) :
   typeof define === 'function' && define.amd ? define(['../../moment'], factory) :
   factory(global.moment)
}(this, function (moment) { 'use strict';

    function each(array, callback) {
        var i;
        for (i = 0; i < array.length; i++) {
            callback(array[i], i, array);
        }
    }

    function objectKeys(obj) {
        if (Object.keys) {
            return Object.keys(obj);
        } else {
            // IE8
            var res = [], i;
            for (i in obj) {
                if (obj.hasOwnProperty(i)) {
                    res.push(i);
                }
            }
            return res;
        }
    }

    // Pick the first defined of two or three arguments.
    function defaults(a, b, c) {
        if (a != null) {
            return a;
        }
        if (b != null) {
            return b;
        }
        return c;
    }

    function defineCommonLocaleTests(locale, options) {
        test('lenient ordinal parsing', function (assert) {
            var i, ordinalStr, testMoment;
            for (i = 1; i <= 31; ++i) {
                ordinalStr = moment([2014, 0, i]).format('YYYY MM Do');
                testMoment = moment(ordinalStr, 'YYYY MM Do');
                assert.equal(testMoment.year(), 2014,
                        'lenient ordinal parsing ' + i + ' year check');
                assert.equal(testMoment.month(), 0,
                        'lenient ordinal parsing ' + i + ' month check');
                assert.equal(testMoment.date(), i,
                        'lenient ordinal parsing ' + i + ' date check');
            }
        });

        test('lenient ordinal parsing of number', function (assert) {
            var i, testMoment;
            for (i = 1; i <= 31; ++i) {
                testMoment = moment('2014 01 ' + i, 'YYYY MM Do');
                assert.equal(testMoment.year(), 2014,
                        'lenient ordinal parsing of number ' + i + ' year check');
                assert.equal(testMoment.month(), 0,
                        'lenient ordinal parsing of number ' + i + ' month check');
                assert.equal(testMoment.date(), i,
                        'lenient ordinal parsing of number ' + i + ' date check');
            }
        });

        test('strict ordinal parsing', function (assert) {
            var i, ordinalStr, testMoment;
            for (i = 1; i <= 31; ++i) {
                ordinalStr = moment([2014, 0, i]).format('YYYY MM Do');
                testMoment = moment(ordinalStr, 'YYYY MM Do', true);
                assert.ok(testMoment.isValid(), 'strict ordinal parsing ' + i);
            }
        });

        test('meridiem invariant', function (assert) {
            var h, m, t1, t2;
            for (h = 0; h < 24; ++h) {
                for (m = 0; m < 60; m += 15) {
                    t1 = moment.utc([2000, 0, 1, h, m]);
                    t2 = moment.utc(t1.format('A h:mm'), 'A h:mm');
                    assert.equal(t2.format('HH:mm'), t1.format('HH:mm'),
                            'meridiem at ' + t1.format('HH:mm'));
                }
            }
        });

        test('date format correctness', function (assert) {
            var data, tokens;
            data = moment.localeData()._longDateFormat;
            tokens = objectKeys(data);
            each(tokens, function (srchToken) {
                // Check each format string to make sure it does not contain any
                // tokens that need to be expanded.
                each(tokens, function (baseToken) {
                    // strip escaped sequences
                    var format = data[baseToken].replace(/(\[[^\]]*\])/g, '');
                    assert.equal(false, !!~format.indexOf(srchToken),
                            'contains ' + srchToken + ' in ' + baseToken);
                });
            });
        });

        test('month parsing correctness', function (assert) {
            var i, m;

            if (locale === 'tr') {
                // I can't fix it :(
                expect(0);
                return;
            }
            function tester(format) {
                var r;
                r = moment(m.format(format), format);
                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format);
                r = moment(m.format(format).toLocaleUpperCase(), format);
                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' upper');
                r = moment(m.format(format).toLocaleLowerCase(), format);
                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' lower');

                r = moment(m.format(format), format, true);
                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' strict');
                r = moment(m.format(format).toLocaleUpperCase(), format, true);
                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' upper strict');
                r = moment(m.format(format).toLocaleLowerCase(), format, true);
                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' lower strict');
            }

            for (i = 0; i < 12; ++i) {
                m = moment([2015, i, 15, 18]);
                tester('MMM');
                tester('MMM.');
                tester('MMMM');
                tester('MMMM.');
            }
        });

        test('weekday parsing correctness', function (assert) {
            var i, m;

            if (locale === 'tr' || locale === 'az') {
                // There is a lower-case letter (Ä±), that converted to upper then
                // lower changes to i
                expect(0);
                return;
            }
            function tester(format) {
                var r, baseMsg = 'weekday ' + m.weekday() + ' fmt ' + format;
                r = moment(m.format(format), format);
                assert.equal(r.weekday(), m.weekday(), baseMsg);
                r = moment(m.format(format).toLocaleUpperCase(), format);
                assert.equal(r.weekday(), m.weekday(), baseMsg + ' upper');
                r = moment(m.format(format).toLocaleLowerCase(), format);
                assert.equal(r.weekday(), m.weekday(), baseMsg + ' lower');

                r = moment(m.format(format), format, true);
                assert.equal(r.weekday(), m.weekday(), baseMsg + ' strict');
                r = moment(m.format(format).toLocaleUpperCase(), format, true);
                assert.equal(r.weekday(), m.weekday(), baseMsg + ' upper strict');
                r = moment(m.format(format).toLocaleLowerCase(), format, true);
                assert.equal(r.weekday(), m.weekday(), baseMsg + ' lower strict');
            }

            for (i = 0; i < 7; ++i) {
                m = moment.utc([2015, i, 15, 18]);
                tester('dd');
                tester('ddd');
                tester('dddd');
            }
        });
    }

    function setupDeprecationHandler(test, moment, scope) {
        test._expectedDeprecations = null;
        test._observedDeprecations = null;
        test._oldSupress = moment.suppressDeprecationWarnings;
        moment.suppressDeprecationWarnings = true;
        test.expectedDeprecations = function () {
            test._expectedDeprecations = arguments;
            test._observedDeprecations = [];
        };
        moment.deprecationHandler = function (name, msg) {
            var deprecationId = matchedDeprecation(name, msg, test._expectedDeprecations);
            if (deprecationId === -1) {
                throw new Error('Unexpected deprecation thrown name=' +
                        name + ' msg=' + msg);
            }
            test._observedDeprecations[deprecationId] = 1;
        };
    }

    function teardownDeprecationHandler(test, moment, scope) {
        moment.suppressDeprecationWarnings = test._oldSupress;

        if (test._expectedDeprecations != null) {
            var missedDeprecations = [];
            each(test._expectedDeprecations, function (deprecationPattern, id) {
                if (test._observedDeprecations[id] !== 1) {
                    missedDeprecations.push(deprecationPattern);
                }
            });
            if (missedDeprecations.length !== 0) {
                throw new Error('Expected deprecation warnings did not happen: ' +
                        missedDeprecations.join(' '));
            }
        }
    }

    function matchedDeprecation(name, msg, deprecations) {
        if (deprecations == null) {
            return -1;
        }
        for (var i = 0; i < deprecations.length; ++i) {
            if (name != null && name === deprecations[i]) {
                return i;
            }
            if (msg != null && msg.substring(0, deprecations[i].length) === deprecations[i]) {
                return i;
            }
        }
        return -1;
    }

    /*global QUnit:false*/

    var test = QUnit.test;

    var expect = QUnit.expect;

    function module (name, lifecycle) {
        QUnit.module(name, {
            setup : function () {
                moment.locale('en');
                moment.createFromInputFallback = function (config) {
                    throw new Error('input not handled by moment: ' + config._i);
                };
                setupDeprecationHandler(test, moment, 'core');
                if (lifecycle && lifecycle.setup) {
                    lifecycle.setup();
                }
            },
            teardown : function () {
                teardownDeprecationHandler(test, moment, 'core');
                if (lifecycle && lifecycle.teardown) {
                    lifecycle.teardown();
                }
            }
        });
    }

    function localeModule (name, lifecycle) {
        QUnit.module('locale:' + name, {
            setup : function () {
                moment.locale(name);
                moment.createFromInputFallback = function (config) {
                    throw new Error('input not handled by moment: ' + config._i);
                };
                setupDeprecationHandler(test, moment, 'locale');
                if (lifecycle && lifecycle.setup) {
                    lifecycle.setup();
                }
            },
            teardown : function () {
                moment.locale('en');
                teardownDeprecationHandler(test, moment, 'locale');
                if (lifecycle && lifecycle.teardown) {
                    lifecycle.teardown();
                }
            }
        });
        defineCommonLocaleTests(name, -1, -1);
    }

    localeModule('en-ca');

    test('parse', function (assert) {
        var i,
            tests = 'January Jan_February Feb_March Mar_April Apr_May May_June Jun_July Jul_August Aug_September Sep_October Oct_November Nov_December Dec'.split('_');

        function equalTest(input, mmm, i) {
            assert.equal(moment(input, mmm).month(), i, input + ' should be month ' + (i + 1));
        }

        for (i = 0; i < 12; i++) {
            tests[i] = tests[i].split(' ');
            equalTest(tests[i][0], 'MMM', i);
            equalTest(tests[i][1], 'MMM', i);
            equalTest(tests[i][0], 'MMMM', i);
            equalTest(tests[i][1], 'MMMM', i);
            equalTest(tests[i][0].toLocaleLowerCase(), 'MMMM', i);
            equalTest(tests[i][1].toLocaleLowerCase(), 'MMMM', i);
            equalTest(tests[i][0].toLocaleUpperCase(), 'MMMM', i);
            equalTest(tests[i][1].toLocaleUpperCase(), 'MMMM', i);
        }
    });

    test('format', function (assert) {
        var a = [
                ['dddd, MMMM Do YYYY, h:mm:ss a',      'Sunday, February 14th 2010, 3:25:50 pm'],
                ['ddd, hA',                            'Sun, 3PM'],
                ['M Mo MM MMMM MMM',                   '2 2nd 02 February Feb'],
                ['YYYY YY',                            '2010 10'],
                ['D Do DD',                            '14 14th 14'],
                ['d do dddd ddd dd',                   '0 0th Sunday Sun Su'],
                ['DDD DDDo DDDD',                      '45 45th 045'],
                ['w wo ww',                            '8 8th 08'],
                ['h hh',                               '3 03'],
                ['H HH',                               '15 15'],
                ['m mm',                               '25 25'],
                ['s ss',                               '50 50'],
                ['a A',                                'pm PM'],
                ['[the] DDDo [day of the year]',       'the 45th day of the year'],
                ['L',                                  '2010-02-14'],
                ['LTS',                                '3:25:50 PM'],
                ['LL',                                 'February 14, 2010'],
                ['LLL',                                'February 14, 2010 3:25 PM'],
                ['LLLL',                               'Sunday, February 14, 2010 3:25 PM'],
                ['l',                                  '2010-2-14'],
                ['ll',                                 'Feb 14, 2010'],
                ['lll',                                'Feb 14, 2010 3:25 PM'],
                ['llll',                               'Sun, Feb 14, 2010 3:25 PM']
            ],
            b = moment(new Date(2010, 1, 14, 15, 25, 50, 125)),
            i;

        for (i = 0; i < a.length; i++) {
            assert.equal(b.format(a[i][0]), a[i][1], a[i][0] + ' ---> ' + a[i][1]);
        }
    });

    test('format ordinal', function (assert) {
        assert.equal(moment([2011, 0, 1]).format('DDDo'), '1st', '1st');
        assert.equal(moment([2011, 0, 2]).format('DDDo'), '2nd', '2nd');
        assert.equal(moment([2011, 0, 3]).format('DDDo'), '3rd', '3rd');
        assert.equal(moment([2011, 0, 4]).format('DDDo'), '4th', '4th');
        assert.equal(moment([2011, 0, 5]).format('DDDo'), '5th', '5th');
        assert.equal(moment([2011, 0, 6]).format('DDDo'), '6th', '6th');
        assert.equal(moment([2011, 0, 7]).format('DDDo'), '7th', '7th');
        assert.equal(moment([2011, 0, 8]).format('DDDo'), '8th', '8th');
        assert.equal(moment([2011, 0, 9]).format('DDDo'), '9th', '9th');
        assert.equal(moment([2011, 0, 10]).format('DDDo'), '10th', '10th');

        assert.equal(moment([2011, 0, 11]).format('DDDo'), '11th', '11th');
        assert.equal(moment([2011, 0, 12]).format('DDDo'), '12th', '12th');
        assert.equal(moment([2011, 0, 13]).format('DDDo'), '13th', '13th');
        assert.equal(moment([2011, 0, 14]).format('DDDo'), '14th', '14th');
        assert.equal(moment([2011, 0, 15]).format('DDDo'), '15th', '15th');
        assert.equal(moment([2011, 0, 16]).format('DDDo'), '16th', '16th');
        assert.equal(moment([2011, 0, 17]).format('DDDo'), '17th', '17th');
        assert.equal(moment([2011, 0, 18]).format('DDDo'), '18th', '18th');
        assert.equal(moment([2011, 0, 19]).format('DDDo'), '19th', '19th');
        assert.equal(moment([2011, 0, 20]).format('DDDo'), '20th', '20th');

        assert.equal(moment([2011, 0, 21]).format('DDDo'), '21st', '21st');
        assert.equal(moment([2011, 0, 22]).format('DDDo'), '22nd', '22nd');
        assert.equal(moment([2011, 0, 23]).format('DDDo'), '23rd', '23rd');
        assert.equal(moment([2011, 0, 24]).format('DDDo'), '24th', '24th');
        assert.equal(moment([2011, 0, 25]).format('DDDo'), '25th', '25th');
        assert.equal(moment([2011, 0, 26]).format('DDDo'), '26th', '26th');
        assert.equal(moment([2011, 0, 27]).format('DDDo'), '27th', '27th');
        assert.equal(moment([2011, 0, 28]).format('DDDo'), '28th', '28th');
        assert.equal(moment([2011, 0, 29]).format('DDDo'), '29th', '29th');
        assert.equal(moment([2011, 0, 30]).format('DDDo'), '30th', '30th');

        assert.equal(moment([2011, 0, 31]).format('DDDo'), '31st', '31st');
    });

    test('format month', function (assert) {
        var i,
            expected = 'January Jan_February Feb_March Mar_April Apr_May May_June Jun_July Jul_August Aug_September Sep_October Oct_November Nov_December Dec'.split('_');

        for (i = 0; i < expected.length; i++) {
            assert.equal(moment([2011, i, 1]).format('MMMM MMM'), expected[i], expected[i]);
        }
    });

    test('format week', function (assert) {
        var i,
            expected = 'Sunday Sun Su_Monday Mon Mo_Tuesday Tue Tu_Wednesday Wed We_Thursday Thu Th_Friday Fri Fr_Saturday Sat Sa'.split('_');

        for (i = 0; i < expected.length; i++) {
            assert.equal(moment([2011, 0, 2 + i]).format('dddd ddd dd'), expected[i], expected[i]);
        }
    });

    test('from', function (assert) {
        var start = moment([2007, 1, 28]);
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 44}), true),  'a few seconds', '44 seconds = a few seconds');
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 45}), true),  'a minute',      '45 seconds = a minute');
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 89}), true),  'a minute',      '89 seconds = a minute');
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 90}), true),  '2 minutes',     '90 seconds = 2 minutes');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 44}), true),  '44 minutes',    '44 minutes = 44 minutes');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 45}), true),  'an hour',       '45 minutes = an hour');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 89}), true),  'an hour',       '89 minutes = an hour');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 90}), true),  '2 hours',       '90 minutes = 2 hours');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 5}), true),   '5 hours',       '5 hours = 5 hours');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 21}), true),  '21 hours',      '21 hours = 21 hours');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 22}), true),  'a day',         '22 hours = a day');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 35}), true),  'a day',         '35 hours = a day');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 36}), true),  '2 days',        '36 hours = 2 days');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 1}), true),   'a day',         '1 day = a day');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 5}), true),   '5 days',        '5 days = 5 days');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 25}), true),  '25 days',       '25 days = 25 days');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 26}), true),  'a month',       '26 days = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 30}), true),  'a month',       '30 days = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 43}), true),  'a month',       '43 days = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 46}), true),  '2 months',      '46 days = 2 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 74}), true),  '2 months',      '75 days = 2 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 76}), true),  '3 months',      '76 days = 3 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({M: 1}), true),   'a month',       '1 month = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({M: 5}), true),   '5 months',      '5 months = 5 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 345}), true), 'a year',        '345 days = a year');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 548}), true), '2 years',       '548 days = 2 years');
        assert.equal(start.from(moment([2007, 1, 28]).add({y: 1}), true),   'a year',        '1 year = a year');
        assert.equal(start.from(moment([2007, 1, 28]).add({y: 5}), true),   '5 years',       '5 years = 5 years');
    });

    test('suffix', function (assert) {
        assert.equal(moment(30000).from(0), 'in a few seconds',  'prefix');
        assert.equal(moment(0).from(30000), 'a few seconds ago', 'suffix');
    });

    test('now from now', function (assert) {
        assert.equal(moment().fromNow(), 'a few seconds ago',  'now from now should display as in the past');
    });

    test('fromNow', function (assert) {
        assert.equal(moment().add({s: 30}).fromNow(), 'in a few seconds', 'in a few seconds');
        assert.equal(moment().add({d: 5}).fromNow(), 'in 5 days', 'in 5 days');
    });

    test('calendar day', function (assert) {
        var a = moment().hours(12).minutes(0).seconds(0);

        assert.equal(moment(a).calendar(),                   'Today at 12:00 PM',     'today at the same time');
        assert.equal(moment(a).add({m: 25}).calendar(),      'Today at 12:25 PM',     'Now plus 25 min');
        assert.equal(moment(a).add({h: 1}).calendar(),       'Today at 1:00 PM',      'Now plus 1 hour');
        assert.equal(moment(a).add({d: 1}).calendar(),       'Tomorrow at 12:00 PM',  'tomorrow at the same time');
        assert.equal(moment(a).subtract({h: 1}).calendar(),  'Today at 11:00 AM',     'Now minus 1 hour');
        assert.equal(moment(a).subtract({d: 1}).calendar(),  'Yesterday at 12:00 PM', 'yesterday at the same time');
    });

    test('calendar next week', function (assert) {
        var i, m;

        for (i = 2; i < 7; i++) {
            m = moment().add({d: i});
            assert.equal(m.calendar(),       m.format('dddd [at] LT'),  'Today + ' + i + ' days current time');
            m.hours(0).minutes(0).seconds(0).milliseconds(0);
            assert.equal(m.calendar(),       m.format('dddd [at] LT'),  'Today + ' + i + ' days beginning of day');
            m.hours(23).minutes(59).seconds(59).milliseconds(999);
            assert.equal(m.calendar(),       m.format('dddd [at] LT'),  'Today + ' + i + ' days end of day');
        }
    });

    test('calendar last week', function (assert) {
        var i, m;

        for (i = 2; i < 7; i++) {
            m = moment().subtract({d: i});
            assert.equal(m.calendar(),       m.format('[Last] dddd [at] LT'),  'Today - ' + i + ' days current time');
            m.hours(0).minutes(0).seconds(0).milliseconds(0);
            assert.equal(m.calendar(),       m.format('[Last] dddd [at] LT'),  'Today - ' + i + ' days beginning of day');
            m.hours(23).minutes(59).seconds(59).milliseconds(999);
            assert.equal(m.calendar(),       m.format('[Last] dddd [at] LT'),  'Today - ' + i + ' days end of day');
        }
    });

    test('calendar all else', function (assert) {
        var weeksAgo = moment().subtract({w: 1}),
            weeksFromNow = moment().add({w: 1});

        assert.equal(weeksAgo.calendar(),       weeksAgo.format('L'),  '1 week ago');
        assert.equal(weeksFromNow.calendar(),   weeksFromNow.format('L'),  'in 1 week');

        weeksAgo = moment().subtract({w: 2});
        weeksFromNow = moment().add({w: 2});

        assert.equal(weeksAgo.calendar(),       weeksAgo.format('L'),  '2 weeks ago');
        assert.equal(weeksFromNow.calendar(),   weeksFromNow.format('L'),  'in 2 weeks');
    });

    test('weeks year starting sunday format', function (assert) {
        assert.equal(moment([2012, 0,  1]).format('w ww wo'), '1 01 1st', 'Jan  1 2012 should be week 1');
        assert.equal(moment([2012, 0,  7]).format('w ww wo'), '1 01 1st', 'Jan  7 2012 should be week 1');
        assert.equal(moment([2012, 0,  8]).format('w ww wo'), '2 02 2nd', 'Jan  8 2012 should be week 2');
        assert.equal(moment([2012, 0, 14]).format('w ww wo'), '2 02 2nd', 'Jan 14 2012 should be week 2');
        assert.equal(moment([2012, 0, 15]).format('w ww wo'), '3 03 3rd', 'Jan 15 2012 should be week 3');
    });

}));

;(function (global, factory) {
   typeof exports === 'object' && typeof module !== 'undefined'
       && typeof require === 'function' ? factory(require('../../moment')) :
   typeof define === 'function' && define.amd ? define(['../../moment'], factory) :
   factory(global.moment)
}(this, function (moment) { 'use strict';

    function each(array, callback) {
        var i;
        for (i = 0; i < array.length; i++) {
            callback(array[i], i, array);
        }
    }

    function objectKeys(obj) {
        if (Object.keys) {
            return Object.keys(obj);
        } else {
            // IE8
            var res = [], i;
            for (i in obj) {
                if (obj.hasOwnProperty(i)) {
                    res.push(i);
                }
            }
            return res;
        }
    }

    // Pick the first defined of two or three arguments.
    function defaults(a, b, c) {
        if (a != null) {
            return a;
        }
        if (b != null) {
            return b;
        }
        return c;
    }

    function defineCommonLocaleTests(locale, options) {
        test('lenient ordinal parsing', function (assert) {
            var i, ordinalStr, testMoment;
            for (i = 1; i <= 31; ++i) {
                ordinalStr = moment([2014, 0, i]).format('YYYY MM Do');
                testMoment = moment(ordinalStr, 'YYYY MM Do');
                assert.equal(testMoment.year(), 2014,
                        'lenient ordinal parsing ' + i + ' year check');
                assert.equal(testMoment.month(), 0,
                        'lenient ordinal parsing ' + i + ' month check');
                assert.equal(testMoment.date(), i,
                        'lenient ordinal parsing ' + i + ' date check');
            }
        });

        test('lenient ordinal parsing of number', function (assert) {
            var i, testMoment;
            for (i = 1; i <= 31; ++i) {
                testMoment = moment('2014 01 ' + i, 'YYYY MM Do');
                assert.equal(testMoment.year(), 2014,
                        'lenient ordinal parsing of number ' + i + ' year check');
                assert.equal(testMoment.month(), 0,
                        'lenient ordinal parsing of number ' + i + ' month check');
                assert.equal(testMoment.date(), i,
                        'lenient ordinal parsing of number ' + i + ' date check');
            }
        });

        test('strict ordinal parsing', function (assert) {
            var i, ordinalStr, testMoment;
            for (i = 1; i <= 31; ++i) {
                ordinalStr = moment([2014, 0, i]).format('YYYY MM Do');
                testMoment = moment(ordinalStr, 'YYYY MM Do', true);
                assert.ok(testMoment.isValid(), 'strict ordinal parsing ' + i);
            }
        });

        test('meridiem invariant', function (assert) {
            var h, m, t1, t2;
            for (h = 0; h < 24; ++h) {
                for (m = 0; m < 60; m += 15) {
                    t1 = moment.utc([2000, 0, 1, h, m]);
                    t2 = moment.utc(t1.format('A h:mm'), 'A h:mm');
                    assert.equal(t2.format('HH:mm'), t1.format('HH:mm'),
                            'meridiem at ' + t1.format('HH:mm'));
                }
            }
        });

        test('date format correctness', function (assert) {
            var data, tokens;
            data = moment.localeData()._longDateFormat;
            tokens = objectKeys(data);
            each(tokens, function (srchToken) {
                // Check each format string to make sure it does not contain any
                // tokens that need to be expanded.
                each(tokens, function (baseToken) {
                    // strip escaped sequences
                    var format = data[baseToken].replace(/(\[[^\]]*\])/g, '');
                    assert.equal(false, !!~format.indexOf(srchToken),
                            'contains ' + srchToken + ' in ' + baseToken);
                });
            });
        });

        test('month parsing correctness', function (assert) {
            var i, m;

            if (locale === 'tr') {
                // I can't fix it :(
                expect(0);
                return;
            }
            function tester(format) {
                var r;
                r = moment(m.format(format), format);
                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format);
                r = moment(m.format(format).toLocaleUpperCase(), format);
                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' upper');
                r = moment(m.format(format).toLocaleLowerCase(), format);
                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' lower');

                r = moment(m.format(format), format, true);
                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' strict');
                r = moment(m.format(format).toLocaleUpperCase(), format, true);
                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' upper strict');
                r = moment(m.format(format).toLocaleLowerCase(), format, true);
                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' lower strict');
            }

            for (i = 0; i < 12; ++i) {
                m = moment([2015, i, 15, 18]);
                tester('MMM');
                tester('MMM.');
                tester('MMMM');
                tester('MMMM.');
            }
        });

        test('weekday parsing correctness', function (assert) {
            var i, m;

            if (locale === 'tr' || locale === 'az') {
                // There is a lower-case letter (Ä±), that converted to upper then
                // lower changes to i
                expect(0);
                return;
            }
            function tester(format) {
                var r, baseMsg = 'weekday ' + m.weekday() + ' fmt ' + format;
                r = moment(m.format(format), format);
                assert.equal(r.weekday(), m.weekday(), baseMsg);
                r = moment(m.format(format).toLocaleUpperCase(), format);
                assert.equal(r.weekday(), m.weekday(), baseMsg + ' upper');
                r = moment(m.format(format).toLocaleLowerCase(), format);
                assert.equal(r.weekday(), m.weekday(), baseMsg + ' lower');

                r = moment(m.format(format), format, true);
                assert.equal(r.weekday(), m.weekday(), baseMsg + ' strict');
                r = moment(m.format(format).toLocaleUpperCase(), format, true);
                assert.equal(r.weekday(), m.weekday(), baseMsg + ' upper strict');
                r = moment(m.format(format).toLocaleLowerCase(), format, true);
                assert.equal(r.weekday(), m.weekday(), baseMsg + ' lower strict');
            }

            for (i = 0; i < 7; ++i) {
                m = moment.utc([2015, i, 15, 18]);
                tester('dd');
                tester('ddd');
                tester('dddd');
            }
        });
    }

    function setupDeprecationHandler(test, moment, scope) {
        test._expectedDeprecations = null;
        test._observedDeprecations = null;
        test._oldSupress = moment.suppressDeprecationWarnings;
        moment.suppressDeprecationWarnings = true;
        test.expectedDeprecations = function () {
            test._expectedDeprecations = arguments;
            test._observedDeprecations = [];
        };
        moment.deprecationHandler = function (name, msg) {
            var deprecationId = matchedDeprecation(name, msg, test._expectedDeprecations);
            if (deprecationId === -1) {
                throw new Error('Unexpected deprecation thrown name=' +
                        name + ' msg=' + msg);
            }
            test._observedDeprecations[deprecationId] = 1;
        };
    }

    function teardownDeprecationHandler(test, moment, scope) {
        moment.suppressDeprecationWarnings = test._oldSupress;

        if (test._expectedDeprecations != null) {
            var missedDeprecations = [];
            each(test._expectedDeprecations, function (deprecationPattern, id) {
                if (test._observedDeprecations[id] !== 1) {
                    missedDeprecations.push(deprecationPattern);
                }
            });
            if (missedDeprecations.length !== 0) {
                throw new Error('Expected deprecation warnings did not happen: ' +
                        missedDeprecations.join(' '));
            }
        }
    }

    function matchedDeprecation(name, msg, deprecations) {
        if (deprecations == null) {
            return -1;
        }
        for (var i = 0; i < deprecations.length; ++i) {
            if (name != null && name === deprecations[i]) {
                return i;
            }
            if (msg != null && msg.substring(0, deprecations[i].length) === deprecations[i]) {
                return i;
            }
        }
        return -1;
    }

    /*global QUnit:false*/

    var test = QUnit.test;

    var expect = QUnit.expect;

    function module (name, lifecycle) {
        QUnit.module(name, {
            setup : function () {
                moment.locale('en');
                moment.createFromInputFallback = function (config) {
                    throw new Error('input not handled by moment: ' + config._i);
                };
                setupDeprecationHandler(test, moment, 'core');
                if (lifecycle && lifecycle.setup) {
                    lifecycle.setup();
                }
            },
            teardown : function () {
                teardownDeprecationHandler(test, moment, 'core');
                if (lifecycle && lifecycle.teardown) {
                    lifecycle.teardown();
                }
            }
        });
    }

    function localeModule (name, lifecycle) {
        QUnit.module('locale:' + name, {
            setup : function () {
                moment.locale(name);
                moment.createFromInputFallback = function (config) {
                    throw new Error('input not handled by moment: ' + config._i);
                };
                setupDeprecationHandler(test, moment, 'locale');
                if (lifecycle && lifecycle.setup) {
                    lifecycle.setup();
                }
            },
            teardown : function () {
                moment.locale('en');
                teardownDeprecationHandler(test, moment, 'locale');
                if (lifecycle && lifecycle.teardown) {
                    lifecycle.teardown();
                }
            }
        });
        defineCommonLocaleTests(name, -1, -1);
    }

    localeModule('en-gb');

    test('parse', function (assert) {
        var tests = 'January Jan_February Feb_March Mar_April Apr_May May_June Jun_July Jul_August Aug_September Sep_October Oct_November Nov_December Dec'.split('_'), i;
        function equalTest(input, mmm, i) {
            assert.equal(moment(input, mmm).month(), i, input + ' should be month ' + (i + 1));
        }
        for (i = 0; i < 12; i++) {
            tests[i] = tests[i].split(' ');
            equalTest(tests[i][0], 'MMM', i);
            equalTest(tests[i][1], 'MMM', i);
            equalTest(tests[i][0], 'MMMM', i);
            equalTest(tests[i][1], 'MMMM', i);
            equalTest(tests[i][0].toLocaleLowerCase(), 'MMMM', i);
            equalTest(tests[i][1].toLocaleLowerCase(), 'MMMM', i);
            equalTest(tests[i][0].toLocaleUpperCase(), 'MMMM', i);
            equalTest(tests[i][1].toLocaleUpperCase(), 'MMMM', i);
        }
    });

    test('format', function (assert) {
        var a = [
                ['dddd, MMMM Do YYYY, h:mm:ss a',      'Sunday, February 14th 2010, 3:25:50 pm'],
                ['ddd, hA',                            'Sun, 3PM'],
                ['M Mo MM MMMM MMM',                   '2 2nd 02 February Feb'],
                ['YYYY YY',                            '2010 10'],
                ['D Do DD',                            '14 14th 14'],
                ['d do dddd ddd dd',                   '0 0th Sunday Sun Su'],
                ['DDD DDDo DDDD',                      '45 45th 045'],
                ['w wo ww',                            '6 6th 06'],
                ['h hh',                               '3 03'],
                ['H HH',                               '15 15'],
                ['m mm',                               '25 25'],
                ['s ss',                               '50 50'],
                ['a A',                                'pm PM'],
                ['[the] DDDo [day of the year]',       'the 45th day of the year'],
                ['LTS',                                '15:25:50'],
                ['L',                                  '14/02/2010'],
                ['LL',                                 '14 February 2010'],
                ['LLL',                                '14 February 2010 15:25'],
                ['LLLL',                               'Sunday, 14 February 2010 15:25'],
                ['l',                                  '14/2/2010'],
                ['ll',                                 '14 Feb 2010'],
                ['lll',                                '14 Feb 2010 15:25'],
                ['llll',                               'Sun, 14 Feb 2010 15:25']
            ],
            b = moment(new Date(2010, 1, 14, 15, 25, 50, 125)),
            i;
        for (i = 0; i < a.length; i++) {
            assert.equal(b.format(a[i][0]), a[i][1], a[i][0] + ' ---> ' + a[i][1]);
        }
    });

    test('format ordinal', function (assert) {
        assert.equal(moment([2011, 0, 1]).format('DDDo'), '1st', '1st');
        assert.equal(moment([2011, 0, 2]).format('DDDo'), '2nd', '2nd');
        assert.equal(moment([2011, 0, 3]).format('DDDo'), '3rd', '3rd');
        assert.equal(moment([2011, 0, 4]).format('DDDo'), '4th', '4th');
        assert.equal(moment([2011, 0, 5]).format('DDDo'), '5th', '5th');
        assert.equal(moment([2011, 0, 6]).format('DDDo'), '6th', '6th');
        assert.equal(moment([2011, 0, 7]).format('DDDo'), '7th', '7th');
        assert.equal(moment([2011, 0, 8]).format('DDDo'), '8th', '8th');
        assert.equal(moment([2011, 0, 9]).format('DDDo'), '9th', '9th');
        assert.equal(moment([2011, 0, 10]).format('DDDo'), '10th', '10th');

        assert.equal(moment([2011, 0, 11]).format('DDDo'), '11th', '11th');
        assert.equal(moment([2011, 0, 12]).format('DDDo'), '12th', '12th');
        assert.equal(moment([2011, 0, 13]).format('DDDo'), '13th', '13th');
        assert.equal(moment([2011, 0, 14]).format('DDDo'), '14th', '14th');
        assert.equal(moment([2011, 0, 15]).format('DDDo'), '15th', '15th');
        assert.equal(moment([2011, 0, 16]).format('DDDo'), '16th', '16th');
        assert.equal(moment([2011, 0, 17]).format('DDDo'), '17th', '17th');
        assert.equal(moment([2011, 0, 18]).format('DDDo'), '18th', '18th');
        assert.equal(moment([2011, 0, 19]).format('DDDo'), '19th', '19th');
        assert.equal(moment([2011, 0, 20]).format('DDDo'), '20th', '20th');

        assert.equal(moment([2011, 0, 21]).format('DDDo'), '21st', '21st');
        assert.equal(moment([2011, 0, 22]).format('DDDo'), '22nd', '22nd');
        assert.equal(moment([2011, 0, 23]).format('DDDo'), '23rd', '23rd');
        assert.equal(moment([2011, 0, 24]).format('DDDo'), '24th', '24th');
        assert.equal(moment([2011, 0, 25]).format('DDDo'), '25th', '25th');
        assert.equal(moment([2011, 0, 26]).format('DDDo'), '26th', '26th');
        assert.equal(moment([2011, 0, 27]).format('DDDo'), '27th', '27th');
        assert.equal(moment([2011, 0, 28]).format('DDDo'), '28th', '28th');
        assert.equal(moment([2011, 0, 29]).format('DDDo'), '29th', '29th');
        assert.equal(moment([2011, 0, 30]).format('DDDo'), '30th', '30th');

        assert.equal(moment([2011, 0, 31]).format('DDDo'), '31st', '31st');
    });

    test('format month', function (assert) {
        var expected = 'January Jan_February Feb_March Mar_April Apr_May May_June Jun_July Jul_August Aug_September Sep_October Oct_November Nov_December Dec'.split('_'), i;
        for (i = 0; i < expected.length; i++) {
            assert.equal(moment([2011, i, 1]).format('MMMM MMM'), expected[i], expected[i]);
        }
    });

    test('format week', function (assert) {
        var expected = 'Sunday Sun Su_Monday Mon Mo_Tuesday Tue Tu_Wednesday Wed We_Thursday Thu Th_Friday Fri Fr_Saturday Sat Sa'.split('_'), i;
        for (i = 0; i < expected.length; i++) {
            assert.equal(moment([2011, 0, 2 + i]).format('dddd ddd dd'), expected[i], expected[i]);
        }
    });

    test('from', function (assert) {
        var start = moment([2007, 1, 28]);
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 44}), true),  'a few seconds', '44 seconds = a few seconds');
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 45}), true),  'a minute',      '45 seconds = a minute');
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 89}), true),  'a minute',      '89 seconds = a minute');
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 90}), true),  '2 minutes',     '90 seconds = 2 minutes');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 44}), true),  '44 minutes',    '44 minutes = 44 minutes');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 45}), true),  'an hour',       '45 minutes = an hour');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 89}), true),  'an hour',       '89 minutes = an hour');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 90}), true),  '2 hours',       '90 minutes = 2 hours');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 5}), true),   '5 hours',       '5 hours = 5 hours');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 21}), true),  '21 hours',      '21 hours = 21 hours');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 22}), true),  'a day',         '22 hours = a day');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 35}), true),  'a day',         '35 hours = a day');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 36}), true),  '2 days',        '36 hours = 2 days');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 1}), true),   'a day',         '1 day = a day');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 5}), true),   '5 days',        '5 days = 5 days');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 25}), true),  '25 days',       '25 days = 25 days');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 26}), true),  'a month',       '26 days = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 30}), true),  'a month',       '30 days = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 43}), true),  'a month',       '43 days = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 46}), true),  '2 months',      '46 days = 2 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 74}), true),  '2 months',      '75 days = 2 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 76}), true),  '3 months',      '76 days = 3 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({M: 1}), true),   'a month',       '1 month = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({M: 5}), true),   '5 months',      '5 months = 5 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 345}), true), 'a year',        '345 days = a year');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 548}), true), '2 years',       '548 days = 2 years');
        assert.equal(start.from(moment([2007, 1, 28]).add({y: 1}), true),   'a year',        '1 year = a year');
        assert.equal(start.from(moment([2007, 1, 28]).add({y: 5}), true),   '5 years',       '5 years = 5 years');
    });

    test('suffix', function (assert) {
        assert.equal(moment(30000).from(0), 'in a few seconds',  'prefix');
        assert.equal(moment(0).from(30000), 'a few seconds ago', 'suffix');
    });

    test('now from now', function (assert) {
        assert.equal(moment().fromNow(), 'a few seconds ago',  'now from now should display as in the past');
    });

    test('fromNow', function (assert) {
        assert.equal(moment().add({s: 30}).fromNow(), 'in a few seconds', 'in a few seconds');
        assert.equal(moment().add({d: 5}).fromNow(), 'in 5 days', 'in 5 days');
    });

    test('calendar day', function (assert) {
        var a = moment().hours(12).minutes(0).seconds(0);

        assert.equal(moment(a).calendar(),                   'Today at 12:00',      'today at the same time');
        assert.equal(moment(a).add({m: 25}).calendar(),      'Today at 12:25',      'Now plus 25 min');
        assert.equal(moment(a).add({h: 1}).calendar(),       'Today at 13:00',      'Now plus 1 hour');
        assert.equal(moment(a).add({d: 1}).calendar(),       'Tomorrow at 12:00',   'tomorrow at the same time');
        assert.equal(moment(a).subtract({h: 1}).calendar(),  'Today at 11:00',      'Now minus 1 hour');
        assert.equal(moment(a).subtract({d: 1}).calendar(),  'Yesterday at 12:00',  'yesterday at the same time');
    });

    test('calendar next week', function (assert) {
        var i, m;
        for (i = 2; i < 7; i++) {
            m = moment().add({d: i});
            assert.equal(m.calendar(),       m.format('dddd [at] LT'),  'Today + ' + i + ' days current time');
            m.hours(0).minutes(0).seconds(0).milliseconds(0);
            assert.equal(m.calendar(),       m.format('dddd [at] LT'),  'Today + ' + i + ' days beginning of day');
            m.hours(23).minutes(59).seconds(59).milliseconds(999);
            assert.equal(m.calendar(),       m.format('dddd [at] LT'),  'Today + ' + i + ' days end of day');
        }
    });

    test('calendar last week', function (assert) {
        var i, m;

        for (i = 2; i < 7; i++) {
            m = moment().subtract({d: i});
            assert.equal(m.calendar(),       m.format('[Last] dddd [at] LT'),  'Today - ' + i + ' days current time');
            m.hours(0).minutes(0).seconds(0).milliseconds(0);
            assert.equal(m.calendar(),       m.format('[Last] dddd [at] LT'),  'Today - ' + i + ' days beginning of day');
            m.hours(23).minutes(59).seconds(59).milliseconds(999);
            assert.equal(m.calendar(),       m.format('[Last] dddd [at] LT'),  'Today - ' + i + ' days end of day');
        }
    });

    test('calendar all else', function (assert) {
        var weeksAgo = moment().subtract({w: 1}),
            weeksFromNow = moment().add({w: 1});

        assert.equal(weeksAgo.calendar(),       weeksAgo.format('L'),  '1 week ago');
        assert.equal(weeksFromNow.calendar(),   weeksFromNow.format('L'),  'in 1 week');

        weeksAgo = moment().subtract({w: 2});
        weeksFromNow = moment().add({w: 2});

        assert.equal(weeksAgo.calendar(),       weeksAgo.format('L'),  '2 weeks ago');
        assert.equal(weeksFromNow.calendar(),   weeksFromNow.format('L'),  'in 2 weeks');
    });

    test('weeks year starting sunday formatted', function (assert) {
        assert.equal(moment([2012, 0,  1]).format('w ww wo'), '52 52 52nd', 'Jan  1 2012 should be week 52');
        assert.equal(moment([2012, 0,  2]).format('w ww wo'),   '1 01 1st', 'Jan  2 2012 should be week 1');
        assert.equal(moment([2012, 0,  8]).format('w ww wo'),   '1 01 1st', 'Jan  8 2012 should be week 1');
        assert.equal(moment([2012, 0,  9]).format('w ww wo'),   '2 02 2nd', 'Jan  9 2012 should be week 2');
        assert.equal(moment([2012, 0, 15]).format('w ww wo'),   '2 02 2nd', 'Jan 15 2012 should be week 2');
    });

}));

;(function (global, factory) {
   typeof exports === 'object' && typeof module !== 'undefined'
       && typeof require === 'function' ? factory(require('../../moment')) :
   typeof define === 'function' && define.amd ? define(['../../moment'], factory) :
   factory(global.moment)
}(this, function (moment) { 'use strict';

    function each(array, callback) {
        var i;
        for (i = 0; i < array.length; i++) {
            callback(array[i], i, array);
        }
    }

    function objectKeys(obj) {
        if (Object.keys) {
            return Object.keys(obj);
        } else {
            // IE8
            var res = [], i;
            for (i in obj) {
                if (obj.hasOwnProperty(i)) {
                    res.push(i);
                }
            }
            return res;
        }
    }

    // Pick the first defined of two or three arguments.
    function defaults(a, b, c) {
        if (a != null) {
            return a;
        }
        if (b != null) {
            return b;
        }
        return c;
    }

    function defineCommonLocaleTests(locale, options) {
        test('lenient ordinal parsing', function (assert) {
            var i, ordinalStr, testMoment;
            for (i = 1; i <= 31; ++i) {
                ordinalStr = moment([2014, 0, i]).format('YYYY MM Do');
                testMoment = moment(ordinalStr, 'YYYY MM Do');
                assert.equal(testMoment.year(), 2014,
                        'lenient ordinal parsing ' + i + ' year check');
                assert.equal(testMoment.month(), 0,
                        'lenient ordinal parsing ' + i + ' month check');
                assert.equal(testMoment.date(), i,
                        'lenient ordinal parsing ' + i + ' date check');
            }
        });

        test('lenient ordinal parsing of number', function (assert) {
            var i, testMoment;
            for (i = 1; i <= 31; ++i) {
                testMoment = moment('2014 01 ' + i, 'YYYY MM Do');
                assert.equal(testMoment.year(), 2014,
                        'lenient ordinal parsing of number ' + i + ' year check');
                assert.equal(testMoment.month(), 0,
                        'lenient ordinal parsing of number ' + i + ' month check');
                assert.equal(testMoment.date(), i,
                        'lenient ordinal parsing of number ' + i + ' date check');
            }
        });

        test('strict ordinal parsing', function (assert) {
            var i, ordinalStr, testMoment;
            for (i = 1; i <= 31; ++i) {
                ordinalStr = moment([2014, 0, i]).format('YYYY MM Do');
                testMoment = moment(ordinalStr, 'YYYY MM Do', true);
                assert.ok(testMoment.isValid(), 'strict ordinal parsing ' + i);
            }
        });

        test('meridiem invariant', function (assert) {
            var h, m, t1, t2;
            for (h = 0; h < 24; ++h) {
                for (m = 0; m < 60; m += 15) {
                    t1 = moment.utc([2000, 0, 1, h, m]);
                    t2 = moment.utc(t1.format('A h:mm'), 'A h:mm');
                    assert.equal(t2.format('HH:mm'), t1.format('HH:mm'),
                            'meridiem at ' + t1.format('HH:mm'));
                }
            }
        });

        test('date format correctness', function (assert) {
            var data, tokens;
            data = moment.localeData()._longDateFormat;
            tokens = objectKeys(data);
            each(tokens, function (srchToken) {
                // Check each format string to make sure it does not contain any
                // tokens that need to be expanded.
                each(tokens, function (baseToken) {
                    // strip escaped sequences
                    var format = data[baseToken].replace(/(\[[^\]]*\])/g, '');
                    assert.equal(false, !!~format.indexOf(srchToken),
                            'contains ' + srchToken + ' in ' + baseToken);
                });
            });
        });

        test('month parsing correctness', function (assert) {
            var i, m;

            if (locale === 'tr') {
                // I can't fix it :(
                expect(0);
                return;
            }
            function tester(format) {
                var r;
                r = moment(m.format(format), format);
                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format);
                r = moment(m.format(format).toLocaleUpperCase(), format);
                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' upper');
                r = moment(m.format(format).toLocaleLowerCase(), format);
                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' lower');

                r = moment(m.format(format), format, true);
                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' strict');
                r = moment(m.format(format).toLocaleUpperCase(), format, true);
                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' upper strict');
                r = moment(m.format(format).toLocaleLowerCase(), format, true);
                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' lower strict');
            }

            for (i = 0; i < 12; ++i) {
                m = moment([2015, i, 15, 18]);
                tester('MMM');
                tester('MMM.');
                tester('MMMM');
                tester('MMMM.');
            }
        });

        test('weekday parsing correctness', function (assert) {
            var i, m;

            if (locale === 'tr' || locale === 'az') {
                // There is a lower-case letter (Ä±), that converted to upper then
                // lower changes to i
                expect(0);
                return;
            }
            function tester(format) {
                var r, baseMsg = 'weekday ' + m.weekday() + ' fmt ' + format;
                r = moment(m.format(format), format);
                assert.equal(r.weekday(), m.weekday(), baseMsg);
                r = moment(m.format(format).toLocaleUpperCase(), format);
                assert.equal(r.weekday(), m.weekday(), baseMsg + ' upper');
                r = moment(m.format(format).toLocaleLowerCase(), format);
                assert.equal(r.weekday(), m.weekday(), baseMsg + ' lower');

                r = moment(m.format(format), format, true);
                assert.equal(r.weekday(), m.weekday(), baseMsg + ' strict');
                r = moment(m.format(format).toLocaleUpperCase(), format, true);
                assert.equal(r.weekday(), m.weekday(), baseMsg + ' upper strict');
                r = moment(m.format(format).toLocaleLowerCase(), format, true);
                assert.equal(r.weekday(), m.weekday(), baseMsg + ' lower strict');
            }

            for (i = 0; i < 7; ++i) {
                m = moment.utc([2015, i, 15, 18]);
                tester('dd');
                tester('ddd');
                tester('dddd');
            }
        });
    }

    function setupDeprecationHandler(test, moment, scope) {
        test._expectedDeprecations = null;
        test._observedDeprecations = null;
        test._oldSupress = moment.suppressDeprecationWarnings;
        moment.suppressDeprecationWarnings = true;
        test.expectedDeprecations = function () {
            test._expectedDeprecations = arguments;
            test._observedDeprecations = [];
        };
        moment.deprecationHandler = function (name, msg) {
            var deprecationId = matchedDeprecation(name, msg, test._expectedDeprecations);
            if (deprecationId === -1) {
                throw new Error('Unexpected deprecation thrown name=' +
                        name + ' msg=' + msg);
            }
            test._observedDeprecations[deprecationId] = 1;
        };
    }

    function teardownDeprecationHandler(test, moment, scope) {
        moment.suppressDeprecationWarnings = test._oldSupress;

        if (test._expectedDeprecations != null) {
            var missedDeprecations = [];
            each(test._expectedDeprecations, function (deprecationPattern, id) {
                if (test._observedDeprecations[id] !== 1) {
                    missedDeprecations.push(deprecationPattern);
                }
            });
            if (missedDeprecations.length !== 0) {
                throw new Error('Expected deprecation warnings did not happen: ' +
                        missedDeprecations.join(' '));
            }
        }
    }

    function matchedDeprecation(name, msg, deprecations) {
        if (deprecations == null) {
            return -1;
        }
        for (var i = 0; i < deprecations.length; ++i) {
            if (name != null && name === deprecations[i]) {
                return i;
            }
            if (msg != null && msg.substring(0, deprecations[i].length) === deprecations[i]) {
                return i;
            }
        }
        return -1;
    }

    /*global QUnit:false*/

    var test = QUnit.test;

    var expect = QUnit.expect;

    function module (name, lifecycle) {
        QUnit.module(name, {
            setup : function () {
                moment.locale('en');
                moment.createFromInputFallback = function (config) {
                    throw new Error('input not handled by moment: ' + config._i);
                };
                setupDeprecationHandler(test, moment, 'core');
                if (lifecycle && lifecycle.setup) {
                    lifecycle.setup();
                }
            },
            teardown : function () {
                teardownDeprecationHandler(test, moment, 'core');
                if (lifecycle && lifecycle.teardown) {
                    lifecycle.teardown();
                }
            }
        });
    }

    function localeModule (name, lifecycle) {
        QUnit.module('locale:' + name, {
            setup : function () {
                moment.locale(name);
                moment.createFromInputFallback = function (config) {
                    throw new Error('input not handled by moment: ' + config._i);
                };
                setupDeprecationHandler(test, moment, 'locale');
                if (lifecycle && lifecycle.setup) {
                    lifecycle.setup();
                }
            },
            teardown : function () {
                moment.locale('en');
                teardownDeprecationHandler(test, moment, 'locale');
                if (lifecycle && lifecycle.teardown) {
                    lifecycle.teardown();
                }
            }
        });
        defineCommonLocaleTests(name, -1, -1);
    }

    localeModule('en-ie');

    test('parse', function (assert) {
        var tests = 'January Jan_February Feb_March Mar_April Apr_May May_June Jun_July Jul_August Aug_September Sep_October Oct_November Nov_December Dec'.split('_'), i;
        function equalTest(input, mmm, i) {
            assert.equal(moment(input, mmm).month(), i, input + ' should be month ' + (i + 1));
        }
        for (i = 0; i < 12; i++) {
            tests[i] = tests[i].split(' ');
            equalTest(tests[i][0], 'MMM', i);
            equalTest(tests[i][1], 'MMM', i);
            equalTest(tests[i][0], 'MMMM', i);
            equalTest(tests[i][1], 'MMMM', i);
            equalTest(tests[i][0].toLocaleLowerCase(), 'MMMM', i);
            equalTest(tests[i][1].toLocaleLowerCase(), 'MMMM', i);
            equalTest(tests[i][0].toLocaleUpperCase(), 'MMMM', i);
            equalTest(tests[i][1].toLocaleUpperCase(), 'MMMM', i);
        }
    });

    test('format', function (assert) {
        var a = [
                ['dddd, MMMM Do YYYY, h:mm:ss a',      'Sunday, February 14th 2010, 3:25:50 pm'],
                ['ddd, hA',                            'Sun, 3PM'],
                ['M Mo MM MMMM MMM',                   '2 2nd 02 February Feb'],
                ['YYYY YY',                            '2010 10'],
                ['D Do DD',                            '14 14th 14'],
                ['d do dddd ddd dd',                   '0 0th Sunday Sun Su'],
                ['DDD DDDo DDDD',                      '45 45th 045'],
                ['w wo ww',                            '6 6th 06'],
                ['h hh',                               '3 03'],
                ['H HH',                               '15 15'],
                ['m mm',                               '25 25'],
                ['s ss',                               '50 50'],
                ['a A',                                'pm PM'],
                ['[the] DDDo [day of the year]',       'the 45th day of the year'],
                ['LTS',                                '15:25:50'],
                ['L',                                  '14-02-2010'],
                ['LL',                                 '14 February 2010'],
                ['LLL',                                '14 February 2010 15:25'],
                ['LLLL',                               'Sunday 14 February 2010 15:25'],
                ['l',                                  '14-2-2010'],
                ['ll',                                 '14 Feb 2010'],
                ['lll',                                '14 Feb 2010 15:25'],
                ['llll',                               'Sun 14 Feb 2010 15:25']
            ],
            b = moment(new Date(2010, 1, 14, 15, 25, 50, 125)),
            i;
        for (i = 0; i < a.length; i++) {
            assert.equal(b.format(a[i][0]), a[i][1], a[i][0] + ' ---> ' + a[i][1]);
        }
    });

    test('format ordinal', function (assert) {
        assert.equal(moment([2011, 0, 1]).format('DDDo'), '1st', '1st');
        assert.equal(moment([2011, 0, 2]).format('DDDo'), '2nd', '2nd');
        assert.equal(moment([2011, 0, 3]).format('DDDo'), '3rd', '3rd');
        assert.equal(moment([2011, 0, 4]).format('DDDo'), '4th', '4th');
        assert.equal(moment([2011, 0, 5]).format('DDDo'), '5th', '5th');
        assert.equal(moment([2011, 0, 6]).format('DDDo'), '6th', '6th');
        assert.equal(moment([2011, 0, 7]).format('DDDo'), '7th', '7th');
        assert.equal(moment([2011, 0, 8]).format('DDDo'), '8th', '8th');
        assert.equal(moment([2011, 0, 9]).format('DDDo'), '9th', '9th');
        assert.equal(moment([2011, 0, 10]).format('DDDo'), '10th', '10th');

        assert.equal(moment([2011, 0, 11]).format('DDDo'), '11th', '11th');
        assert.equal(moment([2011, 0, 12]).format('DDDo'), '12th', '12th');
        assert.equal(moment([2011, 0, 13]).format('DDDo'), '13th', '13th');
        assert.equal(moment([2011, 0, 14]).format('DDDo'), '14th', '14th');
        assert.equal(moment([2011, 0, 15]).format('DDDo'), '15th', '15th');
        assert.equal(moment([2011, 0, 16]).format('DDDo'), '16th', '16th');
        assert.equal(moment([2011, 0, 17]).format('DDDo'), '17th', '17th');
        assert.equal(moment([2011, 0, 18]).format('DDDo'), '18th', '18th');
        assert.equal(moment([2011, 0, 19]).format('DDDo'), '19th', '19th');
        assert.equal(moment([2011, 0, 20]).format('DDDo'), '20th', '20th');

        assert.equal(moment([2011, 0, 21]).format('DDDo'), '21st', '21st');
        assert.equal(moment([2011, 0, 22]).format('DDDo'), '22nd', '22nd');
        assert.equal(moment([2011, 0, 23]).format('DDDo'), '23rd', '23rd');
        assert.equal(moment([2011, 0, 24]).format('DDDo'), '24th', '24th');
        assert.equal(moment([2011, 0, 25]).format('DDDo'), '25th', '25th');
        assert.equal(moment([2011, 0, 26]).format('DDDo'), '26th', '26th');
        assert.equal(moment([2011, 0, 27]).format('DDDo'), '27th', '27th');
        assert.equal(moment([2011, 0, 28]).format('DDDo'), '28th', '28th');
        assert.equal(moment([2011, 0, 29]).format('DDDo'), '29th', '29th');
        assert.equal(moment([2011, 0, 30]).format('DDDo'), '30th', '30th');

        assert.equal(moment([2011, 0, 31]).format('DDDo'), '31st', '31st');
    });

    test('format month', function (assert) {
        var expected = 'January Jan_February Feb_March Mar_April Apr_May May_June Jun_July Jul_August Aug_September Sep_October Oct_November Nov_December Dec'.split('_'), i;
        for (i = 0; i < expected.length; i++) {
            assert.equal(moment([2011, i, 1]).format('MMMM MMM'), expected[i], expected[i]);
        }
    });

    test('format week', function (assert) {
        var expected = 'Sunday Sun Su_Monday Mon Mo_Tuesday Tue Tu_Wednesday Wed We_Thursday Thu Th_Friday Fri Fr_Saturday Sat Sa'.split('_'), i;
        for (i = 0; i < expected.length; i++) {
            assert.equal(moment([2011, 0, 2 + i]).format('dddd ddd dd'), expected[i], expected[i]);
        }
    });

    test('from', function (assert) {
        var start = moment([2007, 1, 28]);
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 44}), true),  'a few seconds', '44 seconds = a few seconds');
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 45}), true),  'a minute',      '45 seconds = a minute');
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 89}), true),  'a minute',      '89 seconds = a minute');
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 90}), true),  '2 minutes',     '90 seconds = 2 minutes');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 44}), true),  '44 minutes',    '44 minutes = 44 minutes');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 45}), true),  'an hour',       '45 minutes = an hour');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 89}), true),  'an hour',       '89 minutes = an hour');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 90}), true),  '2 hours',       '90 minutes = 2 hours');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 5}), true),   '5 hours',       '5 hours = 5 hours');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 21}), true),  '21 hours',      '21 hours = 21 hours');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 22}), true),  'a day',         '22 hours = a day');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 35}), true),  'a day',         '35 hours = a day');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 36}), true),  '2 days',        '36 hours = 2 days');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 1}), true),   'a day',         '1 day = a day');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 5}), true),   '5 days',        '5 days = 5 days');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 25}), true),  '25 days',       '25 days = 25 days');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 26}), true),  'a month',       '26 days = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 30}), true),  'a month',       '30 days = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 43}), true),  'a month',       '43 days = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 46}), true),  '2 months',      '46 days = 2 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 74}), true),  '2 months',      '75 days = 2 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 76}), true),  '3 months',      '76 days = 3 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({M: 1}), true),   'a month',       '1 month = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({M: 5}), true),   '5 months',      '5 months = 5 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 345}), true), 'a year',        '345 days = a year');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 548}), true), '2 years',       '548 days = 2 years');
        assert.equal(start.from(moment([2007, 1, 28]).add({y: 1}), true),   'a year',        '1 year = a year');
        assert.equal(start.from(moment([2007, 1, 28]).add({y: 5}), true),   '5 years',       '5 years = 5 years');
    });

    test('suffix', function (assert) {
        assert.equal(moment(30000).from(0), 'in a few seconds',  'prefix');
        assert.equal(moment(0).from(30000), 'a few seconds ago', 'suffix');
    });

    test('now from now', function (assert) {
        assert.equal(moment().fromNow(), 'a few seconds ago',  'now from now should display as in the past');
    });

    test('fromNow', function (assert) {
        assert.equal(moment().add({s: 30}).fromNow(), 'in a few seconds', 'in a few seconds');
        assert.equal(moment().add({d: 5}).fromNow(), 'in 5 days', 'in 5 days');
    });

    test('calendar day', function (assert) {
        var a = moment().hours(12).minutes(0).seconds(0);

        assert.equal(moment(a).calendar(),                   'Today at 12:00',      'today at the same time');
        assert.equal(moment(a).add({m: 25}).calendar(),      'Today at 12:25',      'Now plus 25 min');
        assert.equal(moment(a).add({h: 1}).calendar(),       'Today at 13:00',      'Now plus 1 hour');
        assert.equal(moment(a).add({d: 1}).calendar(),       'Tomorrow at 12:00',   'tomorrow at the same time');
        assert.equal(moment(a).subtract({h: 1}).calendar(),  'Today at 11:00',      'Now minus 1 hour');
        assert.equal(moment(a).subtract({d: 1}).calendar(),  'Yesterday at 12:00',  'yesterday at the same time');
    });

    test('calendar next week', function (assert) {
        var i, m;
        for (i = 2; i < 7; i++) {
            m = moment().add({d: i});
            assert.equal(m.calendar(),       m.format('dddd [at] LT'),  'Today + ' + i + ' days current time');
            m.hours(0).minutes(0).seconds(0).milliseconds(0);
            assert.equal(m.calendar(),       m.format('dddd [at] LT'),  'Today + ' + i + ' days beginning of day');
            m.hours(23).minutes(59).seconds(59).milliseconds(999);
            assert.equal(m.calendar(),       m.format('dddd [at] LT'),  'Today + ' + i + ' days end of day');
        }
    });

    test('calendar last week', function (assert) {
        var i, m;

        for (i = 2; i < 7; i++) {
            m = moment().subtract({d: i});
            assert.equal(m.calendar(),       m.format('[Last] dddd [at] LT'),  'Today - ' + i + ' days current time');
            m.hours(0).minutes(0).seconds(0).milliseconds(0);
            assert.equal(m.calendar(),       m.format('[Last] dddd [at] LT'),  'Today - ' + i + ' days beginning of day');
            m.hours(23).minutes(59).seconds(59).milliseconds(999);
            assert.equal(m.calendar(),       m.format('[Last] dddd [at] LT'),  'Today - ' + i + ' days end of day');
        }
    });

    test('calendar all else', function (assert) {
        var weeksAgo = moment().subtract({w: 1}),
            weeksFromNow = moment().add({w: 1});

        assert.equal(weeksAgo.calendar(),       weeksAgo.format('L'),  '1 week ago');
        assert.equal(weeksFromNow.calendar(),   weeksFromNow.format('L'),  'in 1 week');

        weeksAgo = moment().subtract({w: 2});
        weeksFromNow = moment().add({w: 2});

        assert.equal(weeksAgo.calendar(),       weeksAgo.format('L'),  '2 weeks ago');
        assert.equal(weeksFromNow.calendar(),   weeksFromNow.format('L'),  'in 2 weeks');
    });

    test('weeks year starting sunday formatted', function (assert) {
        assert.equal(moment([2012, 0,  1]).format('w ww wo'), '52 52 52nd', 'Jan  1 2012 should be week 52');
        assert.equal(moment([2012, 0,  2]).format('w ww wo'),   '1 01 1st', 'Jan  2 2012 should be week 1');
        assert.equal(moment([2012, 0,  8]).format('w ww wo'),   '1 01 1st', 'Jan  8 2012 should be week 1');
        assert.equal(moment([2012, 0,  9]).format('w ww wo'),   '2 02 2nd', 'Jan  9 2012 should be week 2');
        assert.equal(moment([2012, 0, 15]).format('w ww wo'),   '2 02 2nd', 'Jan 15 2012 should be week 2');
    });

}));

;(function (global, factory) {
   typeof exports === 'object' && typeof module !== 'undefined'
       && typeof require === 'function' ? factory(require('../../moment')) :
   typeof define === 'function' && define.amd ? define(['../../moment'], factory) :
   factory(global.moment)
}(this, function (moment) { 'use strict';

    function each(array, callback) {
        var i;
        for (i = 0; i < array.length; i++) {
            callback(array[i], i, array);
        }
    }

    function objectKeys(obj) {
        if (Object.keys) {
            return Object.keys(obj);
        } else {
            // IE8
            var res = [], i;
            for (i in obj) {
                if (obj.hasOwnProperty(i)) {
                    res.push(i);
                }
            }
            return res;
        }
    }

    // Pick the first defined of two or three arguments.
    function defaults(a, b, c) {
        if (a != null) {
            return a;
        }
        if (b != null) {
            return b;
        }
        return c;
    }

    function defineCommonLocaleTests(locale, options) {
        test('lenient ordinal parsing', function (assert) {
            var i, ordinalStr, testMoment;
            for (i = 1; i <= 31; ++i) {
                ordinalStr = moment([2014, 0, i]).format('YYYY MM Do');
                testMoment = moment(ordinalStr, 'YYYY MM Do');
                assert.equal(testMoment.year(), 2014,
                        'lenient ordinal parsing ' + i + ' year check');
                assert.equal(testMoment.month(), 0,
                        'lenient ordinal parsing ' + i + ' month check');
                assert.equal(testMoment.date(), i,
                        'lenient ordinal parsing ' + i + ' date check');
            }
        });

        test('lenient ordinal parsing of number', function (assert) {
            var i, testMoment;
            for (i = 1; i <= 31; ++i) {
                testMoment = moment('2014 01 ' + i, 'YYYY MM Do');
                assert.equal(testMoment.year(), 2014,
                        'lenient ordinal parsing of number ' + i + ' year check');
                assert.equal(testMoment.month(), 0,
                        'lenient ordinal parsing of number ' + i + ' month check');
                assert.equal(testMoment.date(), i,
                        'lenient ordinal parsing of number ' + i + ' date check');
            }
        });

        test('strict ordinal parsing', function (assert) {
            var i, ordinalStr, testMoment;
            for (i = 1; i <= 31; ++i) {
                ordinalStr = moment([2014, 0, i]).format('YYYY MM Do');
                testMoment = moment(ordinalStr, 'YYYY MM Do', true);
                assert.ok(testMoment.isValid(), 'strict ordinal parsing ' + i);
            }
        });

        test('meridiem invariant', function (assert) {
            var h, m, t1, t2;
            for (h = 0; h < 24; ++h) {
                for (m = 0; m < 60; m += 15) {
                    t1 = moment.utc([2000, 0, 1, h, m]);
                    t2 = moment.utc(t1.format('A h:mm'), 'A h:mm');
                    assert.equal(t2.format('HH:mm'), t1.format('HH:mm'),
                            'meridiem at ' + t1.format('HH:mm'));
                }
            }
        });

        test('date format correctness', function (assert) {
            var data, tokens;
            data = moment.localeData()._longDateFormat;
            tokens = objectKeys(data);
            each(tokens, function (srchToken) {
                // Check each format string to make sure it does not contain any
                // tokens that need to be expanded.
                each(tokens, function (baseToken) {
                    // strip escaped sequences
                    var format = data[baseToken].replace(/(\[[^\]]*\])/g, '');
                    assert.equal(false, !!~format.indexOf(srchToken),
                            'contains ' + srchToken + ' in ' + baseToken);
                });
            });
        });

        test('month parsing correctness', function (assert) {
            var i, m;

            if (locale === 'tr') {
                // I can't fix it :(
                expect(0);
                return;
            }
            function tester(format) {
                var r;
                r = moment(m.format(format), format);
                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format);
                r = moment(m.format(format).toLocaleUpperCase(), format);
                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' upper');
                r = moment(m.format(format).toLocaleLowerCase(), format);
                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' lower');

                r = moment(m.format(format), format, true);
                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' strict');
                r = moment(m.format(format).toLocaleUpperCase(), format, true);
                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' upper strict');
                r = moment(m.format(format).toLocaleLowerCase(), format, true);
                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' lower strict');
            }

            for (i = 0; i < 12; ++i) {
                m = moment([2015, i, 15, 18]);
                tester('MMM');
                tester('MMM.');
                tester('MMMM');
                tester('MMMM.');
            }
        });

        test('weekday parsing correctness', function (assert) {
            var i, m;

            if (locale === 'tr' || locale === 'az') {
                // There is a lower-case letter (Ä±), that converted to upper then
                // lower changes to i
                expect(0);
                return;
            }
            function tester(format) {
                var r, baseMsg = 'weekday ' + m.weekday() + ' fmt ' + format;
                r = moment(m.format(format), format);
                assert.equal(r.weekday(), m.weekday(), baseMsg);
                r = moment(m.format(format).toLocaleUpperCase(), format);
                assert.equal(r.weekday(), m.weekday(), baseMsg + ' upper');
                r = moment(m.format(format).toLocaleLowerCase(), format);
                assert.equal(r.weekday(), m.weekday(), baseMsg + ' lower');

                r = moment(m.format(format), format, true);
                assert.equal(r.weekday(), m.weekday(), baseMsg + ' strict');
                r = moment(m.format(format).toLocaleUpperCase(), format, true);
                assert.equal(r.weekday(), m.weekday(), baseMsg + ' upper strict');
                r = moment(m.format(format).toLocaleLowerCase(), format, true);
                assert.equal(r.weekday(), m.weekday(), baseMsg + ' lower strict');
            }

            for (i = 0; i < 7; ++i) {
                m = moment.utc([2015, i, 15, 18]);
                tester('dd');
                tester('ddd');
                tester('dddd');
            }
        });
    }

    function setupDeprecationHandler(test, moment, scope) {
        test._expectedDeprecations = null;
        test._observedDeprecations = null;
        test._oldSupress = moment.suppressDeprecationWarnings;
        moment.suppressDeprecationWarnings = true;
        test.expectedDeprecations = function () {
            test._expectedDeprecations = arguments;
            test._observedDeprecations = [];
        };
        moment.deprecationHandler = function (name, msg) {
            var deprecationId = matchedDeprecation(name, msg, test._expectedDeprecations);
            if (deprecationId === -1) {
                throw new Error('Unexpected deprecation thrown name=' +
                        name + ' msg=' + msg);
            }
            test._observedDeprecations[deprecationId] = 1;
        };
    }

    function teardownDeprecationHandler(test, moment, scope) {
        moment.suppressDeprecationWarnings = test._oldSupress;

        if (test._expectedDeprecations != null) {
            var missedDeprecations = [];
            each(test._expectedDeprecations, function (deprecationPattern, id) {
                if (test._observedDeprecations[id] !== 1) {
                    missedDeprecations.push(deprecationPattern);
                }
            });
            if (missedDeprecations.length !== 0) {
                throw new Error('Expected deprecation warnings did not happen: ' +
                        missedDeprecations.join(' '));
            }
        }
    }

    function matchedDeprecation(name, msg, deprecations) {
        if (deprecations == null) {
            return -1;
        }
        for (var i = 0; i < deprecations.length; ++i) {
            if (name != null && name === deprecations[i]) {
                return i;
            }
            if (msg != null && msg.substring(0, deprecations[i].length) === deprecations[i]) {
                return i;
            }
        }
        return -1;
    }

    /*global QUnit:false*/

    var test = QUnit.test;

    var expect = QUnit.expect;

    function module (name, lifecycle) {
        QUnit.module(name, {
            setup : function () {
                moment.locale('en');
                moment.createFromInputFallback = function (config) {
                    throw new Error('input not handled by moment: ' + config._i);
                };
                setupDeprecationHandler(test, moment, 'core');
                if (lifecycle && lifecycle.setup) {
                    lifecycle.setup();
                }
            },
            teardown : function () {
                teardownDeprecationHandler(test, moment, 'core');
                if (lifecycle && lifecycle.teardown) {
                    lifecycle.teardown();
                }
            }
        });
    }

    function localeModule (name, lifecycle) {
        QUnit.module('locale:' + name, {
            setup : function () {
                moment.locale(name);
                moment.createFromInputFallback = function (config) {
                    throw new Error('input not handled by moment: ' + config._i);
                };
                setupDeprecationHandler(test, moment, 'locale');
                if (lifecycle && lifecycle.setup) {
                    lifecycle.setup();
                }
            },
            teardown : function () {
                moment.locale('en');
                teardownDeprecationHandler(test, moment, 'locale');
                if (lifecycle && lifecycle.teardown) {
                    lifecycle.teardown();
                }
            }
        });
        defineCommonLocaleTests(name, -1, -1);
    }

    localeModule('en-nz');

    test('parse', function (assert) {
        var tests = 'January Jan_February Feb_March Mar_April Apr_May May_June Jun_July Jul_August Aug_September Sep_October Oct_November Nov_December Dec'.split('_'), i;
        function equalTest(input, mmm, i) {
            assert.equal(moment(input, mmm).month(), i, input + ' should be month ' + (i + 1));
        }
        for (i = 0; i < 12; i++) {
            tests[i] = tests[i].split(' ');
            equalTest(tests[i][0], 'MMM', i);
            equalTest(tests[i][1], 'MMM', i);
            equalTest(tests[i][0], 'MMMM', i);
            equalTest(tests[i][1], 'MMMM', i);
            equalTest(tests[i][0].toLocaleLowerCase(), 'MMMM', i);
            equalTest(tests[i][1].toLocaleLowerCase(), 'MMMM', i);
            equalTest(tests[i][0].toLocaleUpperCase(), 'MMMM', i);
            equalTest(tests[i][1].toLocaleUpperCase(), 'MMMM', i);
        }
    });

    test('format', function (assert) {
        var a = [
                ['dddd, MMMM Do YYYY, h:mm:ss a',      'Sunday, February 14th 2010, 3:25:50 pm'],
                ['ddd, hA',                            'Sun, 3PM'],
                ['M Mo MM MMMM MMM',                   '2 2nd 02 February Feb'],
                ['YYYY YY',                            '2010 10'],
                ['D Do DD',                            '14 14th 14'],
                ['d do dddd ddd dd',                   '0 0th Sunday Sun Su'],
                ['DDD DDDo DDDD',                      '45 45th 045'],
                ['w wo ww',                            '6 6th 06'],
                ['h hh',                               '3 03'],
                ['H HH',                               '15 15'],
                ['m mm',                               '25 25'],
                ['s ss',                               '50 50'],
                ['a A',                                'pm PM'],
                ['[the] DDDo [day of the year]',       'the 45th day of the year'],
                ['LTS',                                '3:25:50 PM'],
                ['L',                                  '14/02/2010'],
                ['LL',                                 '14 February 2010'],
                ['LLL',                                '14 February 2010 3:25 PM'],
                ['LLLL',                               'Sunday, 14 February 2010 3:25 PM'],
                ['l',                                  '14/2/2010'],
                ['ll',                                 '14 Feb 2010'],
                ['lll',                                '14 Feb 2010 3:25 PM'],
                ['llll',                               'Sun, 14 Feb 2010 3:25 PM']
            ],
            b = moment(new Date(2010, 1, 14, 15, 25, 50, 125)),
            i;
        for (i = 0; i < a.length; i++) {
            assert.equal(b.format(a[i][0]), a[i][1], a[i][0] + ' ---> ' + a[i][1]);
        }
    });

    test('format ordinal', function (assert) {
        assert.equal(moment([2011, 0, 1]).format('DDDo'), '1st', '1st');
        assert.equal(moment([2011, 0, 2]).format('DDDo'), '2nd', '2nd');
        assert.equal(moment([2011, 0, 3]).format('DDDo'), '3rd', '3rd');
        assert.equal(moment([2011, 0, 4]).format('DDDo'), '4th', '4th');
        assert.equal(moment([2011, 0, 5]).format('DDDo'), '5th', '5th');
        assert.equal(moment([2011, 0, 6]).format('DDDo'), '6th', '6th');
        assert.equal(moment([2011, 0, 7]).format('DDDo'), '7th', '7th');
        assert.equal(moment([2011, 0, 8]).format('DDDo'), '8th', '8th');
        assert.equal(moment([2011, 0, 9]).format('DDDo'), '9th', '9th');
        assert.equal(moment([2011, 0, 10]).format('DDDo'), '10th', '10th');

        assert.equal(moment([2011, 0, 11]).format('DDDo'), '11th', '11th');
        assert.equal(moment([2011, 0, 12]).format('DDDo'), '12th', '12th');
        assert.equal(moment([2011, 0, 13]).format('DDDo'), '13th', '13th');
        assert.equal(moment([2011, 0, 14]).format('DDDo'), '14th', '14th');
        assert.equal(moment([2011, 0, 15]).format('DDDo'), '15th', '15th');
        assert.equal(moment([2011, 0, 16]).format('DDDo'), '16th', '16th');
        assert.equal(moment([2011, 0, 17]).format('DDDo'), '17th', '17th');
        assert.equal(moment([2011, 0, 18]).format('DDDo'), '18th', '18th');
        assert.equal(moment([2011, 0, 19]).format('DDDo'), '19th', '19th');
        assert.equal(moment([2011, 0, 20]).format('DDDo'), '20th', '20th');

        assert.equal(moment([2011, 0, 21]).format('DDDo'), '21st', '21st');
        assert.equal(moment([2011, 0, 22]).format('DDDo'), '22nd', '22nd');
        assert.equal(moment([2011, 0, 23]).format('DDDo'), '23rd', '23rd');
        assert.equal(moment([2011, 0, 24]).format('DDDo'), '24th', '24th');
        assert.equal(moment([2011, 0, 25]).format('DDDo'), '25th', '25th');
        assert.equal(moment([2011, 0, 26]).format('DDDo'), '26th', '26th');
        assert.equal(moment([2011, 0, 27]).format('DDDo'), '27th', '27th');
        assert.equal(moment([2011, 0, 28]).format('DDDo'), '28th', '28th');
        assert.equal(moment([2011, 0, 29]).format('DDDo'), '29th', '29th');
        assert.equal(moment([2011, 0, 30]).format('DDDo'), '30th', '30th');

        assert.equal(moment([2011, 0, 31]).format('DDDo'), '31st', '31st');
    });

    test('format month', function (assert) {
        var expected = 'January Jan_February Feb_March Mar_April Apr_May May_June Jun_July Jul_August Aug_September Sep_October Oct_November Nov_December Dec'.split('_'), i;
        for (i = 0; i < expected.length; i++) {
            assert.equal(moment([2011, i, 1]).format('MMMM MMM'), expected[i], expected[i]);
        }
    });

    test('format week', function (assert) {
        var expected = 'Sunday Sun Su_Monday Mon Mo_Tuesday Tue Tu_Wednesday Wed We_Thursday Thu Th_Friday Fri Fr_Saturday Sat Sa'.split('_'), i;
        for (i = 0; i < expected.length; i++) {
            assert.equal(moment([2011, 0, 2 + i]).format('dddd ddd dd'), expected[i], expected[i]);
        }
    });

    test('from', function (assert) {
        var start = moment([2007, 1, 28]);
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 44}), true),  'a few seconds', '44 seconds = a few seconds');
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 45}), true),  'a minute',      '45 seconds = a minute');
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 89}), true),  'a minute',      '89 seconds = a minute');
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 90}), true),  '2 minutes',     '90 seconds = 2 minutes');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 44}), true),  '44 minutes',    '44 minutes = 44 minutes');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 45}), true),  'an hour',       '45 minutes = an hour');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 89}), true),  'an hour',       '89 minutes = an hour');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 90}), true),  '2 hours',       '90 minutes = 2 hours');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 5}), true),   '5 hours',       '5 hours = 5 hours');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 21}), true),  '21 hours',      '21 hours = 21 hours');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 22}), true),  'a day',         '22 hours = a day');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 35}), true),  'a day',         '35 hours = a day');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 36}), true),  '2 days',        '36 hours = 2 days');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 1}), true),   'a day',         '1 day = a day');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 5}), true),   '5 days',        '5 days = 5 days');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 25}), true),  '25 days',       '25 days = 25 days');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 26}), true),  'a month',       '26 days = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 30}), true),  'a month',       '30 days = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 43}), true),  'a month',       '43 days = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 46}), true),  '2 months',      '46 days = 2 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 74}), true),  '2 months',      '75 days = 2 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 76}), true),  '3 months',      '76 days = 3 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({M: 1}), true),   'a month',       '1 month = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({M: 5}), true),   '5 months',      '5 months = 5 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 345}), true), 'a year',        '345 days = a year');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 548}), true), '2 years',       '548 days = 2 years');
        assert.equal(start.from(moment([2007, 1, 28]).add({y: 1}), true),   'a year',        '1 year = a year');
        assert.equal(start.from(moment([2007, 1, 28]).add({y: 5}), true),   '5 years',       '5 years = 5 years');
    });

    test('suffix', function (assert) {
        assert.equal(moment(30000).from(0), 'in a few seconds',  'prefix');
        assert.equal(moment(0).from(30000), 'a few seconds ago', 'suffix');
    });

    test('now from now', function (assert) {
        assert.equal(moment().fromNow(), 'a few seconds ago',  'now from now should display as in the past');
    });

    test('fromNow', function (assert) {
        assert.equal(moment().add({s: 30}).fromNow(), 'in a few seconds', 'in a few seconds');
        assert.equal(moment().add({d: 5}).fromNow(), 'in 5 days', 'in 5 days');
    });

    test('calendar day', function (assert) {
        var a = moment().hours(12).minutes(0).seconds(0);

        assert.equal(moment(a).calendar(),                   'Today at 12:00 PM',     'today at the same time');
        assert.equal(moment(a).add({m: 25}).calendar(),      'Today at 12:25 PM',     'Now plus 25 min');
        assert.equal(moment(a).add({h: 1}).calendar(),       'Today at 1:00 PM',      'Now plus 1 hour');
        assert.equal(moment(a).add({d: 1}).calendar(),       'Tomorrow at 12:00 PM',  'tomorrow at the same time');
        assert.equal(moment(a).subtract({h: 1}).calendar(),  'Today at 11:00 AM',     'Now minus 1 hour');
        assert.equal(moment(a).subtract({d: 1}).calendar(),  'Yesterday at 12:00 PM', 'yesterday at the same time');
    });

    test('calendar next week', function (assert) {
        var i, m;
        for (i = 2; i < 7; i++) {
            m = moment().add({d: i});
            assert.equal(m.calendar(),       m.format('dddd [at] LT'),  'Today + ' + i + ' days current time');
            m.hours(0).minutes(0).seconds(0).milliseconds(0);
            assert.equal(m.calendar(),       m.format('dddd [at] LT'),  'Today + ' + i + ' days beginning of day');
            m.hours(23).minutes(59).seconds(59).milliseconds(999);
            assert.equal(m.calendar(),       m.format('dddd [at] LT'),  'Today + ' + i + ' days end of day');
        }
    });

    test('calendar last week', function (assert) {
        var i, m;

        for (i = 2; i < 7; i++) {
            m = moment().subtract({d: i});
            assert.equal(m.calendar(),       m.format('[Last] dddd [at] LT'),  'Today - ' + i + ' days current time');
            m.hours(0).minutes(0).seconds(0).milliseconds(0);
            assert.equal(m.calendar(),       m.format('[Last] dddd [at] LT'),  'Today - ' + i + ' days beginning of day');
            m.hours(23).minutes(59).seconds(59).milliseconds(999);
            assert.equal(m.calendar(),       m.format('[Last] dddd [at] LT'),  'Today - ' + i + ' days end of day');
        }
    });

    test('calendar all else', function (assert) {
        var weeksAgo = moment().subtract({w: 1}),
            weeksFromNow = moment().add({w: 1});

        assert.equal(weeksAgo.calendar(),       weeksAgo.format('L'),  '1 week ago');
        assert.equal(weeksFromNow.calendar(),   weeksFromNow.format('L'),  'in 1 week');

        weeksAgo = moment().subtract({w: 2});
        weeksFromNow = moment().add({w: 2});

        assert.equal(weeksAgo.calendar(),       weeksAgo.format('L'),  '2 weeks ago');
        assert.equal(weeksFromNow.calendar(),   weeksFromNow.format('L'),  'in 2 weeks');
    });

    test('weeks year starting sunday formatted', function (assert) {
        assert.equal(moment([2012, 0,  1]).format('w ww wo'), '52 52 52nd', 'Jan  1 2012 should be week 52');
        assert.equal(moment([2012, 0,  2]).format('w ww wo'),   '1 01 1st', 'Jan  2 2012 should be week 1');
        assert.equal(moment([2012, 0,  8]).format('w ww wo'),   '1 01 1st', 'Jan  8 2012 should be week 1');
        assert.equal(moment([2012, 0,  9]).format('w ww wo'),   '2 02 2nd', 'Jan  9 2012 should be week 2');
        assert.equal(moment([2012, 0, 15]).format('w ww wo'),   '2 02 2nd', 'Jan 15 2012 should be week 2');
    });

}));

;(function (global, factory) {
   typeof exports === 'object' && typeof module !== 'undefined'
       && typeof require === 'function' ? factory(require('../../moment')) :
   typeof define === 'function' && define.amd ? define(['../../moment'], factory) :
   factory(global.moment)
}(this, function (moment) { 'use strict';

    function each(array, callback) {
        var i;
        for (i = 0; i < array.length; i++) {
            callback(array[i], i, array);
        }
    }

    function objectKeys(obj) {
        if (Object.keys) {
            return Object.keys(obj);
        } else {
            // IE8
            var res = [], i;
            for (i in obj) {
                if (obj.hasOwnProperty(i)) {
                    res.push(i);
                }
            }
            return res;
        }
    }

    // Pick the first defined of two or three arguments.
    function defaults(a, b, c) {
        if (a != null) {
            return a;
        }
        if (b != null) {
            return b;
        }
        return c;
    }

    function defineCommonLocaleTests(locale, options) {
        test('lenient ordinal parsing', function (assert) {
            var i, ordinalStr, testMoment;
            for (i = 1; i <= 31; ++i) {
                ordinalStr = moment([2014, 0, i]).format('YYYY MM Do');
                testMoment = moment(ordinalStr, 'YYYY MM Do');
                assert.equal(testMoment.year(), 2014,
                        'lenient ordinal parsing ' + i + ' year check');
                assert.equal(testMoment.month(), 0,
                        'lenient ordinal parsing ' + i + ' month check');
                assert.equal(testMoment.date(), i,
                        'lenient ordinal parsing ' + i + ' date check');
            }
        });

        test('lenient ordinal parsing of number', function (assert) {
            var i, testMoment;
            for (i = 1; i <= 31; ++i) {
                testMoment = moment('2014 01 ' + i, 'YYYY MM Do');
                assert.equal(testMoment.year(), 2014,
                        'lenient ordinal parsing of number ' + i + ' year check');
                assert.equal(testMoment.month(), 0,
                        'lenient ordinal parsing of number ' + i + ' month check');
                assert.equal(testMoment.date(), i,
                        'lenient ordinal parsing of number ' + i + ' date check');
            }
        });

        test('strict ordinal parsing', function (assert) {
            var i, ordinalStr, testMoment;
            for (i = 1; i <= 31; ++i) {
                ordinalStr = moment([2014, 0, i]).format('YYYY MM Do');
                testMoment = moment(ordinalStr, 'YYYY MM Do', true);
                assert.ok(testMoment.isValid(), 'strict ordinal parsing ' + i);
            }
        });

        test('meridiem invariant', function (assert) {
            var h, m, t1, t2;
            for (h = 0; h < 24; ++h) {
                for (m = 0; m < 60; m += 15) {
                    t1 = moment.utc([2000, 0, 1, h, m]);
                    t2 = moment.utc(t1.format('A h:mm'), 'A h:mm');
                    assert.equal(t2.format('HH:mm'), t1.format('HH:mm'),
                            'meridiem at ' + t1.format('HH:mm'));
                }
            }
        });

        test('date format correctness', function (assert) {
            var data, tokens;
            data = moment.localeData()._longDateFormat;
            tokens = objectKeys(data);
            each(tokens, function (srchToken) {
                // Check each format string to make sure it does not contain any
                // tokens that need to be expanded.
                each(tokens, function (baseToken) {
                    // strip escaped sequences
                    var format = data[baseToken].replace(/(\[[^\]]*\])/g, '');
                    assert.equal(false, !!~format.indexOf(srchToken),
                            'contains ' + srchToken + ' in ' + baseToken);
                });
            });
        });

        test('month parsing correctness', function (assert) {
            var i, m;

            if (locale === 'tr') {
                // I can't fix it :(
                expect(0);
                return;
            }
            function tester(format) {
                var r;
                r = moment(m.format(format), format);
                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format);
                r = moment(m.format(format).toLocaleUpperCase(), format);
                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' upper');
                r = moment(m.format(format).toLocaleLowerCase(), format);
                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' lower');

                r = moment(m.format(format), format, true);
                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' strict');
                r = moment(m.format(format).toLocaleUpperCase(), format, true);
                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' upper strict');
                r = moment(m.format(format).toLocaleLowerCase(), format, true);
                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' lower strict');
            }

            for (i = 0; i < 12; ++i) {
                m = moment([2015, i, 15, 18]);
                tester('MMM');
                tester('MMM.');
                tester('MMMM');
                tester('MMMM.');
            }
        });

        test('weekday parsing correctness', function (assert) {
            var i, m;

            if (locale === 'tr' || locale === 'az') {
                // There is a lower-case letter (Ä±), that converted to upper then
                // lower changes to i
                expect(0);
                return;
            }
            function tester(format) {
                var r, baseMsg = 'weekday ' + m.weekday() + ' fmt ' + format;
                r = moment(m.format(format), format);
                assert.equal(r.weekday(), m.weekday(), baseMsg);
                r = moment(m.format(format).toLocaleUpperCase(), format);
                assert.equal(r.weekday(), m.weekday(), baseMsg + ' upper');
                r = moment(m.format(format).toLocaleLowerCase(), format);
                assert.equal(r.weekday(), m.weekday(), baseMsg + ' lower');

                r = moment(m.format(format), format, true);
                assert.equal(r.weekday(), m.weekday(), baseMsg + ' strict');
                r = moment(m.format(format).toLocaleUpperCase(), format, true);
                assert.equal(r.weekday(), m.weekday(), baseMsg + ' upper strict');
                r = moment(m.format(format).toLocaleLowerCase(), format, true);
                assert.equal(r.weekday(), m.weekday(), baseMsg + ' lower strict');
            }

            for (i = 0; i < 7; ++i) {
                m = moment.utc([2015, i, 15, 18]);
                tester('dd');
                tester('ddd');
                tester('dddd');
            }
        });
    }

    function setupDeprecationHandler(test, moment, scope) {
        test._expectedDeprecations = null;
        test._observedDeprecations = null;
        test._oldSupress = moment.suppressDeprecationWarnings;
        moment.suppressDeprecationWarnings = true;
        test.expectedDeprecations = function () {
            test._expectedDeprecations = arguments;
            test._observedDeprecations = [];
        };
        moment.deprecationHandler = function (name, msg) {
            var deprecationId = matchedDeprecation(name, msg, test._expectedDeprecations);
            if (deprecationId === -1) {
                throw new Error('Unexpected deprecation thrown name=' +
                        name + ' msg=' + msg);
            }
            test._observedDeprecations[deprecationId] = 1;
        };
    }

    function teardownDeprecationHandler(test, moment, scope) {
        moment.suppressDeprecationWarnings = test._oldSupress;

        if (test._expectedDeprecations != null) {
            var missedDeprecations = [];
            each(test._expectedDeprecations, function (deprecationPattern, id) {
                if (test._observedDeprecations[id] !== 1) {
                    missedDeprecations.push(deprecationPattern);
                }
            });
            if (missedDeprecations.length !== 0) {
                throw new Error('Expected deprecation warnings did not happen: ' +
                        missedDeprecations.join(' '));
            }
        }
    }

    function matchedDeprecation(name, msg, deprecations) {
        if (deprecations == null) {
            return -1;
        }
        for (var i = 0; i < deprecations.length; ++i) {
            if (name != null && name === deprecations[i]) {
                return i;
            }
            if (msg != null && msg.substring(0, deprecations[i].length) === deprecations[i]) {
                return i;
            }
        }
        return -1;
    }

    /*global QUnit:false*/

    var test = QUnit.test;

    var expect = QUnit.expect;

    function module (name, lifecycle) {
        QUnit.module(name, {
            setup : function () {
                moment.locale('en');
                moment.createFromInputFallback = function (config) {
                    throw new Error('input not handled by moment: ' + config._i);
                };
                setupDeprecationHandler(test, moment, 'core');
                if (lifecycle && lifecycle.setup) {
                    lifecycle.setup();
                }
            },
            teardown : function () {
                teardownDeprecationHandler(test, moment, 'core');
                if (lifecycle && lifecycle.teardown) {
                    lifecycle.teardown();
                }
            }
        });
    }

    function localeModule (name, lifecycle) {
        QUnit.module('locale:' + name, {
            setup : function () {
                moment.locale(name);
                moment.createFromInputFallback = function (config) {
                    throw new Error('input not handled by moment: ' + config._i);
                };
                setupDeprecationHandler(test, moment, 'locale');
                if (lifecycle && lifecycle.setup) {
                    lifecycle.setup();
                }
            },
            teardown : function () {
                moment.locale('en');
                teardownDeprecationHandler(test, moment, 'locale');
                if (lifecycle && lifecycle.teardown) {
                    lifecycle.teardown();
                }
            }
        });
        defineCommonLocaleTests(name, -1, -1);
    }

    localeModule('en');

    test('parse', function (assert) {
        var i,
            tests = 'January Jan_February Feb_March Mar_April Apr_May May_June Jun_July Jul_August Aug_September Sep_October Oct_November Nov_December Dec'.split('_');

        function equalTest(input, mmm, i) {
            assert.equal(moment(input, mmm).month(), i, input + ' should be month ' + (i + 1));
        }

        for (i = 0; i < 12; i++) {
            tests[i] = tests[i].split(' ');
            equalTest(tests[i][0], 'MMM', i);
            equalTest(tests[i][1], 'MMM', i);
            equalTest(tests[i][0], 'MMMM', i);
            equalTest(tests[i][1], 'MMMM', i);
            equalTest(tests[i][0].toLocaleLowerCase(), 'MMMM', i);
            equalTest(tests[i][1].toLocaleLowerCase(), 'MMMM', i);
            equalTest(tests[i][0].toLocaleUpperCase(), 'MMMM', i);
            equalTest(tests[i][1].toLocaleUpperCase(), 'MMMM', i);
        }
    });

    test('format', function (assert) {
        var a = [
                ['dddd, MMMM Do YYYY, h:mm:ss a',      'Sunday, February 14th 2010, 3:25:50 pm'],
                ['ddd, hA',                            'Sun, 3PM'],
                ['M Mo MM MMMM MMM',                   '2 2nd 02 February Feb'],
                ['YYYY YY',                            '2010 10'],
                ['D Do DD',                            '14 14th 14'],
                ['d do dddd ddd dd',                   '0 0th Sunday Sun Su'],
                ['DDD DDDo DDDD',                      '45 45th 045'],
                ['w wo ww',                            '8 8th 08'],
                ['h hh',                               '3 03'],
                ['H HH',                               '15 15'],
                ['m mm',                               '25 25'],
                ['s ss',                               '50 50'],
                ['a A',                                'pm PM'],
                ['[the] DDDo [day of the year]',       'the 45th day of the year'],
                ['LTS',                                '3:25:50 PM'],
                ['L',                                  '02/14/2010'],
                ['LL',                                 'February 14, 2010'],
                ['LLL',                                'February 14, 2010 3:25 PM'],
                ['LLLL',                               'Sunday, February 14, 2010 3:25 PM'],
                ['l',                                  '2/14/2010'],
                ['ll',                                 'Feb 14, 2010'],
                ['lll',                                'Feb 14, 2010 3:25 PM'],
                ['llll',                               'Sun, Feb 14, 2010 3:25 PM']
            ],
            b = moment(new Date(2010, 1, 14, 15, 25, 50, 125)),
            i;

        for (i = 0; i < a.length; i++) {
            assert.equal(b.format(a[i][0]), a[i][1], a[i][0] + ' ---> ' + a[i][1]);
        }
    });

    test('format ordinal', function (assert) {
        assert.equal(moment([2011, 0, 1]).format('DDDo'), '1st', '1st');
        assert.equal(moment([2011, 0, 2]).format('DDDo'), '2nd', '2nd');
        assert.equal(moment([2011, 0, 3]).format('DDDo'), '3rd', '3rd');
        assert.equal(moment([2011, 0, 4]).format('DDDo'), '4th', '4th');
        assert.equal(moment([2011, 0, 5]).format('DDDo'), '5th', '5th');
        assert.equal(moment([2011, 0, 6]).format('DDDo'), '6th', '6th');
        assert.equal(moment([2011, 0, 7]).format('DDDo'), '7th', '7th');
        assert.equal(moment([2011, 0, 8]).format('DDDo'), '8th', '8th');
        assert.equal(moment([2011, 0, 9]).format('DDDo'), '9th', '9th');
        assert.equal(moment([2011, 0, 10]).format('DDDo'), '10th', '10th');

        assert.equal(moment([2011, 0, 11]).format('DDDo'), '11th', '11th');
        assert.equal(moment([2011, 0, 12]).format('DDDo'), '12th', '12th');
        assert.equal(moment([2011, 0, 13]).format('DDDo'), '13th', '13th');
        assert.equal(moment([2011, 0, 14]).format('DDDo'), '14th', '14th');
        assert.equal(moment([2011, 0, 15]).format('DDDo'), '15th', '15th');
        assert.equal(moment([2011, 0, 16]).format('DDDo'), '16th', '16th');
        assert.equal(moment([2011, 0, 17]).format('DDDo'), '17th', '17th');
        assert.equal(moment([2011, 0, 18]).format('DDDo'), '18th', '18th');
        assert.equal(moment([2011, 0, 19]).format('DDDo'), '19th', '19th');
        assert.equal(moment([2011, 0, 20]).format('DDDo'), '20th', '20th');

        assert.equal(moment([2011, 0, 21]).format('DDDo'), '21st', '21st');
        assert.equal(moment([2011, 0, 22]).format('DDDo'), '22nd', '22nd');
        assert.equal(moment([2011, 0, 23]).format('DDDo'), '23rd', '23rd');
        assert.equal(moment([2011, 0, 24]).format('DDDo'), '24th', '24th');
        assert.equal(moment([2011, 0, 25]).format('DDDo'), '25th', '25th');
        assert.equal(moment([2011, 0, 26]).format('DDDo'), '26th', '26th');
        assert.equal(moment([2011, 0, 27]).format('DDDo'), '27th', '27th');
        assert.equal(moment([2011, 0, 28]).format('DDDo'), '28th', '28th');
        assert.equal(moment([2011, 0, 29]).format('DDDo'), '29th', '29th');
        assert.equal(moment([2011, 0, 30]).format('DDDo'), '30th', '30th');

        assert.equal(moment([2011, 0, 31]).format('DDDo'), '31st', '31st');
    });

    test('format month', function (assert) {
        var i,
            expected = 'January Jan_February Feb_March Mar_April Apr_May May_June Jun_July Jul_August Aug_September Sep_October Oct_November Nov_December Dec'.split('_');

        for (i = 0; i < expected.length; i++) {
            assert.equal(moment([2011, i, 1]).format('MMMM MMM'), expected[i], expected[i]);
        }
    });

    test('format week', function (assert) {
        var i,
            expected = 'Sunday Sun Su_Monday Mon Mo_Tuesday Tue Tu_Wednesday Wed We_Thursday Thu Th_Friday Fri Fr_Saturday Sat Sa'.split('_');

        for (i = 0; i < expected.length; i++) {
            assert.equal(moment([2011, 0, 2 + i]).format('dddd ddd dd'), expected[i], expected[i]);
        }
    });

    test('from', function (assert) {
        var start = moment([2007, 1, 28]);

        assert.equal(start.from(moment([2007, 1, 28]).add({s: 44}), true),  'a few seconds', '44 seconds = a few seconds');
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 45}), true),  'a minute',      '45 seconds = a minute');
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 89}), true),  'a minute',      '89 seconds = a minute');
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 90}), true),  '2 minutes',     '90 seconds = 2 minutes');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 44}), true),  '44 minutes',    '44 minutes = 44 minutes');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 45}), true),  'an hour',       '45 minutes = an hour');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 89}), true),  'an hour',       '89 minutes = an hour');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 90}), true),  '2 hours',       '90 minutes = 2 hours');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 5}), true),   '5 hours',       '5 hours = 5 hours');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 21}), true),  '21 hours',      '21 hours = 21 hours');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 22}), true),  'a day',         '22 hours = a day');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 35}), true),  'a day',         '35 hours = a day');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 36}), true),  '2 days',        '36 hours = 2 days');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 1}), true),   'a day',         '1 day = a day');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 5}), true),   '5 days',        '5 days = 5 days');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 25}), true),  '25 days',       '25 days = 25 days');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 26}), true),  'a month',       '26 days = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 30}), true),  'a month',       '30 days = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 43}), true),  'a month',       '43 days = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 46}), true),  '2 months',      '46 days = 2 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 74}), true),  '2 months',      '75 days = 2 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 76}), true),  '3 months',      '76 days = 3 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({M: 1}), true),   'a month',       '1 month = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({M: 5}), true),   '5 months',      '5 months = 5 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 345}), true), 'a year',        '345 days = a year');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 548}), true), '2 years',       '548 days = 2 years');
        assert.equal(start.from(moment([2007, 1, 28]).add({y: 1}), true),   'a year',        '1 year = a year');
        assert.equal(start.from(moment([2007, 1, 28]).add({y: 5}), true),   '5 years',       '5 years = 5 years');
    });

    test('suffix', function (assert) {
        assert.equal(moment(30000).from(0), 'in a few seconds',  'prefix');
        assert.equal(moment(0).from(30000), 'a few seconds ago', 'suffix');
    });

    test('now from now', function (assert) {
        assert.equal(moment().fromNow(), 'a few seconds ago',  'now from now should display as in the past');
    });

    test('fromNow', function (assert) {
        assert.equal(moment().add({s: 30}).fromNow(), 'in a few seconds', 'in a few seconds');
        assert.equal(moment().add({d: 5}).fromNow(), 'in 5 days', 'in 5 days');
    });

    test('calendar day', function (assert) {
        var a = moment().hours(12).minutes(0).seconds(0);

        assert.equal(moment(a).calendar(),                   'Today at 12:00 PM',     'today at the same time');
        assert.equal(moment(a).add({m: 25}).calendar(),      'Today at 12:25 PM',     'Now plus 25 min');
        assert.equal(moment(a).add({h: 1}).calendar(),       'Today at 1:00 PM',      'Now plus 1 hour');
        assert.equal(moment(a).add({d: 1}).calendar(),       'Tomorrow at 12:00 PM',  'tomorrow at the same time');
        assert.equal(moment(a).subtract({h: 1}).calendar(),  'Today at 11:00 AM',     'Now minus 1 hour');
        assert.equal(moment(a).subtract({d: 1}).calendar(),  'Yesterday at 12:00 PM', 'yesterday at the same time');
    });

    test('calendar next week', function (assert) {
        var i, m;

        for (i = 2; i < 7; i++) {
            m = moment().add({d: i});
            assert.equal(m.calendar(),       m.format('dddd [at] LT'),  'Today + ' + i + ' days current time');
            m.hours(0).minutes(0).seconds(0).milliseconds(0);
            assert.equal(m.calendar(),       m.format('dddd [at] LT'),  'Today + ' + i + ' days beginning of day');
            m.hours(23).minutes(59).seconds(59).milliseconds(999);
            assert.equal(m.calendar(),       m.format('dddd [at] LT'),  'Today + ' + i + ' days end of day');
        }
    });

    test('calendar last week', function (assert) {
        var i, m;

        for (i = 2; i < 7; i++) {
            m = moment().subtract({d: i});
            assert.equal(m.calendar(),       m.format('[Last] dddd [at] LT'),  'Today - ' + i + ' days current time');
            m.hours(0).minutes(0).seconds(0).milliseconds(0);
            assert.equal(m.calendar(),       m.format('[Last] dddd [at] LT'),  'Today - ' + i + ' days beginning of day');
            m.hours(23).minutes(59).seconds(59).milliseconds(999);
            assert.equal(m.calendar(),       m.format('[Last] dddd [at] LT'),  'Today - ' + i + ' days end of day');
        }
    });

    test('calendar all else', function (assert) {
        var weeksAgo = moment().subtract({w: 1}),
            weeksFromNow = moment().add({w: 1});

        assert.equal(weeksAgo.calendar(),       weeksAgo.format('L'),  '1 week ago');
        assert.equal(weeksFromNow.calendar(),   weeksFromNow.format('L'),  'in 1 week');

        weeksAgo = moment().subtract({w: 2});
        weeksFromNow = moment().add({w: 2});

        assert.equal(weeksAgo.calendar(),       weeksAgo.format('L'),  '2 weeks ago');
        assert.equal(weeksFromNow.calendar(),   weeksFromNow.format('L'),  'in 2 weeks');
    });

    test('weeks year starting sunday format', function (assert) {
        assert.equal(moment([2012, 0,  1]).format('w ww wo'), '1 01 1st', 'Jan  1 2012 should be week 1');
        assert.equal(moment([2012, 0,  7]).format('w ww wo'), '1 01 1st', 'Jan  7 2012 should be week 1');
        assert.equal(moment([2012, 0,  8]).format('w ww wo'), '2 02 2nd', 'Jan  8 2012 should be week 2');
        assert.equal(moment([2012, 0, 14]).format('w ww wo'), '2 02 2nd', 'Jan 14 2012 should be week 2');
        assert.equal(moment([2012, 0, 15]).format('w ww wo'), '3 03 3rd', 'Jan 15 2012 should be week 3');
    });

    test('weekdays strict parsing', function (assert) {
        var m = moment('2015-01-01T12', moment.ISO_8601, true),
            enLocale = moment.localeData('en');

        for (var i = 0; i < 7; ++i) {
            assert.equal(moment(enLocale.weekdays(m.day(i), ''), 'dddd', true).isValid(), true, 'parse weekday ' + i);
            assert.equal(moment(enLocale.weekdaysShort(m.day(i), ''), 'ddd', true).isValid(), true, 'parse short weekday ' + i);
            assert.equal(moment(enLocale.weekdaysMin(m.day(i), ''), 'dd', true).isValid(), true, 'parse min weekday ' + i);

            // negative tests
            assert.equal(moment(enLocale.weekdaysMin(m.day(i), ''), 'ddd', true).isValid(), false, 'parse short weekday ' + i);
            assert.equal(moment(enLocale.weekdaysShort(m.day(i), ''), 'dd', true).isValid(), false, 'parse min weekday ' + i);
        }
    });

}));

;(function (global, factory) {
   typeof exports === 'object' && typeof module !== 'undefined'
       && typeof require === 'function' ? factory(require('../../moment')) :
   typeof define === 'function' && define.amd ? define(['../../moment'], factory) :
   factory(global.moment)
}(this, function (moment) { 'use strict';

    function each(array, callback) {
        var i;
        for (i = 0; i < array.length; i++) {
            callback(array[i], i, array);
        }
    }

    function objectKeys(obj) {
        if (Object.keys) {
            return Object.keys(obj);
        } else {
            // IE8
            var res = [], i;
            for (i in obj) {
                if (obj.hasOwnProperty(i)) {
                    res.push(i);
                }
            }
            return res;
        }
    }

    // Pick the first defined of two or three arguments.
    function defaults(a, b, c) {
        if (a != null) {
            return a;
        }
        if (b != null) {
            return b;
        }
        return c;
    }

    function defineCommonLocaleTests(locale, options) {
        test('lenient ordinal parsing', function (assert) {
            var i, ordinalStr, testMoment;
            for (i = 1; i <= 31; ++i) {
                ordinalStr = moment([2014, 0, i]).format('YYYY MM Do');
                testMoment = moment(ordinalStr, 'YYYY MM Do');
                assert.equal(testMoment.year(), 2014,
                        'lenient ordinal parsing ' + i + ' year check');
                assert.equal(testMoment.month(), 0,
                        'lenient ordinal parsing ' + i + ' month check');
                assert.equal(testMoment.date(), i,
                        'lenient ordinal parsing ' + i + ' date check');
            }
        });

        test('lenient ordinal parsing of number', function (assert) {
            var i, testMoment;
            for (i = 1; i <= 31; ++i) {
                testMoment = moment('2014 01 ' + i, 'YYYY MM Do');
                assert.equal(testMoment.year(), 2014,
                        'lenient ordinal parsing of number ' + i + ' year check');
                assert.equal(testMoment.month(), 0,
                        'lenient ordinal parsing of number ' + i + ' month check');
                assert.equal(testMoment.date(), i,
                        'lenient ordinal parsing of number ' + i + ' date check');
            }
        });

        test('strict ordinal parsing', function (assert) {
            var i, ordinalStr, testMoment;
            for (i = 1; i <= 31; ++i) {
                ordinalStr = moment([2014, 0, i]).format('YYYY MM Do');
                testMoment = moment(ordinalStr, 'YYYY MM Do', true);
                assert.ok(testMoment.isValid(), 'strict ordinal parsing ' + i);
            }
        });

        test('meridiem invariant', function (assert) {
            var h, m, t1, t2;
            for (h = 0; h < 24; ++h) {
                for (m = 0; m < 60; m += 15) {
                    t1 = moment.utc([2000, 0, 1, h, m]);
                    t2 = moment.utc(t1.format('A h:mm'), 'A h:mm');
                    assert.equal(t2.format('HH:mm'), t1.format('HH:mm'),
                            'meridiem at ' + t1.format('HH:mm'));
                }
            }
        });

        test('date format correctness', function (assert) {
            var data, tokens;
            data = moment.localeData()._longDateFormat;
            tokens = objectKeys(data);
            each(tokens, function (srchToken) {
                // Check each format string to make sure it does not contain any
                // tokens that need to be expanded.
                each(tokens, function (baseToken) {
                    // strip escaped sequences
                    var format = data[baseToken].replace(/(\[[^\]]*\])/g, '');
                    assert.equal(false, !!~format.indexOf(srchToken),
                            'contains ' + srchToken + ' in ' + baseToken);
                });
            });
        });

        test('month parsing correctness', function (assert) {
            var i, m;

            if (locale === 'tr') {
                // I can't fix it :(
                expect(0);
                return;
            }
            function tester(format) {
                var r;
                r = moment(m.format(format), format);
                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format);
                r = moment(m.format(format).toLocaleUpperCase(), format);
                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' upper');
                r = moment(m.format(format).toLocaleLowerCase(), format);
                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' lower');

                r = moment(m.format(format), format, true);
                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' strict');
                r = moment(m.format(format).toLocaleUpperCase(), format, true);
                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' upper strict');
                r = moment(m.format(format).toLocaleLowerCase(), format, true);
                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' lower strict');
            }

            for (i = 0; i < 12; ++i) {
                m = moment([2015, i, 15, 18]);
                tester('MMM');
                tester('MMM.');
                tester('MMMM');
                tester('MMMM.');
            }
        });

        test('weekday parsing correctness', function (assert) {
            var i, m;

            if (locale === 'tr' || locale === 'az') {
                // There is a lower-case letter (Ä±), that converted to upper then
                // lower changes to i
                expect(0);
                return;
            }
            function tester(format) {
                var r, baseMsg = 'weekday ' + m.weekday() + ' fmt ' + format;
                r = moment(m.format(format), format);
                assert.equal(r.weekday(), m.weekday(), baseMsg);
                r = moment(m.format(format).toLocaleUpperCase(), format);
                assert.equal(r.weekday(), m.weekday(), baseMsg + ' upper');
                r = moment(m.format(format).toLocaleLowerCase(), format);
                assert.equal(r.weekday(), m.weekday(), baseMsg + ' lower');

                r = moment(m.format(format), format, true);
                assert.equal(r.weekday(), m.weekday(), baseMsg + ' strict');
                r = moment(m.format(format).toLocaleUpperCase(), format, true);
                assert.equal(r.weekday(), m.weekday(), baseMsg + ' upper strict');
                r = moment(m.format(format).toLocaleLowerCase(), format, true);
                assert.equal(r.weekday(), m.weekday(), baseMsg + ' lower strict');
            }

            for (i = 0; i < 7; ++i) {
                m = moment.utc([2015, i, 15, 18]);
                tester('dd');
                tester('ddd');
                tester('dddd');
            }
        });
    }

    function setupDeprecationHandler(test, moment, scope) {
        test._expectedDeprecations = null;
        test._observedDeprecations = null;
        test._oldSupress = moment.suppressDeprecationWarnings;
        moment.suppressDeprecationWarnings = true;
        test.expectedDeprecations = function () {
            test._expectedDeprecations = arguments;
            test._observedDeprecations = [];
        };
        moment.deprecationHandler = function (name, msg) {
            var deprecationId = matchedDeprecation(name, msg, test._expectedDeprecations);
            if (deprecationId === -1) {
                throw new Error('Unexpected deprecation thrown name=' +
                        name + ' msg=' + msg);
            }
            test._observedDeprecations[deprecationId] = 1;
        };
    }

    function teardownDeprecationHandler(test, moment, scope) {
        moment.suppressDeprecationWarnings = test._oldSupress;

        if (test._expectedDeprecations != null) {
            var missedDeprecations = [];
            each(test._expectedDeprecations, function (deprecationPattern, id) {
                if (test._observedDeprecations[id] !== 1) {
                    missedDeprecations.push(deprecationPattern);
                }
            });
            if (missedDeprecations.length !== 0) {
                throw new Error('Expected deprecation warnings did not happen: ' +
                        missedDeprecations.join(' '));
            }
        }
    }

    function matchedDeprecation(name, msg, deprecations) {
        if (deprecations == null) {
            return -1;
        }
        for (var i = 0; i < deprecations.length; ++i) {
            if (name != null && name === deprecations[i]) {
                return i;
            }
            if (msg != null && msg.substring(0, deprecations[i].length) === deprecations[i]) {
                return i;
            }
        }
        return -1;
    }

    /*global QUnit:false*/

    var test = QUnit.test;

    var expect = QUnit.expect;

    function module (name, lifecycle) {
        QUnit.module(name, {
            setup : function () {
                moment.locale('en');
                moment.createFromInputFallback = function (config) {
                    throw new Error('input not handled by moment: ' + config._i);
                };
                setupDeprecationHandler(test, moment, 'core');
                if (lifecycle && lifecycle.setup) {
                    lifecycle.setup();
                }
            },
            teardown : function () {
                teardownDeprecationHandler(test, moment, 'core');
                if (lifecycle && lifecycle.teardown) {
                    lifecycle.teardown();
                }
            }
        });
    }

    function localeModule (name, lifecycle) {
        QUnit.module('locale:' + name, {
            setup : function () {
                moment.locale(name);
                moment.createFromInputFallback = function (config) {
                    throw new Error('input not handled by moment: ' + config._i);
                };
                setupDeprecationHandler(test, moment, 'locale');
                if (lifecycle && lifecycle.setup) {
                    lifecycle.setup();
                }
            },
            teardown : function () {
                moment.locale('en');
                teardownDeprecationHandler(test, moment, 'locale');
                if (lifecycle && lifecycle.teardown) {
                    lifecycle.teardown();
                }
            }
        });
        defineCommonLocaleTests(name, -1, -1);
    }

    localeModule('eo');

    test('parse', function (assert) {
        var tests = 'januaro jan_februaro feb_marto mar_aprilo apr_majo maj_junio jun_julio jul_aÅ­gusto aÅ­g_septembro sep_oktobro okt_novembro nov_decembro dec'.split('_'), i;
        function equalTest(input, mmm, i) {
            assert.equal(moment(input, mmm).month(), i, input + ' should be month ' + (i + 1));
        }
        for (i = 0; i < 12; i++) {
            tests[i] = tests[i].split(' ');
            equalTest(tests[i][0], 'MMM', i);
            equalTest(tests[i][1], 'MMM', i);
            equalTest(tests[i][0], 'MMMM', i);
            equalTest(tests[i][1], 'MMMM', i);
            equalTest(tests[i][0].toLocaleLowerCase(), 'MMMM', i);
            equalTest(tests[i][1].toLocaleLowerCase(), 'MMMM', i);
            equalTest(tests[i][0].toLocaleUpperCase(), 'MMMM', i);
            equalTest(tests[i][1].toLocaleUpperCase(), 'MMMM', i);
        }
    });

    test('format', function (assert) {
        var a = [
                ['dddd, MMMM Do YYYY, h:mm:ss a',      'DimanÄo, februaro 14a 2010, 3:25:50 p.t.m.'],
                ['ddd, hA',                            'Dim, 3P.T.M.'],
                ['M Mo MM MMMM MMM',                   '2 2a 02 februaro feb'],
                ['YYYY YY',                            '2010 10'],
                ['D Do DD',                            '14 14a 14'],
                ['d do dddd ddd dd',                   '0 0a DimanÄo Dim Di'],
                ['DDD DDDo DDDD',                      '45 45a 045'],
                ['w wo ww',                            '7 7a 07'],
                ['h hh',                               '3 03'],
                ['H HH',                               '15 15'],
                ['m mm',                               '25 25'],
                ['s ss',                               '50 50'],
                ['a A',                                'p.t.m. P.T.M.'],
                ['[la] DDDo [tago] [de] [la] [jaro]',  'la 45a tago de la jaro'],
                ['LTS',                                '15:25:50'],
                ['L',                                  '2010-02-14'],
                ['LL',                                 '14-an de februaro, 2010'],
                ['LLL',                                '14-an de februaro, 2010 15:25'],
                ['LLLL',                               'DimanÄo, la 14-an de februaro, 2010 15:25'],
                ['l',                                  '2010-2-14'],
                ['ll',                                 '14-an de feb, 2010'],
                ['lll',                                '14-an de feb, 2010 15:25'],
                ['llll',                               'Dim, la 14-an de feb, 2010 15:25']
            ],
            b = moment(new Date(2010, 1, 14, 15, 25, 50, 125)),
            i;
        for (i = 0; i < a.length; i++) {
            assert.equal(b.format(a[i][0]), a[i][1], a[i][0] + ' ---> ' + a[i][1]);
        }
    });

    test('format ordinal', function (assert) {
        assert.equal(moment([2011, 0, 1]).format('DDDo'), '1a', '1a');
        assert.equal(moment([2011, 0, 2]).format('DDDo'), '2a', '2a');
        assert.equal(moment([2011, 0, 3]).format('DDDo'), '3a', '3a');
        assert.equal(moment([2011, 0, 4]).format('DDDo'), '4a', '4a');
        assert.equal(moment([2011, 0, 5]).format('DDDo'), '5a', '5a');
        assert.equal(moment([2011, 0, 6]).format('DDDo'), '6a', '6a');
        assert.equal(moment([2011, 0, 7]).format('DDDo'), '7a', '7a');
        assert.equal(moment([2011, 0, 8]).format('DDDo'), '8a', '8a');
        assert.equal(moment([2011, 0, 9]).format('DDDo'), '9a', '9a');
        assert.equal(moment([2011, 0, 10]).format('DDDo'), '10a', '10a');

        assert.equal(moment([2011, 0, 11]).format('DDDo'), '11a', '11a');
        assert.equal(moment([2011, 0, 12]).format('DDDo'), '12a', '12a');
        assert.equal(moment([2011, 0, 13]).format('DDDo'), '13a', '13a');
        assert.equal(moment([2011, 0, 14]).format('DDDo'), '14a', '14a');
        assert.equal(moment([2011, 0, 15]).format('DDDo'), '15a', '15a');
        assert.equal(moment([2011, 0, 16]).format('DDDo'), '16a', '16a');
        assert.equal(moment([2011, 0, 17]).format('DDDo'), '17a', '17a');
        assert.equal(moment([2011, 0, 18]).format('DDDo'), '18a', '18a');
        assert.equal(moment([2011, 0, 19]).format('DDDo'), '19a', '19a');
        assert.equal(moment([2011, 0, 20]).format('DDDo'), '20a', '20a');

        assert.equal(moment([2011, 0, 21]).format('DDDo'), '21a', '21a');
        assert.equal(moment([2011, 0, 22]).format('DDDo'), '22a', '22a');
        assert.equal(moment([2011, 0, 23]).format('DDDo'), '23a', '23a');
        assert.equal(moment([2011, 0, 24]).format('DDDo'), '24a', '24a');
        assert.equal(moment([2011, 0, 25]).format('DDDo'), '25a', '25a');
        assert.equal(moment([2011, 0, 26]).format('DDDo'), '26a', '26a');
        assert.equal(moment([2011, 0, 27]).format('DDDo'), '27a', '27a');
        assert.equal(moment([2011, 0, 28]).format('DDDo'), '28a', '28a');
        assert.equal(moment([2011, 0, 29]).format('DDDo'), '29a', '29a');
        assert.equal(moment([2011, 0, 30]).format('DDDo'), '30a', '30a');

        assert.equal(moment([2011, 0, 31]).format('DDDo'), '31a', '31a');
    });

    test('format month', function (assert) {
        var expected = 'januaro jan_februaro feb_marto mar_aprilo apr_majo maj_junio jun_julio jul_aÅ­gusto aÅ­g_septembro sep_oktobro okt_novembro nov_decembro dec'.split('_'), i;
        for (i = 0; i < expected.length; i++) {
            assert.equal(moment([2011, i, 1]).format('MMMM MMM'), expected[i], expected[i]);
        }
    });

    test('format week', function (assert) {
        var expected = 'DimanÄo Dim Di_Lundo Lun Lu_Mardo Mard Ma_Merkredo Merk Me_Ä´aÅ­do Ä´aÅ­ Ä´a_Vendredo Ven Ve_Sabato Sab Sa'.split('_'), i;
        for (i = 0; i < expected.length; i++) {
            assert.equal(moment([2011, 0, 2 + i]).format('dddd ddd dd'), expected[i], expected[i]);
        }
    });

    test('from', function (assert) {
        var start = moment([2007, 1, 28]);
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 44}), true),  'sekundoj', '44 seconds = a few seconds');
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 45}), true),  'minuto',      '45 seconds = a minute');
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 89}), true),  'minuto',      '89 seconds = a minute');
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 90}), true),  '2 minutoj',     '90 seconds = 2 minutes');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 44}), true),  '44 minutoj',    '44 minutes = 44 minutes');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 45}), true),  'horo',       '45 minutes = an hour');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 89}), true),  'horo',       '89 minutes = an hour');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 90}), true),  '2 horoj',       '90 minutes = 2 hours');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 5}), true),   '5 horoj',       '5 hours = 5 hours');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 21}), true),  '21 horoj',      '21 hours = 21 hours');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 22}), true),  'tago',         '22 hours = a day');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 35}), true),  'tago',         '35 hours = a day');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 36}), true),  '2 tagoj',        '36 hours = 2 days');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 1}), true),   'tago',         '1 day = a day');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 5}), true),   '5 tagoj',        '5 days = 5 days');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 25}), true),  '25 tagoj',       '25 days = 25 days');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 26}), true),  'monato',       '26 days = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 30}), true),  'monato',       '30 days = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 43}), true),  'monato',       '43 days = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 46}), true),  '2 monatoj',      '46 days = 2 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 74}), true),  '2 monatoj',      '75 days = 2 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 76}), true),  '3 monatoj',      '76 days = 3 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({M: 1}), true),   'monato',       '1 month = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({M: 5}), true),   '5 monatoj',      '5 months = 5 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 345}), true), 'jaro',        '345 days = a year');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 548}), true), '2 jaroj',       '548 days = 2 years');
        assert.equal(start.from(moment([2007, 1, 28]).add({y: 1}), true),   'jaro',        '1 year = a year');
        assert.equal(start.from(moment([2007, 1, 28]).add({y: 5}), true),   '5 jaroj',       '5 years = 5 years');
    });

    test('suffix', function (assert) {
        assert.equal(moment(30000).from(0), 'je sekundoj',  'je prefix');
        assert.equal(moment(0).from(30000), 'antaÅ­ sekundoj', 'antaÅ­ prefix');
    });

    test('now from now', function (assert) {
        assert.equal(moment().fromNow(), 'antaÅ­ sekundoj',  'now from now should display as in the past');
    });

    test('fromNow', function (assert) {
        assert.equal(moment().add({s: 30}).fromNow(), 'je sekundoj', 'je sekundoj');
        assert.equal(moment().add({d: 5}).fromNow(), 'je 5 tagoj', 'je 5 tagoj');
    });

    test('calendar day', function (assert) {
        var a = moment().hours(12).minutes(0).seconds(0);

        assert.equal(moment(a).calendar(),                   'HodiaÅ­ je 12:00',     'today at the same time');
        assert.equal(moment(a).add({m: 25}).calendar(),      'HodiaÅ­ je 12:25',     'Now plus 25 min');
        assert.equal(moment(a).add({h: 1}).calendar(),       'HodiaÅ­ je 13:00',     'Now plus 1 hour');
        assert.equal(moment(a).add({d: 1}).calendar(),       'MorgaÅ­ je 12:00',     'tomorrow at the same time');
        assert.equal(moment(a).subtract({h: 1}).calendar(),  'HodiaÅ­ je 11:00',     'Now minus 1 hour');
        assert.equal(moment(a).subtract({d: 1}).calendar(),  'HieraÅ­ je 12:00',     'yesterday at the same time');
    });

    test('calendar next week', function (assert) {
        var i, m;

        for (i = 2; i < 7; i++) {
            m = moment().add({d: i});
            assert.equal(m.calendar(),       m.format('dddd [je] LT'),  'Today + ' + i + ' days current time');
            m.hours(0).minutes(0).seconds(0).milliseconds(0);
            assert.equal(m.calendar(),       m.format('dddd [je] LT'),  'Today + ' + i + ' days beginning of day');
            m.hours(23).minutes(59).seconds(59).milliseconds(999);
            assert.equal(m.calendar(),       m.format('dddd [je] LT'),  'Today + ' + i + ' days end of day');
        }
    });

    test('calendar last week', function (assert) {
        var i, m;

        for (i = 2; i < 7; i++) {
            m = moment().subtract({d: i});
            assert.equal(m.calendar(),       m.format('[pasinta] dddd [je] LT'),  'Today - ' + i + ' days current time');
            m.hours(0).minutes(0).seconds(0).milliseconds(0);
            assert.equal(m.calendar(),       m.format('[pasinta] dddd [je] LT'),  'Today - ' + i + ' days beginning of day');
            m.hours(23).minutes(59).seconds(59).milliseconds(999);
            assert.equal(m.calendar(),       m.format('[pasinta] dddd [je] LT'),  'Today - ' + i + ' days end of day');
        }
    });

    test('calendar all else', function (assert) {
        var weeksAgo = moment().subtract({w: 1}),
            weeksFromNow = moment().add({w: 1});

        assert.equal(weeksAgo.calendar(),       weeksAgo.format('L'),  '1 week ago');
        assert.equal(weeksFromNow.calendar(),   weeksFromNow.format('L'),  'in 1 week');

        weeksAgo = moment().subtract({w: 2});
        weeksFromNow = moment().add({w: 2});

        assert.equal(weeksAgo.calendar(),       weeksAgo.format('L'),  '2 weeks ago');
        assert.equal(weeksFromNow.calendar(),   weeksFromNow.format('L'),  'in 2 weeks');
    });

    test('weeks year starting sunday formatted', function (assert) {
        assert.equal(moment([2011, 11, 26]).format('w ww wo'), '1 01 1a', 'Dec 26 2011 should be week 1');
        assert.equal(moment([2012,  0,  1]).format('w ww wo'), '1 01 1a', 'Jan  1 2012 should be week 1');
        assert.equal(moment([2012,  0,  2]).format('w ww wo'), '2 02 2a', 'Jan  2 2012 should be week 2');
        assert.equal(moment([2012,  0,  8]).format('w ww wo'), '2 02 2a', 'Jan  8 2012 should be week 2');
        assert.equal(moment([2012,  0,  9]).format('w ww wo'), '3 03 3a', 'Jan  9 2012 should be week 3');
    });

}));

;(function (global, factory) {
   typeof exports === 'object' && typeof module !== 'undefined'
       && typeof require === 'function' ? factory(require('../../moment')) :
   typeof define === 'function' && define.amd ? define(['../../moment'], factory) :
   factory(global.moment)
}(this, function (moment) { 'use strict';

    function each(array, callback) {
        var i;
        for (i = 0; i < array.length; i++) {
            callback(array[i], i, array);
        }
    }

    function objectKeys(obj) {
        if (Object.keys) {
            return Object.keys(obj);
        } else {
            // IE8
            var res = [], i;
            for (i in obj) {
                if (obj.hasOwnProperty(i)) {
                    res.push(i);
                }
            }
            return res;
        }
    }

    // Pick the first defined of two or three arguments.
    function defaults(a, b, c) {
        if (a != null) {
            return a;
        }
        if (b != null) {
            return b;
        }
        return c;
    }

    function defineCommonLocaleTests(locale, options) {
        test('lenient ordinal parsing', function (assert) {
            var i, ordinalStr, testMoment;
            for (i = 1; i <= 31; ++i) {
                ordinalStr = moment([2014, 0, i]).format('YYYY MM Do');
                testMoment = moment(ordinalStr, 'YYYY MM Do');
                assert.equal(testMoment.year(), 2014,
                        'lenient ordinal parsing ' + i + ' year check');
                assert.equal(testMoment.month(), 0,
                        'lenient ordinal parsing ' + i + ' month check');
                assert.equal(testMoment.date(), i,
                        'lenient ordinal parsing ' + i + ' date check');
            }
        });

        test('lenient ordinal parsing of number', function (assert) {
            var i, testMoment;
            for (i = 1; i <= 31; ++i) {
                testMoment = moment('2014 01 ' + i, 'YYYY MM Do');
                assert.equal(testMoment.year(), 2014,
                        'lenient ordinal parsing of number ' + i + ' year check');
                assert.equal(testMoment.month(), 0,
                        'lenient ordinal parsing of number ' + i + ' month check');
                assert.equal(testMoment.date(), i,
                        'lenient ordinal parsing of number ' + i + ' date check');
            }
        });

        test('strict ordinal parsing', function (assert) {
            var i, ordinalStr, testMoment;
            for (i = 1; i <= 31; ++i) {
                ordinalStr = moment([2014, 0, i]).format('YYYY MM Do');
                testMoment = moment(ordinalStr, 'YYYY MM Do', true);
                assert.ok(testMoment.isValid(), 'strict ordinal parsing ' + i);
            }
        });

        test('meridiem invariant', function (assert) {
            var h, m, t1, t2;
            for (h = 0; h < 24; ++h) {
                for (m = 0; m < 60; m += 15) {
                    t1 = moment.utc([2000, 0, 1, h, m]);
                    t2 = moment.utc(t1.format('A h:mm'), 'A h:mm');
                    assert.equal(t2.format('HH:mm'), t1.format('HH:mm'),
                            'meridiem at ' + t1.format('HH:mm'));
                }
            }
        });

        test('date format correctness', function (assert) {
            var data, tokens;
            data = moment.localeData()._longDateFormat;
            tokens = objectKeys(data);
            each(tokens, function (srchToken) {
                // Check each format string to make sure it does not contain any
                // tokens that need to be expanded.
                each(tokens, function (baseToken) {
                    // strip escaped sequences
                    var format = data[baseToken].replace(/(\[[^\]]*\])/g, '');
                    assert.equal(false, !!~format.indexOf(srchToken),
                            'contains ' + srchToken + ' in ' + baseToken);
                });
            });
        });

        test('month parsing correctness', function (assert) {
            var i, m;

            if (locale === 'tr') {
                // I can't fix it :(
                expect(0);
                return;
            }
            function tester(format) {
                var r;
                r = moment(m.format(format), format);
                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format);
                r = moment(m.format(format).toLocaleUpperCase(), format);
                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' upper');
                r = moment(m.format(format).toLocaleLowerCase(), format);
                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' lower');

                r = moment(m.format(format), format, true);
                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' strict');
                r = moment(m.format(format).toLocaleUpperCase(), format, true);
                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' upper strict');
                r = moment(m.format(format).toLocaleLowerCase(), format, true);
                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' lower strict');
            }

            for (i = 0; i < 12; ++i) {
                m = moment([2015, i, 15, 18]);
                tester('MMM');
                tester('MMM.');
                tester('MMMM');
                tester('MMMM.');
            }
        });

        test('weekday parsing correctness', function (assert) {
            var i, m;

            if (locale === 'tr' || locale === 'az') {
                // There is a lower-case letter (Ä±), that converted to upper then
                // lower changes to i
                expect(0);
                return;
            }
            function tester(format) {
                var r, baseMsg = 'weekday ' + m.weekday() + ' fmt ' + format;
                r = moment(m.format(format), format);
                assert.equal(r.weekday(), m.weekday(), baseMsg);
                r = moment(m.format(format).toLocaleUpperCase(), format);
                assert.equal(r.weekday(), m.weekday(), baseMsg + ' upper');
                r = moment(m.format(format).toLocaleLowerCase(), format);
                assert.equal(r.weekday(), m.weekday(), baseMsg + ' lower');

                r = moment(m.format(format), format, true);
                assert.equal(r.weekday(), m.weekday(), baseMsg + ' strict');
                r = moment(m.format(format).toLocaleUpperCase(), format, true);
                assert.equal(r.weekday(), m.weekday(), baseMsg + ' upper strict');
                r = moment(m.format(format).toLocaleLowerCase(), format, true);
                assert.equal(r.weekday(), m.weekday(), baseMsg + ' lower strict');
            }

            for (i = 0; i < 7; ++i) {
                m = moment.utc([2015, i, 15, 18]);
                tester('dd');
                tester('ddd');
                tester('dddd');
            }
        });
    }

    function setupDeprecationHandler(test, moment, scope) {
        test._expectedDeprecations = null;
        test._observedDeprecations = null;
        test._oldSupress = moment.suppressDeprecationWarnings;
        moment.suppressDeprecationWarnings = true;
        test.expectedDeprecations = function () {
            test._expectedDeprecations = arguments;
            test._observedDeprecations = [];
        };
        moment.deprecationHandler = function (name, msg) {
            var deprecationId = matchedDeprecation(name, msg, test._expectedDeprecations);
            if (deprecationId === -1) {
                throw new Error('Unexpected deprecation thrown name=' +
                        name + ' msg=' + msg);
            }
            test._observedDeprecations[deprecationId] = 1;
        };
    }

    function teardownDeprecationHandler(test, moment, scope) {
        moment.suppressDeprecationWarnings = test._oldSupress;

        if (test._expectedDeprecations != null) {
            var missedDeprecations = [];
            each(test._expectedDeprecations, function (deprecationPattern, id) {
                if (test._observedDeprecations[id] !== 1) {
                    missedDeprecations.push(deprecationPattern);
                }
            });
            if (missedDeprecations.length !== 0) {
                throw new Error('Expected deprecation warnings did not happen: ' +
                        missedDeprecations.join(' '));
            }
        }
    }

    function matchedDeprecation(name, msg, deprecations) {
        if (deprecations == null) {
            return -1;
        }
        for (var i = 0; i < deprecations.length; ++i) {
            if (name != null && name === deprecations[i]) {
                return i;
            }
            if (msg != null && msg.substring(0, deprecations[i].length) === deprecations[i]) {
                return i;
            }
        }
        return -1;
    }

    /*global QUnit:false*/

    var test = QUnit.test;

    var expect = QUnit.expect;

    function module (name, lifecycle) {
        QUnit.module(name, {
            setup : function () {
                moment.locale('en');
                moment.createFromInputFallback = function (config) {
                    throw new Error('input not handled by moment: ' + config._i);
                };
                setupDeprecationHandler(test, moment, 'core');
                if (lifecycle && lifecycle.setup) {
                    lifecycle.setup();
                }
            },
            teardown : function () {
                teardownDeprecationHandler(test, moment, 'core');
                if (lifecycle && lifecycle.teardown) {
                    lifecycle.teardown();
                }
            }
        });
    }

    function localeModule (name, lifecycle) {
        QUnit.module('locale:' + name, {
            setup : function () {
                moment.locale(name);
                moment.createFromInputFallback = function (config) {
                    throw new Error('input not handled by moment: ' + config._i);
                };
                setupDeprecationHandler(test, moment, 'locale');
                if (lifecycle && lifecycle.setup) {
                    lifecycle.setup();
                }
            },
            teardown : function () {
                moment.locale('en');
                teardownDeprecationHandler(test, moment, 'locale');
                if (lifecycle && lifecycle.teardown) {
                    lifecycle.teardown();
                }
            }
        });
        defineCommonLocaleTests(name, -1, -1);
    }

    localeModule('es');

    test('parse', function (assert) {
        var tests = 'enero ene._febrero feb._marzo mar._abril abr._mayo may._junio jun._julio jul._agosto ago._septiembre sep._octubre oct._noviembre nov._diciembre dic.'.split('_'), i;
        function equalTest(input, mmm, i) {
            assert.equal(moment(input, mmm).month(), i, input + ' should be month ' + (i + 1));
        }
        for (i = 0; i < 12; i++) {
            tests[i] = tests[i].split(' ');
            equalTest(tests[i][0], 'MMM', i);
            equalTest(tests[i][1], 'MMM', i);
            equalTest(tests[i][0], 'MMMM', i);
            equalTest(tests[i][1], 'MMMM', i);
            equalTest(tests[i][0].toLocaleLowerCase(), 'MMMM', i);
            equalTest(tests[i][1].toLocaleLowerCase(), 'MMMM', i);
            equalTest(tests[i][0].toLocaleUpperCase(), 'MMMM', i);
            equalTest(tests[i][1].toLocaleUpperCase(), 'MMMM', i);
        }
    });

    test('format', function (assert) {
        var a = [
                ['dddd, MMMM Do YYYY, h:mm:ss a',      'domingo, febrero 14Âº 2010, 3:25:50 pm'],
                ['ddd, hA',                            'dom., 3PM'],
                ['M Mo MM MMMM MMM',                   '2 2Âº 02 febrero feb.'],
                ['YYYY YY',                            '2010 10'],
                ['D Do DD',                            '14 14Âº 14'],
                ['d do dddd ddd dd',                   '0 0Âº domingo dom. do'],
                ['DDD DDDo DDDD',                      '45 45Âº 045'],
                ['w wo ww',                            '6 6Âº 06'],
                ['YYYY-MMM-DD',                        '2010-feb-14'],
                ['h hh',                               '3 03'],
                ['H HH',                               '15 15'],
                ['m mm',                               '25 25'],
                ['s ss',                               '50 50'],
                ['a A',                                'pm PM'],
                ['[the] DDDo [day of the year]',       'the 45Âº day of the year'],
                ['LTS',                                '15:25:50'],
                ['L',                                  '14/02/2010'],
                ['LL',                                 '14 de febrero de 2010'],
                ['LLL',                                '14 de febrero de 2010 15:25'],
                ['LLLL',                               'domingo, 14 de febrero de 2010 15:25'],
                ['l',                                  '14/2/2010'],
                ['ll',                                 '14 de feb. de 2010'],
                ['lll',                                '14 de feb. de 2010 15:25'],
                ['llll',                               'dom., 14 de feb. de 2010 15:25']
            ],
            b = moment(new Date(2010, 1, 14, 15, 25, 50, 125)),
            i;
        for (i = 0; i < a.length; i++) {
            assert.equal(b.format(a[i][0]), a[i][1], a[i][0] + ' ---> ' + a[i][1]);
        }
    });

    test('format ordinal', function (assert) {
        assert.equal(moment([2011, 0, 1]).format('DDDo'), '1Âº', '1Âº');
        assert.equal(moment([2011, 0, 2]).format('DDDo'), '2Âº', '2Âº');
        assert.equal(moment([2011, 0, 3]).format('DDDo'), '3Âº', '3Âº');
        assert.equal(moment([2011, 0, 4]).format('DDDo'), '4Âº', '4Âº');
        assert.equal(moment([2011, 0, 5]).format('DDDo'), '5Âº', '5Âº');
        assert.equal(moment([2011, 0, 6]).format('DDDo'), '6Âº', '6Âº');
        assert.equal(moment([2011, 0, 7]).format('DDDo'), '7Âº', '7Âº');
        assert.equal(moment([2011, 0, 8]).format('DDDo'), '8Âº', '8Âº');
        assert.equal(moment([2011, 0, 9]).format('DDDo'), '9Âº', '9Âº');
        assert.equal(moment([2011, 0, 10]).format('DDDo'), '10Âº', '10Âº');

        assert.equal(moment([2011, 0, 11]).format('DDDo'), '11Âº', '11Âº');
        assert.equal(moment([2011, 0, 12]).format('DDDo'), '12Âº', '12Âº');
        assert.equal(moment([2011, 0, 13]).format('DDDo'), '13Âº', '13Âº');
        assert.equal(moment([2011, 0, 14]).format('DDDo'), '14Âº', '14Âº');
        assert.equal(moment([2011, 0, 15]).format('DDDo'), '15Âº', '15Âº');
        assert.equal(moment([2011, 0, 16]).format('DDDo'), '16Âº', '16Âº');
        assert.equal(moment([2011, 0, 17]).format('DDDo'), '17Âº', '17Âº');
        assert.equal(moment([2011, 0, 18]).format('DDDo'), '18Âº', '18Âº');
        assert.equal(moment([2011, 0, 19]).format('DDDo'), '19Âº', '19Âº');
        assert.equal(moment([2011, 0, 20]).format('DDDo'), '20Âº', '20Âº');

        assert.equal(moment([2011, 0, 21]).format('DDDo'), '21Âº', '21Âº');
        assert.equal(moment([2011, 0, 22]).format('DDDo'), '22Âº', '22Âº');
        assert.equal(moment([2011, 0, 23]).format('DDDo'), '23Âº', '23Âº');
        assert.equal(moment([2011, 0, 24]).format('DDDo'), '24Âº', '24Âº');
        assert.equal(moment([2011, 0, 25]).format('DDDo'), '25Âº', '25Âº');
        assert.equal(moment([2011, 0, 26]).format('DDDo'), '26Âº', '26Âº');
        assert.equal(moment([2011, 0, 27]).format('DDDo'), '27Âº', '27Âº');
        assert.equal(moment([2011, 0, 28]).format('DDDo'), '28Âº', '28Âº');
        assert.equal(moment([2011, 0, 29]).format('DDDo'), '29Âº', '29Âº');
        assert.equal(moment([2011, 0, 30]).format('DDDo'), '30Âº', '30Âº');

        assert.equal(moment([2011, 0, 31]).format('DDDo'), '31Âº', '31Âº');
    });

    test('format month', function (assert) {
        var expected = 'enero ene._febrero feb._marzo mar._abril abr._mayo may._junio jun._julio jul._agosto ago._septiembre sep._octubre oct._noviembre nov._diciembre dic.'.split('_'), i;
        for (i = 0; i < expected.length; i++) {
            assert.equal(moment([2011, i, 1]).format('MMMM MMM'), expected[i], expected[i]);
        }
    });

    test('format week', function (assert) {
        var expected = 'domingo dom. do_lunes lun. lu_martes mar. ma_miÃ©rcoles miÃ©. mi_jueves jue. ju_viernes vie. vi_sÃ¡bado sÃ¡b. sÃ¡'.split('_'), i;
        for (i = 0; i < expected.length; i++) {
            assert.equal(moment([2011, 0, 2 + i]).format('dddd ddd dd'), expected[i], expected[i]);
        }
    });

    test('from', function (assert) {
        var start = moment([2007, 1, 28]);
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 44}), true),  'unos segundos', '44 seconds = a few seconds');
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 45}), true),  'un minuto',      '45 seconds = a minute');
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 89}), true),  'un minuto',      '89 seconds = a minute');
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 90}), true),  '2 minutos',     '90 seconds = 2 minutes');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 44}), true),  '44 minutos',    '44 minutes = 44 minutes');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 45}), true),  'una hora',       '45 minutes = an hour');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 89}), true),  'una hora',       '89 minutes = an hour');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 90}), true),  '2 horas',       '90 minutes = 2 hours');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 5}), true),   '5 horas',       '5 hours = 5 hours');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 21}), true),  '21 horas',      '21 hours = 21 hours');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 22}), true),  'un dÃ­a',         '22 hours = a day');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 35}), true),  'un dÃ­a',         '35 hours = a day');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 36}), true),  '2 dÃ­as',        '36 hours = 2 days');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 1}), true),   'un dÃ­a',         '1 day = a day');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 5}), true),   '5 dÃ­as',        '5 days = 5 days');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 25}), true),  '25 dÃ­as',       '25 days = 25 days');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 26}), true),  'un mes',       '26 days = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 30}), true),  'un mes',       '30 days = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 43}), true),  'un mes',       '43 days = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 46}), true),  '2 meses',      '46 days = 2 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 74}), true),  '2 meses',      '75 days = 2 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 76}), true),  '3 meses',      '76 days = 3 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({M: 1}), true),   'un mes',       '1 month = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({M: 5}), true),   '5 meses',      '5 months = 5 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 345}), true), 'un aÃ±o',        '345 days = a year');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 548}), true), '2 aÃ±os',       '548 days = 2 years');
        assert.equal(start.from(moment([2007, 1, 28]).add({y: 1}), true),   'un aÃ±o',        '1 year = a year');
        assert.equal(start.from(moment([2007, 1, 28]).add({y: 5}), true),   '5 aÃ±os',       '5 years = 5 years');
    });

    test('suffix', function (assert) {
        assert.equal(moment(30000).from(0), 'en unos segundos',  'prefix');
        assert.equal(moment(0).from(30000), 'hace unos segundos', 'suffix');
    });

    test('now from now', function (assert) {
        assert.equal(moment().fromNow(), 'hace unos segundos',  'now from now should display as in the past');
    });

    test('fromNow', function (assert) {
        assert.equal(moment().add({s: 30}).fromNow(), 'en unos segundos', 'en unos segundos');
        assert.equal(moment().add({d: 5}).fromNow(), 'en 5 dÃ­as', 'en 5 dÃ­as');
    });

    test('calendar day', function (assert) {
        var a = moment().hours(12).minutes(0).seconds(0);

        assert.equal(moment(a).calendar(),                       'hoy a las 12:00',     'today at the same time');
        assert.equal(moment(a).add({m: 25}).calendar(),          'hoy a las 12:25',     'Now plus 25 min');
        assert.equal(moment(a).add({h: 1}).calendar(),           'hoy a las 13:00',     'Now plus 1 hour');
        assert.equal(moment(a).add({d: 1}).calendar(),           'maÃ±ana a las 12:00',  'tomorrow at the same time');
        assert.equal(moment(a).add({d: 1, h : -1}).calendar(),   'maÃ±ana a las 11:00',   'tomorrow minus 1 hour');
        assert.equal(moment(a).subtract({h: 1}).calendar(),      'hoy a las 11:00',     'Now minus 1 hour');
        assert.equal(moment(a).subtract({d: 1}).calendar(),      'ayer a las 12:00',    'yesterday at the same time');
    });

    test('calendar next week', function (assert) {
        var i, m;

        for (i = 2; i < 7; i++) {
            m = moment().add({d: i});
            assert.equal(m.calendar(),       m.format('dddd [a la' + ((m.hours() !== 1) ? 's' : '') + '] LT'),  'Today + ' + i + ' days current time');
            m.hours(0).minutes(0).seconds(0).milliseconds(0);
            assert.equal(m.calendar(),       m.format('dddd [a la' + ((m.hours() !== 1) ? 's' : '') + '] LT'),  'Today + ' + i + ' days beginning of day');
            m.hours(23).minutes(59).seconds(59).milliseconds(999);
            assert.equal(m.calendar(),       m.format('dddd [a la' + ((m.hours() !== 1) ? 's' : '') + '] LT'),  'Today + ' + i + ' days end of day');
        }
    });

    test('calendar last week', function (assert) {
        var i, m;

        for (i = 2; i < 7; i++) {
            m = moment().subtract({d: i});
            assert.equal(m.calendar(),       m.format('[el] dddd [pasado a la' + ((m.hours() !== 1) ? 's' : '') + '] LT'),  'Today - ' + i + ' days current time');
            m.hours(0).minutes(0).seconds(0).milliseconds(0);
            assert.equal(m.calendar(),       m.format('[el] dddd [pasado a la' + ((m.hours() !== 1) ? 's' : '') + '] LT'),  'Today - ' + i + ' days beginning of day');
            m.hours(23).minutes(59).seconds(59).milliseconds(999);
            assert.equal(m.calendar(),       m.format('[el] dddd [pasado a la' + ((m.hours() !== 1) ? 's' : '') + '] LT'),  'Today - ' + i + ' days end of day');
        }
    });

    test('calendar all else', function (assert) {
        var weeksAgo = moment().subtract({w: 1}),
            weeksFromNow = moment().add({w: 1});

        assert.equal(weeksAgo.calendar(),       weeksAgo.format('L'),  '1 week ago');
        assert.equal(weeksFromNow.calendar(),   weeksFromNow.format('L'),  'in 1 week');

        weeksAgo = moment().subtract({w: 2});
        weeksFromNow = moment().add({w: 2});

        assert.equal(weeksAgo.calendar(),       weeksAgo.format('L'),  '2 weeks ago');
        assert.equal(weeksFromNow.calendar(),   weeksFromNow.format('L'),  'in 2 weeks');
    });

    test('weeks year starting sunday formatted', function (assert) {
        assert.equal(moment([2012, 0,  1]).format('w ww wo'), '52 52 52Âº', 'Jan  1 2012 should be week 52');
        assert.equal(moment([2012, 0,  2]).format('w ww wo'),   '1 01 1Âº', 'Jan  2 2012 should be week 1');
        assert.equal(moment([2012, 0,  8]).format('w ww wo'),   '1 01 1Âº', 'Jan  8 2012 should be week 1');
        assert.equal(moment([2012, 0,  9]).format('w ww wo'),   '2 02 2Âº', 'Jan  9 2012 should be week 2');
        assert.equal(moment([2012, 0, 15]).format('w ww wo'),   '2 02 2Âº', 'Jan 15 2012 should be week 2');
    });

}));

;(function (global, factory) {
   typeof exports === 'object' && typeof module !== 'undefined'
       && typeof require === 'function' ? factory(require('../../moment')) :
   typeof define === 'function' && define.amd ? define(['../../moment'], factory) :
   factory(global.moment)
}(this, function (moment) { 'use strict';

    function each(array, callback) {
        var i;
        for (i = 0; i < array.length; i++) {
            callback(array[i], i, array);
        }
    }

    function objectKeys(obj) {
        if (Object.keys) {
            return Object.keys(obj);
        } else {
            // IE8
            var res = [], i;
            for (i in obj) {
                if (obj.hasOwnProperty(i)) {
                    res.push(i);
                }
            }
            return res;
        }
    }

    // Pick the first defined of two or three arguments.
    function defaults(a, b, c) {
        if (a != null) {
            return a;
        }
        if (b != null) {
            return b;
        }
        return c;
    }

    function defineCommonLocaleTests(locale, options) {
        test('lenient ordinal parsing', function (assert) {
            var i, ordinalStr, testMoment;
            for (i = 1; i <= 31; ++i) {
                ordinalStr = moment([2014, 0, i]).format('YYYY MM Do');
                testMoment = moment(ordinalStr, 'YYYY MM Do');
                assert.equal(testMoment.year(), 2014,
                        'lenient ordinal parsing ' + i + ' year check');
                assert.equal(testMoment.month(), 0,
                        'lenient ordinal parsing ' + i + ' month check');
                assert.equal(testMoment.date(), i,
                        'lenient ordinal parsing ' + i + ' date check');
            }
        });

        test('lenient ordinal parsing of number', function (assert) {
            var i, testMoment;
            for (i = 1; i <= 31; ++i) {
                testMoment = moment('2014 01 ' + i, 'YYYY MM Do');
                assert.equal(testMoment.year(), 2014,
                        'lenient ordinal parsing of number ' + i + ' year check');
                assert.equal(testMoment.month(), 0,
                        'lenient ordinal parsing of number ' + i + ' month check');
                assert.equal(testMoment.date(), i,
                        'lenient ordinal parsing of number ' + i + ' date check');
            }
        });

        test('strict ordinal parsing', function (assert) {
            var i, ordinalStr, testMoment;
            for (i = 1; i <= 31; ++i) {
                ordinalStr = moment([2014, 0, i]).format('YYYY MM Do');
                testMoment = moment(ordinalStr, 'YYYY MM Do', true);
                assert.ok(testMoment.isValid(), 'strict ordinal parsing ' + i);
            }
        });

        test('meridiem invariant', function (assert) {
            var h, m, t1, t2;
            for (h = 0; h < 24; ++h) {
                for (m = 0; m < 60; m += 15) {
                    t1 = moment.utc([2000, 0, 1, h, m]);
                    t2 = moment.utc(t1.format('A h:mm'), 'A h:mm');
                    assert.equal(t2.format('HH:mm'), t1.format('HH:mm'),
                            'meridiem at ' + t1.format('HH:mm'));
                }
            }
        });

        test('date format correctness', function (assert) {
            var data, tokens;
            data = moment.localeData()._longDateFormat;
            tokens = objectKeys(data);
            each(tokens, function (srchToken) {
                // Check each format string to make sure it does not contain any
                // tokens that need to be expanded.
                each(tokens, function (baseToken) {
                    // strip escaped sequences
                    var format = data[baseToken].replace(/(\[[^\]]*\])/g, '');
                    assert.equal(false, !!~format.indexOf(srchToken),
                            'contains ' + srchToken + ' in ' + baseToken);
                });
            });
        });

        test('month parsing correctness', function (assert) {
            var i, m;

            if (locale === 'tr') {
                // I can't fix it :(
                expect(0);
                return;
            }
            function tester(format) {
                var r;
                r = moment(m.format(format), format);
                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format);
                r = moment(m.format(format).toLocaleUpperCase(), format);
                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' upper');
                r = moment(m.format(format).toLocaleLowerCase(), format);
                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' lower');

                r = moment(m.format(format), format, true);
                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' strict');
                r = moment(m.format(format).toLocaleUpperCase(), format, true);
                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' upper strict');
                r = moment(m.format(format).toLocaleLowerCase(), format, true);
                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' lower strict');
            }

            for (i = 0; i < 12; ++i) {
                m = moment([2015, i, 15, 18]);
                tester('MMM');
                tester('MMM.');
                tester('MMMM');
                tester('MMMM.');
            }
        });

        test('weekday parsing correctness', function (assert) {
            var i, m;

            if (locale === 'tr' || locale === 'az') {
                // There is a lower-case letter (Ä±), that converted to upper then
                // lower changes to i
                expect(0);
                return;
            }
            function tester(format) {
                var r, baseMsg = 'weekday ' + m.weekday() + ' fmt ' + format;
                r = moment(m.format(format), format);
                assert.equal(r.weekday(), m.weekday(), baseMsg);
                r = moment(m.format(format).toLocaleUpperCase(), format);
                assert.equal(r.weekday(), m.weekday(), baseMsg + ' upper');
                r = moment(m.format(format).toLocaleLowerCase(), format);
                assert.equal(r.weekday(), m.weekday(), baseMsg + ' lower');

                r = moment(m.format(format), format, true);
                assert.equal(r.weekday(), m.weekday(), baseMsg + ' strict');
                r = moment(m.format(format).toLocaleUpperCase(), format, true);
                assert.equal(r.weekday(), m.weekday(), baseMsg + ' upper strict');
                r = moment(m.format(format).toLocaleLowerCase(), format, true);
                assert.equal(r.weekday(), m.weekday(), baseMsg + ' lower strict');
            }

            for (i = 0; i < 7; ++i) {
                m = moment.utc([2015, i, 15, 18]);
                tester('dd');
                tester('ddd');
                tester('dddd');
            }
        });
    }

    function setupDeprecationHandler(test, moment, scope) {
        test._expectedDeprecations = null;
        test._observedDeprecations = null;
        test._oldSupress = moment.suppressDeprecationWarnings;
        moment.suppressDeprecationWarnings = true;
        test.expectedDeprecations = function () {
            test._expectedDeprecations = arguments;
            test._observedDeprecations = [];
        };
        moment.deprecationHandler = function (name, msg) {
            var deprecationId = matchedDeprecation(name, msg, test._expectedDeprecations);
            if (deprecationId === -1) {
                throw new Error('Unexpected deprecation thrown name=' +
                        name + ' msg=' + msg);
            }
            test._observedDeprecations[deprecationId] = 1;
        };
    }

    function teardownDeprecationHandler(test, moment, scope) {
        moment.suppressDeprecationWarnings = test._oldSupress;

        if (test._expectedDeprecations != null) {
            var missedDeprecations = [];
            each(test._expectedDeprecations, function (deprecationPattern, id) {
                if (test._observedDeprecations[id] !== 1) {
                    missedDeprecations.push(deprecationPattern);
                }
            });
            if (missedDeprecations.length !== 0) {
                throw new Error('Expected deprecation warnings did not happen: ' +
                        missedDeprecations.join(' '));
            }
        }
    }

    function matchedDeprecation(name, msg, deprecations) {
        if (deprecations == null) {
            return -1;
        }
        for (var i = 0; i < deprecations.length; ++i) {
            if (name != null && name === deprecations[i]) {
                return i;
            }
            if (msg != null && msg.substring(0, deprecations[i].length) === deprecations[i]) {
                return i;
            }
        }
        return -1;
    }

    /*global QUnit:false*/

    var test = QUnit.test;

    var expect = QUnit.expect;

    function module (name, lifecycle) {
        QUnit.module(name, {
            setup : function () {
                moment.locale('en');
                moment.createFromInputFallback = function (config) {
                    throw new Error('input not handled by moment: ' + config._i);
                };
                setupDeprecationHandler(test, moment, 'core');
                if (lifecycle && lifecycle.setup) {
                    lifecycle.setup();
                }
            },
            teardown : function () {
                teardownDeprecationHandler(test, moment, 'core');
                if (lifecycle && lifecycle.teardown) {
                    lifecycle.teardown();
                }
            }
        });
    }

    function localeModule (name, lifecycle) {
        QUnit.module('locale:' + name, {
            setup : function () {
                moment.locale(name);
                moment.createFromInputFallback = function (config) {
                    throw new Error('input not handled by moment: ' + config._i);
                };
                setupDeprecationHandler(test, moment, 'locale');
                if (lifecycle && lifecycle.setup) {
                    lifecycle.setup();
                }
            },
            teardown : function () {
                moment.locale('en');
                teardownDeprecationHandler(test, moment, 'locale');
                if (lifecycle && lifecycle.teardown) {
                    lifecycle.teardown();
                }
            }
        });
        defineCommonLocaleTests(name, -1, -1);
    }

    localeModule('et');

    test('parse', function (assert) {
        var tests = 'jaanuar jaan_veebruar veebr_mÃ¤rts mÃ¤rts_aprill apr_mai mai_juuni juuni_juuli juuli_august aug_september sept_oktoober okt_november nov_detsember dets'.split('_'), i;
        function equalTest(input, mmm, i) {
            assert.equal(moment(input, mmm).month(), i, input + ' peaks olema kuu ' + (i + 1));
        }
        for (i = 0; i < 12; i++) {
            tests[i] = tests[i].split(' ');
            equalTest(tests[i][0], 'MMM', i);
            equalTest(tests[i][1], 'MMM', i);
            equalTest(tests[i][0], 'MMMM', i);
            equalTest(tests[i][1], 'MMMM', i);
            equalTest(tests[i][0].toLocaleLowerCase(), 'MMMM', i);
            equalTest(tests[i][1].toLocaleLowerCase(), 'MMMM', i);
            equalTest(tests[i][0].toLocaleUpperCase(), 'MMMM', i);
            equalTest(tests[i][1].toLocaleUpperCase(), 'MMMM', i);
        }
    });

    test('format', function (assert) {
        var a = [
                ['dddd, Do MMMM YYYY, H:mm:ss',      'pÃ¼hapÃ¤ev, 14. veebruar 2010, 15:25:50'],
                ['ddd, h',                           'P, 3'],
                ['M Mo MM MMMM MMM',                 '2 2. 02 veebruar veebr'],
                ['YYYY YY',                          '2010 10'],
                ['D Do DD',                          '14 14. 14'],
                ['d do dddd ddd dd',                 '0 0. pÃ¼hapÃ¤ev P P'],
                ['DDD DDDo DDDD',                    '45 45. 045'],
                ['w wo ww',                          '6 6. 06'],
                ['h hh',                             '3 03'],
                ['H HH',                             '15 15'],
                ['m mm',                             '25 25'],
                ['s ss',                             '50 50'],
                ['a A',                              'pm PM'],
                ['[aasta] DDDo [pÃ¤ev]',              'aasta 45. pÃ¤ev'],
                ['LTS',                              '15:25:50'],
                ['L',                                '14.02.2010'],
                ['LL',                               '14. veebruar 2010'],
                ['LLL',                              '14. veebruar 2010 15:25'],
                ['LLLL',                             'pÃ¼hapÃ¤ev, 14. veebruar 2010 15:25'],
                ['l',                                '14.2.2010'],
                ['ll',                               '14. veebr 2010'],
                ['lll',                              '14. veebr 2010 15:25'],
                ['llll',                             'P, 14. veebr 2010 15:25']
            ],
            b = moment(new Date(2010, 1, 14, 15, 25, 50, 125)),
            i;
        for (i = 0; i < a.length; i++) {
            assert.equal(b.format(a[i][0]), a[i][1], a[i][0] + ' ---> ' + a[i][1]);
        }
    });

    test('format ordinal', function (assert) {
        assert.equal(moment([2011, 0, 1]).format('DDDo'), '1.', '1.');
        assert.equal(moment([2011, 0, 2]).format('DDDo'), '2.', '2.');
        assert.equal(moment([2011, 0, 3]).format('DDDo'), '3.', '3.');
        assert.equal(moment([2011, 0, 4]).format('DDDo'), '4.', '4.');
        assert.equal(moment([2011, 0, 5]).format('DDDo'), '5.', '5.');
        assert.equal(moment([2011, 0, 6]).format('DDDo'), '6.', '6.');
        assert.equal(moment([2011, 0, 7]).format('DDDo'), '7.', '7.');
        assert.equal(moment([2011, 0, 8]).format('DDDo'), '8.', '8.');
        assert.equal(moment([2011, 0, 9]).format('DDDo'), '9.', '9.');
        assert.equal(moment([2011, 0, 10]).format('DDDo'), '10.', '10.');

        assert.equal(moment([2011, 0, 11]).format('DDDo'), '11.', '11.');
        assert.equal(moment([2011, 0, 12]).format('DDDo'), '12.', '12.');
        assert.equal(moment([2011, 0, 13]).format('DDDo'), '13.', '13.');
        assert.equal(moment([2011, 0, 14]).format('DDDo'), '14.', '14.');
        assert.equal(moment([2011, 0, 15]).format('DDDo'), '15.', '15.');
        assert.equal(moment([2011, 0, 16]).format('DDDo'), '16.', '16.');
        assert.equal(moment([2011, 0, 17]).format('DDDo'), '17.', '17.');
        assert.equal(moment([2011, 0, 18]).format('DDDo'), '18.', '18.');
        assert.equal(moment([2011, 0, 19]).format('DDDo'), '19.', '19.');
        assert.equal(moment([2011, 0, 20]).format('DDDo'), '20.', '20.');

        assert.equal(moment([2011, 0, 21]).format('DDDo'), '21.', '21.');
        assert.equal(moment([2011, 0, 22]).format('DDDo'), '22.', '22.');
        assert.equal(moment([2011, 0, 23]).format('DDDo'), '23.', '23.');
        assert.equal(moment([2011, 0, 24]).format('DDDo'), '24.', '24.');
        assert.equal(moment([2011, 0, 25]).format('DDDo'), '25.', '25.');
        assert.equal(moment([2011, 0, 26]).format('DDDo'), '26.', '26.');
        assert.equal(moment([2011, 0, 27]).format('DDDo'), '27.', '27.');
        assert.equal(moment([2011, 0, 28]).format('DDDo'), '28.', '28.');
        assert.equal(moment([2011, 0, 29]).format('DDDo'), '29.', '29.');
        assert.equal(moment([2011, 0, 30]).format('DDDo'), '30.', '30.');

        assert.equal(moment([2011, 0, 31]).format('DDDo'), '31.', '31.');
    });

    test('format month', function (assert) {
        var expected = 'jaanuar jaan_veebruar veebr_mÃ¤rts mÃ¤rts_aprill apr_mai mai_juuni juuni_juuli juuli_august aug_september sept_oktoober okt_november nov_detsember dets'.split('_'), i;
        for (i = 0; i < expected.length; i++) {
            assert.equal(moment([2011, i, 1]).format('MMMM MMM'), expected[i], expected[i]);
        }
    });

    test('format week', function (assert) {
        var expected = 'pÃ¼hapÃ¤ev P P_esmaspÃ¤ev E E_teisipÃ¤ev T T_kolmapÃ¤ev K K_neljapÃ¤ev N N_reede R R_laupÃ¤ev L L'.split('_'), i;
        for (i = 0; i < expected.length; i++) {
            assert.equal(moment([2011, 0, 2 + i]).format('dddd ddd dd'), expected[i], expected[i]);
        }
    });

    test('from', function (assert) {
        var start = moment([2007, 1, 28]);
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 44}), true),  'paar sekundit',  '44 seconds = paar sekundit');
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 45}), true),  'Ã¼ks minut',      '45 seconds = Ã¼ks minut');
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 89}), true),  'Ã¼ks minut',      '89 seconds = Ã¼ks minut');
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 90}), true),  '2 minutit',      '90 seconds = 2 minutit');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 44}), true),  '44 minutit',     '44 minutes = 44 minutit');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 45}), true),  'Ã¼ks tund',       '45 minutes = tund aega');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 89}), true),  'Ã¼ks tund',       '89 minutes = Ã¼ks tund');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 90}), true),  '2 tundi',        '90 minutes = 2 tundi');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 5}), true),   '5 tundi',        '5 hours = 5 tundi');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 21}), true),  '21 tundi',       '21 hours = 21 tundi');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 22}), true),  'Ã¼ks pÃ¤ev',       '22 hours = Ã¼ks pÃ¤ev');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 35}), true),  'Ã¼ks pÃ¤ev',       '35 hours = Ã¼ks pÃ¤ev');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 36}), true),  '2 pÃ¤eva',        '36 hours = 2 pÃ¤eva');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 1}), true),   'Ã¼ks pÃ¤ev',       '1 day = Ã¼ks pÃ¤ev');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 5}), true),   '5 pÃ¤eva',        '5 days = 5 pÃ¤eva');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 25}), true),  '25 pÃ¤eva',       '25 days = 25 pÃ¤eva');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 26}), true),  'Ã¼ks kuu',        '26 days = Ã¼ks kuu');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 30}), true),  'Ã¼ks kuu',        '30 days = Ã¼ks kuu');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 43}), true),  'Ã¼ks kuu',        '43 days = Ã¼ks kuu');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 46}), true),  '2 kuud',         '46 days = 2 kuud');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 74}), true),  '2 kuud',         '75 days = 2 kuud');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 76}), true),  '3 kuud',         '76 days = 3 kuud');
        assert.equal(start.from(moment([2007, 1, 28]).add({M: 1}), true),   'Ã¼ks kuu',        '1 month = Ã¼ks kuu');
        assert.equal(start.from(moment([2007, 1, 28]).add({M: 5}), true),   '5 kuud',         '5 months = 5 kuud');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 345}), true), 'Ã¼ks aasta',      '345 days = Ã¼ks aasta');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 548}), true), '2 aastat',       '548 days = 2 aastat');
        assert.equal(start.from(moment([2007, 1, 28]).add({y: 1}), true),   'Ã¼ks aasta',      '1 year = Ã¼ks aasta');
        assert.equal(start.from(moment([2007, 1, 28]).add({y: 5}), true),   '5 aastat',       '5 years = 5 aastat');
    });

    test('suffix', function (assert) {
        assert.equal(moment(30000).from(0), 'mÃµne sekundi pÃ¤rast',  'prefix');
        assert.equal(moment(0).from(30000), 'mÃµni sekund tagasi', 'suffix');
    });

    test('now from now', function (assert) {
        assert.equal(moment().fromNow(), 'mÃµni sekund tagasi',  'now from now should display as in the past');
    });

    test('fromNow', function (assert) {
        assert.equal(moment().add({s: 30}).fromNow(), 'mÃµne sekundi pÃ¤rast', 'in a few seconds');
        assert.equal(moment().subtract({s: 30}).fromNow(), 'mÃµni sekund tagasi', 'a few seconds ago');

        assert.equal(moment().add({m: 1}).fromNow(), 'Ã¼he minuti pÃ¤rast', 'in a minute');
        assert.equal(moment().subtract({m: 1}).fromNow(), 'Ã¼ks minut tagasi', 'a minute ago');

        assert.equal(moment().add({m: 5}).fromNow(), '5 minuti pÃ¤rast', 'in 5 minutes');
        assert.equal(moment().subtract({m: 5}).fromNow(), '5 minutit tagasi', '5 minutes ago');

        assert.equal(moment().add({d: 1}).fromNow(), 'Ã¼he pÃ¤eva pÃ¤rast', 'in one day');
        assert.equal(moment().subtract({d: 1}).fromNow(), 'Ã¼ks pÃ¤ev tagasi', 'one day ago');

        assert.equal(moment().add({d: 5}).fromNow(), '5 pÃ¤eva pÃ¤rast', 'in 5 days');
        assert.equal(moment().subtract({d: 5}).fromNow(), '5 pÃ¤eva tagasi', '5 days ago');

        assert.equal(moment().add({M: 1}).fromNow(), 'kuu aja pÃ¤rast', 'in a month');
        assert.equal(moment().subtract({M: 1}).fromNow(), 'kuu aega tagasi', 'a month ago');

        assert.equal(moment().add({M: 5}).fromNow(), '5 kuu pÃ¤rast', 'in 5 months');
        assert.equal(moment().subtract({M: 5}).fromNow(), '5 kuud tagasi', '5 months ago');

        assert.equal(moment().add({y: 1}).fromNow(), 'Ã¼he aasta pÃ¤rast', 'in a year');
        assert.equal(moment().subtract({y: 1}).fromNow(), 'aasta tagasi', 'a year ago');

        assert.equal(moment().add({y: 5}).fromNow(), '5 aasta pÃ¤rast', 'in 5 years');
        assert.equal(moment().subtract({y: 5}).fromNow(), '5 aastat tagasi', '5 years ago');
    });

    test('calendar day', function (assert) {
        var a = moment().hours(12).minutes(0).seconds(0);

        assert.equal(moment(a).calendar(),                   'TÃ¤na, 12:00',     'today at the same time');
        assert.equal(moment(a).add({m: 25}).calendar(),      'TÃ¤na, 12:25',     'Now plus 25 min');
        assert.equal(moment(a).add({h: 1}).calendar(),       'TÃ¤na, 13:00',     'Now plus 1 hour');
        assert.equal(moment(a).add({d: 1}).calendar(),       'Homme, 12:00',    'tomorrow at the same time');
        assert.equal(moment(a).subtract({h: 1}).calendar(),  'TÃ¤na, 11:00',     'Now minus 1 hour');
        assert.equal(moment(a).subtract({d: 1}).calendar(),  'Eile, 12:00',     'yesterday at the same time');
    });

    test('calendar next week', function (assert) {
        var i, m;
        for (i = 2; i < 7; i++) {
            m = moment().add({d: i});
            assert.equal(m.calendar(),       m.format('[JÃ¤rgmine] dddd LT'),  'Today + ' + i + ' days current time');
            m.hours(0).minutes(0).seconds(0).milliseconds(0);
            assert.equal(m.calendar(),       m.format('[JÃ¤rgmine] dddd LT'),  'Today + ' + i + ' days beginning of day');
            m.hours(23).minutes(59).seconds(59).milliseconds(999);
            assert.equal(m.calendar(),       m.format('[JÃ¤rgmine] dddd LT'),  'Today + ' + i + ' days end of day');
        }
    });

    test('calendar last week', function (assert) {
        var i, m;
        for (i = 2; i < 7; i++) {
            m = moment().subtract({d: i});
            assert.equal(m.calendar(),       m.format('[Eelmine] dddd LT'),  'Today - ' + i + ' days current time');
            m.hours(0).minutes(0).seconds(0).milliseconds(0);
            assert.equal(m.calendar(),       m.format('[Eelmine] dddd LT'),  'Today - ' + i + ' days beginning of day');
            m.hours(23).minutes(59).seconds(59).milliseconds(999);
            assert.equal(m.calendar(),       m.format('[Eelmine] dddd LT'),  'Today - ' + i + ' days end of day');
        }
    });

    test('calendar all else', function (assert) {
        var weeksAgo = moment().subtract({w: 1}),
            weeksFromNow = moment().add({w: 1});

        assert.equal(weeksAgo.calendar(),       weeksAgo.format('L'),  '1 nÃ¤dal tagasi');
        assert.equal(weeksFromNow.calendar(),   weeksFromNow.format('L'),  '1 nÃ¤dala pÃ¤rast');

        weeksAgo = moment().subtract({w: 2});
        weeksFromNow = moment().add({w: 2});

        assert.equal(weeksAgo.calendar(),       weeksAgo.format('L'),  '2 nÃ¤dalat tagasi');
        assert.equal(weeksFromNow.calendar(),   weeksFromNow.format('L'),  '2 nÃ¤dala pÃ¤rast');
    });

    test('weeks year starting sunday formatted', function (assert) {
        assert.equal(moment([2012, 0,  1]).format('w ww wo'), '52 52 52.', 'Jan  1 2012 should be week 52');
        assert.equal(moment([2012, 0,  2]).format('w ww wo'),   '1 01 1.', 'Jan  2 2012 should be week 1');
        assert.equal(moment([2012, 0,  8]).format('w ww wo'),   '1 01 1.', 'Jan  8 2012 should be week 1');
        assert.equal(moment([2012, 0,  9]).format('w ww wo'),   '2 02 2.', 'Jan  9 2012 should be week 2');
        assert.equal(moment([2012, 0, 15]).format('w ww wo'),   '2 02 2.', 'Jan 15 2012 should be week 2');
    });

}));

;(function (global, factory) {
   typeof exports === 'object' && typeof module !== 'undefined'
       && typeof require === 'function' ? factory(require('../../moment')) :
   typeof define === 'function' && define.amd ? define(['../../moment'], factory) :
   factory(global.moment)
}(this, function (moment) { 'use strict';

    function each(array, callback) {
        var i;
        for (i = 0; i < array.length; i++) {
            callback(array[i], i, array);
        }
    }

    function objectKeys(obj) {
        if (Object.keys) {
            return Object.keys(obj);
        } else {
            // IE8
            var res = [], i;
            for (i in obj) {
                if (obj.hasOwnProperty(i)) {
                    res.push(i);
                }
            }
            return res;
        }
    }

    // Pick the first defined of two or three arguments.
    function defaults(a, b, c) {
        if (a != null) {
            return a;
        }
        if (b != null) {
            return b;
        }
        return c;
    }

    function defineCommonLocaleTests(locale, options) {
        test('lenient ordinal parsing', function (assert) {
            var i, ordinalStr, testMoment;
            for (i = 1; i <= 31; ++i) {
                ordinalStr = moment([2014, 0, i]).format('YYYY MM Do');
                testMoment = moment(ordinalStr, 'YYYY MM Do');
                assert.equal(testMoment.year(), 2014,
                        'lenient ordinal parsing ' + i + ' year check');
                assert.equal(testMoment.month(), 0,
                        'lenient ordinal parsing ' + i + ' month check');
                assert.equal(testMoment.date(), i,
                        'lenient ordinal parsing ' + i + ' date check');
            }
        });

        test('lenient ordinal parsing of number', function (assert) {
            var i, testMoment;
            for (i = 1; i <= 31; ++i) {
                testMoment = moment('2014 01 ' + i, 'YYYY MM Do');
                assert.equal(testMoment.year(), 2014,
                        'lenient ordinal parsing of number ' + i + ' year check');
                assert.equal(testMoment.month(), 0,
                        'lenient ordinal parsing of number ' + i + ' month check');
                assert.equal(testMoment.date(), i,
                        'lenient ordinal parsing of number ' + i + ' date check');
            }
        });

        test('strict ordinal parsing', function (assert) {
            var i, ordinalStr, testMoment;
            for (i = 1; i <= 31; ++i) {
                ordinalStr = moment([2014, 0, i]).format('YYYY MM Do');
                testMoment = moment(ordinalStr, 'YYYY MM Do', true);
                assert.ok(testMoment.isValid(), 'strict ordinal parsing ' + i);
            }
        });

        test('meridiem invariant', function (assert) {
            var h, m, t1, t2;
            for (h = 0; h < 24; ++h) {
                for (m = 0; m < 60; m += 15) {
                    t1 = moment.utc([2000, 0, 1, h, m]);
                    t2 = moment.utc(t1.format('A h:mm'), 'A h:mm');
                    assert.equal(t2.format('HH:mm'), t1.format('HH:mm'),
                            'meridiem at ' + t1.format('HH:mm'));
                }
            }
        });

        test('date format correctness', function (assert) {
            var data, tokens;
            data = moment.localeData()._longDateFormat;
            tokens = objectKeys(data);
            each(tokens, function (srchToken) {
                // Check each format string to make sure it does not contain any
                // tokens that need to be expanded.
                each(tokens, function (baseToken) {
                    // strip escaped sequences
                    var format = data[baseToken].replace(/(\[[^\]]*\])/g, '');
                    assert.equal(false, !!~format.indexOf(srchToken),
                            'contains ' + srchToken + ' in ' + baseToken);
                });
            });
        });

        test('month parsing correctness', function (assert) {
            var i, m;

            if (locale === 'tr') {
                // I can't fix it :(
                expect(0);
                return;
            }
            function tester(format) {
                var r;
                r = moment(m.format(format), format);
                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format);
                r = moment(m.format(format).toLocaleUpperCase(), format);
                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' upper');
                r = moment(m.format(format).toLocaleLowerCase(), format);
                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' lower');

                r = moment(m.format(format), format, true);
                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' strict');
                r = moment(m.format(format).toLocaleUpperCase(), format, true);
                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' upper strict');
                r = moment(m.format(format).toLocaleLowerCase(), format, true);
                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' lower strict');
            }

            for (i = 0; i < 12; ++i) {
                m = moment([2015, i, 15, 18]);
                tester('MMM');
                tester('MMM.');
                tester('MMMM');
                tester('MMMM.');
            }
        });

        test('weekday parsing correctness', function (assert) {
            var i, m;

            if (locale === 'tr' || locale === 'az') {
                // There is a lower-case letter (Ä±), that converted to upper then
                // lower changes to i
                expect(0);
                return;
            }
            function tester(format) {
                var r, baseMsg = 'weekday ' + m.weekday() + ' fmt ' + format;
                r = moment(m.format(format), format);
                assert.equal(r.weekday(), m.weekday(), baseMsg);
                r = moment(m.format(format).toLocaleUpperCase(), format);
                assert.equal(r.weekday(), m.weekday(), baseMsg + ' upper');
                r = moment(m.format(format).toLocaleLowerCase(), format);
                assert.equal(r.weekday(), m.weekday(), baseMsg + ' lower');

                r = moment(m.format(format), format, true);
                assert.equal(r.weekday(), m.weekday(), baseMsg + ' strict');
                r = moment(m.format(format).toLocaleUpperCase(), format, true);
                assert.equal(r.weekday(), m.weekday(), baseMsg + ' upper strict');
                r = moment(m.format(format).toLocaleLowerCase(), format, true);
                assert.equal(r.weekday(), m.weekday(), baseMsg + ' lower strict');
            }

            for (i = 0; i < 7; ++i) {
                m = moment.utc([2015, i, 15, 18]);
                tester('dd');
                tester('ddd');
                tester('dddd');
            }
        });
    }

    function setupDeprecationHandler(test, moment, scope) {
        test._expectedDeprecations = null;
        test._observedDeprecations = null;
        test._oldSupress = moment.suppressDeprecationWarnings;
        moment.suppressDeprecationWarnings = true;
        test.expectedDeprecations = function () {
            test._expectedDeprecations = arguments;
            test._observedDeprecations = [];
        };
        moment.deprecationHandler = function (name, msg) {
            var deprecationId = matchedDeprecation(name, msg, test._expectedDeprecations);
            if (deprecationId === -1) {
                throw new Error('Unexpected deprecation thrown name=' +
                        name + ' msg=' + msg);
            }
            test._observedDeprecations[deprecationId] = 1;
        };
    }

    function teardownDeprecationHandler(test, moment, scope) {
        moment.suppressDeprecationWarnings = test._oldSupress;

        if (test._expectedDeprecations != null) {
            var missedDeprecations = [];
            each(test._expectedDeprecations, function (deprecationPattern, id) {
                if (test._observedDeprecations[id] !== 1) {
                    missedDeprecations.push(deprecationPattern);
                }
            });
            if (missedDeprecations.length !== 0) {
                throw new Error('Expected deprecation warnings did not happen: ' +
                        missedDeprecations.join(' '));
            }
        }
    }

    function matchedDeprecation(name, msg, deprecations) {
        if (deprecations == null) {
            return -1;
        }
        for (var i = 0; i < deprecations.length; ++i) {
            if (name != null && name === deprecations[i]) {
                return i;
            }
            if (msg != null && msg.substring(0, deprecations[i].length) === deprecations[i]) {
                return i;
            }
        }
        return -1;
    }

    /*global QUnit:false*/

    var test = QUnit.test;

    var expect = QUnit.expect;

    function module (name, lifecycle) {
        QUnit.module(name, {
            setup : function () {
                moment.locale('en');
                moment.createFromInputFallback = function (config) {
                    throw new Error('input not handled by moment: ' + config._i);
                };
                setupDeprecationHandler(test, moment, 'core');
                if (lifecycle && lifecycle.setup) {
                    lifecycle.setup();
                }
            },
            teardown : function () {
                teardownDeprecationHandler(test, moment, 'core');
                if (lifecycle && lifecycle.teardown) {
                    lifecycle.teardown();
                }
            }
        });
    }

    function localeModule (name, lifecycle) {
        QUnit.module('locale:' + name, {
            setup : function () {
                moment.locale(name);
                moment.createFromInputFallback = function (config) {
                    throw new Error('input not handled by moment: ' + config._i);
                };
                setupDeprecationHandler(test, moment, 'locale');
                if (lifecycle && lifecycle.setup) {
                    lifecycle.setup();
                }
            },
            teardown : function () {
                moment.locale('en');
                teardownDeprecationHandler(test, moment, 'locale');
                if (lifecycle && lifecycle.teardown) {
                    lifecycle.teardown();
                }
            }
        });
        defineCommonLocaleTests(name, -1, -1);
    }

    localeModule('eu');

    test('parse', function (assert) {
        var tests = 'urtarrila urt._otsaila ots._martxoa mar._apirila api._maiatza mai._ekaina eka._uztaila uzt._abuztua abu._iraila ira._urria urr._azaroa aza._abendua abe.'.split('_'), i;
        function equalTest(input, mmm, i) {
            assert.equal(moment(input, mmm).month(), i, input + ' should be month ' + (i + 1));
        }
        for (i = 0; i < 12; i++) {
            tests[i] = tests[i].split(' ');
            equalTest(tests[i][0], 'MMM', i);
            equalTest(tests[i][1], 'MMM', i);
            equalTest(tests[i][0], 'MMMM', i);
            equalTest(tests[i][1], 'MMMM', i);
            equalTest(tests[i][0].toLocaleLowerCase(), 'MMMM', i);
            equalTest(tests[i][1].toLocaleLowerCase(), 'MMMM', i);
            equalTest(tests[i][0].toLocaleUpperCase(), 'MMMM', i);
            equalTest(tests[i][1].toLocaleUpperCase(), 'MMMM', i);
        }
    });

    test('format', function (assert) {
        var a = [
                ['dddd, MMMM Do YYYY, h:mm:ss a',      'igandea, otsaila 14. 2010, 3:25:50 pm'],
                ['ddd, hA',                            'ig., 3PM'],
                ['M Mo MM MMMM MMM',                   '2 2. 02 otsaila ots.'],
                ['YYYY YY',                            '2010 10'],
                ['D Do DD',                            '14 14. 14'],
                ['d do dddd ddd dd',                   '0 0. igandea ig. ig'],
                ['DDD DDDo DDDD',                      '45 45. 045'],
                ['w wo ww',                            '7 7. 07'],
                ['h hh',                               '3 03'],
                ['H HH',                               '15 15'],
                ['m mm',                               '25 25'],
                ['s ss',                               '50 50'],
                ['a A',                                'pm PM'],
                ['[the] DDDo [day of the year]',       'the 45. day of the year'],
                ['LTS',                                '15:25:50'],
                ['L',                                  '2010-02-14'],
                ['LL',                                 '2010ko otsailaren 14a'],
                ['LLL',                                '2010ko otsailaren 14a 15:25'],
                ['LLLL',                               'igandea, 2010ko otsailaren 14a 15:25'],
                ['l',                                  '2010-2-14'],
                ['ll',                                 '2010ko ots. 14a'],
                ['lll',                                '2010ko ots. 14a 15:25'],
                ['llll',                               'ig., 2010ko ots. 14a 15:25']
            ],
            b = moment(new Date(2010, 1, 14, 15, 25, 50, 125)),
            i;
        for (i = 0; i < a.length; i++) {
            assert.equal(b.format(a[i][0]), a[i][1], a[i][0] + ' ---> ' + a[i][1]);
        }
    });

    test('format ordinal', function (assert) {
        assert.equal(moment([2011, 0, 1]).format('DDDo'), '1.', '1.');
        assert.equal(moment([2011, 0, 2]).format('DDDo'), '2.', '2.');
        assert.equal(moment([2011, 0, 3]).format('DDDo'), '3.', '3.');
        assert.equal(moment([2011, 0, 4]).format('DDDo'), '4.', '4.');
        assert.equal(moment([2011, 0, 5]).format('DDDo'), '5.', '5.');
        assert.equal(moment([2011, 0, 6]).format('DDDo'), '6.', '6.');
        assert.equal(moment([2011, 0, 7]).format('DDDo'), '7.', '7.');
        assert.equal(moment([2011, 0, 8]).format('DDDo'), '8.', '8.');
        assert.equal(moment([2011, 0, 9]).format('DDDo'), '9.', '9.');
        assert.equal(moment([2011, 0, 10]).format('DDDo'), '10.', '10.');

        assert.equal(moment([2011, 0, 11]).format('DDDo'), '11.', '11.');
        assert.equal(moment([2011, 0, 12]).format('DDDo'), '12.', '12.');
        assert.equal(moment([2011, 0, 13]).format('DDDo'), '13.', '13.');
        assert.equal(moment([2011, 0, 14]).format('DDDo'), '14.', '14.');
        assert.equal(moment([2011, 0, 15]).format('DDDo'), '15.', '15.');
        assert.equal(moment([2011, 0, 16]).format('DDDo'), '16.', '16.');
        assert.equal(moment([2011, 0, 17]).format('DDDo'), '17.', '17.');
        assert.equal(moment([2011, 0, 18]).format('DDDo'), '18.', '18.');
        assert.equal(moment([2011, 0, 19]).format('DDDo'), '19.', '19.');
        assert.equal(moment([2011, 0, 20]).format('DDDo'), '20.', '20.');

        assert.equal(moment([2011, 0, 21]).format('DDDo'), '21.', '21.');
        assert.equal(moment([2011, 0, 22]).format('DDDo'), '22.', '22.');
        assert.equal(moment([2011, 0, 23]).format('DDDo'), '23.', '23.');
        assert.equal(moment([2011, 0, 24]).format('DDDo'), '24.', '24.');
        assert.equal(moment([2011, 0, 25]).format('DDDo'), '25.', '25.');
        assert.equal(moment([2011, 0, 26]).format('DDDo'), '26.', '26.');
        assert.equal(moment([2011, 0, 27]).format('DDDo'), '27.', '27.');
        assert.equal(moment([2011, 0, 28]).format('DDDo'), '28.', '28.');
        assert.equal(moment([2011, 0, 29]).format('DDDo'), '29.', '29.');
        assert.equal(moment([2011, 0, 30]).format('DDDo'), '30.', '30.');

        assert.equal(moment([2011, 0, 31]).format('DDDo'), '31.', '31.');
    });

    test('format month', function (assert) {
        var expected = 'urtarrila urt._otsaila ots._martxoa mar._apirila api._maiatza mai._ekaina eka._uztaila uzt._abuztua abu._iraila ira._urria urr._azaroa aza._abendua abe.'.split('_'), i;
        for (i = 0; i < expected.length; i++) {
            assert.equal(moment([2011, i, 1]).format('MMMM MMM'), expected[i], expected[i]);
        }
    });

    test('format week', function (assert) {
        var expected = 'igandea ig. ig_astelehena al. al_asteartea ar. ar_asteazkena az. az_osteguna og. og_ostirala ol. ol_larunbata lr. lr'.split('_'), i;
        for (i = 0; i < expected.length; i++) {
            assert.equal(moment([2011, 0, 2 + i]).format('dddd ddd dd'), expected[i], expected[i]);
        }
    });

    test('from', function (assert) {
        var start = moment([2007, 1, 28]);
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 44}), true),  'segundo batzuk', '44 seconds = a few seconds');
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 45}), true),  'minutu bat',     '45 seconds = a minute');
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 89}), true),  'minutu bat',     '89 seconds = a minute');
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 90}), true),  '2 minutu',       '90 seconds = 2 minutes');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 44}), true),  '44 minutu',      '44 minutes = 44 minutes');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 45}), true),  'ordu bat',       '45 minutes = an hour');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 89}), true),  'ordu bat',       '89 minutes = an hour');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 90}), true),  '2 ordu',         '90 minutes = 2 hours');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 5}), true),   '5 ordu',         '5 hours = 5 hours');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 21}), true),  '21 ordu',        '21 hours = 21 hours');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 22}), true),  'egun bat',       '22 hours = a day');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 35}), true),  'egun bat',       '35 hours = a day');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 36}), true),  '2 egun',         '36 hours = 2 days');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 1}), true),   'egun bat',       '1 day = a day');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 5}), true),   '5 egun',         '5 days = 5 days');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 25}), true),  '25 egun',        '25 days = 25 days');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 26}), true),  'hilabete bat',   '26 days = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 30}), true),  'hilabete bat',   '30 days = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 43}), true),  'hilabete bat',   '43 days = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 46}), true),  '2 hilabete',     '46 days = 2 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 74}), true),  '2 hilabete',     '75 days = 2 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 76}), true),  '3 hilabete',     '76 days = 3 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({M: 1}), true),   'hilabete bat',   '1 month = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({M: 5}), true),   '5 hilabete',     '5 months = 5 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 345}), true), 'urte bat',       '345 days = a year');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 548}), true), '2 urte',         '548 days = 2 years');
        assert.equal(start.from(moment([2007, 1, 28]).add({y: 1}), true),   'urte bat',       '1 year = a year');
        assert.equal(start.from(moment([2007, 1, 28]).add({y: 5}), true),   '5 urte',         '5 years = 5 years');
    });

    test('suffix', function (assert) {
        assert.equal(moment(30000).from(0), 'segundo batzuk barru',  'prefix');
        assert.equal(moment(0).from(30000), 'duela segundo batzuk', 'suffix');
    });

    test('now from now', function (assert) {
        assert.equal(moment().fromNow(), 'duela segundo batzuk',  'now from now should display as in the past');
    });

    test('fromNow', function (assert) {
        assert.equal(moment().add({s: 30}).fromNow(), 'segundo batzuk barru', 'in seconds');
        assert.equal(moment().add({d: 5}).fromNow(), '5 egun barru', 'in 5 days');
    });

    test('calendar day', function (assert) {
        var a = moment().hours(12).minutes(0).seconds(0);

        assert.equal(moment(a).calendar(),                   'gaur 12:00etan',  'today at the same time');
        assert.equal(moment(a).add({m: 25}).calendar(),      'gaur 12:25etan',  'now plus 25 min');
        assert.equal(moment(a).add({h: 1}).calendar(),       'gaur 13:00etan',  'now plus 1 hour');
        assert.equal(moment(a).add({d: 1}).calendar(),       'bihar 12:00etan', 'tomorrow at the same time');
        assert.equal(moment(a).subtract({h: 1}).calendar(),  'gaur 11:00etan',  'now minus 1 hour');
        assert.equal(moment(a).subtract({d: 1}).calendar(),  'atzo 12:00etan',  'yesterday at the same time');
    });

    test('calendar next week', function (assert) {
        var i, m;
        for (i = 2; i < 7; i++) {
            m = moment().add({d: i});
            assert.equal(m.calendar(),       m.format('dddd LT[etan]'),  'Today + ' + i + ' days current time');
            m.hours(0).minutes(0).seconds(0).milliseconds(0);
            assert.equal(m.calendar(),       m.format('dddd LT[etan]'),  'Today + ' + i + ' days beginning of day');
            m.hours(23).minutes(59).seconds(59).milliseconds(999);
            assert.equal(m.calendar(),       m.format('dddd LT[etan]'),  'Today + ' + i + ' days end of day');
        }
    });

    test('calendar last week', function (assert) {
        var i, m;
        for (i = 2; i < 7; i++) {
            m = moment().subtract({d: i});
            assert.equal(m.calendar(),       m.format('[aurreko] dddd LT[etan]'),  'Today - ' + i + ' days current time');
            m.hours(0).minutes(0).seconds(0).milliseconds(0);
            assert.equal(m.calendar(),       m.format('[aurreko] dddd LT[etan]'),  'Today - ' + i + ' days beginning of day');
            m.hours(23).minutes(59).seconds(59).milliseconds(999);
            assert.equal(m.calendar(),       m.format('[aurreko] dddd LT[etan]'),  'Today - ' + i + ' days end of day');
        }
    });

    test('calendar all else', function (assert) {
        var weeksAgo = moment().subtract({w: 1}),
            weeksFromNow = moment().add({w: 1});

        assert.equal(weeksAgo.calendar(),       weeksAgo.format('L'),  '1 week ago');
        assert.equal(weeksFromNow.calendar(),   weeksFromNow.format('L'),  'in 1 week');

        weeksAgo = moment().subtract({w: 2});
        weeksFromNow = moment().add({w: 2});

        assert.equal(weeksAgo.calendar(),       weeksAgo.format('L'),  '2 weeks ago');
        assert.equal(weeksFromNow.calendar(),   weeksFromNow.format('L'),  'in 2 weeks');
    });

    test('weeks year starting sunday formatted', function (assert) {
        assert.equal(moment([2011, 11, 26]).format('w ww wo'), '1 01 1.', 'Dec 26 2011 should be week 1');
        assert.equal(moment([2012,  0,  1]).format('w ww wo'), '1 01 1.', 'Jan  1 2012 should be week 1');
        assert.equal(moment([2012,  0,  2]).format('w ww wo'), '2 02 2.', 'Jan  2 2012 should be week 2');
        assert.equal(moment([2012,  0,  8]).format('w ww wo'), '2 02 2.', 'Jan  8 2012 should be week 2');
        assert.equal(moment([2012,  0,  9]).format('w ww wo'), '3 03 3.', 'Jan  9 2012 should be week 3');
    });

}));

;(function (global, factory) {
   typeof exports === 'object' && typeof module !== 'undefined'
       && typeof require === 'function' ? factory(require('../../moment')) :
   typeof define === 'function' && define.amd ? define(['../../moment'], factory) :
   factory(global.moment)
}(this, function (moment) { 'use strict';

    function each(array, callback) {
        var i;
        for (i = 0; i < array.length; i++) {
            callback(array[i], i, array);
        }
    }

    function objectKeys(obj) {
        if (Object.keys) {
            return Object.keys(obj);
        } else {
            // IE8
            var res = [], i;
            for (i in obj) {
                if (obj.hasOwnProperty(i)) {
                    res.push(i);
                }
            }
            return res;
        }
    }

    // Pick the first defined of two or three arguments.
    function defaults(a, b, c) {
        if (a != null) {
            return a;
        }
        if (b != null) {
            return b;
        }
        return c;
    }

    function defineCommonLocaleTests(locale, options) {
        test('lenient ordinal parsing', function (assert) {
            var i, ordinalStr, testMoment;
            for (i = 1; i <= 31; ++i) {
                ordinalStr = moment([2014, 0, i]).format('YYYY MM Do');
                testMoment = moment(ordinalStr, 'YYYY MM Do');
                assert.equal(testMoment.year(), 2014,
                        'lenient ordinal parsing ' + i + ' year check');
                assert.equal(testMoment.month(), 0,
                        'lenient ordinal parsing ' + i + ' month check');
                assert.equal(testMoment.date(), i,
                        'lenient ordinal parsing ' + i + ' date check');
            }
        });

        test('lenient ordinal parsing of number', function (assert) {
            var i, testMoment;
            for (i = 1; i <= 31; ++i) {
                testMoment = moment('2014 01 ' + i, 'YYYY MM Do');
                assert.equal(testMoment.year(), 2014,
                        'lenient ordinal parsing of number ' + i + ' year check');
                assert.equal(testMoment.month(), 0,
                        'lenient ordinal parsing of number ' + i + ' month check');
                assert.equal(testMoment.date(), i,
                        'lenient ordinal parsing of number ' + i + ' date check');
            }
        });

        test('strict ordinal parsing', function (assert) {
            var i, ordinalStr, testMoment;
            for (i = 1; i <= 31; ++i) {
                ordinalStr = moment([2014, 0, i]).format('YYYY MM Do');
                testMoment = moment(ordinalStr, 'YYYY MM Do', true);
                assert.ok(testMoment.isValid(), 'strict ordinal parsing ' + i);
            }
        });

        test('meridiem invariant', function (assert) {
            var h, m, t1, t2;
            for (h = 0; h < 24; ++h) {
                for (m = 0; m < 60; m += 15) {
                    t1 = moment.utc([2000, 0, 1, h, m]);
                    t2 = moment.utc(t1.format('A h:mm'), 'A h:mm');
                    assert.equal(t2.format('HH:mm'), t1.format('HH:mm'),
                            'meridiem at ' + t1.format('HH:mm'));
                }
            }
        });

        test('date format correctness', function (assert) {
            var data, tokens;
            data = moment.localeData()._longDateFormat;
            tokens = objectKeys(data);
            each(tokens, function (srchToken) {
                // Check each format string to make sure it does not contain any
                // tokens that need to be expanded.
                each(tokens, function (baseToken) {
                    // strip escaped sequences
                    var format = data[baseToken].replace(/(\[[^\]]*\])/g, '');
                    assert.equal(false, !!~format.indexOf(srchToken),
                            'contains ' + srchToken + ' in ' + baseToken);
                });
            });
        });

        test('month parsing correctness', function (assert) {
            var i, m;

            if (locale === 'tr') {
                // I can't fix it :(
                expect(0);
                return;
            }
            function tester(format) {
                var r;
                r = moment(m.format(format), format);
                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format);
                r = moment(m.format(format).toLocaleUpperCase(), format);
                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' upper');
                r = moment(m.format(format).toLocaleLowerCase(), format);
                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' lower');

                r = moment(m.format(format), format, true);
                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' strict');
                r = moment(m.format(format).toLocaleUpperCase(), format, true);
                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' upper strict');
                r = moment(m.format(format).toLocaleLowerCase(), format, true);
                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' lower strict');
            }

            for (i = 0; i < 12; ++i) {
                m = moment([2015, i, 15, 18]);
                tester('MMM');
                tester('MMM.');
                tester('MMMM');
                tester('MMMM.');
            }
        });

        test('weekday parsing correctness', function (assert) {
            var i, m;

            if (locale === 'tr' || locale === 'az') {
                // There is a lower-case letter (Ä±), that converted to upper then
                // lower changes to i
                expect(0);
                return;
            }
            function tester(format) {
                var r, baseMsg = 'weekday ' + m.weekday() + ' fmt ' + format;
                r = moment(m.format(format), format);
                assert.equal(r.weekday(), m.weekday(), baseMsg);
                r = moment(m.format(format).toLocaleUpperCase(), format);
                assert.equal(r.weekday(), m.weekday(), baseMsg + ' upper');
                r = moment(m.format(format).toLocaleLowerCase(), format);
                assert.equal(r.weekday(), m.weekday(), baseMsg + ' lower');

                r = moment(m.format(format), format, true);
                assert.equal(r.weekday(), m.weekday(), baseMsg + ' strict');
                r = moment(m.format(format).toLocaleUpperCase(), format, true);
                assert.equal(r.weekday(), m.weekday(), baseMsg + ' upper strict');
                r = moment(m.format(format).toLocaleLowerCase(), format, true);
                assert.equal(r.weekday(), m.weekday(), baseMsg + ' lower strict');
            }

            for (i = 0; i < 7; ++i) {
                m = moment.utc([2015, i, 15, 18]);
                tester('dd');
                tester('ddd');
                tester('dddd');
            }
        });
    }

    function setupDeprecationHandler(test, moment, scope) {
        test._expectedDeprecations = null;
        test._observedDeprecations = null;
        test._oldSupress = moment.suppressDeprecationWarnings;
        moment.suppressDeprecationWarnings = true;
        test.expectedDeprecations = function () {
            test._expectedDeprecations = arguments;
            test._observedDeprecations = [];
        };
        moment.deprecationHandler = function (name, msg) {
            var deprecationId = matchedDeprecation(name, msg, test._expectedDeprecations);
            if (deprecationId === -1) {
                throw new Error('Unexpected deprecation thrown name=' +
                        name + ' msg=' + msg);
            }
            test._observedDeprecations[deprecationId] = 1;
        };
    }

    function teardownDeprecationHandler(test, moment, scope) {
        moment.suppressDeprecationWarnings = test._oldSupress;

        if (test._expectedDeprecations != null) {
            var missedDeprecations = [];
            each(test._expectedDeprecations, function (deprecationPattern, id) {
                if (test._observedDeprecations[id] !== 1) {
                    missedDeprecations.push(deprecationPattern);
                }
            });
            if (missedDeprecations.length !== 0) {
                throw new Error('Expected deprecation warnings did not happen: ' +
                        missedDeprecations.join(' '));
            }
        }
    }

    function matchedDeprecation(name, msg, deprecations) {
        if (deprecations == null) {
            return -1;
        }
        for (var i = 0; i < deprecations.length; ++i) {
            if (name != null && name === deprecations[i]) {
                return i;
            }
            if (msg != null && msg.substring(0, deprecations[i].length) === deprecations[i]) {
                return i;
            }
        }
        return -1;
    }

    /*global QUnit:false*/

    var test = QUnit.test;

    var expect = QUnit.expect;

    function module (name, lifecycle) {
        QUnit.module(name, {
            setup : function () {
                moment.locale('en');
                moment.createFromInputFallback = function (config) {
                    throw new Error('input not handled by moment: ' + config._i);
                };
                setupDeprecationHandler(test, moment, 'core');
                if (lifecycle && lifecycle.setup) {
                    lifecycle.setup();
                }
            },
            teardown : function () {
                teardownDeprecationHandler(test, moment, 'core');
                if (lifecycle && lifecycle.teardown) {
                    lifecycle.teardown();
                }
            }
        });
    }

    function localeModule (name, lifecycle) {
        QUnit.module('locale:' + name, {
            setup : function () {
                moment.locale(name);
                moment.createFromInputFallback = function (config) {
                    throw new Error('input not handled by moment: ' + config._i);
                };
                setupDeprecationHandler(test, moment, 'locale');
                if (lifecycle && lifecycle.setup) {
                    lifecycle.setup();
                }
            },
            teardown : function () {
                moment.locale('en');
                teardownDeprecationHandler(test, moment, 'locale');
                if (lifecycle && lifecycle.teardown) {
                    lifecycle.teardown();
                }
            }
        });
        defineCommonLocaleTests(name, -1, -1);
    }

    localeModule('fa');

    test('parse', function (assert) {
        var tests = 'ÚØ§ÙÙÛÙ_ÙÙØ±ÛÙ_ÙØ§Ø±Ø³_Ø¢ÙØ±ÛÙ_ÙÙ_ÚÙØ¦Ù_ÚÙØ¦ÛÙ_Ø§ÙØª_Ø³Ù¾ØªØ§ÙØ¨Ø±_Ø§Ú©ØªØ¨Ø±_ÙÙØ§ÙØ¨Ø±_Ø¯Ø³Ø§ÙØ¨Ø±'.split('_'), i;
        function equalTest(input, mmm, i) {
            assert.equal(moment(input, mmm).month(), i, input + ' should be month ' + (i + 1) + ' instead is month ' + moment(input, mmm).month());
        }
        for (i = 0; i < 12; i++) {
            equalTest(tests[i], 'MMM', i);
            equalTest(tests[i], 'MMMM', i);
        }
    });

    test('format', function (assert) {
        var a = [
                ['dddd, MMMM Do YYYY, h:mm:ss a',      'ÛÚ©\u200cØ´ÙØ¨ÙØ ÙÙØ±ÛÙ Û±Û´Ù Û²Û°Û±Û°Ø Û³:Û²Ûµ:ÛµÛ° Ø¨Ø¹Ø¯ Ø§Ø² Ø¸ÙØ±'],
                ['ddd, hA',                            'ÛÚ©\u200cØ´ÙØ¨ÙØ Û³Ø¨Ø¹Ø¯ Ø§Ø² Ø¸ÙØ±'],
                ['M Mo MM MMMM MMM',                   'Û² Û²Ù Û°Û² ÙÙØ±ÛÙ ÙÙØ±ÛÙ'],
                ['YYYY YY',                            'Û²Û°Û±Û° Û±Û°'],
                ['D Do DD',                            'Û±Û´ Û±Û´Ù Û±Û´'],
                ['d do dddd ddd dd',                   'Û° Û°Ù ÛÚ©\u200cØ´ÙØ¨Ù ÛÚ©\u200cØ´ÙØ¨Ù Û'],
                ['DDD DDDo DDDD',                      'Û´Ûµ Û´ÛµÙ Û°Û´Ûµ'],
                ['w wo ww',                            'Û¸ Û¸Ù Û°Û¸'],
                ['h hh',                               'Û³ Û°Û³'],
                ['H HH',                               'Û±Ûµ Û±Ûµ'],
                ['m mm',                               'Û²Ûµ Û²Ûµ'],
                ['s ss',                               'ÛµÛ° ÛµÛ°'],
                ['a A',                                'Ø¨Ø¹Ø¯ Ø§Ø² Ø¸ÙØ± Ø¨Ø¹Ø¯ Ø§Ø² Ø¸ÙØ±'],
                ['DDDo [Ø±ÙØ² Ø³Ø§Ù]',             'Û´ÛµÙ Ø±ÙØ² Ø³Ø§Ù'],
                ['LTS',                                'Û±Ûµ:Û²Ûµ:ÛµÛ°'],
                ['L',                                  'Û±Û´/Û°Û²/Û²Û°Û±Û°'],
                ['LL',                                 'Û±Û´ ÙÙØ±ÛÙ Û²Û°Û±Û°'],
                ['LLL',                                'Û±Û´ ÙÙØ±ÛÙ Û²Û°Û±Û° Û±Ûµ:Û²Ûµ'],
                ['LLLL',                               'ÛÚ©\u200cØ´ÙØ¨ÙØ Û±Û´ ÙÙØ±ÛÙ Û²Û°Û±Û° Û±Ûµ:Û²Ûµ'],
                ['l',                                  'Û±Û´/Û²/Û²Û°Û±Û°'],
                ['ll',                                 'Û±Û´ ÙÙØ±ÛÙ Û²Û°Û±Û°'],
                ['lll',                                'Û±Û´ ÙÙØ±ÛÙ Û²Û°Û±Û° Û±Ûµ:Û²Ûµ'],
                ['llll',                               'ÛÚ©\u200cØ´ÙØ¨ÙØ Û±Û´ ÙÙØ±ÛÙ Û²Û°Û±Û° Û±Ûµ:Û²Ûµ']
            ],
            b = moment(new Date(2010, 1, 14, 15, 25, 50, 125)),
            i;
        for (i = 0; i < a.length; i++) {
            assert.equal(b.format(a[i][0]), a[i][1], a[i][0] + ' ---> ' + a[i][1]);
        }
    });

    test('format ordinal', function (assert) {
        assert.equal(moment([2011, 0, 1]).format('DDDo'), 'Û±Ù', '1');
        assert.equal(moment([2011, 0, 2]).format('DDDo'), 'Û²Ù', '2');
        assert.equal(moment([2011, 0, 3]).format('DDDo'), 'Û³Ù', '3');
        assert.equal(moment([2011, 0, 4]).format('DDDo'), 'Û´Ù', '4');
        assert.equal(moment([2011, 0, 5]).format('DDDo'), 'ÛµÙ', '5');
        assert.equal(moment([2011, 0, 6]).format('DDDo'), 'Û¶Ù', '6');
        assert.equal(moment([2011, 0, 7]).format('DDDo'), 'Û·Ù', '7');
        assert.equal(moment([2011, 0, 8]).format('DDDo'), 'Û¸Ù', '8');
        assert.equal(moment([2011, 0, 9]).format('DDDo'), 'Û¹Ù', '9');
        assert.equal(moment([2011, 0, 10]).format('DDDo'), 'Û±Û°Ù', '10');

        assert.equal(moment([2011, 0, 11]).format('DDDo'), 'Û±Û±Ù', '11');
        assert.equal(moment([2011, 0, 12]).format('DDDo'), 'Û±Û²Ù', '12');
        assert.equal(moment([2011, 0, 13]).format('DDDo'), 'Û±Û³Ù', '13');
        assert.equal(moment([2011, 0, 14]).format('DDDo'), 'Û±Û´Ù', '14');
        assert.equal(moment([2011, 0, 15]).format('DDDo'), 'Û±ÛµÙ', '15');
        assert.equal(moment([2011, 0, 16]).format('DDDo'), 'Û±Û¶Ù', '16');
        assert.equal(moment([2011, 0, 17]).format('DDDo'), 'Û±Û·Ù', '17');
        assert.equal(moment([2011, 0, 18]).format('DDDo'), 'Û±Û¸Ù', '18');
        assert.equal(moment([2011, 0, 19]).format('DDDo'), 'Û±Û¹Ù', '19');
        assert.equal(moment([2011, 0, 20]).format('DDDo'), 'Û²Û°Ù', '20');

        assert.equal(moment([2011, 0, 21]).format('DDDo'), 'Û²Û±Ù', '21');
        assert.equal(moment([2011, 0, 22]).format('DDDo'), 'Û²Û²Ù', '22');
        assert.equal(moment([2011, 0, 23]).format('DDDo'), 'Û²Û³Ù', '23');
        assert.equal(moment([2011, 0, 24]).format('DDDo'), 'Û²Û´Ù', '24');
        assert.equal(moment([2011, 0, 25]).format('DDDo'), 'Û²ÛµÙ', '25');
        assert.equal(moment([2011, 0, 26]).format('DDDo'), 'Û²Û¶Ù', '26');
        assert.equal(moment([2011, 0, 27]).format('DDDo'), 'Û²Û·Ù', '27');
        assert.equal(moment([2011, 0, 28]).format('DDDo'), 'Û²Û¸Ù', '28');
        assert.equal(moment([2011, 0, 29]).format('DDDo'), 'Û²Û¹Ù', '29');
        assert.equal(moment([2011, 0, 30]).format('DDDo'), 'Û³Û°Ù', '30');

        assert.equal(moment([2011, 0, 31]).format('DDDo'), 'Û³Û±Ù', '31');
    });

    test('format month', function (assert) {
        var expected = 'ÚØ§ÙÙÛÙ ÚØ§ÙÙÛÙ_ÙÙØ±ÛÙ ÙÙØ±ÛÙ_ÙØ§Ø±Ø³ ÙØ§Ø±Ø³_Ø¢ÙØ±ÛÙ Ø¢ÙØ±ÛÙ_ÙÙ ÙÙ_ÚÙØ¦Ù ÚÙØ¦Ù_ÚÙØ¦ÛÙ ÚÙØ¦ÛÙ_Ø§ÙØª Ø§ÙØª_Ø³Ù¾ØªØ§ÙØ¨Ø± Ø³Ù¾ØªØ§ÙØ¨Ø±_Ø§Ú©ØªØ¨Ø± Ø§Ú©ØªØ¨Ø±_ÙÙØ§ÙØ¨Ø± ÙÙØ§ÙØ¨Ø±_Ø¯Ø³Ø§ÙØ¨Ø± Ø¯Ø³Ø§ÙØ¨Ø±'.split('_'), i;
        for (i = 0; i < expected.length; i++) {
            assert.equal(moment([2011, i, 1]).format('MMMM MMM'), expected[i], expected[i]);
        }
    });

    test('format week', function (assert) {
        var expected = 'ÛÚ©\u200cØ´ÙØ¨Ù ÛÚ©\u200cØ´ÙØ¨Ù Û_Ø¯ÙØ´ÙØ¨Ù Ø¯ÙØ´ÙØ¨Ù Ø¯_Ø³Ù\u200cØ´ÙØ¨Ù Ø³Ù\u200cØ´ÙØ¨Ù Ø³_ÚÙØ§Ø±Ø´ÙØ¨Ù ÚÙØ§Ø±Ø´ÙØ¨Ù Ú_Ù¾ÙØ¬\u200cØ´ÙØ¨Ù Ù¾ÙØ¬\u200cØ´ÙØ¨Ù Ù¾_Ø¬ÙØ¹Ù Ø¬ÙØ¹Ù Ø¬_Ø´ÙØ¨Ù Ø´ÙØ¨Ù Ø´'.split('_'), i;
        for (i = 0; i < expected.length; i++) {
            assert.equal(moment([2011, 0, 2 + i]).format('dddd ddd dd'), expected[i], expected[i]);
        }
    });

    test('from', function (assert) {
        var start = moment([2007, 1, 28]);
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 44}), true),  'ÚÙØ¯ÛÙ Ø«Ø§ÙÛÙ', '44 seconds = a few seconds');
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 45}), true),  'ÛÚ© Ø¯ÙÛÙÙ',       '45 seconds = a minute');
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 89}), true),  'ÛÚ© Ø¯ÙÛÙÙ',       '89 seconds = a minute');
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 90}), true),  'Û² Ø¯ÙÛÙÙ',     '90 seconds = 2 minutes');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 44}), true),  'Û´Û´ Ø¯ÙÛÙÙ',    '44 minutes = 44 minutes');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 45}), true),  'ÛÚ© Ø³Ø§Ø¹Øª',     '45 minutes = an hour');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 89}), true),  'ÛÚ© Ø³Ø§Ø¹Øª',     '89 minutes = an hour');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 90}), true),  'Û² Ø³Ø§Ø¹Øª',      '90 minutes = 2 hours');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 5}), true),   'Ûµ Ø³Ø§Ø¹Øª',      '5 hours = 5 hours');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 21}), true),  'Û²Û± Ø³Ø§Ø¹Øª',     '21 hours = 21 hours');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 22}), true),  'ÛÚ© Ø±ÙØ²',      '22 hours = a day');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 35}), true),  'ÛÚ© Ø±ÙØ²',      '35 hours = a day');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 36}), true),  'Û² Ø±ÙØ²',       '36 hours = 2 days');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 1}), true),   'ÛÚ© Ø±ÙØ²',      '1 day = a day');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 5}), true),   'Ûµ Ø±ÙØ²',       '5 days = 5 days');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 25}), true),  'Û²Ûµ Ø±ÙØ²',      '25 days = 25 days');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 26}), true),  'ÛÚ© ÙØ§Ù',      '26 days = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 30}), true),  'ÛÚ© ÙØ§Ù',      '30 days = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 43}), true),  'ÛÚ© ÙØ§Ù',      '43 days = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 46}), true),  'Û² ÙØ§Ù',       '46 days = 2 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 74}), true),  'Û² ÙØ§Ù',       '75 days = 2 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 76}), true),  'Û³ ÙØ§Ù',       '76 days = 3 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({M: 1}), true),   'ÛÚ© ÙØ§Ù',      '1 month = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({M: 5}), true),   'Ûµ ÙØ§Ù',       '5 months = 5 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 345}), true), 'ÛÚ© Ø³Ø§Ù',      '345 days = a year');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 548}), true), 'Û² Ø³Ø§Ù',       '548 days = 2 years');
        assert.equal(start.from(moment([2007, 1, 28]).add({y: 1}), true),   'ÛÚ© Ø³Ø§Ù',      '1 year = a year');
        assert.equal(start.from(moment([2007, 1, 28]).add({y: 5}), true),   'Ûµ Ø³Ø§Ù',       '5 years = 5 years');
    });

    test('suffix', function (assert) {
        assert.equal(moment(30000).from(0), 'Ø¯Ø± ÚÙØ¯ÛÙ Ø«Ø§ÙÛÙ', 'prefix');
        assert.equal(moment(0).from(30000), 'ÚÙØ¯ÛÙ Ø«Ø§ÙÛÙ Ù¾ÛØ´', 'suffix');
    });

    test('now from now', function (assert) {
        assert.equal(moment().fromNow(), 'ÚÙØ¯ÛÙ Ø«Ø§ÙÛÙ Ù¾ÛØ´',  'now from now should display as in the past');
    });

    test('fromNow', function (assert) {
        assert.equal(moment().add({s: 30}).fromNow(), 'Ø¯Ø± ÚÙØ¯ÛÙ Ø«Ø§ÙÛÙ', 'in a few seconds');
        assert.equal(moment().add({d: 5}).fromNow(), 'Ø¯Ø± Ûµ Ø±ÙØ²', 'in 5 days');
    });

    test('calendar day', function (assert) {
        var a = moment().hours(12).minutes(0).seconds(0);

        assert.equal(moment(a).calendar(),                   'Ø§ÙØ±ÙØ² Ø³Ø§Ø¹Øª Û±Û²:Û°Û°', 'today at the same time');
        assert.equal(moment(a).add({m: 25}).calendar(),      'Ø§ÙØ±ÙØ² Ø³Ø§Ø¹Øª Û±Û²:Û²Ûµ', 'Now plus 25 min');
        assert.equal(moment(a).add({h: 1}).calendar(),       'Ø§ÙØ±ÙØ² Ø³Ø§Ø¹Øª Û±Û³:Û°Û°', 'Now plus 1 hour');
        assert.equal(moment(a).add({d: 1}).calendar(),       'ÙØ±Ø¯Ø§ Ø³Ø§Ø¹Øª Û±Û²:Û°Û°', 'tomorrow at the same time');
        assert.equal(moment(a).subtract({h: 1}).calendar(),  'Ø§ÙØ±ÙØ² Ø³Ø§Ø¹Øª Û±Û±:Û°Û°', 'Now minus 1 hour');
        assert.equal(moment(a).subtract({d: 1}).calendar(),  'Ø¯ÛØ±ÙØ² Ø³Ø§Ø¹Øª Û±Û²:Û°Û°', 'yesterday at the same time');
    });

    test('calendar next week', function (assert) {
        var i, m;
        for (i = 2; i < 7; i++) {
            m = moment().add({d: i});
            assert.equal(m.calendar(),       m.format('dddd [Ø³Ø§Ø¹Øª] LT'),  'Today + ' + i + ' days current time');
            m.hours(0).minutes(0).seconds(0).milliseconds(0);
            assert.equal(m.calendar(),       m.format('dddd [Ø³Ø§Ø¹Øª] LT'),  'Today + ' + i + ' days beginning of day');
            m.hours(23).minutes(59).seconds(59).milliseconds(999);
            assert.equal(m.calendar(),       m.format('dddd [Ø³Ø§Ø¹Øª] LT'),  'Today + ' + i + ' days end of day');
        }
    });

    test('calendar last week', function (assert) {
        var i, m;
        for (i = 2; i < 7; i++) {
            m = moment().subtract({d: i});
            assert.equal(m.calendar(),       m.format('dddd [Ù¾ÛØ´ Ø³Ø§Ø¹Øª] LT'),  'Today - ' + i + ' days current time');
            m.hours(0).minutes(0).seconds(0).milliseconds(0);
            assert.equal(m.calendar(),       m.format('dddd [Ù¾ÛØ´ Ø³Ø§Ø¹Øª] LT'),  'Today - ' + i + ' days beginning of day');
            m.hours(23).minutes(59).seconds(59).milliseconds(999);
            assert.equal(m.calendar(),       m.format('dddd [Ù¾ÛØ´ Ø³Ø§Ø¹Øª] LT'),  'Today - ' + i + ' days end of day');
        }
    });

    test('calendar all else', function (assert) {
        var weeksAgo = moment().subtract({w: 1}),
            weeksFromNow = moment().add({w: 1});

        assert.equal(weeksAgo.calendar(),       weeksAgo.format('L'),  '1 week ago');
        assert.equal(weeksFromNow.calendar(),   weeksFromNow.format('L'),  'in 1 week');

        weeksAgo = moment().subtract({w: 2});
        weeksFromNow = moment().add({w: 2});

        assert.equal(weeksAgo.calendar(),       weeksAgo.format('L'),  '2 weeks ago');
        assert.equal(weeksFromNow.calendar(),   weeksFromNow.format('L'),  'in 2 weeks');
    });

    test('weeks year starting sunday formatted', function (assert) {
        assert.equal(moment([2011, 11, 31]).format('w ww wo'), 'Û± Û°Û± Û±Ù', 'Dec 31 2011 should be week 1');
        assert.equal(moment([2012,  0,  6]).format('w ww wo'), 'Û± Û°Û± Û±Ù', 'Jan  6 2012 should be week 1');
        assert.equal(moment([2012,  0,  7]).format('w ww wo'), 'Û² Û°Û² Û²Ù', 'Jan  7 2012 should be week 2');
        assert.equal(moment([2012,  0, 13]).format('w ww wo'), 'Û² Û°Û² Û²Ù', 'Jan 13 2012 should be week 2');
        assert.equal(moment([2012,  0, 14]).format('w ww wo'), 'Û³ Û°Û³ Û³Ù', 'Jan 14 2012 should be week 3');
    });

}));

;(function (global, factory) {
   typeof exports === 'object' && typeof module !== 'undefined'
       && typeof require === 'function' ? factory(require('../../moment')) :
   typeof define === 'function' && define.amd ? define(['../../moment'], factory) :
   factory(global.moment)
}(this, function (moment) { 'use strict';

    function each(array, callback) {
        var i;
        for (i = 0; i < array.length; i++) {
            callback(array[i], i, array);
        }
    }

    function objectKeys(obj) {
        if (Object.keys) {
            return Object.keys(obj);
        } else {
            // IE8
            var res = [], i;
            for (i in obj) {
                if (obj.hasOwnProperty(i)) {
                    res.push(i);
                }
            }
            return res;
        }
    }

    // Pick the first defined of two or three arguments.
    function defaults(a, b, c) {
        if (a != null) {
            return a;
        }
        if (b != null) {
            return b;
        }
        return c;
    }

    function defineCommonLocaleTests(locale, options) {
        test('lenient ordinal parsing', function (assert) {
            var i, ordinalStr, testMoment;
            for (i = 1; i <= 31; ++i) {
                ordinalStr = moment([2014, 0, i]).format('YYYY MM Do');
                testMoment = moment(ordinalStr, 'YYYY MM Do');
                assert.equal(testMoment.year(), 2014,
                        'lenient ordinal parsing ' + i + ' year check');
                assert.equal(testMoment.month(), 0,
                        'lenient ordinal parsing ' + i + ' month check');
                assert.equal(testMoment.date(), i,
                        'lenient ordinal parsing ' + i + ' date check');
            }
        });

        test('lenient ordinal parsing of number', function (assert) {
            var i, testMoment;
            for (i = 1; i <= 31; ++i) {
                testMoment = moment('2014 01 ' + i, 'YYYY MM Do');
                assert.equal(testMoment.year(), 2014,
                        'lenient ordinal parsing of number ' + i + ' year check');
                assert.equal(testMoment.month(), 0,
                        'lenient ordinal parsing of number ' + i + ' month check');
                assert.equal(testMoment.date(), i,
                        'lenient ordinal parsing of number ' + i + ' date check');
            }
        });

        test('strict ordinal parsing', function (assert) {
            var i, ordinalStr, testMoment;
            for (i = 1; i <= 31; ++i) {
                ordinalStr = moment([2014, 0, i]).format('YYYY MM Do');
                testMoment = moment(ordinalStr, 'YYYY MM Do', true);
                assert.ok(testMoment.isValid(), 'strict ordinal parsing ' + i);
            }
        });

        test('meridiem invariant', function (assert) {
            var h, m, t1, t2;
            for (h = 0; h < 24; ++h) {
                for (m = 0; m < 60; m += 15) {
                    t1 = moment.utc([2000, 0, 1, h, m]);
                    t2 = moment.utc(t1.format('A h:mm'), 'A h:mm');
                    assert.equal(t2.format('HH:mm'), t1.format('HH:mm'),
                            'meridiem at ' + t1.format('HH:mm'));
                }
            }
        });

        test('date format correctness', function (assert) {
            var data, tokens;
            data = moment.localeData()._longDateFormat;
            tokens = objectKeys(data);
            each(tokens, function (srchToken) {
                // Check each format string to make sure it does not contain any
                // tokens that need to be expanded.
                each(tokens, function (baseToken) {
                    // strip escaped sequences
                    var format = data[baseToken].replace(/(\[[^\]]*\])/g, '');
                    assert.equal(false, !!~format.indexOf(srchToken),
                            'contains ' + srchToken + ' in ' + baseToken);
                });
            });
        });

        test('month parsing correctness', function (assert) {
            var i, m;

            if (locale === 'tr') {
                // I can't fix it :(
                expect(0);
                return;
            }
            function tester(format) {
                var r;
                r = moment(m.format(format), format);
                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format);
                r = moment(m.format(format).toLocaleUpperCase(), format);
                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' upper');
                r = moment(m.format(format).toLocaleLowerCase(), format);
                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' lower');

                r = moment(m.format(format), format, true);
                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' strict');
                r = moment(m.format(format).toLocaleUpperCase(), format, true);
                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' upper strict');
                r = moment(m.format(format).toLocaleLowerCase(), format, true);
                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' lower strict');
            }

            for (i = 0; i < 12; ++i) {
                m = moment([2015, i, 15, 18]);
                tester('MMM');
                tester('MMM.');
                tester('MMMM');
                tester('MMMM.');
            }
        });

        test('weekday parsing correctness', function (assert) {
            var i, m;

            if (locale === 'tr' || locale === 'az') {
                // There is a lower-case letter (Ä±), that converted to upper then
                // lower changes to i
                expect(0);
                return;
            }
            function tester(format) {
                var r, baseMsg = 'weekday ' + m.weekday() + ' fmt ' + format;
                r = moment(m.format(format), format);
                assert.equal(r.weekday(), m.weekday(), baseMsg);
                r = moment(m.format(format).toLocaleUpperCase(), format);
                assert.equal(r.weekday(), m.weekday(), baseMsg + ' upper');
                r = moment(m.format(format).toLocaleLowerCase(), format);
                assert.equal(r.weekday(), m.weekday(), baseMsg + ' lower');

                r = moment(m.format(format), format, true);
                assert.equal(r.weekday(), m.weekday(), baseMsg + ' strict');
                r = moment(m.format(format).toLocaleUpperCase(), format, true);
                assert.equal(r.weekday(), m.weekday(), baseMsg + ' upper strict');
                r = moment(m.format(format).toLocaleLowerCase(), format, true);
                assert.equal(r.weekday(), m.weekday(), baseMsg + ' lower strict');
            }

            for (i = 0; i < 7; ++i) {
                m = moment.utc([2015, i, 15, 18]);
                tester('dd');
                tester('ddd');
                tester('dddd');
            }
        });
    }

    function setupDeprecationHandler(test, moment, scope) {
        test._expectedDeprecations = null;
        test._observedDeprecations = null;
        test._oldSupress = moment.suppressDeprecationWarnings;
        moment.suppressDeprecationWarnings = true;
        test.expectedDeprecations = function () {
            test._expectedDeprecations = arguments;
            test._observedDeprecations = [];
        };
        moment.deprecationHandler = function (name, msg) {
            var deprecationId = matchedDeprecation(name, msg, test._expectedDeprecations);
            if (deprecationId === -1) {
                throw new Error('Unexpected deprecation thrown name=' +
                        name + ' msg=' + msg);
            }
            test._observedDeprecations[deprecationId] = 1;
        };
    }

    function teardownDeprecationHandler(test, moment, scope) {
        moment.suppressDeprecationWarnings = test._oldSupress;

        if (test._expectedDeprecations != null) {
            var missedDeprecations = [];
            each(test._expectedDeprecations, function (deprecationPattern, id) {
                if (test._observedDeprecations[id] !== 1) {
                    missedDeprecations.push(deprecationPattern);
                }
            });
            if (missedDeprecations.length !== 0) {
                throw new Error('Expected deprecation warnings did not happen: ' +
                        missedDeprecations.join(' '));
            }
        }
    }

    function matchedDeprecation(name, msg, deprecations) {
        if (deprecations == null) {
            return -1;
        }
        for (var i = 0; i < deprecations.length; ++i) {
            if (name != null && name === deprecations[i]) {
                return i;
            }
            if (msg != null && msg.substring(0, deprecations[i].length) === deprecations[i]) {
                return i;
            }
        }
        return -1;
    }

    /*global QUnit:false*/

    var test = QUnit.test;

    var expect = QUnit.expect;

    function module (name, lifecycle) {
        QUnit.module(name, {
            setup : function () {
                moment.locale('en');
                moment.createFromInputFallback = function (config) {
                    throw new Error('input not handled by moment: ' + config._i);
                };
                setupDeprecationHandler(test, moment, 'core');
                if (lifecycle && lifecycle.setup) {
                    lifecycle.setup();
                }
            },
            teardown : function () {
                teardownDeprecationHandler(test, moment, 'core');
                if (lifecycle && lifecycle.teardown) {
                    lifecycle.teardown();
                }
            }
        });
    }

    function localeModule (name, lifecycle) {
        QUnit.module('locale:' + name, {
            setup : function () {
                moment.locale(name);
                moment.createFromInputFallback = function (config) {
                    throw new Error('input not handled by moment: ' + config._i);
                };
                setupDeprecationHandler(test, moment, 'locale');
                if (lifecycle && lifecycle.setup) {
                    lifecycle.setup();
                }
            },
            teardown : function () {
                moment.locale('en');
                teardownDeprecationHandler(test, moment, 'locale');
                if (lifecycle && lifecycle.teardown) {
                    lifecycle.teardown();
                }
            }
        });
        defineCommonLocaleTests(name, -1, -1);
    }

    localeModule('fi');

    test('parse', function (assert) {
        var tests = 'tammikuu tammi_helmikuu helmi_maaliskuu maalis_huhtikuu huhti_toukokuu touko_kesÃ¤kuu kesÃ¤_heinÃ¤kuu heinÃ¤_elokuu elo_syyskuu syys_lokakuu loka_marraskuu marras_joulukuu joulu'.split('_'), i;
        function equalTest(input, mmm, i) {
            assert.equal(moment(input, mmm).month(), i, input + ' should be month ' + (i + 1));
        }
        for (i = 0; i < 12; i++) {
            tests[i] = tests[i].split(' ');
            equalTest(tests[i][0], 'MMM', i);
            equalTest(tests[i][1], 'MMM', i);
            equalTest(tests[i][0], 'MMMM', i);
            equalTest(tests[i][1], 'MMMM', i);
            equalTest(tests[i][0].toLocaleLowerCase(), 'MMMM', i);
            equalTest(tests[i][1].toLocaleLowerCase(), 'MMMM', i);
            equalTest(tests[i][0].toLocaleUpperCase(), 'MMMM', i);
            equalTest(tests[i][1].toLocaleUpperCase(), 'MMMM', i);
        }
    });

    test('format', function (assert) {
        var a = [
                ['dddd, MMMM Do YYYY, h:mm:ss a',      'sunnuntai, helmikuu 14. 2010, 3:25:50 pm'],
                ['ddd, hA',                            'su, 3PM'],
                ['M Mo MM MMMM MMM',                   '2 2. 02 helmikuu helmi'],
                ['YYYY YY',                            '2010 10'],
                ['D Do DD',                            '14 14. 14'],
                ['d do dddd ddd dd',                   '0 0. sunnuntai su su'],
                ['DDD DDDo DDDD',                      '45 45. 045'],
                ['w wo ww',                            '6 6. 06'],
                ['h hh',                               '3 03'],
                ['H HH',                               '15 15'],
                ['m mm',                               '25 25'],
                ['s ss',                               '50 50'],
                ['a A',                                'pm PM'],
                ['[vuoden] DDDo [pÃ¤ivÃ¤]',              'vuoden 45. pÃ¤ivÃ¤'],
                ['LTS',                                '15.25.50'],
                ['L',                                  '14.02.2010'],
                ['LL',                                 '14. helmikuuta 2010'],
                ['LLL',                                '14. helmikuuta 2010, klo 15.25'],
                ['LLLL',                               'sunnuntai, 14. helmikuuta 2010, klo 15.25'],
                ['l',                                  '14.2.2010'],
                ['ll',                                 '14. helmi 2010'],
                ['lll',                                '14. helmi 2010, klo 15.25'],
                ['llll',                               'su, 14. helmi 2010, klo 15.25']
            ],
            b = moment(new Date(2010, 1, 14, 15, 25, 50, 125)),
            i;
        for (i = 0; i < a.length; i++) {
            assert.equal(b.format(a[i][0]), a[i][1], a[i][0] + ' ---> ' + a[i][1]);
        }
    });

    test('format ordinal', function (assert) {
        assert.equal(moment([2011, 0, 1]).format('DDDo'), '1.', '1st');
        assert.equal(moment([2011, 0, 2]).format('DDDo'), '2.', '2nd');
        assert.equal(moment([2011, 0, 3]).format('DDDo'), '3.', '3rd');
        assert.equal(moment([2011, 0, 4]).format('DDDo'), '4.', '4th');
        assert.equal(moment([2011, 0, 5]).format('DDDo'), '5.', '5th');
        assert.equal(moment([2011, 0, 6]).format('DDDo'), '6.', '6th');
        assert.equal(moment([2011, 0, 7]).format('DDDo'), '7.', '7th');
        assert.equal(moment([2011, 0, 8]).format('DDDo'), '8.', '8th');
        assert.equal(moment([2011, 0, 9]).format('DDDo'), '9.', '9th');
        assert.equal(moment([2011, 0, 10]).format('DDDo'), '10.', '10th');

        assert.equal(moment([2011, 0, 11]).format('DDDo'), '11.', '11th');
        assert.equal(moment([2011, 0, 12]).format('DDDo'), '12.', '12th');
        assert.equal(moment([2011, 0, 13]).format('DDDo'), '13.', '13th');
        assert.equal(moment([2011, 0, 14]).format('DDDo'), '14.', '14th');
        assert.equal(moment([2011, 0, 15]).format('DDDo'), '15.', '15th');
        assert.equal(moment([2011, 0, 16]).format('DDDo'), '16.', '16th');
        assert.equal(moment([2011, 0, 17]).format('DDDo'), '17.', '17th');
        assert.equal(moment([2011, 0, 18]).format('DDDo'), '18.', '18th');
        assert.equal(moment([2011, 0, 19]).format('DDDo'), '19.', '19th');
        assert.equal(moment([2011, 0, 20]).format('DDDo'), '20.', '20th');

        assert.equal(moment([2011, 0, 21]).format('DDDo'), '21.', '21st');
        assert.equal(moment([2011, 0, 22]).format('DDDo'), '22.', '22nd');
        assert.equal(moment([2011, 0, 23]).format('DDDo'), '23.', '23rd');
        assert.equal(moment([2011, 0, 24]).format('DDDo'), '24.', '24th');
        assert.equal(moment([2011, 0, 25]).format('DDDo'), '25.', '25th');
        assert.equal(moment([2011, 0, 26]).format('DDDo'), '26.', '26th');
        assert.equal(moment([2011, 0, 27]).format('DDDo'), '27.', '27th');
        assert.equal(moment([2011, 0, 28]).format('DDDo'), '28.', '28th');
        assert.equal(moment([2011, 0, 29]).format('DDDo'), '29.', '29th');
        assert.equal(moment([2011, 0, 30]).format('DDDo'), '30.', '30th');

        assert.equal(moment([2011, 0, 31]).format('DDDo'), '31.', '31st');
    });

    test('format month', function (assert) {
        var expected = 'tammikuu tammi_helmikuu helmi_maaliskuu maalis_huhtikuu huhti_toukokuu touko_kesÃ¤kuu kesÃ¤_heinÃ¤kuu heinÃ¤_elokuu elo_syyskuu syys_lokakuu loka_marraskuu marras_joulukuu joulu'.split('_'), i;
        for (i = 0; i < expected.length; i++) {
            assert.equal(moment([2011, i, 1]).format('MMMM MMM'), expected[i], expected[i]);
        }
    });

    test('format week', function (assert) {
        var expected = 'sunnuntai su su_maanantai ma ma_tiistai ti ti_keskiviikko ke ke_torstai to to_perjantai pe pe_lauantai la la'.split('_'), i;
        for (i = 0; i < expected.length; i++) {
            assert.equal(moment([2011, 0, 2 + i]).format('dddd ddd dd'), expected[i], expected[i]);
        }
    });

    test('from', function (assert) {
        var start = moment([2007, 1, 28]);
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 44}), true),  'muutama sekunti', '44 seconds = few seconds');
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 45}), true),  'minuutti',      '45 seconds = a minute');
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 89}), true),  'minuutti',      '89 seconds = a minute');
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 90}), true),  'kaksi minuuttia',     '90 seconds = 2 minutes');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 44}), true),  '44 minuuttia',    '44 minutes = 44 minutes');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 45}), true),  'tunti',       '45 minutes = an hour');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 89}), true),  'tunti',       '89 minutes = an hour');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 90}), true),  'kaksi tuntia',       '90 minutes = 2 hours');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 5}), true),   'viisi tuntia',       '5 hours = 5 hours');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 21}), true),  '21 tuntia',      '21 hours = 21 hours');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 22}), true),  'pÃ¤ivÃ¤',         '22 hours = a day');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 35}), true),  'pÃ¤ivÃ¤',         '35 hours = a day');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 36}), true),  'kaksi pÃ¤ivÃ¤Ã¤',        '36 hours = 2 days');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 1}), true),   'pÃ¤ivÃ¤',         '1 day = a day');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 5}), true),   'viisi pÃ¤ivÃ¤Ã¤',        '5 days = 5 days');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 25}), true),  '25 pÃ¤ivÃ¤Ã¤',       '25 days = 25 days');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 26}), true),  'kuukausi',       '26 days = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 30}), true),  'kuukausi',       '30 days = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 43}), true),  'kuukausi',       '43 days = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 46}), true),  'kaksi kuukautta',      '46 days = 2 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 74}), true),  'kaksi kuukautta',      '75 days = 2 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 76}), true),  'kolme kuukautta',      '76 days = 3 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({M: 1}), true),   'kuukausi',       '1 month = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({M: 5}), true),   'viisi kuukautta',      '5 months = 5 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 345}), true), 'vuosi',        '345 days = a year');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 548}), true), 'kaksi vuotta',       '548 days = 2 years');
        assert.equal(start.from(moment([2007, 1, 28]).add({y: 1}), true),   'vuosi',        '1 year = a year');
        assert.equal(start.from(moment([2007, 1, 28]).add({y: 5}), true),   'viisi vuotta',       '5 years = 5 years');
    });

    test('suffix', function (assert) {
        assert.equal(moment(30000).from(0), 'muutaman sekunnin pÃ¤Ã¤stÃ¤',  'prefix');
        assert.equal(moment(0).from(30000), 'muutama sekunti sitten', 'suffix');
    });

    test('now from now', function (assert) {
        assert.equal(moment().fromNow(), 'muutama sekunti sitten',  'now from now should display as in the past');
    });

    test('fromNow', function (assert) {
        assert.equal(moment().add({s: 30}).fromNow(), 'muutaman sekunnin pÃ¤Ã¤stÃ¤', 'in a few seconds');
        assert.equal(moment().add({d: 5}).fromNow(), 'viiden pÃ¤ivÃ¤n pÃ¤Ã¤stÃ¤', 'in 5 days');
    });

    test('calendar day', function (assert) {
        var a = moment().hours(12).minutes(0).seconds(0);

        assert.equal(moment(a).calendar(),                   'tÃ¤nÃ¤Ã¤n klo 12.00',    'today at the same time');
        assert.equal(moment(a).add({m: 25}).calendar(),      'tÃ¤nÃ¤Ã¤n klo 12.25',    'Now plus 25 min');
        assert.equal(moment(a).add({h: 1}).calendar(),       'tÃ¤nÃ¤Ã¤n klo 13.00',    'Now plus 1 hour');
        assert.equal(moment(a).add({d: 1}).calendar(),       'huomenna klo 12.00',  'tomorrow at the same time');
        assert.equal(moment(a).subtract({h: 1}).calendar(),  'tÃ¤nÃ¤Ã¤n klo 11.00',    'Now minus 1 hour');
        assert.equal(moment(a).subtract({d: 1}).calendar(),  'eilen klo 12.00',     'yesterday at the same time');
    });

    test('calendar next week', function (assert) {
        var i, m;

        for (i = 2; i < 7; i++) {
            m = moment().add({d: i});
            assert.equal(m.calendar(),       m.format('dddd [klo] LT'),  'today + ' + i + ' days current time');
            m.hours(0).minutes(0).seconds(0).milliseconds(0);
            assert.equal(m.calendar(),       m.format('dddd [klo] LT'),  'today + ' + i + ' days beginning of day');
            m.hours(23).minutes(59).seconds(59).milliseconds(999);
            assert.equal(m.calendar(),       m.format('dddd [klo] LT'),  'today + ' + i + ' days end of day');
        }
    });

    test('calendar last week', function (assert) {
        var i, m;
        for (i = 2; i < 7; i++) {
            m = moment().subtract({d: i});
            assert.equal(m.calendar(),       m.format('[viime] dddd[na] [klo] LT'),  'today - ' + i + ' days current time');
            m.hours(0).minutes(0).seconds(0).milliseconds(0);
            assert.equal(m.calendar(),       m.format('[viime] dddd[na] [klo] LT'),  'today - ' + i + ' days beginning of day');
            m.hours(23).minutes(59).seconds(59).milliseconds(999);
            assert.equal(m.calendar(),       m.format('[viime] dddd[na] [klo] LT'),  'today - ' + i + ' days end of day');
        }
    });

    test('calendar all else', function (assert) {
        var weeksAgo = moment().subtract({w: 1}),
            weeksFromNow = moment().add({w: 1});

        assert.equal(weeksAgo.calendar(),       weeksAgo.format('L'),  'yksi viikko sitten');
        assert.equal(weeksFromNow.calendar(),   weeksFromNow.format('L'),  'yhden viikon pÃ¤Ã¤stÃ¤');

        weeksAgo = moment().subtract({w: 2});
        weeksFromNow = moment().add({w: 2});

        assert.equal(weeksAgo.calendar(),       weeksAgo.format('L'),  'kaksi viikkoa sitten');
        assert.equal(weeksFromNow.calendar(),   weeksFromNow.format('L'),  'kaden viikon pÃ¤Ã¤stÃ¤');
    });

    test('weeks year starting sunday formatted', function (assert) {
        assert.equal(moment([2012, 0,  1]).format('w ww wo'), '52 52 52.', 'Jan  1 2012 should be week 52');
        assert.equal(moment([2012, 0,  2]).format('w ww wo'),   '1 01 1.', 'Jan  2 2012 should be week 1');
        assert.equal(moment([2012, 0,  8]).format('w ww wo'),   '1 01 1.', 'Jan  8 2012 should be week 1');
        assert.equal(moment([2012, 0,  9]).format('w ww wo'),   '2 02 2.', 'Jan  9 2012 should be week 2');
        assert.equal(moment([2012, 0, 15]).format('w ww wo'),   '2 02 2.', 'Jan 15 2012 should be week 2');
    });

}));

;(function (global, factory) {
   typeof exports === 'object' && typeof module !== 'undefined'
       && typeof require === 'function' ? factory(require('../../moment')) :
   typeof define === 'function' && define.amd ? define(['../../moment'], factory) :
   factory(global.moment)
}(this, function (moment) { 'use strict';

    function each(array, callback) {
        var i;
        for (i = 0; i < array.length; i++) {
            callback(array[i], i, array);
        }
    }

    function objectKeys(obj) {
        if (Object.keys) {
            return Object.keys(obj);
        } else {
            // IE8
            var res = [], i;
            for (i in obj) {
                if (obj.hasOwnProperty(i)) {
                    res.push(i);
                }
            }
            return res;
        }
    }

    // Pick the first defined of two or three arguments.
    function defaults(a, b, c) {
        if (a != null) {
            return a;
        }
        if (b != null) {
            return b;
        }
        return c;
    }

    function defineCommonLocaleTests(locale, options) {
        test('lenient ordinal parsing', function (assert) {
            var i, ordinalStr, testMoment;
            for (i = 1; i <= 31; ++i) {
                ordinalStr = moment([2014, 0, i]).format('YYYY MM Do');
                testMoment = moment(ordinalStr, 'YYYY MM Do');
                assert.equal(testMoment.year(), 2014,
                        'lenient ordinal parsing ' + i + ' year check');
                assert.equal(testMoment.month(), 0,
                        'lenient ordinal parsing ' + i + ' month check');
                assert.equal(testMoment.date(), i,
                        'lenient ordinal parsing ' + i + ' date check');
            }
        });

        test('lenient ordinal parsing of number', function (assert) {
            var i, testMoment;
            for (i = 1; i <= 31; ++i) {
                testMoment = moment('2014 01 ' + i, 'YYYY MM Do');
                assert.equal(testMoment.year(), 2014,
                        'lenient ordinal parsing of number ' + i + ' year check');
                assert.equal(testMoment.month(), 0,
                        'lenient ordinal parsing of number ' + i + ' month check');
                assert.equal(testMoment.date(), i,
                        'lenient ordinal parsing of number ' + i + ' date check');
            }
        });

        test('strict ordinal parsing', function (assert) {
            var i, ordinalStr, testMoment;
            for (i = 1; i <= 31; ++i) {
                ordinalStr = moment([2014, 0, i]).format('YYYY MM Do');
                testMoment = moment(ordinalStr, 'YYYY MM Do', true);
                assert.ok(testMoment.isValid(), 'strict ordinal parsing ' + i);
            }
        });

        test('meridiem invariant', function (assert) {
            var h, m, t1, t2;
            for (h = 0; h < 24; ++h) {
                for (m = 0; m < 60; m += 15) {
                    t1 = moment.utc([2000, 0, 1, h, m]);
                    t2 = moment.utc(t1.format('A h:mm'), 'A h:mm');
                    assert.equal(t2.format('HH:mm'), t1.format('HH:mm'),
                            'meridiem at ' + t1.format('HH:mm'));
                }
            }
        });

        test('date format correctness', function (assert) {
            var data, tokens;
            data = moment.localeData()._longDateFormat;
            tokens = objectKeys(data);
            each(tokens, function (srchToken) {
                // Check each format string to make sure it does not contain any
                // tokens that need to be expanded.
                each(tokens, function (baseToken) {
                    // strip escaped sequences
                    var format = data[baseToken].replace(/(\[[^\]]*\])/g, '');
                    assert.equal(false, !!~format.indexOf(srchToken),
                            'contains ' + srchToken + ' in ' + baseToken);
                });
            });
        });

        test('month parsing correctness', function (assert) {
            var i, m;

            if (locale === 'tr') {
                // I can't fix it :(
                expect(0);
                return;
            }
            function tester(format) {
                var r;
                r = moment(m.format(format), format);
                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format);
                r = moment(m.format(format).toLocaleUpperCase(), format);
                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' upper');
                r = moment(m.format(format).toLocaleLowerCase(), format);
                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' lower');

                r = moment(m.format(format), format, true);
                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' strict');
                r = moment(m.format(format).toLocaleUpperCase(), format, true);
                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' upper strict');
                r = moment(m.format(format).toLocaleLowerCase(), format, true);
                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' lower strict');
            }

            for (i = 0; i < 12; ++i) {
                m = moment([2015, i, 15, 18]);
                tester('MMM');
                tester('MMM.');
                tester('MMMM');
                tester('MMMM.');
            }
        });

        test('weekday parsing correctness', function (assert) {
            var i, m;

            if (locale === 'tr' || locale === 'az') {
                // There is a lower-case letter (Ä±), that converted to upper then
                // lower changes to i
                expect(0);
                return;
            }
            function tester(format) {
                var r, baseMsg = 'weekday ' + m.weekday() + ' fmt ' + format;
                r = moment(m.format(format), format);
                assert.equal(r.weekday(), m.weekday(), baseMsg);
                r = moment(m.format(format).toLocaleUpperCase(), format);
                assert.equal(r.weekday(), m.weekday(), baseMsg + ' upper');
                r = moment(m.format(format).toLocaleLowerCase(), format);
                assert.equal(r.weekday(), m.weekday(), baseMsg + ' lower');

                r = moment(m.format(format), format, true);
                assert.equal(r.weekday(), m.weekday(), baseMsg + ' strict');
                r = moment(m.format(format).toLocaleUpperCase(), format, true);
                assert.equal(r.weekday(), m.weekday(), baseMsg + ' upper strict');
                r = moment(m.format(format).toLocaleLowerCase(), format, true);
                assert.equal(r.weekday(), m.weekday(), baseMsg + ' lower strict');
            }

            for (i = 0; i < 7; ++i) {
                m = moment.utc([2015, i, 15, 18]);
                tester('dd');
                tester('ddd');
                tester('dddd');
            }
        });
    }

    function setupDeprecationHandler(test, moment, scope) {
        test._expectedDeprecations = null;
        test._observedDeprecations = null;
        test._oldSupress = moment.suppressDeprecationWarnings;
        moment.suppressDeprecationWarnings = true;
        test.expectedDeprecations = function () {
            test._expectedDeprecations = arguments;
            test._observedDeprecations = [];
        };
        moment.deprecationHandler = function (name, msg) {
            var deprecationId = matchedDeprecation(name, msg, test._expectedDeprecations);
            if (deprecationId === -1) {
                throw new Error('Unexpected deprecation thrown name=' +
                        name + ' msg=' + msg);
            }
            test._observedDeprecations[deprecationId] = 1;
        };
    }

    function teardownDeprecationHandler(test, moment, scope) {
        moment.suppressDeprecationWarnings = test._oldSupress;

        if (test._expectedDeprecations != null) {
            var missedDeprecations = [];
            each(test._expectedDeprecations, function (deprecationPattern, id) {
                if (test._observedDeprecations[id] !== 1) {
                    missedDeprecations.push(deprecationPattern);
                }
            });
            if (missedDeprecations.length !== 0) {
                throw new Error('Expected deprecation warnings did not happen: ' +
                        missedDeprecations.join(' '));
            }
        }
    }

    function matchedDeprecation(name, msg, deprecations) {
        if (deprecations == null) {
            return -1;
        }
        for (var i = 0; i < deprecations.length; ++i) {
            if (name != null && name === deprecations[i]) {
                return i;
            }
            if (msg != null && msg.substring(0, deprecations[i].length) === deprecations[i]) {
                return i;
            }
        }
        return -1;
    }

    /*global QUnit:false*/

    var test = QUnit.test;

    var expect = QUnit.expect;

    function module (name, lifecycle) {
        QUnit.module(name, {
            setup : function () {
                moment.locale('en');
                moment.createFromInputFallback = function (config) {
                    throw new Error('input not handled by moment: ' + config._i);
                };
                setupDeprecationHandler(test, moment, 'core');
                if (lifecycle && lifecycle.setup) {
                    lifecycle.setup();
                }
            },
            teardown : function () {
                teardownDeprecationHandler(test, moment, 'core');
                if (lifecycle && lifecycle.teardown) {
                    lifecycle.teardown();
                }
            }
        });
    }

    function localeModule (name, lifecycle) {
        QUnit.module('locale:' + name, {
            setup : function () {
                moment.locale(name);
                moment.createFromInputFallback = function (config) {
                    throw new Error('input not handled by moment: ' + config._i);
                };
                setupDeprecationHandler(test, moment, 'locale');
                if (lifecycle && lifecycle.setup) {
                    lifecycle.setup();
                }
            },
            teardown : function () {
                moment.locale('en');
                teardownDeprecationHandler(test, moment, 'locale');
                if (lifecycle && lifecycle.teardown) {
                    lifecycle.teardown();
                }
            }
        });
        defineCommonLocaleTests(name, -1, -1);
    }

    localeModule('fo');

    test('parse', function (assert) {
        var tests = 'januar jan_februar feb_mars mar_aprÃ­l apr_mai mai_juni jun_juli jul_august aug_september sep_oktober okt_november nov_desember des'.split('_'), i;
        function equalTest(input, mmm, i) {
            assert.equal(moment(input, mmm).month(), i, input + ' should be month ' + (i + 1));
        }
        for (i = 0; i < 12; i++) {
            tests[i] = tests[i].split(' ');
            equalTest(tests[i][0], 'MMM', i);
            equalTest(tests[i][1], 'MMM', i);
            equalTest(tests[i][0], 'MMMM', i);
            equalTest(tests[i][1], 'MMMM', i);
            equalTest(tests[i][0].toLocaleLowerCase(), 'MMMM', i);
            equalTest(tests[i][1].toLocaleLowerCase(), 'MMMM', i);
            equalTest(tests[i][0].toLocaleUpperCase(), 'MMMM', i);
            equalTest(tests[i][1].toLocaleUpperCase(), 'MMMM', i);
        }
    });

    test('format', function (assert) {
        var a = [
                ['dddd [tann] Do MMMM YYYY, h:mm:ss a', 'sunnudagur tann 14. februar 2010, 3:25:50 pm'],
                ['ddd hA',                             'sun 3PM'],
                ['M Mo MM MMMM MMM',                   '2 2. 02 februar feb'],
                ['YYYY YY',                            '2010 10'],
                ['D Do DD',                            '14 14. 14'],
                ['d do dddd ddd dd',                   '0 0. sunnudagur sun su'],
                ['DDD DDDo DDDD',                      '45 45. 045'],
                ['w wo ww',                            '6 6. 06'],
                ['h hh',                               '3 03'],
                ['H HH',                               '15 15'],
                ['m mm',                               '25 25'],
                ['s ss',                               '50 50'],
                ['a A',                                'pm PM'],
                ['[tann] DDDo [dagin Ã¡ Ã¡rinum]',       'tann 45. dagin Ã¡ Ã¡rinum'],
                ['LTS',                                '15:25:50'],
                ['L',                                  '14/02/2010'],
                ['LL',                                 '14 februar 2010'],
                ['LLL',                                '14 februar 2010 15:25'],
                ['LLLL',                               'sunnudagur 14. februar, 2010 15:25'],
                ['l',                                  '14/2/2010'],
                ['ll',                                 '14 feb 2010'],
                ['lll',                                '14 feb 2010 15:25'],
                ['llll',                               'sun 14. feb, 2010 15:25']
            ],
            b = moment(new Date(2010, 1, 14, 15, 25, 50, 125)),
            i;
        for (i = 0; i < a.length; i++) {
            assert.equal(b.format(a[i][0]), a[i][1], a[i][0] + ' ---> ' + a[i][1]);
        }
    });

    test('format ordinal', function (assert) {
        assert.equal(moment([2011, 0, 1]).format('DDDo'), '1.', '1.');
        assert.equal(moment([2011, 0, 2]).format('DDDo'), '2.', '2.');
        assert.equal(moment([2011, 0, 3]).format('DDDo'), '3.', '3.');
        assert.equal(moment([2011, 0, 4]).format('DDDo'), '4.', '4.');
        assert.equal(moment([2011, 0, 5]).format('DDDo'), '5.', '5.');
        assert.equal(moment([2011, 0, 6]).format('DDDo'), '6.', '6.');
        assert.equal(moment([2011, 0, 7]).format('DDDo'), '7.', '7.');
        assert.equal(moment([2011, 0, 8]).format('DDDo'), '8.', '8.');
        assert.equal(moment([2011, 0, 9]).format('DDDo'), '9.', '9.');
        assert.equal(moment([2011, 0, 10]).format('DDDo'), '10.', '10.');

        assert.equal(moment([2011, 0, 11]).format('DDDo'), '11.', '11.');
        assert.equal(moment([2011, 0, 12]).format('DDDo'), '12.', '12.');
        assert.equal(moment([2011, 0, 13]).format('DDDo'), '13.', '13.');
        assert.equal(moment([2011, 0, 14]).format('DDDo'), '14.', '14.');
        assert.equal(moment([2011, 0, 15]).format('DDDo'), '15.', '15.');
        assert.equal(moment([2011, 0, 16]).format('DDDo'), '16.', '16.');
        assert.equal(moment([2011, 0, 17]).format('DDDo'), '17.', '17.');
        assert.equal(moment([2011, 0, 18]).format('DDDo'), '18.', '18.');
        assert.equal(moment([2011, 0, 19]).format('DDDo'), '19.', '19.');
        assert.equal(moment([2011, 0, 20]).format('DDDo'), '20.', '20.');

        assert.equal(moment([2011, 0, 21]).format('DDDo'), '21.', '21.');
        assert.equal(moment([2011, 0, 22]).format('DDDo'), '22.', '22.');
        assert.equal(moment([2011, 0, 23]).format('DDDo'), '23.', '23.');
        assert.equal(moment([2011, 0, 24]).format('DDDo'), '24.', '24.');
        assert.equal(moment([2011, 0, 25]).format('DDDo'), '25.', '25.');
        assert.equal(moment([2011, 0, 26]).format('DDDo'), '26.', '26.');
        assert.equal(moment([2011, 0, 27]).format('DDDo'), '27.', '27.');
        assert.equal(moment([2011, 0, 28]).format('DDDo'), '28.', '28.');
        assert.equal(moment([2011, 0, 29]).format('DDDo'), '29.', '29.');
        assert.equal(moment([2011, 0, 30]).format('DDDo'), '30.', '30.');

        assert.equal(moment([2011, 0, 31]).format('DDDo'), '31.', '31.');
    });

    test('format month', function (assert) {
        var expected = 'januar jan_februar feb_mars mar_aprÃ­l apr_mai mai_juni jun_juli jul_august aug_september sep_oktober okt_november nov_desember des'.split('_'), i;
        for (i = 0; i < expected.length; i++) {
            assert.equal(moment([2011, i, 1]).format('MMMM MMM'), expected[i], expected[i]);
        }
    });

    test('format week', function (assert) {
        var expected = 'sunnudagur sun su_mÃ¡nadagur mÃ¡n mÃ¡_tÃ½sdagur tÃ½s tÃ½_mikudagur mik mi_hÃ³sdagur hÃ³s hÃ³_frÃ­ggjadagur frÃ­ fr_leygardagur ley le'.split('_'), i;
        for (i = 0; i < expected.length; i++) {
            assert.equal(moment([2011, 0, 2 + i]).format('dddd ddd dd'), expected[i], expected[i]);
        }
    });

    test('from', function (assert) {
        var start = moment([2007, 1, 28]);
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 44}), true),  'fÃ¡ sekund', '44 seconds = a few seconds');
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 45}), true),  'ein minutt',    '45 seconds = a minute');
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 89}), true),  'ein minutt',    '89 seconds = a minute');
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 90}), true),  '2 minuttir',  '90 seconds = 2 minutes');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 44}), true),  '44 minuttir', '44 minutes = 44 minutes');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 45}), true),  'ein tÃ­mi',     '45 minutes = an hour');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 89}), true),  'ein tÃ­mi',     '89 minutes = an hour');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 90}), true),  '2 tÃ­mar',     '90 minutes = 2 hours');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 5}), true),   '5 tÃ­mar',     '5 hours = 5 hours');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 21}), true),  '21 tÃ­mar',    '21 hours = 21 hours');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 22}), true),  'ein dagur',      '22 hours = a day');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 35}), true),  'ein dagur',      '35 hours = a day');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 36}), true),  '2 dagar',      '36 hours = 2 days');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 1}), true),   'ein dagur',      '1 day = a day');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 5}), true),   '5 dagar',      '5 days = 5 days');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 25}), true),  '25 dagar',     '25 days = 25 days');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 26}), true),  'ein mÃ¡naÃ°i',    '26 days = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 30}), true),  'ein mÃ¡naÃ°i',    '30 days = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 43}), true),  'ein mÃ¡naÃ°i',    '43 days = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 46}), true),  '2 mÃ¡naÃ°ir',   '46 days = 2 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 74}), true),  '2 mÃ¡naÃ°ir',   '75 days = 2 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 76}), true),  '3 mÃ¡naÃ°ir',   '76 days = 3 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({M: 1}), true),   'ein mÃ¡naÃ°i',    '1 month = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({M: 5}), true),   '5 mÃ¡naÃ°ir',   '5 months = 5 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 345}), true), 'eitt Ã¡r',       '345 days = a year');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 548}), true), '2 Ã¡r',        '548 days = 2 years');
        assert.equal(start.from(moment([2007, 1, 28]).add({y: 1}), true),   'eitt Ã¡r',       '1 year = a year');
        assert.equal(start.from(moment([2007, 1, 28]).add({y: 5}), true),   '5 Ã¡r',        '5 years = 5 years');
    });

    test('suffix', function (assert) {
        assert.equal(moment(30000).from(0), 'um fÃ¡ sekund',  'prefix');
        assert.equal(moment(0).from(30000), 'fÃ¡ sekund sÃ­Ã°ani', 'suffix');
    });

    test('now from now', function (assert) {
        assert.equal(moment().fromNow(), 'fÃ¡ sekund sÃ­Ã°ani',  'now from now should display as in the past');
    });

    test('fromNow', function (assert) {
        assert.equal(moment().add({s: 30}).fromNow(), 'um fÃ¡ sekund', 'in a few seconds');
        assert.equal(moment().add({d: 5}).fromNow(), 'um 5 dagar', 'in 5 days');
    });


    test('calendar day', function (assert) {
        var a = moment().hours(12).minutes(0).seconds(0);

        assert.equal(moment(a).calendar(),                   'Ã dag kl. 12:00',    'today at the same time');
        assert.equal(moment(a).add({m: 25}).calendar(),      'Ã dag kl. 12:25',    'Now plus 25 min');
        assert.equal(moment(a).add({h: 1}).calendar(),       'Ã dag kl. 13:00',    'Now plus 1 hour');
        assert.equal(moment(a).add({d: 1}).calendar(),       'Ã morgin kl. 12:00', 'tomorrow at the same time');
        assert.equal(moment(a).subtract({h: 1}).calendar(),  'Ã dag kl. 11:00',    'Now minus 1 hour');
        assert.equal(moment(a).subtract({d: 1}).calendar(),  'Ã gjÃ¡r kl. 12:00',   'yesterday at the same time');
    });

    test('calendar next week', function (assert) {
        var i, m;

        for (i = 2; i < 7; i++) {
            m = moment().add({d: i});
            assert.equal(m.calendar(),       m.format('dddd [kl.] LT'),  'today + ' + i + ' days current time');
            m.hours(0).minutes(0).seconds(0).milliseconds(0);
            assert.equal(m.calendar(),       m.format('dddd [kl.] LT'),  'today + ' + i + ' days beginning of day');
            m.hours(23).minutes(59).seconds(59).milliseconds(999);
            assert.equal(m.calendar(),       m.format('dddd [kl.] LT'),  'today + ' + i + ' days end of day');
        }
    });

    test('calendar last week', function (assert) {
        var i, m;
        for (i = 2; i < 7; i++) {
            m = moment().subtract({d: i});
            assert.equal(m.calendar(),       m.format('[sÃ­Ã°stu] dddd [kl] LT'),  'today - ' + i + ' days current time');
            m.hours(0).minutes(0).seconds(0).milliseconds(0);
            assert.equal(m.calendar(),       m.format('[sÃ­Ã°stu] dddd [kl] LT'),  'today - ' + i + ' days beginning of day');
            m.hours(23).minutes(59).seconds(59).milliseconds(999);
            assert.equal(m.calendar(),       m.format('[sÃ­Ã°stu] dddd [kl] LT'),  'today - ' + i + ' days end of day');
        }
    });

    test('calendar all else', function (assert) {
        var weeksAgo = moment().subtract({w: 1}),
            weeksFromNow = moment().add({w: 1});

        assert.equal(weeksAgo.calendar(),       weeksAgo.format('L'),  'yksi viikko sitten');
        assert.equal(weeksFromNow.calendar(),   weeksFromNow.format('L'),  'yhden viikon pÃ¤Ã¤stÃ¤');

        weeksAgo = moment().subtract({w: 2});
        weeksFromNow = moment().add({w: 2});

        assert.equal(weeksAgo.calendar(),       weeksAgo.format('L'),  'kaksi viikkoa sitten');
        assert.equal(weeksFromNow.calendar(),   weeksFromNow.format('L'),  'kaden viikon pÃ¤Ã¤stÃ¤');
    });

    test('weeks year starting sunday formatted', function (assert) {
        assert.equal(moment([2012, 0,  1]).format('w ww wo'), '52 52 52.', 'Jan  1 2012 should be week 52');
        assert.equal(moment([2012, 0,  2]).format('w ww wo'),   '1 01 1.', 'Jan  2 2012 should be week 1');
        assert.equal(moment([2012, 0,  8]).format('w ww wo'),   '1 01 1.', 'Jan  8 2012 should be week 1');
        assert.equal(moment([2012, 0,  9]).format('w ww wo'),   '2 02 2.', 'Jan  9 2012 should be week 2');
        assert.equal(moment([2012, 0, 15]).format('w ww wo'),   '2 02 2.', 'Jan 15 2012 should be week 2');
    });

}));

;(function (global, factory) {
   typeof exports === 'object' && typeof module !== 'undefined'
       && typeof require === 'function' ? factory(require('../../moment')) :
   typeof define === 'function' && define.amd ? define(['../../moment'], factory) :
   factory(global.moment)
}(this, function (moment) { 'use strict';

    function each(array, callback) {
        var i;
        for (i = 0; i < array.length; i++) {
            callback(array[i], i, array);
        }
    }

    function objectKeys(obj) {
        if (Object.keys) {
            return Object.keys(obj);
        } else {
            // IE8
            var res = [], i;
            for (i in obj) {
                if (obj.hasOwnProperty(i)) {
                    res.push(i);
                }
            }
            return res;
        }
    }

    // Pick the first defined of two or three arguments.
    function defaults(a, b, c) {
        if (a != null) {
            return a;
        }
        if (b != null) {
            return b;
        }
        return c;
    }

    function defineCommonLocaleTests(locale, options) {
        test('lenient ordinal parsing', function (assert) {
            var i, ordinalStr, testMoment;
            for (i = 1; i <= 31; ++i) {
                ordinalStr = moment([2014, 0, i]).format('YYYY MM Do');
                testMoment = moment(ordinalStr, 'YYYY MM Do');
                assert.equal(testMoment.year(), 2014,
                        'lenient ordinal parsing ' + i + ' year check');
                assert.equal(testMoment.month(), 0,
                        'lenient ordinal parsing ' + i + ' month check');
                assert.equal(testMoment.date(), i,
                        'lenient ordinal parsing ' + i + ' date check');
            }
        });

        test('lenient ordinal parsing of number', function (assert) {
            var i, testMoment;
            for (i = 1; i <= 31; ++i) {
                testMoment = moment('2014 01 ' + i, 'YYYY MM Do');
                assert.equal(testMoment.year(), 2014,
                        'lenient ordinal parsing of number ' + i + ' year check');
                assert.equal(testMoment.month(), 0,
                        'lenient ordinal parsing of number ' + i + ' month check');
                assert.equal(testMoment.date(), i,
                        'lenient ordinal parsing of number ' + i + ' date check');
            }
        });

        test('strict ordinal parsing', function (assert) {
            var i, ordinalStr, testMoment;
            for (i = 1; i <= 31; ++i) {
                ordinalStr = moment([2014, 0, i]).format('YYYY MM Do');
                testMoment = moment(ordinalStr, 'YYYY MM Do', true);
                assert.ok(testMoment.isValid(), 'strict ordinal parsing ' + i);
            }
        });

        test('meridiem invariant', function (assert) {
            var h, m, t1, t2;
            for (h = 0; h < 24; ++h) {
                for (m = 0; m < 60; m += 15) {
                    t1 = moment.utc([2000, 0, 1, h, m]);
                    t2 = moment.utc(t1.format('A h:mm'), 'A h:mm');
                    assert.equal(t2.format('HH:mm'), t1.format('HH:mm'),
                            'meridiem at ' + t1.format('HH:mm'));
                }
            }
        });

        test('date format correctness', function (assert) {
            var data, tokens;
            data = moment.localeData()._longDateFormat;
            tokens = objectKeys(data);
            each(tokens, function (srchToken) {
                // Check each format string to make sure it does not contain any
                // tokens that need to be expanded.
                each(tokens, function (baseToken) {
                    // strip escaped sequences
                    var format = data[baseToken].replace(/(\[[^\]]*\])/g, '');
                    assert.equal(false, !!~format.indexOf(srchToken),
                            'contains ' + srchToken + ' in ' + baseToken);
                });
            });
        });

        test('month parsing correctness', function (assert) {
            var i, m;

            if (locale === 'tr') {
                // I can't fix it :(
                expect(0);
                return;
            }
            function tester(format) {
                var r;
                r = moment(m.format(format), format);
                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format);
                r = moment(m.format(format).toLocaleUpperCase(), format);
                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' upper');
                r = moment(m.format(format).toLocaleLowerCase(), format);
                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' lower');

                r = moment(m.format(format), format, true);
                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' strict');
                r = moment(m.format(format).toLocaleUpperCase(), format, true);
                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' upper strict');
                r = moment(m.format(format).toLocaleLowerCase(), format, true);
                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' lower strict');
            }

            for (i = 0; i < 12; ++i) {
                m = moment([2015, i, 15, 18]);
                tester('MMM');
                tester('MMM.');
                tester('MMMM');
                tester('MMMM.');
            }
        });

        test('weekday parsing correctness', function (assert) {
            var i, m;

            if (locale === 'tr' || locale === 'az') {
                // There is a lower-case letter (Ä±), that converted to upper then
                // lower changes to i
                expect(0);
                return;
            }
            function tester(format) {
                var r, baseMsg = 'weekday ' + m.weekday() + ' fmt ' + format;
                r = moment(m.format(format), format);
                assert.equal(r.weekday(), m.weekday(), baseMsg);
                r = moment(m.format(format).toLocaleUpperCase(), format);
                assert.equal(r.weekday(), m.weekday(), baseMsg + ' upper');
                r = moment(m.format(format).toLocaleLowerCase(), format);
                assert.equal(r.weekday(), m.weekday(), baseMsg + ' lower');

                r = moment(m.format(format), format, true);
                assert.equal(r.weekday(), m.weekday(), baseMsg + ' strict');
                r = moment(m.format(format).toLocaleUpperCase(), format, true);
                assert.equal(r.weekday(), m.weekday(), baseMsg + ' upper strict');
                r = moment(m.format(format).toLocaleLowerCase(), format, true);
                assert.equal(r.weekday(), m.weekday(), baseMsg + ' lower strict');
            }

            for (i = 0; i < 7; ++i) {
                m = moment.utc([2015, i, 15, 18]);
                tester('dd');
                tester('ddd');
                tester('dddd');
            }
        });
    }

    function setupDeprecationHandler(test, moment, scope) {
        test._expectedDeprecations = null;
        test._observedDeprecations = null;
        test._oldSupress = moment.suppressDeprecationWarnings;
        moment.suppressDeprecationWarnings = true;
        test.expectedDeprecations = function () {
            test._expectedDeprecations = arguments;
            test._observedDeprecations = [];
        };
        moment.deprecationHandler = function (name, msg) {
            var deprecationId = matchedDeprecation(name, msg, test._expectedDeprecations);
            if (deprecationId === -1) {
                throw new Error('Unexpected deprecation thrown name=' +
                        name + ' msg=' + msg);
            }
            test._observedDeprecations[deprecationId] = 1;
        };
    }

    function teardownDeprecationHandler(test, moment, scope) {
        moment.suppressDeprecationWarnings = test._oldSupress;

        if (test._expectedDeprecations != null) {
            var missedDeprecations = [];
            each(test._expectedDeprecations, function (deprecationPattern, id) {
                if (test._observedDeprecations[id] !== 1) {
                    missedDeprecations.push(deprecationPattern);
                }
            });
            if (missedDeprecations.length !== 0) {
                throw new Error('Expected deprecation warnings did not happen: ' +
                        missedDeprecations.join(' '));
            }
        }
    }

    function matchedDeprecation(name, msg, deprecations) {
        if (deprecations == null) {
            return -1;
        }
        for (var i = 0; i < deprecations.length; ++i) {
            if (name != null && name === deprecations[i]) {
                return i;
            }
            if (msg != null && msg.substring(0, deprecations[i].length) === deprecations[i]) {
                return i;
            }
        }
        return -1;
    }

    /*global QUnit:false*/

    var test = QUnit.test;

    var expect = QUnit.expect;

    function module (name, lifecycle) {
        QUnit.module(name, {
            setup : function () {
                moment.locale('en');
                moment.createFromInputFallback = function (config) {
                    throw new Error('input not handled by moment: ' + config._i);
                };
                setupDeprecationHandler(test, moment, 'core');
                if (lifecycle && lifecycle.setup) {
                    lifecycle.setup();
                }
            },
            teardown : function () {
                teardownDeprecationHandler(test, moment, 'core');
                if (lifecycle && lifecycle.teardown) {
                    lifecycle.teardown();
                }
            }
        });
    }

    function localeModule (name, lifecycle) {
        QUnit.module('locale:' + name, {
            setup : function () {
                moment.locale(name);
                moment.createFromInputFallback = function (config) {
                    throw new Error('input not handled by moment: ' + config._i);
                };
                setupDeprecationHandler(test, moment, 'locale');
                if (lifecycle && lifecycle.setup) {
                    lifecycle.setup();
                }
            },
            teardown : function () {
                moment.locale('en');
                teardownDeprecationHandler(test, moment, 'locale');
                if (lifecycle && lifecycle.teardown) {
                    lifecycle.teardown();
                }
            }
        });
        defineCommonLocaleTests(name, -1, -1);
    }

    localeModule('fr-ca');

    test('parse', function (assert) {
        var i,
            tests = 'janvier janv._fÃ©vrier fÃ©vr._mars mars_avril avr._mai mai_juin juin_juillet juil._aoÃ»t aoÃ»t_septembre sept._octobre oct._novembre nov._dÃ©cembre dÃ©c.'.split('_');

        function equalTest(input, mmm, i) {
            assert.equal(moment(input, mmm).month(), i, input + ' should be month ' + (i + 1));
        }

        for (i = 0; i < 12; i++) {
            tests[i] = tests[i].split(' ');
            equalTest(tests[i][0], 'MMM', i);
            equalTest(tests[i][1], 'MMM', i);
            equalTest(tests[i][0], 'MMMM', i);
            equalTest(tests[i][1], 'MMMM', i);
            equalTest(tests[i][0].toLocaleLowerCase(), 'MMMM', i);
            equalTest(tests[i][1].toLocaleLowerCase(), 'MMMM', i);
            equalTest(tests[i][0].toLocaleUpperCase(), 'MMMM', i);
            equalTest(tests[i][1].toLocaleUpperCase(), 'MMMM', i);
        }
    });

    test('format', function (assert) {
        var a = [
                ['dddd, MMMM Do YYYY, h:mm:ss a',      'dimanche, fÃ©vrier 14e 2010, 3:25:50 pm'],
                ['ddd, hA',                            'dim., 3PM'],
                ['M Mo MM MMMM MMM',                   '2 2e 02 fÃ©vrier fÃ©vr.'],
                ['YYYY YY',                            '2010 10'],
                ['D Do DD',                            '14 14e 14'],
                ['d do dddd ddd dd',                   '0 0e dimanche dim. Di'],
                ['DDD DDDo DDDD',                      '45 45e 045'],
                ['w wo ww',                            '8 8e 08'],
                ['h hh',                               '3 03'],
                ['H HH',                               '15 15'],
                ['m mm',                               '25 25'],
                ['s ss',                               '50 50'],
                ['a A',                                'pm PM'],
                ['[the] DDDo [day of the year]',       'the 45e day of the year'],
                ['LTS',                                '15:25:50'],
                ['L',                                  '2010-02-14'],
                ['LL',                                 '14 fÃ©vrier 2010'],
                ['LLL',                                '14 fÃ©vrier 2010 15:25'],
                ['LLLL',                               'dimanche 14 fÃ©vrier 2010 15:25'],
                ['l',                                  '2010-2-14'],
                ['ll',                                 '14 fÃ©vr. 2010'],
                ['lll',                                '14 fÃ©vr. 2010 15:25'],
                ['llll',                               'dim. 14 fÃ©vr. 2010 15:25']
            ],
            b = moment(new Date(2010, 1, 14, 15, 25, 50, 125)),
            i;

        for (i = 0; i < a.length; i++) {
            assert.equal(b.format(a[i][0]), a[i][1], a[i][0] + ' ---> ' + a[i][1]);
        }
    });

    test('format ordinal', function (assert) {
        assert.equal(moment([2011, 0, 1]).format('DDDo'), '1er', '1er');
        assert.equal(moment([2011, 0, 2]).format('DDDo'), '2e', '2e');
        assert.equal(moment([2011, 0, 3]).format('DDDo'), '3e', '3e');
        assert.equal(moment([2011, 0, 4]).format('DDDo'), '4e', '4e');
        assert.equal(moment([2011, 0, 5]).format('DDDo'), '5e', '5e');
        assert.equal(moment([2011, 0, 6]).format('DDDo'), '6e', '6e');
        assert.equal(moment([2011, 0, 7]).format('DDDo'), '7e', '7e');
        assert.equal(moment([2011, 0, 8]).format('DDDo'), '8e', '8e');
        assert.equal(moment([2011, 0, 9]).format('DDDo'), '9e', '9e');
        assert.equal(moment([2011, 0, 10]).format('DDDo'), '10e', '10e');

        assert.equal(moment([2011, 0, 11]).format('DDDo'), '11e', '11e');
        assert.equal(moment([2011, 0, 12]).format('DDDo'), '12e', '12e');
        assert.equal(moment([2011, 0, 13]).format('DDDo'), '13e', '13e');
        assert.equal(moment([2011, 0, 14]).format('DDDo'), '14e', '14e');
        assert.equal(moment([2011, 0, 15]).format('DDDo'), '15e', '15e');
        assert.equal(moment([2011, 0, 16]).format('DDDo'), '16e', '16e');
        assert.equal(moment([2011, 0, 17]).format('DDDo'), '17e', '17e');
        assert.equal(moment([2011, 0, 18]).format('DDDo'), '18e', '18e');
        assert.equal(moment([2011, 0, 19]).format('DDDo'), '19e', '19e');
        assert.equal(moment([2011, 0, 20]).format('DDDo'), '20e', '20e');

        assert.equal(moment([2011, 0, 21]).format('DDDo'), '21e', '21e');
        assert.equal(moment([2011, 0, 22]).format('DDDo'), '22e', '22e');
        assert.equal(moment([2011, 0, 23]).format('DDDo'), '23e', '23e');
        assert.equal(moment([2011, 0, 24]).format('DDDo'), '24e', '24e');
        assert.equal(moment([2011, 0, 25]).format('DDDo'), '25e', '25e');
        assert.equal(moment([2011, 0, 26]).format('DDDo'), '26e', '26e');
        assert.equal(moment([2011, 0, 27]).format('DDDo'), '27e', '27e');
        assert.equal(moment([2011, 0, 28]).format('DDDo'), '28e', '28e');
        assert.equal(moment([2011, 0, 29]).format('DDDo'), '29e', '29e');
        assert.equal(moment([2011, 0, 30]).format('DDDo'), '30e', '30e');

        assert.equal(moment([2011, 0, 31]).format('DDDo'), '31e', '31e');
    });

    test('format month', function (assert) {
        var i,
            expected = 'janvier janv._fÃ©vrier fÃ©vr._mars mars_avril avr._mai mai_juin juin_juillet juil._aoÃ»t aoÃ»t_septembre sept._octobre oct._novembre nov._dÃ©cembre dÃ©c.'.split('_');

        for (i = 0; i < expected.length; i++) {
            assert.equal(moment([2011, i, 1]).format('MMMM MMM'), expected[i], expected[i]);
        }
    });

    test('format week', function (assert) {
        var i,
            expected = 'dimanche dim. Di_lundi lun. Lu_mardi mar. Ma_mercredi mer. Me_jeudi jeu. Je_vendredi ven. Ve_samedi sam. Sa'.split('_');

        for (i = 0; i < expected.length; i++) {
            assert.equal(moment([2011, 0, 2 + i]).format('dddd ddd dd'), expected[i], expected[i]);
        }
    });

    test('from', function (assert) {
        var start = moment([2007, 1, 28]);

        assert.equal(start.from(moment([2007, 1, 28]).add({s: 44}), true),  'quelques secondes', '44 seconds = a few seconds');
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 45}), true),  'une minute',   '45 seconds = a minute');
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 89}), true),  'une minute',   '89 seconds = a minute');
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 90}), true),  '2 minutes',  '90 seconds = 2 minutes');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 44}), true),  '44 minutes', '44 minutes = 44 minutes');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 45}), true),  'une heure',    '45 minutes = an hour');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 89}), true),  'une heure',    '89 minutes = an hour');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 90}), true),  '2 heures',    '90 minutes = 2 hours');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 5}), true),   '5 heures',    '5 hours = 5 hours');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 21}), true),  '21 heures',   '21 hours = 21 hours');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 22}), true),  'un jour',      '22 hours = a day');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 35}), true),  'un jour',      '35 hours = a day');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 36}), true),  '2 jours',     '36 hours = 2 days');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 1}), true),   'un jour',      '1 day = a day');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 5}), true),   '5 jours',     '5 days = 5 days');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 25}), true),  '25 jours',    '25 days = 25 days');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 26}), true),  'un mois',    '26 days = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 30}), true),  'un mois',    '30 days = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 43}), true),  'un mois',    '43 days = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 46}), true),  '2 mois',   '46 days = 2 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 74}), true),  '2 mois',   '75 days = 2 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 76}), true),  '3 mois',   '76 days = 3 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({M: 1}), true),   'un mois',    '1 month = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({M: 5}), true),   '5 mois',   '5 months = 5 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 345}), true), 'un an',     '345 days = a year');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 548}), true), '2 ans',    '548 days = 2 years');
        assert.equal(start.from(moment([2007, 1, 28]).add({y: 1}), true),   'un an',     '1 year = a year');
        assert.equal(start.from(moment([2007, 1, 28]).add({y: 5}), true),   '5 ans',    '5 years = 5 years');
    });

    test('suffix', function (assert) {
        assert.equal(moment(30000).from(0), 'dans quelques secondes', 'prefix');
        assert.equal(moment(0).from(30000), 'il y a quelques secondes', 'suffix');
    });

    test('fromNow', function (assert) {
        assert.equal(moment().add({s: 30}).fromNow(), 'dans quelques secondes', 'in a few seconds');
        assert.equal(moment().add({d: 5}).fromNow(), 'dans 5 jours', 'in 5 days');
    });

    test('same day', function (assert) {
        var a = moment().hours(12).minutes(0).seconds(0);

        assert.equal(moment(a).calendar(),                   'Aujourd\'hui Ã  12:00',    'today at the same time');
        assert.equal(moment(a).add({m: 25}).calendar(),      'Aujourd\'hui Ã  12:25',    'Now plus 25 min');
        assert.equal(moment(a).add({h: 1}).calendar(),       'Aujourd\'hui Ã  13:00',    'Now plus 1 hour');
        assert.equal(moment(a).add({d: 1}).calendar(),       'Demain Ã  12:00',          'tomorrow at the same time');
        assert.equal(moment(a).subtract({h: 1}).calendar(),  'Aujourd\'hui Ã  11:00',    'Now minus 1 hour');
        assert.equal(moment(a).subtract({d: 1}).calendar(),  'Hier Ã  12:00',            'yesterday at the same time');
    });

    test('same next week', function (assert) {
        var i, m;

        for (i = 2; i < 7; i++) {
            m = moment().add({d: i});
            assert.equal(m.calendar(),       m.format('dddd [Ã ] LT'),  'Today + ' + i + ' days current time');
            m.hours(0).minutes(0).seconds(0).milliseconds(0);
            assert.equal(m.calendar(),       m.format('dddd [Ã ] LT'),  'Today + ' + i + ' days beginning of day');
            m.hours(23).minutes(59).seconds(59).milliseconds(999);
            assert.equal(m.calendar(),       m.format('dddd [Ã ] LT'),  'Today + ' + i + ' days end of day');
        }
    });

    test('same last week', function (assert) {
        var i, m;

        for (i = 2; i < 7; i++) {
            m = moment().subtract({d: i});
            assert.equal(m.calendar(),       m.format('dddd [dernier Ã ] LT'),  'Today - ' + i + ' days current time');
            m.hours(0).minutes(0).seconds(0).milliseconds(0);
            assert.equal(m.calendar(),       m.format('dddd [dernier Ã ] LT'),  'Today - ' + i + ' days beginning of day');
            m.hours(23).minutes(59).seconds(59).milliseconds(999);
            assert.equal(m.calendar(),       m.format('dddd [dernier Ã ] LT'),  'Today - ' + i + ' days end of day');
        }
    });

    test('same all else', function (assert) {
        var weeksAgo = moment().subtract({w: 1}),
            weeksFromNow = moment().add({w: 1});

        assert.equal(weeksAgo.calendar(),       weeksAgo.format('L'),  '1 week ago');
        assert.equal(weeksFromNow.calendar(),   weeksFromNow.format('L'),  'in 1 week');

        weeksAgo = moment().subtract({w: 2});
        weeksFromNow = moment().add({w: 2});

        assert.equal(weeksAgo.calendar(),       weeksAgo.format('L'),  '2 weeks ago');
        assert.equal(weeksFromNow.calendar(),   weeksFromNow.format('L'),  'in 2 weeks');
    });

    test('weeks year starting sunday format', function (assert) {
        assert.equal(moment([2012, 0,  1]).format('w ww wo'), '1 01 1er', 'Jan  1 2012 should be week 1');
        assert.equal(moment([2012, 0,  7]).format('w ww wo'), '1 01 1er', 'Jan  7 2012 should be week 1');
        assert.equal(moment([2012, 0,  8]).format('w ww wo'), '2 02 2e', 'Jan  8 2012 should be week 2');
        assert.equal(moment([2012, 0, 14]).format('w ww wo'), '2 02 2e', 'Jan 14 2012 should be week 2');
        assert.equal(moment([2012, 0, 15]).format('w ww wo'), '3 03 3e', 'Jan 15 2012 should be week 3');
    });

}));

;(function (global, factory) {
   typeof exports === 'object' && typeof module !== 'undefined'
       && typeof require === 'function' ? factory(require('../../moment')) :
   typeof define === 'function' && define.amd ? define(['../../moment'], factory) :
   factory(global.moment)
}(this, function (moment) { 'use strict';

    function each(array, callback) {
        var i;
        for (i = 0; i < array.length; i++) {
            callback(array[i], i, array);
        }
    }

    function objectKeys(obj) {
        if (Object.keys) {
            return Object.keys(obj);
        } else {
            // IE8
            var res = [], i;
            for (i in obj) {
                if (obj.hasOwnProperty(i)) {
                    res.push(i);
                }
            }
            return res;
        }
    }

    // Pick the first defined of two or three arguments.
    function defaults(a, b, c) {
        if (a != null) {
            return a;
        }
        if (b != null) {
            return b;
        }
        return c;
    }

    function defineCommonLocaleTests(locale, options) {
        test('lenient ordinal parsing', function (assert) {
            var i, ordinalStr, testMoment;
            for (i = 1; i <= 31; ++i) {
                ordinalStr = moment([2014, 0, i]).format('YYYY MM Do');
                testMoment = moment(ordinalStr, 'YYYY MM Do');
                assert.equal(testMoment.year(), 2014,
                        'lenient ordinal parsing ' + i + ' year check');
                assert.equal(testMoment.month(), 0,
                        'lenient ordinal parsing ' + i + ' month check');
                assert.equal(testMoment.date(), i,
                        'lenient ordinal parsing ' + i + ' date check');
            }
        });

        test('lenient ordinal parsing of number', function (assert) {
            var i, testMoment;
            for (i = 1; i <= 31; ++i) {
                testMoment = moment('2014 01 ' + i, 'YYYY MM Do');
                assert.equal(testMoment.year(), 2014,
                        'lenient ordinal parsing of number ' + i + ' year check');
                assert.equal(testMoment.month(), 0,
                        'lenient ordinal parsing of number ' + i + ' month check');
                assert.equal(testMoment.date(), i,
                        'lenient ordinal parsing of number ' + i + ' date check');
            }
        });

        test('strict ordinal parsing', function (assert) {
            var i, ordinalStr, testMoment;
            for (i = 1; i <= 31; ++i) {
                ordinalStr = moment([2014, 0, i]).format('YYYY MM Do');
                testMoment = moment(ordinalStr, 'YYYY MM Do', true);
                assert.ok(testMoment.isValid(), 'strict ordinal parsing ' + i);
            }
        });

        test('meridiem invariant', function (assert) {
            var h, m, t1, t2;
            for (h = 0; h < 24; ++h) {
                for (m = 0; m < 60; m += 15) {
                    t1 = moment.utc([2000, 0, 1, h, m]);
                    t2 = moment.utc(t1.format('A h:mm'), 'A h:mm');
                    assert.equal(t2.format('HH:mm'), t1.format('HH:mm'),
                            'meridiem at ' + t1.format('HH:mm'));
                }
            }
        });

        test('date format correctness', function (assert) {
            var data, tokens;
            data = moment.localeData()._longDateFormat;
            tokens = objectKeys(data);
            each(tokens, function (srchToken) {
                // Check each format string to make sure it does not contain any
                // tokens that need to be expanded.
                each(tokens, function (baseToken) {
                    // strip escaped sequences
                    var format = data[baseToken].replace(/(\[[^\]]*\])/g, '');
                    assert.equal(false, !!~format.indexOf(srchToken),
                            'contains ' + srchToken + ' in ' + baseToken);
                });
            });
        });

        test('month parsing correctness', function (assert) {
            var i, m;

            if (locale === 'tr') {
                // I can't fix it :(
                expect(0);
                return;
            }
            function tester(format) {
                var r;
                r = moment(m.format(format), format);
                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format);
                r = moment(m.format(format).toLocaleUpperCase(), format);
                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' upper');
                r = moment(m.format(format).toLocaleLowerCase(), format);
                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' lower');

                r = moment(m.format(format), format, true);
                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' strict');
                r = moment(m.format(format).toLocaleUpperCase(), format, true);
                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' upper strict');
                r = moment(m.format(format).toLocaleLowerCase(), format, true);
                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' lower strict');
            }

            for (i = 0; i < 12; ++i) {
                m = moment([2015, i, 15, 18]);
                tester('MMM');
                tester('MMM.');
                tester('MMMM');
                tester('MMMM.');
            }
        });

        test('weekday parsing correctness', function (assert) {
            var i, m;

            if (locale === 'tr' || locale === 'az') {
                // There is a lower-case letter (Ä±), that converted to upper then
                // lower changes to i
                expect(0);
                return;
            }
            function tester(format) {
                var r, baseMsg = 'weekday ' + m.weekday() + ' fmt ' + format;
                r = moment(m.format(format), format);
                assert.equal(r.weekday(), m.weekday(), baseMsg);
                r = moment(m.format(format).toLocaleUpperCase(), format);
                assert.equal(r.weekday(), m.weekday(), baseMsg + ' upper');
                r = moment(m.format(format).toLocaleLowerCase(), format);
                assert.equal(r.weekday(), m.weekday(), baseMsg + ' lower');

                r = moment(m.format(format), format, true);
                assert.equal(r.weekday(), m.weekday(), baseMsg + ' strict');
                r = moment(m.format(format).toLocaleUpperCase(), format, true);
                assert.equal(r.weekday(), m.weekday(), baseMsg + ' upper strict');
                r = moment(m.format(format).toLocaleLowerCase(), format, true);
                assert.equal(r.weekday(), m.weekday(), baseMsg + ' lower strict');
            }

            for (i = 0; i < 7; ++i) {
                m = moment.utc([2015, i, 15, 18]);
                tester('dd');
                tester('ddd');
                tester('dddd');
            }
        });
    }

    function setupDeprecationHandler(test, moment, scope) {
        test._expectedDeprecations = null;
        test._observedDeprecations = null;
        test._oldSupress = moment.suppressDeprecationWarnings;
        moment.suppressDeprecationWarnings = true;
        test.expectedDeprecations = function () {
            test._expectedDeprecations = arguments;
            test._observedDeprecations = [];
        };
        moment.deprecationHandler = function (name, msg) {
            var deprecationId = matchedDeprecation(name, msg, test._expectedDeprecations);
            if (deprecationId === -1) {
                throw new Error('Unexpected deprecation thrown name=' +
                        name + ' msg=' + msg);
            }
            test._observedDeprecations[deprecationId] = 1;
        };
    }

    function teardownDeprecationHandler(test, moment, scope) {
        moment.suppressDeprecationWarnings = test._oldSupress;

        if (test._expectedDeprecations != null) {
            var missedDeprecations = [];
            each(test._expectedDeprecations, function (deprecationPattern, id) {
                if (test._observedDeprecations[id] !== 1) {
                    missedDeprecations.push(deprecationPattern);
                }
            });
            if (missedDeprecations.length !== 0) {
                throw new Error('Expected deprecation warnings did not happen: ' +
                        missedDeprecations.join(' '));
            }
        }
    }

    function matchedDeprecation(name, msg, deprecations) {
        if (deprecations == null) {
            return -1;
        }
        for (var i = 0; i < deprecations.length; ++i) {
            if (name != null && name === deprecations[i]) {
                return i;
            }
            if (msg != null && msg.substring(0, deprecations[i].length) === deprecations[i]) {
                return i;
            }
        }
        return -1;
    }

    /*global QUnit:false*/

    var test = QUnit.test;

    var expect = QUnit.expect;

    function module (name, lifecycle) {
        QUnit.module(name, {
            setup : function () {
                moment.locale('en');
                moment.createFromInputFallback = function (config) {
                    throw new Error('input not handled by moment: ' + config._i);
                };
                setupDeprecationHandler(test, moment, 'core');
                if (lifecycle && lifecycle.setup) {
                    lifecycle.setup();
                }
            },
            teardown : function () {
                teardownDeprecationHandler(test, moment, 'core');
                if (lifecycle && lifecycle.teardown) {
                    lifecycle.teardown();
                }
            }
        });
    }

    function localeModule (name, lifecycle) {
        QUnit.module('locale:' + name, {
            setup : function () {
                moment.locale(name);
                moment.createFromInputFallback = function (config) {
                    throw new Error('input not handled by moment: ' + config._i);
                };
                setupDeprecationHandler(test, moment, 'locale');
                if (lifecycle && lifecycle.setup) {
                    lifecycle.setup();
                }
            },
            teardown : function () {
                moment.locale('en');
                teardownDeprecationHandler(test, moment, 'locale');
                if (lifecycle && lifecycle.teardown) {
                    lifecycle.teardown();
                }
            }
        });
        defineCommonLocaleTests(name, -1, -1);
    }

    localeModule('fr-ch');

    test('parse', function (assert) {
        var i,
            tests = 'janvier janv._fÃ©vrier fÃ©vr._mars mars_avril avr._mai mai_juin juin_juillet juil._aoÃ»t aoÃ»t_septembre sept._octobre oct._novembre nov._dÃ©cembre dÃ©c.'.split('_');

        function equalTest(input, mmm, i) {
            assert.equal(moment(input, mmm).month(), i, input + ' should be month ' + (i + 1));
        }

        for (i = 0; i < 12; i++) {
            tests[i] = tests[i].split(' ');
            equalTest(tests[i][0], 'MMM', i);
            equalTest(tests[i][1], 'MMM', i);
            equalTest(tests[i][0], 'MMMM', i);
            equalTest(tests[i][1], 'MMMM', i);
            equalTest(tests[i][0].toLocaleLowerCase(), 'MMMM', i);
            equalTest(tests[i][1].toLocaleLowerCase(), 'MMMM', i);
            equalTest(tests[i][0].toLocaleUpperCase(), 'MMMM', i);
            equalTest(tests[i][1].toLocaleUpperCase(), 'MMMM', i);
        }
    });

    test('format', function (assert) {
        var a = [
                ['dddd, MMMM Do YYYY, h:mm:ss a',      'dimanche, fÃ©vrier 14e 2010, 3:25:50 pm'],
                ['ddd, hA',                            'dim., 3PM'],
                ['M Mo MM MMMM MMM',                   '2 2e 02 fÃ©vrier fÃ©vr.'],
                ['YYYY YY',                            '2010 10'],
                ['D Do DD',                            '14 14e 14'],
                ['d do dddd ddd dd',                   '0 0e dimanche dim. Di'],
                ['DDD DDDo DDDD',                      '45 45e 045'],
                ['w wo ww',                            '6 6e 06'],
                ['h hh',                               '3 03'],
                ['H HH',                               '15 15'],
                ['m mm',                               '25 25'],
                ['s ss',                               '50 50'],
                ['a A',                                'pm PM'],
                ['[the] DDDo [day of the year]',       'the 45e day of the year'],
                ['LTS',                                '15:25:50'],
                ['L',                                  '14.02.2010'],
                ['LL',                                 '14 fÃ©vrier 2010'],
                ['LLL',                                '14 fÃ©vrier 2010 15:25'],
                ['LLLL',                               'dimanche 14 fÃ©vrier 2010 15:25'],
                ['l',                                  '14.2.2010'],
                ['ll',                                 '14 fÃ©vr. 2010'],
                ['lll',                                '14 fÃ©vr. 2010 15:25'],
                ['llll',                               'dim. 14 fÃ©vr. 2010 15:25']
            ],
            b = moment(new Date(2010, 1, 14, 15, 25, 50, 125)),
            i;

        for (i = 0; i < a.length; i++) {
            assert.equal(b.format(a[i][0]), a[i][1], a[i][0] + ' ---> ' + a[i][1]);
        }
    });

    test('format ordinal', function (assert) {
        assert.equal(moment([2011, 0, 1]).format('DDDo'), '1er', '1er');
        assert.equal(moment([2011, 0, 2]).format('DDDo'), '2e', '2e');
        assert.equal(moment([2011, 0, 3]).format('DDDo'), '3e', '3e');
        assert.equal(moment([2011, 0, 4]).format('DDDo'), '4e', '4e');
        assert.equal(moment([2011, 0, 5]).format('DDDo'), '5e', '5e');
        assert.equal(moment([2011, 0, 6]).format('DDDo'), '6e', '6e');
        assert.equal(moment([2011, 0, 7]).format('DDDo'), '7e', '7e');
        assert.equal(moment([2011, 0, 8]).format('DDDo'), '8e', '8e');
        assert.equal(moment([2011, 0, 9]).format('DDDo'), '9e', '9e');
        assert.equal(moment([2011, 0, 10]).format('DDDo'), '10e', '10e');

        assert.equal(moment([2011, 0, 11]).format('DDDo'), '11e', '11e');
        assert.equal(moment([2011, 0, 12]).format('DDDo'), '12e', '12e');
        assert.equal(moment([2011, 0, 13]).format('DDDo'), '13e', '13e');
        assert.equal(moment([2011, 0, 14]).format('DDDo'), '14e', '14e');
        assert.equal(moment([2011, 0, 15]).format('DDDo'), '15e', '15e');
        assert.equal(moment([2011, 0, 16]).format('DDDo'), '16e', '16e');
        assert.equal(moment([2011, 0, 17]).format('DDDo'), '17e', '17e');
        assert.equal(moment([2011, 0, 18]).format('DDDo'), '18e', '18e');
        assert.equal(moment([2011, 0, 19]).format('DDDo'), '19e', '19e');
        assert.equal(moment([2011, 0, 20]).format('DDDo'), '20e', '20e');

        assert.equal(moment([2011, 0, 21]).format('DDDo'), '21e', '21e');
        assert.equal(moment([2011, 0, 22]).format('DDDo'), '22e', '22e');
        assert.equal(moment([2011, 0, 23]).format('DDDo'), '23e', '23e');
        assert.equal(moment([2011, 0, 24]).format('DDDo'), '24e', '24e');
        assert.equal(moment([2011, 0, 25]).format('DDDo'), '25e', '25e');
        assert.equal(moment([2011, 0, 26]).format('DDDo'), '26e', '26e');
        assert.equal(moment([2011, 0, 27]).format('DDDo'), '27e', '27e');
        assert.equal(moment([2011, 0, 28]).format('DDDo'), '28e', '28e');
        assert.equal(moment([2011, 0, 29]).format('DDDo'), '29e', '29e');
        assert.equal(moment([2011, 0, 30]).format('DDDo'), '30e', '30e');

        assert.equal(moment([2011, 0, 31]).format('DDDo'), '31e', '31e');
    });

    test('format month', function (assert) {
        var i,
            expected = 'janvier janv._fÃ©vrier fÃ©vr._mars mars_avril avr._mai mai_juin juin_juillet juil._aoÃ»t aoÃ»t_septembre sept._octobre oct._novembre nov._dÃ©cembre dÃ©c.'.split('_');

        for (i = 0; i < expected.length; i++) {
            assert.equal(moment([2011, i, 1]).format('MMMM MMM'), expected[i], expected[i]);
        }
    });

    test('format week', function (assert) {
        var i,
            expected = 'dimanche dim. Di_lundi lun. Lu_mardi mar. Ma_mercredi mer. Me_jeudi jeu. Je_vendredi ven. Ve_samedi sam. Sa'.split('_');

        for (i = 0; i < expected.length; i++) {
            assert.equal(moment([2011, 0, 2 + i]).format('dddd ddd dd'), expected[i], expected[i]);
        }
    });

    test('from', function (assert) {
        var start = moment([2007, 1, 28]);

        assert.equal(start.from(moment([2007, 1, 28]).add({s: 44}), true),  'quelques secondes', '44 seconds = a few seconds');
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 45}), true),  'une minute',   '45 seconds = a minute');
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 89}), true),  'une minute',   '89 seconds = a minute');
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 90}), true),  '2 minutes',  '90 seconds = 2 minutes');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 44}), true),  '44 minutes', '44 minutes = 44 minutes');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 45}), true),  'une heure',    '45 minutes = an hour');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 89}), true),  'une heure',    '89 minutes = an hour');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 90}), true),  '2 heures',    '90 minutes = 2 hours');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 5}), true),   '5 heures',    '5 hours = 5 hours');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 21}), true),  '21 heures',   '21 hours = 21 hours');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 22}), true),  'un jour',      '22 hours = a day');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 35}), true),  'un jour',      '35 hours = a day');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 36}), true),  '2 jours',     '36 hours = 2 days');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 1}), true),   'un jour',      '1 day = a day');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 5}), true),   '5 jours',     '5 days = 5 days');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 25}), true),  '25 jours',    '25 days = 25 days');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 26}), true),  'un mois',    '26 days = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 30}), true),  'un mois',    '30 days = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 43}), true),  'un mois',    '43 days = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 46}), true),  '2 mois',   '46 days = 2 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 74}), true),  '2 mois',   '75 days = 2 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 76}), true),  '3 mois',   '76 days = 3 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({M: 1}), true),   'un mois',    '1 month = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({M: 5}), true),   '5 mois',   '5 months = 5 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 345}), true), 'un an',     '345 days = a year');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 548}), true), '2 ans',    '548 days = 2 years');
        assert.equal(start.from(moment([2007, 1, 28]).add({y: 1}), true),   'un an',     '1 year = a year');
        assert.equal(start.from(moment([2007, 1, 28]).add({y: 5}), true),   '5 ans',    '5 years = 5 years');
    });

    test('suffix', function (assert) {
        assert.equal(moment(30000).from(0), 'dans quelques secondes', 'prefix');
        assert.equal(moment(0).from(30000), 'il y a quelques secondes', 'suffix');
    });

    test('fromNow', function (assert) {
        assert.equal(moment().add({s: 30}).fromNow(), 'dans quelques secondes', 'in a few seconds');
        assert.equal(moment().add({d: 5}).fromNow(), 'dans 5 jours', 'in 5 days');
    });

    test('same day', function (assert) {
        var a = moment().hours(12).minutes(0).seconds(0);

        assert.equal(moment(a).calendar(),                   'Aujourd\'hui Ã  12:00',    'today at the same time');
        assert.equal(moment(a).add({m: 25}).calendar(),      'Aujourd\'hui Ã  12:25',    'Now plus 25 min');
        assert.equal(moment(a).add({h: 1}).calendar(),       'Aujourd\'hui Ã  13:00',    'Now plus 1 hour');
        assert.equal(moment(a).add({d: 1}).calendar(),       'Demain Ã  12:00',          'tomorrow at the same time');
        assert.equal(moment(a).subtract({h: 1}).calendar(),  'Aujourd\'hui Ã  11:00',    'Now minus 1 hour');
        assert.equal(moment(a).subtract({d: 1}).calendar(),  'Hier Ã  12:00',            'yesterday at the same time');
    });

    test('same next week', function (assert) {
        var i, m;

        for (i = 2; i < 7; i++) {
            m = moment().add({d: i});
            assert.equal(m.calendar(),       m.format('dddd [Ã ] LT'),  'Today + ' + i + ' days current time');
            m.hours(0).minutes(0).seconds(0).milliseconds(0);
            assert.equal(m.calendar(),       m.format('dddd [Ã ] LT'),  'Today + ' + i + ' days beginning of day');
            m.hours(23).minutes(59).seconds(59).milliseconds(999);
            assert.equal(m.calendar(),       m.format('dddd [Ã ] LT'),  'Today + ' + i + ' days end of day');
        }
    });

    test('same last week', function (assert) {
        var i, m;

        for (i = 2; i < 7; i++) {
            m = moment().subtract({d: i});
            assert.equal(m.calendar(),       m.format('dddd [dernier Ã ] LT'),  'Today - ' + i + ' days current time');
            m.hours(0).minutes(0).seconds(0).milliseconds(0);
            assert.equal(m.calendar(),       m.format('dddd [dernier Ã ] LT'),  'Today - ' + i + ' days beginning of day');
            m.hours(23).minutes(59).seconds(59).milliseconds(999);
            assert.equal(m.calendar(),       m.format('dddd [dernier Ã ] LT'),  'Today - ' + i + ' days end of day');
        }
    });

    test('same all else', function (assert) {
        var weeksAgo = moment().subtract({w: 1}),
            weeksFromNow = moment().add({w: 1});

        assert.equal(weeksAgo.calendar(),       weeksAgo.format('L'),  '1 week ago');
        assert.equal(weeksFromNow.calendar(),   weeksFromNow.format('L'),  'in 1 week');

        weeksAgo = moment().subtract({w: 2});
        weeksFromNow = moment().add({w: 2});

        assert.equal(weeksAgo.calendar(),       weeksAgo.format('L'),  '2 weeks ago');
        assert.equal(weeksFromNow.calendar(),   weeksFromNow.format('L'),  'in 2 weeks');
    });

    test('weeks year starting sunday formatted', function (assert) {
        assert.equal(moment([2012, 0,  1]).format('w ww wo'), '52 52 52e', 'Jan  1 2012 should be week 52');
        assert.equal(moment([2012, 0,  2]).format('w ww wo'), '1 01 1er', 'Jan  2 2012 should be week 1');
        assert.equal(moment([2012, 0,  8]).format('w ww wo'), '1 01 1er', 'Jan  8 2012 should be week 1');
        assert.equal(moment([2012, 0,  9]).format('w ww wo'),   '2 02 2e', 'Jan  9 2012 should be week 2');
        assert.equal(moment([2012, 0, 15]).format('w ww wo'),   '2 02 2e', 'Jan 15 2012 should be week 2');
    });

}));

;(function (global, factory) {
   typeof exports === 'object' && typeof module !== 'undefined'
       && typeof require === 'function' ? factory(require('../../moment')) :
   typeof define === 'function' && define.amd ? define(['../../moment'], factory) :
   factory(global.moment)
}(this, function (moment) { 'use strict';

    function each(array, callback) {
        var i;
        for (i = 0; i < array.length; i++) {
            callback(array[i], i, array);
        }
    }

    function objectKeys(obj) {
        if (Object.keys) {
            return Object.keys(obj);
        } else {
            // IE8
            var res = [], i;
            for (i in obj) {
                if (obj.hasOwnProperty(i)) {
                    res.push(i);
                }
            }
            return res;
        }
    }

    // Pick the first defined of two or three arguments.
    function defaults(a, b, c) {
        if (a != null) {
            return a;
        }
        if (b != null) {
            return b;
        }
        return c;
    }

    function defineCommonLocaleTests(locale, options) {
        test('lenient ordinal parsing', function (assert) {
            var i, ordinalStr, testMoment;
            for (i = 1; i <= 31; ++i) {
                ordinalStr = moment([2014, 0, i]).format('YYYY MM Do');
                testMoment = moment(ordinalStr, 'YYYY MM Do');
                assert.equal(testMoment.year(), 2014,
                        'lenient ordinal parsing ' + i + ' year check');
                assert.equal(testMoment.month(), 0,
                        'lenient ordinal parsing ' + i + ' month check');
                assert.equal(testMoment.date(), i,
                        'lenient ordinal parsing ' + i + ' date check');
            }
        });

        test('lenient ordinal parsing of number', function (assert) {
            var i, testMoment;
            for (i = 1; i <= 31; ++i) {
                testMoment = moment('2014 01 ' + i, 'YYYY MM Do');
                assert.equal(testMoment.year(), 2014,
                        'lenient ordinal parsing of number ' + i + ' year check');
                assert.equal(testMoment.month(), 0,
                        'lenient ordinal parsing of number ' + i + ' month check');
                assert.equal(testMoment.date(), i,
                        'lenient ordinal parsing of number ' + i + ' date check');
            }
        });

        test('strict ordinal parsing', function (assert) {
            var i, ordinalStr, testMoment;
            for (i = 1; i <= 31; ++i) {
                ordinalStr = moment([2014, 0, i]).format('YYYY MM Do');
                testMoment = moment(ordinalStr, 'YYYY MM Do', true);
                assert.ok(testMoment.isValid(), 'strict ordinal parsing ' + i);
            }
        });

        test('meridiem invariant', function (assert) {
            var h, m, t1, t2;
            for (h = 0; h < 24; ++h) {
                for (m = 0; m < 60; m += 15) {
                    t1 = moment.utc([2000, 0, 1, h, m]);
                    t2 = moment.utc(t1.format('A h:mm'), 'A h:mm');
                    assert.equal(t2.format('HH:mm'), t1.format('HH:mm'),
                            'meridiem at ' + t1.format('HH:mm'));
                }
            }
        });

        test('date format correctness', function (assert) {
            var data, tokens;
            data = moment.localeData()._longDateFormat;
            tokens = objectKeys(data);
            each(tokens, function (srchToken) {
                // Check each format string to make sure it does not contain any
                // tokens that need to be expanded.
                each(tokens, function (baseToken) {
                    // strip escaped sequences
                    var format = data[baseToken].replace(/(\[[^\]]*\])/g, '');
                    assert.equal(false, !!~format.indexOf(srchToken),
                            'contains ' + srchToken + ' in ' + baseToken);
                });
            });
        });

        test('month parsing correctness', function (assert) {
            var i, m;

            if (locale === 'tr') {
                // I can't fix it :(
                expect(0);
                return;
            }
            function tester(format) {
                var r;
                r = moment(m.format(format), format);
                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format);
                r = moment(m.format(format).toLocaleUpperCase(), format);
                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' upper');
                r = moment(m.format(format).toLocaleLowerCase(), format);
                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' lower');

                r = moment(m.format(format), format, true);
                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' strict');
                r = moment(m.format(format).toLocaleUpperCase(), format, true);
                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' upper strict');
                r = moment(m.format(format).toLocaleLowerCase(), format, true);
                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' lower strict');
            }

            for (i = 0; i < 12; ++i) {
                m = moment([2015, i, 15, 18]);
                tester('MMM');
                tester('MMM.');
                tester('MMMM');
                tester('MMMM.');
            }
        });

        test('weekday parsing correctness', function (assert) {
            var i, m;

            if (locale === 'tr' || locale === 'az') {
                // There is a lower-case letter (Ä±), that converted to upper then
                // lower changes to i
                expect(0);
                return;
            }
            function tester(format) {
                var r, baseMsg = 'weekday ' + m.weekday() + ' fmt ' + format;
                r = moment(m.format(format), format);
                assert.equal(r.weekday(), m.weekday(), baseMsg);
                r = moment(m.format(format).toLocaleUpperCase(), format);
                assert.equal(r.weekday(), m.weekday(), baseMsg + ' upper');
                r = moment(m.format(format).toLocaleLowerCase(), format);
                assert.equal(r.weekday(), m.weekday(), baseMsg + ' lower');

                r = moment(m.format(format), format, true);
                assert.equal(r.weekday(), m.weekday(), baseMsg + ' strict');
                r = moment(m.format(format).toLocaleUpperCase(), format, true);
                assert.equal(r.weekday(), m.weekday(), baseMsg + ' upper strict');
                r = moment(m.format(format).toLocaleLowerCase(), format, true);
                assert.equal(r.weekday(), m.weekday(), baseMsg + ' lower strict');
            }

            for (i = 0; i < 7; ++i) {
                m = moment.utc([2015, i, 15, 18]);
                tester('dd');
                tester('ddd');
                tester('dddd');
            }
        });
    }

    function setupDeprecationHandler(test, moment, scope) {
        test._expectedDeprecations = null;
        test._observedDeprecations = null;
        test._oldSupress = moment.suppressDeprecationWarnings;
        moment.suppressDeprecationWarnings = true;
        test.expectedDeprecations = function () {
            test._expectedDeprecations = arguments;
            test._observedDeprecations = [];
        };
        moment.deprecationHandler = function (name, msg) {
            var deprecationId = matchedDeprecation(name, msg, test._expectedDeprecations);
            if (deprecationId === -1) {
                throw new Error('Unexpected deprecation thrown name=' +
                        name + ' msg=' + msg);
            }
            test._observedDeprecations[deprecationId] = 1;
        };
    }

    function teardownDeprecationHandler(test, moment, scope) {
        moment.suppressDeprecationWarnings = test._oldSupress;

        if (test._expectedDeprecations != null) {
            var missedDeprecations = [];
            each(test._expectedDeprecations, function (deprecationPattern, id) {
                if (test._observedDeprecations[id] !== 1) {
                    missedDeprecations.push(deprecationPattern);
                }
            });
            if (missedDeprecations.length !== 0) {
                throw new Error('Expected deprecation warnings did not happen: ' +
                        missedDeprecations.join(' '));
            }
        }
    }

    function matchedDeprecation(name, msg, deprecations) {
        if (deprecations == null) {
            return -1;
        }
        for (var i = 0; i < deprecations.length; ++i) {
            if (name != null && name === deprecations[i]) {
                return i;
            }
            if (msg != null && msg.substring(0, deprecations[i].length) === deprecations[i]) {
                return i;
            }
        }
        return -1;
    }

    /*global QUnit:false*/

    var test = QUnit.test;

    var expect = QUnit.expect;

    function module (name, lifecycle) {
        QUnit.module(name, {
            setup : function () {
                moment.locale('en');
                moment.createFromInputFallback = function (config) {
                    throw new Error('input not handled by moment: ' + config._i);
                };
                setupDeprecationHandler(test, moment, 'core');
                if (lifecycle && lifecycle.setup) {
                    lifecycle.setup();
                }
            },
            teardown : function () {
                teardownDeprecationHandler(test, moment, 'core');
                if (lifecycle && lifecycle.teardown) {
                    lifecycle.teardown();
                }
            }
        });
    }

    function localeModule (name, lifecycle) {
        QUnit.module('locale:' + name, {
            setup : function () {
                moment.locale(name);
                moment.createFromInputFallback = function (config) {
                    throw new Error('input not handled by moment: ' + config._i);
                };
                setupDeprecationHandler(test, moment, 'locale');
                if (lifecycle && lifecycle.setup) {
                    lifecycle.setup();
                }
            },
            teardown : function () {
                moment.locale('en');
                teardownDeprecationHandler(test, moment, 'locale');
                if (lifecycle && lifecycle.teardown) {
                    lifecycle.teardown();
                }
            }
        });
        defineCommonLocaleTests(name, -1, -1);
    }

    localeModule('fr');

    test('parse', function (assert) {
        var tests = 'janvier janv._fÃ©vrier fÃ©vr._mars mars_avril avr._mai mai_juin juin_juillet juil._aoÃ»t aoÃ»t_septembre sept._octobre oct._novembre nov._dÃ©cembre dÃ©c.'.split('_'),
            i;
        function equalTest(input, mmm, i) {
            assert.equal(moment(input, mmm).month(), i, input + ' should be month ' + (i + 1));
        }
        for (i = 0; i < 12; i++) {
            tests[i] = tests[i].split(' ');
            equalTest(tests[i][0], 'MMM', i);
            equalTest(tests[i][1], 'MMM', i);
            equalTest(tests[i][0], 'MMMM', i);
            equalTest(tests[i][1], 'MMMM', i);
            equalTest(tests[i][0].toLocaleLowerCase(), 'MMMM', i);
            equalTest(tests[i][1].toLocaleLowerCase(), 'MMMM', i);
            equalTest(tests[i][0].toLocaleUpperCase(), 'MMMM', i);
            equalTest(tests[i][1].toLocaleUpperCase(), 'MMMM', i);
        }
    });

    test('format', function (assert) {
        var a = [
                ['dddd, MMMM Do YYYY, h:mm:ss a',      'dimanche, fÃ©vrier 14 2010, 3:25:50 pm'],
                ['ddd, hA',                            'dim., 3PM'],
                ['M Mo MM MMMM MMM',                   '2 2 02 fÃ©vrier fÃ©vr.'],
                ['YYYY YY',                            '2010 10'],
                ['D Do DD',                            '14 14 14'],
                ['d do dddd ddd dd',                   '0 0 dimanche dim. Di'],
                ['DDD DDDo DDDD',                      '45 45 045'],
                ['w wo ww',                            '6 6 06'],
                ['h hh',                               '3 03'],
                ['H HH',                               '15 15'],
                ['m mm',                               '25 25'],
                ['s ss',                               '50 50'],
                ['a A',                                'pm PM'],
                ['[the] DDDo [day of the year]',       'the 45 day of the year'],
                ['LTS',                                '15:25:50'],
                ['L',                                  '14/02/2010'],
                ['LL',                                 '14 fÃ©vrier 2010'],
                ['LLL',                                '14 fÃ©vrier 2010 15:25'],
                ['LLLL',                               'dimanche 14 fÃ©vrier 2010 15:25'],
                ['l',                                  '14/2/2010'],
                ['ll',                                 '14 fÃ©vr. 2010'],
                ['lll',                                '14 fÃ©vr. 2010 15:25'],
                ['llll',                               'dim. 14 fÃ©vr. 2010 15:25']
            ],
            b = moment(new Date(2010, 1, 14, 15, 25, 50, 125)),
            i;
        for (i = 0; i < a.length; i++) {
            assert.equal(b.format(a[i][0]), a[i][1], a[i][0] + ' ---> ' + a[i][1]);
        }
    });

    test('format ordinal', function (assert) {
        assert.equal(moment([2011, 0, 1]).format('DDDo'), '1er', '1er');
        assert.equal(moment([2011, 0, 2]).format('DDDo'), '2', '2');
        assert.equal(moment([2011, 0, 3]).format('DDDo'), '3', '3');
        assert.equal(moment([2011, 0, 4]).format('DDDo'), '4', '4');
        assert.equal(moment([2011, 0, 5]).format('DDDo'), '5', '5');
        assert.equal(moment([2011, 0, 6]).format('DDDo'), '6', '6');
        assert.equal(moment([2011, 0, 7]).format('DDDo'), '7', '7');
        assert.equal(moment([2011, 0, 8]).format('DDDo'), '8', '8');
        assert.equal(moment([2011, 0, 9]).format('DDDo'), '9', '9');
        assert.equal(moment([2011, 0, 10]).format('DDDo'), '10', '10');

        assert.equal(moment([2011, 0, 11]).format('DDDo'), '11', '11');
        assert.equal(moment([2011, 0, 12]).format('DDDo'), '12', '12');
        assert.equal(moment([2011, 0, 13]).format('DDDo'), '13', '13');
        assert.equal(moment([2011, 0, 14]).format('DDDo'), '14', '14');
        assert.equal(moment([2011, 0, 15]).format('DDDo'), '15', '15');
        assert.equal(moment([2011, 0, 16]).format('DDDo'), '16', '16');
        assert.equal(moment([2011, 0, 17]).format('DDDo'), '17', '17');
        assert.equal(moment([2011, 0, 18]).format('DDDo'), '18', '18');
        assert.equal(moment([2011, 0, 19]).format('DDDo'), '19', '19');
        assert.equal(moment([2011, 0, 20]).format('DDDo'), '20', '20');

        assert.equal(moment([2011, 0, 21]).format('DDDo'), '21', '21');
        assert.equal(moment([2011, 0, 22]).format('DDDo'), '22', '22');
        assert.equal(moment([2011, 0, 23]).format('DDDo'), '23', '23');
        assert.equal(moment([2011, 0, 24]).format('DDDo'), '24', '24');
        assert.equal(moment([2011, 0, 25]).format('DDDo'), '25', '25');
        assert.equal(moment([2011, 0, 26]).format('DDDo'), '26', '26');
        assert.equal(moment([2011, 0, 27]).format('DDDo'), '27', '27');
        assert.equal(moment([2011, 0, 28]).format('DDDo'), '28', '28');
        assert.equal(moment([2011, 0, 29]).format('DDDo'), '29', '29');
        assert.equal(moment([2011, 0, 30]).format('DDDo'), '30', '30');

        assert.equal(moment([2011, 0, 31]).format('DDDo'), '31', '31');
    });

    test('format month', function (assert) {
        var expected = 'janvier janv._fÃ©vrier fÃ©vr._mars mars_avril avr._mai mai_juin juin_juillet juil._aoÃ»t aoÃ»t_septembre sept._octobre oct._novembre nov._dÃ©cembre dÃ©c.'.split('_'), i;
        for (i = 0; i < expected.length; i++) {
            assert.equal(moment([2011, i, 1]).format('MMMM MMM'), expected[i], expected[i]);
        }
    });

    test('format week', function (assert) {
        var expected = 'dimanche dim. Di_lundi lun. Lu_mardi mar. Ma_mercredi mer. Me_jeudi jeu. Je_vendredi ven. Ve_samedi sam. Sa'.split('_'), i;
        for (i = 0; i < expected.length; i++) {
            assert.equal(moment([2011, 0, 2 + i]).format('dddd ddd dd'), expected[i], expected[i]);
        }
    });

    test('from', function (assert) {
        var start = moment([2007, 1, 28]);
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 44}), true),  'quelques secondes', '44 seconds = a few seconds');
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 45}), true),  'une minute',   '45 seconds = a minute');
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 89}), true),  'une minute',   '89 seconds = a minute');
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 90}), true),  '2 minutes',  '90 seconds = 2 minutes');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 44}), true),  '44 minutes', '44 minutes = 44 minutes');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 45}), true),  'une heure',    '45 minutes = an hour');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 89}), true),  'une heure',    '89 minutes = an hour');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 90}), true),  '2 heures',    '90 minutes = 2 hours');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 5}), true),   '5 heures',    '5 hours = 5 hours');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 21}), true),  '21 heures',   '21 hours = 21 hours');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 22}), true),  'un jour',      '22 hours = a day');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 35}), true),  'un jour',      '35 hours = a day');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 36}), true),  '2 jours',     '36 hours = 2 days');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 1}), true),   'un jour',      '1 day = a day');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 5}), true),   '5 jours',     '5 days = 5 days');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 25}), true),  '25 jours',    '25 days = 25 days');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 26}), true),  'un mois',    '26 days = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 30}), true),  'un mois',    '30 days = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 43}), true),  'un mois',    '43 days = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 46}), true),  '2 mois',   '46 days = 2 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 74}), true),  '2 mois',   '75 days = 2 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 76}), true),  '3 mois',   '76 days = 3 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({M: 1}), true),   'un mois',    '1 month = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({M: 5}), true),   '5 mois',   '5 months = 5 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 345}), true), 'un an',     '345 days = a year');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 548}), true), '2 ans',    '548 days = 2 years');
        assert.equal(start.from(moment([2007, 1, 28]).add({y: 1}), true),   'un an',     '1 year = a year');
        assert.equal(start.from(moment([2007, 1, 28]).add({y: 5}), true),   '5 ans',    '5 years = 5 years');
    });

    test('suffix', function (assert) {
        assert.equal(moment(30000).from(0), 'dans quelques secondes', 'prefix');
        assert.equal(moment(0).from(30000), 'il y a quelques secondes', 'suffix');
    });

    test('fromNow', function (assert) {
        assert.equal(moment().add({s: 30}).fromNow(), 'dans quelques secondes', 'in a few seconds');
        assert.equal(moment().add({d: 5}).fromNow(), 'dans 5 jours', 'in 5 days');
    });

    test('same day', function (assert) {
        var a = moment().hours(12).minutes(0).seconds(0);

        assert.equal(moment(a).calendar(),                   'Aujourd\'hui Ã  12:00',    'today at the same time');
        assert.equal(moment(a).add({m: 25}).calendar(),      'Aujourd\'hui Ã  12:25',    'Now plus 25 min');
        assert.equal(moment(a).add({h: 1}).calendar(),       'Aujourd\'hui Ã  13:00',    'Now plus 1 hour');
        assert.equal(moment(a).add({d: 1}).calendar(),       'Demain Ã  12:00',          'tomorrow at the same time');
        assert.equal(moment(a).subtract({h: 1}).calendar(),  'Aujourd\'hui Ã  11:00',    'Now minus 1 hour');
        assert.equal(moment(a).subtract({d: 1}).calendar(),  'Hier Ã  12:00',            'yesterday at the same time');
    });

    test('same next week', function (assert) {
        var i, m;

        for (i = 2; i < 7; i++) {
            m = moment().add({d: i});
            assert.equal(m.calendar(),       m.format('dddd [Ã ] LT'),  'Today + ' + i + ' days current time');
            m.hours(0).minutes(0).seconds(0).milliseconds(0);
            assert.equal(m.calendar(),       m.format('dddd [Ã ] LT'),  'Today + ' + i + ' days beginning of day');
            m.hours(23).minutes(59).seconds(59).milliseconds(999);
            assert.equal(m.calendar(),       m.format('dddd [Ã ] LT'),  'Today + ' + i + ' days end of day');
        }
    });

    test('same last week', function (assert) {
        var i, m;

        for (i = 2; i < 7; i++) {
            m = moment().subtract({d: i});
            assert.equal(m.calendar(),       m.format('dddd [dernier Ã ] LT'),  'Today - ' + i + ' days current time');
            m.hours(0).minutes(0).seconds(0).milliseconds(0);
            assert.equal(m.calendar(),       m.format('dddd [dernier Ã ] LT'),  'Today - ' + i + ' days beginning of day');
            m.hours(23).minutes(59).seconds(59).milliseconds(999);
            assert.equal(m.calendar(),       m.format('dddd [dernier Ã ] LT'),  'Today - ' + i + ' days end of day');
        }
    });

    test('same all else', function (assert) {
        var weeksAgo = moment().subtract({w: 1}),
            weeksFromNow = moment().add({w: 1});

        assert.equal(weeksAgo.calendar(),       weeksAgo.format('L'),  '1 week ago');
        assert.equal(weeksFromNow.calendar(),   weeksFromNow.format('L'),  'in 1 week');

        weeksAgo = moment().subtract({w: 2});
        weeksFromNow = moment().add({w: 2});

        assert.equal(weeksAgo.calendar(),       weeksAgo.format('L'),  '2 weeks ago');
        assert.equal(weeksFromNow.calendar(),   weeksFromNow.format('L'),  'in 2 weeks');
    });

    test('weeks year starting sunday formatted', function (assert) {
        assert.equal(moment([2012, 0,  1]).format('w ww wo'), '52 52 52', 'Jan  1 2012 should be week 52');
        assert.equal(moment([2012, 0,  2]).format('w ww wo'), '1 01 1er', 'Jan  2 2012 should be week 1');
        assert.equal(moment([2012, 0,  8]).format('w ww wo'), '1 01 1er', 'Jan  8 2012 should be week 1');
        assert.equal(moment([2012, 0,  9]).format('w ww wo'),   '2 02 2', 'Jan  9 2012 should be week 2');
        assert.equal(moment([2012, 0, 15]).format('w ww wo'),   '2 02 2', 'Jan 15 2012 should be week 2');
    });

}));

;(function (global, factory) {
   typeof exports === 'object' && typeof module !== 'undefined'
       && typeof require === 'function' ? factory(require('../../moment')) :
   typeof define === 'function' && define.amd ? define(['../../moment'], factory) :
   factory(global.moment)
}(this, function (moment) { 'use strict';

    function each(array, callback) {
        var i;
        for (i = 0; i < array.length; i++) {
            callback(array[i], i, array);
        }
    }

    function objectKeys(obj) {
        if (Object.keys) {
            return Object.keys(obj);
        } else {
            // IE8
            var res = [], i;
            for (i in obj) {
                if (obj.hasOwnProperty(i)) {
                    res.push(i);
                }
            }
            return res;
        }
    }

    // Pick the first defined of two or three arguments.
    function defaults(a, b, c) {
        if (a != null) {
            return a;
        }
        if (b != null) {
            return b;
        }
        return c;
    }

    function defineCommonLocaleTests(locale, options) {
        test('lenient ordinal parsing', function (assert) {
            var i, ordinalStr, testMoment;
            for (i = 1; i <= 31; ++i) {
                ordinalStr = moment([2014, 0, i]).format('YYYY MM Do');
                testMoment = moment(ordinalStr, 'YYYY MM Do');
                assert.equal(testMoment.year(), 2014,
                        'lenient ordinal parsing ' + i + ' year check');
                assert.equal(testMoment.month(), 0,
                        'lenient ordinal parsing ' + i + ' month check');
                assert.equal(testMoment.date(), i,
                        'lenient ordinal parsing ' + i + ' date check');
            }
        });

        test('lenient ordinal parsing of number', function (assert) {
            var i, testMoment;
            for (i = 1; i <= 31; ++i) {
                testMoment = moment('2014 01 ' + i, 'YYYY MM Do');
                assert.equal(testMoment.year(), 2014,
                        'lenient ordinal parsing of number ' + i + ' year check');
                assert.equal(testMoment.month(), 0,
                        'lenient ordinal parsing of number ' + i + ' month check');
                assert.equal(testMoment.date(), i,
                        'lenient ordinal parsing of number ' + i + ' date check');
            }
        });

        test('strict ordinal parsing', function (assert) {
            var i, ordinalStr, testMoment;
            for (i = 1; i <= 31; ++i) {
                ordinalStr = moment([2014, 0, i]).format('YYYY MM Do');
                testMoment = moment(ordinalStr, 'YYYY MM Do', true);
                assert.ok(testMoment.isValid(), 'strict ordinal parsing ' + i);
            }
        });

        test('meridiem invariant', function (assert) {
            var h, m, t1, t2;
            for (h = 0; h < 24; ++h) {
                for (m = 0; m < 60; m += 15) {
                    t1 = moment.utc([2000, 0, 1, h, m]);
                    t2 = moment.utc(t1.format('A h:mm'), 'A h:mm');
                    assert.equal(t2.format('HH:mm'), t1.format('HH:mm'),
                            'meridiem at ' + t1.format('HH:mm'));
                }
            }
        });

        test('date format correctness', function (assert) {
            var data, tokens;
            data = moment.localeData()._longDateFormat;
            tokens = objectKeys(data);
            each(tokens, function (srchToken) {
                // Check each format string to make sure it does not contain any
                // tokens that need to be expanded.
                each(tokens, function (baseToken) {
                    // strip escaped sequences
                    var format = data[baseToken].replace(/(\[[^\]]*\])/g, '');
                    assert.equal(false, !!~format.indexOf(srchToken),
                            'contains ' + srchToken + ' in ' + baseToken);
                });
            });
        });

        test('month parsing correctness', function (assert) {
            var i, m;

            if (locale === 'tr') {
                // I can't fix it :(
                expect(0);
                return;
            }
            function tester(format) {
                var r;
                r = moment(m.format(format), format);
                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format);
                r = moment(m.format(format).toLocaleUpperCase(), format);
                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' upper');
                r = moment(m.format(format).toLocaleLowerCase(), format);
                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' lower');

                r = moment(m.format(format), format, true);
                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' strict');
                r = moment(m.format(format).toLocaleUpperCase(), format, true);
                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' upper strict');
                r = moment(m.format(format).toLocaleLowerCase(), format, true);
                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' lower strict');
            }

            for (i = 0; i < 12; ++i) {
                m = moment([2015, i, 15, 18]);
                tester('MMM');
                tester('MMM.');
                tester('MMMM');
                tester('MMMM.');
            }
        });

        test('weekday parsing correctness', function (assert) {
            var i, m;

            if (locale === 'tr' || locale === 'az') {
                // There is a lower-case letter (Ä±), that converted to upper then
                // lower changes to i
                expect(0);
                return;
            }
            function tester(format) {
                var r, baseMsg = 'weekday ' + m.weekday() + ' fmt ' + format;
                r = moment(m.format(format), format);
                assert.equal(r.weekday(), m.weekday(), baseMsg);
                r = moment(m.format(format).toLocaleUpperCase(), format);
                assert.equal(r.weekday(), m.weekday(), baseMsg + ' upper');
                r = moment(m.format(format).toLocaleLowerCase(), format);
                assert.equal(r.weekday(), m.weekday(), baseMsg + ' lower');

                r = moment(m.format(format), format, true);
                assert.equal(r.weekday(), m.weekday(), baseMsg + ' strict');
                r = moment(m.format(format).toLocaleUpperCase(), format, true);
                assert.equal(r.weekday(), m.weekday(), baseMsg + ' upper strict');
                r = moment(m.format(format).toLocaleLowerCase(), format, true);
                assert.equal(r.weekday(), m.weekday(), baseMsg + ' lower strict');
            }

            for (i = 0; i < 7; ++i) {
                m = moment.utc([2015, i, 15, 18]);
                tester('dd');
                tester('ddd');
                tester('dddd');
            }
        });
    }

    function setupDeprecationHandler(test, moment, scope) {
        test._expectedDeprecations = null;
        test._observedDeprecations = null;
        test._oldSupress = moment.suppressDeprecationWarnings;
        moment.suppressDeprecationWarnings = true;
        test.expectedDeprecations = function () {
            test._expectedDeprecations = arguments;
            test._observedDeprecations = [];
        };
        moment.deprecationHandler = function (name, msg) {
            var deprecationId = matchedDeprecation(name, msg, test._expectedDeprecations);
            if (deprecationId === -1) {
                throw new Error('Unexpected deprecation thrown name=' +
                        name + ' msg=' + msg);
            }
            test._observedDeprecations[deprecationId] = 1;
        };
    }

    function teardownDeprecationHandler(test, moment, scope) {
        moment.suppressDeprecationWarnings = test._oldSupress;

        if (test._expectedDeprecations != null) {
            var missedDeprecations = [];
            each(test._expectedDeprecations, function (deprecationPattern, id) {
                if (test._observedDeprecations[id] !== 1) {
                    missedDeprecations.push(deprecationPattern);
                }
            });
            if (missedDeprecations.length !== 0) {
                throw new Error('Expected deprecation warnings did not happen: ' +
                        missedDeprecations.join(' '));
            }
        }
    }

    function matchedDeprecation(name, msg, deprecations) {
        if (deprecations == null) {
            return -1;
        }
        for (var i = 0; i < deprecations.length; ++i) {
            if (name != null && name === deprecations[i]) {
                return i;
            }
            if (msg != null && msg.substring(0, deprecations[i].length) === deprecations[i]) {
                return i;
            }
        }
        return -1;
    }

    /*global QUnit:false*/

    var test = QUnit.test;

    var expect = QUnit.expect;

    function module (name, lifecycle) {
        QUnit.module(name, {
            setup : function () {
                moment.locale('en');
                moment.createFromInputFallback = function (config) {
                    throw new Error('input not handled by moment: ' + config._i);
                };
                setupDeprecationHandler(test, moment, 'core');
                if (lifecycle && lifecycle.setup) {
                    lifecycle.setup();
                }
            },
            teardown : function () {
                teardownDeprecationHandler(test, moment, 'core');
                if (lifecycle && lifecycle.teardown) {
                    lifecycle.teardown();
                }
            }
        });
    }

    function localeModule (name, lifecycle) {
        QUnit.module('locale:' + name, {
            setup : function () {
                moment.locale(name);
                moment.createFromInputFallback = function (config) {
                    throw new Error('input not handled by moment: ' + config._i);
                };
                setupDeprecationHandler(test, moment, 'locale');
                if (lifecycle && lifecycle.setup) {
                    lifecycle.setup();
                }
            },
            teardown : function () {
                moment.locale('en');
                teardownDeprecationHandler(test, moment, 'locale');
                if (lifecycle && lifecycle.teardown) {
                    lifecycle.teardown();
                }
            }
        });
        defineCommonLocaleTests(name, -1, -1);
    }

    localeModule('fy');

    test('parse', function (assert) {
        var tests = 'jannewaris jan._febrewaris feb._maart mrt._april apr._maaie mai._juny jun._july jul._augustus aug._septimber sep._oktober okt._novimber nov._desimber des.'.split('_'), i;
        function equalTest(input, mmm, i) {
            assert.equal(moment(input, mmm).month(), i, input + ' should be month ' + (i + 1));
        }
        for (i = 0; i < 12; i++) {
            tests[i] = tests[i].split(' ');
            equalTest(tests[i][0], 'MMM', i);
            equalTest(tests[i][1], 'MMM', i);
            equalTest(tests[i][0], 'MMMM', i);
            equalTest(tests[i][1], 'MMMM', i);
            equalTest(tests[i][0].toLocaleLowerCase(), 'MMMM', i);
            equalTest(tests[i][1].toLocaleLowerCase(), 'MMMM', i);
            equalTest(tests[i][0].toLocaleUpperCase(), 'MMMM', i);
            equalTest(tests[i][1].toLocaleUpperCase(), 'MMMM', i);
        }
    });

    test('format', function (assert) {
        var a = [
                ['dddd, MMMM Do YYYY, HH:mm:ss',       'snein, febrewaris 14de 2010, 15:25:50'],
                ['ddd, HH',                            'si., 15'],
                ['M Mo MM MMMM MMM',                   '2 2de 02 febrewaris feb.'],
                ['YYYY YY',                            '2010 10'],
                ['D Do DD',                            '14 14de 14'],
                ['d do dddd ddd dd',                   '0 0de snein si. Si'],
                ['DDD DDDo DDDD',                      '45 45ste 045'],
                ['w wo ww',                            '6 6de 06'],
                ['h hh',                               '3 03'],
                ['H HH',                               '15 15'],
                ['m mm',                               '25 25'],
                ['s ss',                               '50 50'],
                ['a A',                                'pm PM'],
                ['[the] DDDo [day of the year]',       'the 45ste day of the year'],
                ['LTS',                                '15:25:50'],
                ['L',                                  '14-02-2010'],
                ['LL',                                 '14 febrewaris 2010'],
                ['LLL',                                '14 febrewaris 2010 15:25'],
                ['LLLL',                               'snein 14 febrewaris 2010 15:25'],
                ['l',                                  '14-2-2010'],
                ['ll',                                 '14 feb. 2010'],
                ['lll',                                '14 feb. 2010 15:25'],
                ['llll',                               'si. 14 feb. 2010 15:25']
            ],
            b = moment(new Date(2010, 1, 14, 15, 25, 50, 125)),
            i;
        for (i = 0; i < a.length; i++) {
            assert.equal(b.format(a[i][0]), a[i][1], a[i][0] + ' ---> ' + a[i][1]);
        }
    });

    test('format ordinal', function (assert) {
        assert.equal(moment([2011, 0, 1]).format('DDDo'), '1ste', '1ste');
        assert.equal(moment([2011, 0, 2]).format('DDDo'), '2de', '2de');
        assert.equal(moment([2011, 0, 3]).format('DDDo'), '3de', '3de');
        assert.equal(moment([2011, 0, 4]).format('DDDo'), '4de', '4de');
        assert.equal(moment([2011, 0, 5]).format('DDDo'), '5de', '5de');
        assert.equal(moment([2011, 0, 6]).format('DDDo'), '6de', '6de');
        assert.equal(moment([2011, 0, 7]).format('DDDo'), '7de', '7de');
        assert.equal(moment([2011, 0, 8]).format('DDDo'), '8ste', '8ste');
        assert.equal(moment([2011, 0, 9]).format('DDDo'), '9de', '9de');
        assert.equal(moment([2011, 0, 10]).format('DDDo'), '10de', '10de');

        assert.equal(moment([2011, 0, 11]).format('DDDo'), '11de', '11de');
        assert.equal(moment([2011, 0, 12]).format('DDDo'), '12de', '12de');
        assert.equal(moment([2011, 0, 13]).format('DDDo'), '13de', '13de');
        assert.equal(moment([2011, 0, 14]).format('DDDo'), '14de', '14de');
        assert.equal(moment([2011, 0, 15]).format('DDDo'), '15de', '15de');
        assert.equal(moment([2011, 0, 16]).format('DDDo'), '16de', '16de');
        assert.equal(moment([2011, 0, 17]).format('DDDo'), '17de', '17de');
        assert.equal(moment([2011, 0, 18]).format('DDDo'), '18de', '18de');
        assert.equal(moment([2011, 0, 19]).format('DDDo'), '19de', '19de');
        assert.equal(moment([2011, 0, 20]).format('DDDo'), '20ste', '20ste');

        assert.equal(moment([2011, 0, 21]).format('DDDo'), '21ste', '21ste');
        assert.equal(moment([2011, 0, 22]).format('DDDo'), '22ste', '22ste');
        assert.equal(moment([2011, 0, 23]).format('DDDo'), '23ste', '23ste');
        assert.equal(moment([2011, 0, 24]).format('DDDo'), '24ste', '24ste');
        assert.equal(moment([2011, 0, 25]).format('DDDo'), '25ste', '25ste');
        assert.equal(moment([2011, 0, 26]).format('DDDo'), '26ste', '26ste');
        assert.equal(moment([2011, 0, 27]).format('DDDo'), '27ste', '27ste');
        assert.equal(moment([2011, 0, 28]).format('DDDo'), '28ste', '28ste');
        assert.equal(moment([2011, 0, 29]).format('DDDo'), '29ste', '29ste');
        assert.equal(moment([2011, 0, 30]).format('DDDo'), '30ste', '30ste');

        assert.equal(moment([2011, 0, 31]).format('DDDo'), '31ste', '31ste');
    });

    test('format month', function (assert) {
        var expected = 'jannewaris jan._febrewaris feb._maart mrt._april apr._maaie mai_juny jun._july jul._augustus aug._septimber sep._oktober okt._novimber nov._desimber des.'.split('_'), i;
        for (i = 0; i < expected.length; i++) {
            assert.equal(moment([2011, i, 1]).format('MMMM MMM'), expected[i], expected[i]);
        }
    });

    test('format week', function (assert) {
        var expected = 'snein si. Si_moandei mo. Mo_tiisdei ti. Ti_woansdei wo. Wo_tongersdei to. To_freed fr. Fr_sneon so. So'.split('_'), i;
        for (i = 0; i < expected.length; i++) {
            assert.equal(moment([2011, 0, 2 + i]).format('dddd ddd dd'), expected[i], expected[i]);
        }
    });

    test('from', function (assert) {
        var start = moment([2007, 1, 28]);
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 44}), true),  'in pear sekonden', '44 seconds = a few seconds');
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 45}), true),  'ien minÃºt',      '45 seconds = a minute');
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 89}), true),  'ien minÃºt',      '89 seconds = a minute');
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 90}), true),  '2 minuten',     '90 seconds = 2 minutes');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 44}), true),  '44 minuten',    '44 minutes = 44 minutes');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 45}), true),  'ien oere',       '45 minutes = an hour');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 89}), true),  'ien oere',       '89 minutes = an hour');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 90}), true),  '2 oeren',       '90 minutes = 2 hours');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 5}), true),   '5 oeren',       '5 hours = 5 hours');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 21}), true),  '21 oeren',      '21 hours = 21 hours');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 22}), true),  'ien dei',         '22 hours = a day');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 35}), true),  'ien dei',         '35 hours = a day');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 36}), true),  '2 dagen',        '36 hours = 2 days');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 1}), true),   'ien dei',         '1 day = a day');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 5}), true),   '5 dagen',        '5 days = 5 days');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 25}), true),  '25 dagen',       '25 days = 25 days');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 26}), true),  'ien moanne',       '26 days = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 30}), true),  'ien moanne',       '30 days = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 43}), true),  'ien moanne',       '43 days = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 46}), true),  '2 moannen',      '46 days = 2 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 74}), true),  '2 moannen',      '75 days = 2 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 76}), true),  '3 moannen',      '76 days = 3 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({M: 1}), true),   'ien moanne',       '1 month = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({M: 5}), true),   '5 moannen',      '5 months = 5 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 345}), true), 'ien jier',        '345 days = a year');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 548}), true), '2 jierren',       '548 days = 2 years');
        assert.equal(start.from(moment([2007, 1, 28]).add({y: 1}), true),   'ien jier',        '1 year = a year');
        assert.equal(start.from(moment([2007, 1, 28]).add({y: 5}), true),   '5 jierren',       '5 years = 5 years');
    });

    test('suffix', function (assert) {
        assert.equal(moment(30000).from(0), 'oer in pear sekonden',  'prefix');
        assert.equal(moment(0).from(30000), 'in pear sekonden lyn', 'suffix');
    });

    test('now from now', function (assert) {
        assert.equal(moment().fromNow(), 'in pear sekonden lyn',  'now from now should display as in the past');
    });

    test('fromNow', function (assert) {
        assert.equal(moment().add({s: 30}).fromNow(), 'oer in pear sekonden', 'in a few seconds');
        assert.equal(moment().add({d: 5}).fromNow(), 'oer 5 dagen', 'in 5 days');
    });

    test('calendar day', function (assert) {
        var a = moment().hours(12).minutes(0).seconds(0);

        assert.equal(moment(a).calendar(),                   'hjoed om 12:00',     'today at the same time');
        assert.equal(moment(a).add({m: 25}).calendar(),      'hjoed om 12:25',     'Now plus 25 min');
        assert.equal(moment(a).add({h: 1}).calendar(),       'hjoed om 13:00',     'Now plus 1 hour');
        assert.equal(moment(a).add({d: 1}).calendar(),       'moarn om 12:00',     'tomorrow at the same time');
        assert.equal(moment(a).subtract({h: 1}).calendar(),  'hjoed om 11:00',     'Now minus 1 hour');
        assert.equal(moment(a).subtract({d: 1}).calendar(),  'juster om 12:00',    'yesterday at the same time');
    });

    test('calendar next week', function (assert) {
        var i, m;
        for (i = 2; i < 7; i++) {
            m = moment().add({d: i});
            assert.equal(m.calendar(),       m.format('dddd [om] LT'),  'Today + ' + i + ' days current time');
            m.hours(0).minutes(0).seconds(0).milliseconds(0);
            assert.equal(m.calendar(),       m.format('dddd [om] LT'),  'Today + ' + i + ' days beginning of day');
            m.hours(23).minutes(59).seconds(59).milliseconds(999);
            assert.equal(m.calendar(),       m.format('dddd [om] LT'),  'Today + ' + i + ' days end of day');
        }
    });

    test('calendar last week', function (assert) {
        var i, m;
        for (i = 2; i < 7; i++) {
            m = moment().subtract({d: i});
            assert.equal(m.calendar(),       m.format('[Ã´frÃ»ne] dddd [om] LT'),  'Today - ' + i + ' days current time');
            m.hours(0).minutes(0).seconds(0).milliseconds(0);
            assert.equal(m.calendar(),       m.format('[Ã´frÃ»ne] dddd [om] LT'),  'Today - ' + i + ' days beginning of day');
            m.hours(23).minutes(59).seconds(59).milliseconds(999);
            assert.equal(m.calendar(),       m.format('[Ã´frÃ»ne] dddd [om] LT'),  'Today - ' + i + ' days end of day');
        }
    });

    test('calendar all else', function (assert) {
        var weeksAgo = moment().subtract({w: 1}),
            weeksFromNow = moment().add({w: 1});

        assert.equal(weeksAgo.calendar(),       weeksAgo.format('L'),  '1 week ago');
        assert.equal(weeksFromNow.calendar(),   weeksFromNow.format('L'),  'in 1 week');

        weeksAgo = moment().subtract({w: 2});
        weeksFromNow = moment().add({w: 2});

        assert.equal(weeksAgo.calendar(),       weeksAgo.format('L'),  '2 weeks ago');
        assert.equal(weeksFromNow.calendar(),   weeksFromNow.format('L'),  'in 2 weeks');
    });

    test('month abbreviation', function (assert) {
        assert.equal(moment([2012, 5, 23]).format('D-MMM-YYYY'), '23-jun-2012', 'format month abbreviation surrounded by dashes should not include a dot');
        assert.equal(moment([2012, 5, 23]).format('D MMM YYYY'), '23 jun. 2012', 'format month abbreviation not surrounded by dashes should include a dot');
    });

    test('weeks year starting sunday formatted', function (assert) {
        assert.equal(moment([2012, 0,  1]).format('w ww wo'), '52 52 52ste', 'Jan  1 2012 should be week 52');
        assert.equal(moment([2012, 0,  2]).format('w ww wo'),   '1 01 1ste', 'Jan  2 2012 should be week 1');
        assert.equal(moment([2012, 0,  8]).format('w ww wo'),   '1 01 1ste', 'Jan  8 2012 should be week 1');
        assert.equal(moment([2012, 0,  9]).format('w ww wo'),    '2 02 2de', 'Jan  9 2012 should be week 2');
        assert.equal(moment([2012, 0, 15]).format('w ww wo'),    '2 02 2de', 'Jan 15 2012 should be week 2');
    });

}));

;(function (global, factory) {
   typeof exports === 'object' && typeof module !== 'undefined'
       && typeof require === 'function' ? factory(require('../../moment')) :
   typeof define === 'function' && define.amd ? define(['../../moment'], factory) :
   factory(global.moment)
}(this, function (moment) { 'use strict';

    function each(array, callback) {
        var i;
        for (i = 0; i < array.length; i++) {
            callback(array[i], i, array);
        }
    }

    function objectKeys(obj) {
        if (Object.keys) {
            return Object.keys(obj);
        } else {
            // IE8
            var res = [], i;
            for (i in obj) {
                if (obj.hasOwnProperty(i)) {
                    res.push(i);
                }
            }
            return res;
        }
    }

    // Pick the first defined of two or three arguments.
    function defaults(a, b, c) {
        if (a != null) {
            return a;
        }
        if (b != null) {
            return b;
        }
        return c;
    }

    function defineCommonLocaleTests(locale, options) {
        test('lenient ordinal parsing', function (assert) {
            var i, ordinalStr, testMoment;
            for (i = 1; i <= 31; ++i) {
                ordinalStr = moment([2014, 0, i]).format('YYYY MM Do');
                testMoment = moment(ordinalStr, 'YYYY MM Do');
                assert.equal(testMoment.year(), 2014,
                        'lenient ordinal parsing ' + i + ' year check');
                assert.equal(testMoment.month(), 0,
                        'lenient ordinal parsing ' + i + ' month check');
                assert.equal(testMoment.date(), i,
                        'lenient ordinal parsing ' + i + ' date check');
            }
        });

        test('lenient ordinal parsing of number', function (assert) {
            var i, testMoment;
            for (i = 1; i <= 31; ++i) {
                testMoment = moment('2014 01 ' + i, 'YYYY MM Do');
                assert.equal(testMoment.year(), 2014,
                        'lenient ordinal parsing of number ' + i + ' year check');
                assert.equal(testMoment.month(), 0,
                        'lenient ordinal parsing of number ' + i + ' month check');
                assert.equal(testMoment.date(), i,
                        'lenient ordinal parsing of number ' + i + ' date check');
            }
        });

        test('strict ordinal parsing', function (assert) {
            var i, ordinalStr, testMoment;
            for (i = 1; i <= 31; ++i) {
                ordinalStr = moment([2014, 0, i]).format('YYYY MM Do');
                testMoment = moment(ordinalStr, 'YYYY MM Do', true);
                assert.ok(testMoment.isValid(), 'strict ordinal parsing ' + i);
            }
        });

        test('meridiem invariant', function (assert) {
            var h, m, t1, t2;
            for (h = 0; h < 24; ++h) {
                for (m = 0; m < 60; m += 15) {
                    t1 = moment.utc([2000, 0, 1, h, m]);
                    t2 = moment.utc(t1.format('A h:mm'), 'A h:mm');
                    assert.equal(t2.format('HH:mm'), t1.format('HH:mm'),
                            'meridiem at ' + t1.format('HH:mm'));
                }
            }
        });

        test('date format correctness', function (assert) {
            var data, tokens;
            data = moment.localeData()._longDateFormat;
            tokens = objectKeys(data);
            each(tokens, function (srchToken) {
                // Check each format string to make sure it does not contain any
                // tokens that need to be expanded.
                each(tokens, function (baseToken) {
                    // strip escaped sequences
                    var format = data[baseToken].replace(/(\[[^\]]*\])/g, '');
                    assert.equal(false, !!~format.indexOf(srchToken),
                            'contains ' + srchToken + ' in ' + baseToken);
                });
            });
        });

        test('month parsing correctness', function (assert) {
            var i, m;

            if (locale === 'tr') {
                // I can't fix it :(
                expect(0);
                return;
            }
            function tester(format) {
                var r;
                r = moment(m.format(format), format);
                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format);
                r = moment(m.format(format).toLocaleUpperCase(), format);
                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' upper');
                r = moment(m.format(format).toLocaleLowerCase(), format);
                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' lower');

                r = moment(m.format(format), format, true);
                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' strict');
                r = moment(m.format(format).toLocaleUpperCase(), format, true);
                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' upper strict');
                r = moment(m.format(format).toLocaleLowerCase(), format, true);
                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' lower strict');
            }

            for (i = 0; i < 12; ++i) {
                m = moment([2015, i, 15, 18]);
                tester('MMM');
                tester('MMM.');
                tester('MMMM');
                tester('MMMM.');
            }
        });

        test('weekday parsing correctness', function (assert) {
            var i, m;

            if (locale === 'tr' || locale === 'az') {
                // There is a lower-case letter (Ä±), that converted to upper then
                // lower changes to i
                expect(0);
                return;
            }
            function tester(format) {
                var r, baseMsg = 'weekday ' + m.weekday() + ' fmt ' + format;
                r = moment(m.format(format), format);
                assert.equal(r.weekday(), m.weekday(), baseMsg);
                r = moment(m.format(format).toLocaleUpperCase(), format);
                assert.equal(r.weekday(), m.weekday(), baseMsg + ' upper');
                r = moment(m.format(format).toLocaleLowerCase(), format);
                assert.equal(r.weekday(), m.weekday(), baseMsg + ' lower');

                r = moment(m.format(format), format, true);
                assert.equal(r.weekday(), m.weekday(), baseMsg + ' strict');
                r = moment(m.format(format).toLocaleUpperCase(), format, true);
                assert.equal(r.weekday(), m.weekday(), baseMsg + ' upper strict');
                r = moment(m.format(format).toLocaleLowerCase(), format, true);
                assert.equal(r.weekday(), m.weekday(), baseMsg + ' lower strict');
            }

            for (i = 0; i < 7; ++i) {
                m = moment.utc([2015, i, 15, 18]);
                tester('dd');
                tester('ddd');
                tester('dddd');
            }
        });
    }

    function setupDeprecationHandler(test, moment, scope) {
        test._expectedDeprecations = null;
        test._observedDeprecations = null;
        test._oldSupress = moment.suppressDeprecationWarnings;
        moment.suppressDeprecationWarnings = true;
        test.expectedDeprecations = function () {
            test._expectedDeprecations = arguments;
            test._observedDeprecations = [];
        };
        moment.deprecationHandler = function (name, msg) {
            var deprecationId = matchedDeprecation(name, msg, test._expectedDeprecations);
            if (deprecationId === -1) {
                throw new Error('Unexpected deprecation thrown name=' +
                        name + ' msg=' + msg);
            }
            test._observedDeprecations[deprecationId] = 1;
        };
    }

    function teardownDeprecationHandler(test, moment, scope) {
        moment.suppressDeprecationWarnings = test._oldSupress;

        if (test._expectedDeprecations != null) {
            var missedDeprecations = [];
            each(test._expectedDeprecations, function (deprecationPattern, id) {
                if (test._observedDeprecations[id] !== 1) {
                    missedDeprecations.push(deprecationPattern);
                }
            });
            if (missedDeprecations.length !== 0) {
                throw new Error('Expected deprecation warnings did not happen: ' +
                        missedDeprecations.join(' '));
            }
        }
    }

    function matchedDeprecation(name, msg, deprecations) {
        if (deprecations == null) {
            return -1;
        }
        for (var i = 0; i < deprecations.length; ++i) {
            if (name != null && name === deprecations[i]) {
                return i;
            }
            if (msg != null && msg.substring(0, deprecations[i].length) === deprecations[i]) {
                return i;
            }
        }
        return -1;
    }

    /*global QUnit:false*/

    var test = QUnit.test;

    var expect = QUnit.expect;

    function module (name, lifecycle) {
        QUnit.module(name, {
            setup : function () {
                moment.locale('en');
                moment.createFromInputFallback = function (config) {
                    throw new Error('input not handled by moment: ' + config._i);
                };
                setupDeprecationHandler(test, moment, 'core');
                if (lifecycle && lifecycle.setup) {
                    lifecycle.setup();
                }
            },
            teardown : function () {
                teardownDeprecationHandler(test, moment, 'core');
                if (lifecycle && lifecycle.teardown) {
                    lifecycle.teardown();
                }
            }
        });
    }

    function localeModule (name, lifecycle) {
        QUnit.module('locale:' + name, {
            setup : function () {
                moment.locale(name);
                moment.createFromInputFallback = function (config) {
                    throw new Error('input not handled by moment: ' + config._i);
                };
                setupDeprecationHandler(test, moment, 'locale');
                if (lifecycle && lifecycle.setup) {
                    lifecycle.setup();
                }
            },
            teardown : function () {
                moment.locale('en');
                teardownDeprecationHandler(test, moment, 'locale');
                if (lifecycle && lifecycle.teardown) {
                    lifecycle.teardown();
                }
            }
        });
        defineCommonLocaleTests(name, -1, -1);
    }

    localeModule('gd');

    var months = [
        'Am Faoilleach,Faoi',
        'An Gearran,Gear',
        'Am MÃ rt,MÃ rt',
        'An Giblean,Gibl',
        'An CÃ¨itean,CÃ¨it',
        'An t-Ãgmhios,Ãgmh',
        'An t-Iuchar,Iuch',
        'An LÃ¹nastal,LÃ¹n',
        'An t-Sultain,Sult',
        'An DÃ mhair,DÃ mh',
        'An t-Samhain,Samh',
        'An DÃ¹bhlachd,DÃ¹bh'
    ];

    test('parse', function (assert) {
        function equalTest(monthName, monthFormat, monthNum) {
            assert.equal(moment(monthName, monthFormat).month(), monthNum, monthName + ' should be month ' + (monthNum + 1));
        }

        for (var i = 0; i < 12; i++) {
            var testMonth = months[i].split(',');
            equalTest(testMonth[0], 'MMM', i);
            equalTest(testMonth[1], 'MMM', i);
            equalTest(testMonth[0], 'MMMM', i);
            equalTest(testMonth[1], 'MMMM', i);
            equalTest(testMonth[0].toLocaleLowerCase(), 'MMMM', i);
            equalTest(testMonth[1].toLocaleLowerCase(), 'MMMM', i);
            equalTest(testMonth[0].toLocaleUpperCase(), 'MMMM', i);
            equalTest(testMonth[1].toLocaleUpperCase(), 'MMMM', i);
        }
    });

    test('format', function (assert) {
        var a = [
            ['dddd, MMMM Do YYYY, h:mm:ss a', 'DidÃ²mhnaich, An Gearran 14mh 2010, 3:25:50 pm'],
            ['ddd, hA', 'Did, 3PM'],
            ['M Mo MM MMMM MMM', '2 2na 02 An Gearran Gear'],
            ['YYYY YY', '2010 10'],
            ['D Do DD', '14 14mh 14'],
            ['d do dddd ddd dd', '0 0mh DidÃ²mhnaich Did DÃ²'],
            ['DDD DDDo DDDD', '45 45mh 045'],
            ['w wo ww', '6 6mh 06'],
            ['h hh', '3 03'],
            ['H HH', '15 15'],
            ['m mm', '25 25'],
            ['s ss', '50 50'],
            ['a A', 'pm PM'],
            ['[an] DDDo [latha den bhliadhna]', 'an 45mh latha den bhliadhna'],
            ['LTS', '15:25:50'],
            ['L', '14/02/2010'],
            ['LL', '14 An Gearran 2010'],
            ['LLL', '14 An Gearran 2010 15:25'],
            ['LLLL', 'DidÃ²mhnaich, 14 An Gearran 2010 15:25'],
            ['l', '14/2/2010'],
            ['ll', '14 Gear 2010'],
            ['lll', '14 Gear 2010 15:25'],
            ['llll', 'Did, 14 Gear 2010 15:25']
        ],
        b = moment(new Date(2010, 1, 14, 15, 25, 50, 125)),
        i;
        for (i = 0; i < a.length; i++) {
            assert.equal(b.format(a[i][0]), a[i][1], a[i][0] + ' ---> ' + a[i][1]);
        }
    });

    test('format ordinal', function (assert) {
        assert.equal(moment([2011, 0, 1]).format('DDDo'), '1d', '1d');
        assert.equal(moment([2011, 0, 2]).format('DDDo'), '2na', '2na');
        assert.equal(moment([2011, 0, 3]).format('DDDo'), '3mh', '3mh');
        assert.equal(moment([2011, 0, 4]).format('DDDo'), '4mh', '4mh');
        assert.equal(moment([2011, 0, 5]).format('DDDo'), '5mh', '5mh');
        assert.equal(moment([2011, 0, 6]).format('DDDo'), '6mh', '6mh');
        assert.equal(moment([2011, 0, 7]).format('DDDo'), '7mh', '7mh');
        assert.equal(moment([2011, 0, 8]).format('DDDo'), '8mh', '8mh');
        assert.equal(moment([2011, 0, 9]).format('DDDo'), '9mh', '9mh');
        assert.equal(moment([2011, 0, 10]).format('DDDo'), '10mh', '10mh');
        assert.equal(moment([2011, 0, 11]).format('DDDo'), '11mh', '11mh');
        assert.equal(moment([2011, 0, 12]).format('DDDo'), '12na', '12na');
        assert.equal(moment([2011, 0, 13]).format('DDDo'), '13mh', '13mh');
        assert.equal(moment([2011, 0, 14]).format('DDDo'), '14mh', '14mh');
        assert.equal(moment([2011, 0, 15]).format('DDDo'), '15mh', '15mh');
        assert.equal(moment([2011, 0, 16]).format('DDDo'), '16mh', '16mh');
        assert.equal(moment([2011, 0, 17]).format('DDDo'), '17mh', '17mh');
        assert.equal(moment([2011, 0, 18]).format('DDDo'), '18mh', '18mh');
        assert.equal(moment([2011, 0, 19]).format('DDDo'), '19mh', '19mh');
        assert.equal(moment([2011, 0, 20]).format('DDDo'), '20mh', '20mh');
        assert.equal(moment([2011, 0, 21]).format('DDDo'), '21mh', '21mh');
        assert.equal(moment([2011, 0, 22]).format('DDDo'), '22na', '22na');
        assert.equal(moment([2011, 0, 23]).format('DDDo'), '23mh', '23mh');
        assert.equal(moment([2011, 0, 24]).format('DDDo'), '24mh', '24mh');
        assert.equal(moment([2011, 0, 25]).format('DDDo'), '25mh', '25mh');
        assert.equal(moment([2011, 0, 26]).format('DDDo'), '26mh', '26mh');
        assert.equal(moment([2011, 0, 27]).format('DDDo'), '27mh', '27mh');
        assert.equal(moment([2011, 0, 28]).format('DDDo'), '28mh', '28mh');
        assert.equal(moment([2011, 0, 29]).format('DDDo'), '29mh', '29mh');
        assert.equal(moment([2011, 0, 30]).format('DDDo'), '30mh', '30mh');
        assert.equal(moment([2011, 0, 31]).format('DDDo'), '31mh', '31mh');
    });

    test('format month', function (assert) {
        var expected = months;
        for (var i = 0; i < expected.length; i++) {
            assert.equal(moment([2011, i, 1]).format('MMMM,MMM'), expected[i], expected[i]);
        }
    });

    test('format week', function (assert) {
        var expected = ['DidÃ²mhnaich Did DÃ²', 'Diluain Dil Lu', 'DimÃ irt Dim MÃ ', 'Diciadain Dic Ci', 'Diardaoin Dia Ar', 'Dihaoine Dih Ha', 'Disathairne Dis Sa'];
        for (var i = 0; i < expected.length; i++) {
            assert.equal(moment([2011, 0, 2 + i]).format('dddd ddd dd'), expected[i], expected[i]);
        }
    });

    test('from', function (assert) {
        var start = moment([2007, 1, 28]);
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 44}), true), 'beagan diogan', '44 seconds = a few seconds');
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 45}), true), 'mionaid', '45 seconds = a minute');
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 89}), true), 'mionaid', '89 seconds = a minute');
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 90}), true), '2 mionaidean', '90 seconds = 2 minutes');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 44}), true), '44 mionaidean', '44 minutes = 44 minutes');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 45}), true), 'uair', '45 minutes = an hour');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 89}), true), 'uair', '89 minutes = an hour');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 90}), true), '2 uairean', '90 minutes = 2 hours');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 5}), true), '5 uairean', '5 hours = 5 hours');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 21}), true), '21 uairean', '21 hours = 21 hours');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 22}), true), 'latha', '22 hours = a day');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 35}), true), 'latha', '35 hours = a day');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 36}), true), '2 latha', '36 hours = 2 days');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 1}), true), 'latha', '1 day = a day');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 5}), true), '5 latha', '5 days = 5 days');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 25}), true), '25 latha', '25 days = 25 days');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 26}), true), 'mÃ¬os', '26 days = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 30}), true), 'mÃ¬os', '30 days = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 43}), true), 'mÃ¬os', '43 days = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 46}), true), '2 mÃ¬osan', '46 days = 2 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 74}), true), '2 mÃ¬osan', '75 days = 2 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 76}), true), '3 mÃ¬osan', '76 days = 3 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({M: 1}), true), 'mÃ¬os', '1 month = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({M: 5}), true), '5 mÃ¬osan', '5 months = 5 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 345}), true), 'bliadhna', '345 days = a year');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 548}), true), '2 bliadhna', '548 days = 2 years');
        assert.equal(start.from(moment([2007, 1, 28]).add({y: 1}), true), 'bliadhna', '1 year = a year');
        assert.equal(start.from(moment([2007, 1, 28]).add({y: 5}), true), '5 bliadhna', '5 years = 5 years');
    });

    test('suffix', function (assert) {
        assert.equal(moment(30000).from(0), 'ann an beagan diogan', 'prefix');
        assert.equal(moment(0).from(30000), 'bho chionn beagan diogan', 'suffix');
    });

    test('now from now', function (assert) {
        assert.equal(moment().fromNow(), 'bho chionn beagan diogan', 'now from now should display as in the past');
    });

    test('fromNow', function (assert) {
        assert.equal(moment().add({s: 30}).fromNow(), 'ann an beagan diogan', 'in a few seconds');
        assert.equal(moment().add({d: 5}).fromNow(), 'ann an 5 latha', 'in 5 days');
    });

    test('calendar day', function (assert) {
        var a = moment().hours(12).minutes(0).seconds(0);

        assert.equal(moment(a).calendar(),                  'An-diugh aig 12:00',   'today at the same time');
        assert.equal(moment(a).add({m: 25}).calendar(),     'An-diugh aig 12:25',   'Now plus 25 min');
        assert.equal(moment(a).add({h: 1}).calendar(),      'An-diugh aig 13:00',   'Now plus 1 hour');
        assert.equal(moment(a).add({d: 1}).calendar(),      'A-mÃ ireach aig 12:00', 'tomorrow at the same time');
        assert.equal(moment(a).subtract({h: 1}).calendar(), 'An-diugh aig 11:00',   'Now minus 1 hour');
        assert.equal(moment(a).subtract({d: 1}).calendar(), 'An-dÃ¨ aig 12:00',      'yesterday at the same time');
    });

    test('calendar next week', function (assert) {
        var i, m;
        for (i = 2; i < 7; i++) {
            m = moment().add({d: i});
            assert.equal(m.calendar(), m.format('dddd [aig] LT'), 'Today + ' + i + ' days current time');
            m.hours(0).minutes(0).seconds(0).milliseconds(0);
            assert.equal(m.calendar(), m.format('dddd [aig] LT'), 'Today + ' + i + ' days beginning of day');
            m.hours(23).minutes(59).seconds(59).milliseconds(999);
            assert.equal(m.calendar(), m.format('dddd [aig] LT'), 'Today + ' + i + ' days end of day');
        }
    });

    test('calendar last week', function (assert) {
        var i, m;

        for (i = 2; i < 7; i++) {
            m = moment().subtract({d: i});
            assert.equal(m.calendar(), m.format('dddd [seo chaidh] [aig] LT'), 'Today - ' + i + ' days current time');
            m.hours(0).minutes(0).seconds(0).milliseconds(0);
            assert.equal(m.calendar(), m.format('dddd [seo chaidh] [aig] LT'), 'Today - ' + i + ' days beginning of day');
            m.hours(23).minutes(59).seconds(59).milliseconds(999);
            assert.equal(m.calendar(), m.format('dddd [seo chaidh] [aig] LT'), 'Today - ' + i + ' days end of day');
        }
    });

    test('calendar all else', function (assert) {
        var weeksAgo = moment().subtract({w: 1}),
           weeksFromNow = moment().add({w: 1});

        assert.equal(weeksAgo.calendar(), weeksAgo.format('L'), '1 week ago');
        assert.equal(weeksFromNow.calendar(), weeksFromNow.format('L'), 'in 1 week');

        weeksAgo = moment().subtract({w: 2});
        weeksFromNow = moment().add({w: 2});

        assert.equal(weeksAgo.calendar(), weeksAgo.format('L'), '2 weeks ago');
        assert.equal(weeksFromNow.calendar(), weeksFromNow.format('L'), 'in 2 weeks');
    });

    test('weeks year starting sunday formatted', function (assert) {
        assert.equal(moment([2012, 0, 1]).format('w ww wo'), '52 52 52na', 'Faoi  1 2012 should be week 52');
        assert.equal(moment([2012, 0, 2]).format('w ww wo'), '1 01 1d', 'Faoi  2 2012 should be week 1');
        assert.equal(moment([2012, 0, 8]).format('w ww wo'), '1 01 1d', 'Faoi  8 2012 should be week 1');
        assert.equal(moment([2012, 0, 9]).format('w ww wo'), '2 02 2na', 'Faoi  9 2012 should be week 2');
        assert.equal(moment([2012, 0, 15]).format('w ww wo'), '2 02 2na', 'Faoi 15 2012 should be week 2');
    });

}));

;(function (global, factory) {
   typeof exports === 'object' && typeof module !== 'undefined'
       && typeof require === 'function' ? factory(require('../../moment')) :
   typeof define === 'function' && define.amd ? define(['../../moment'], factory) :
   factory(global.moment)
}(this, function (moment) { 'use strict';

    function each(array, callback) {
        var i;
        for (i = 0; i < array.length; i++) {
            callback(array[i], i, array);
        }
    }

    function objectKeys(obj) {
        if (Object.keys) {
            return Object.keys(obj);
        } else {
            // IE8
            var res = [], i;
            for (i in obj) {
                if (obj.hasOwnProperty(i)) {
                    res.push(i);
                }
            }
            return res;
        }
    }

    // Pick the first defined of two or three arguments.
    function defaults(a, b, c) {
        if (a != null) {
            return a;
        }
        if (b != null) {
            return b;
        }
        return c;
    }

    function defineCommonLocaleTests(locale, options) {
        test('lenient ordinal parsing', function (assert) {
            var i, ordinalStr, testMoment;
            for (i = 1; i <= 31; ++i) {
                ordinalStr = moment([2014, 0, i]).format('YYYY MM Do');
                testMoment = moment(ordinalStr, 'YYYY MM Do');
                assert.equal(testMoment.year(), 2014,
                        'lenient ordinal parsing ' + i + ' year check');
                assert.equal(testMoment.month(), 0,
                        'lenient ordinal parsing ' + i + ' month check');
                assert.equal(testMoment.date(), i,
                        'lenient ordinal parsing ' + i + ' date check');
            }
        });

        test('lenient ordinal parsing of number', function (assert) {
            var i, testMoment;
            for (i = 1; i <= 31; ++i) {
                testMoment = moment('2014 01 ' + i, 'YYYY MM Do');
                assert.equal(testMoment.year(), 2014,
                        'lenient ordinal parsing of number ' + i + ' year check');
                assert.equal(testMoment.month(), 0,
                        'lenient ordinal parsing of number ' + i + ' month check');
                assert.equal(testMoment.date(), i,
                        'lenient ordinal parsing of number ' + i + ' date check');
            }
        });

        test('strict ordinal parsing', function (assert) {
            var i, ordinalStr, testMoment;
            for (i = 1; i <= 31; ++i) {
                ordinalStr = moment([2014, 0, i]).format('YYYY MM Do');
                testMoment = moment(ordinalStr, 'YYYY MM Do', true);
                assert.ok(testMoment.isValid(), 'strict ordinal parsing ' + i);
            }
        });

        test('meridiem invariant', function (assert) {
            var h, m, t1, t2;
            for (h = 0; h < 24; ++h) {
                for (m = 0; m < 60; m += 15) {
                    t1 = moment.utc([2000, 0, 1, h, m]);
                    t2 = moment.utc(t1.format('A h:mm'), 'A h:mm');
                    assert.equal(t2.format('HH:mm'), t1.format('HH:mm'),
                            'meridiem at ' + t1.format('HH:mm'));
                }
            }
        });

        test('date format correctness', function (assert) {
            var data, tokens;
            data = moment.localeData()._longDateFormat;
            tokens = objectKeys(data);
            each(tokens, function (srchToken) {
                // Check each format string to make sure it does not contain any
                // tokens that need to be expanded.
                each(tokens, function (baseToken) {
                    // strip escaped sequences
                    var format = data[baseToken].replace(/(\[[^\]]*\])/g, '');
                    assert.equal(false, !!~format.indexOf(srchToken),
                            'contains ' + srchToken + ' in ' + baseToken);
                });
            });
        });

        test('month parsing correctness', function (assert) {
            var i, m;

            if (locale === 'tr') {
                // I can't fix it :(
                expect(0);
                return;
            }
            function tester(format) {
                var r;
                r = moment(m.format(format), format);
                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format);
                r = moment(m.format(format).toLocaleUpperCase(), format);
                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' upper');
                r = moment(m.format(format).toLocaleLowerCase(), format);
                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' lower');

                r = moment(m.format(format), format, true);
                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' strict');
                r = moment(m.format(format).toLocaleUpperCase(), format, true);
                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' upper strict');
                r = moment(m.format(format).toLocaleLowerCase(), format, true);
                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' lower strict');
            }

            for (i = 0; i < 12; ++i) {
                m = moment([2015, i, 15, 18]);
                tester('MMM');
                tester('MMM.');
                tester('MMMM');
                tester('MMMM.');
            }
        });

        test('weekday parsing correctness', function (assert) {
            var i, m;

            if (locale === 'tr' || locale === 'az') {
                // There is a lower-case letter (Ä±), that converted to upper then
                // lower changes to i
                expect(0);
                return;
            }
            function tester(format) {
                var r, baseMsg = 'weekday ' + m.weekday() + ' fmt ' + format;
                r = moment(m.format(format), format);
                assert.equal(r.weekday(), m.weekday(), baseMsg);
                r = moment(m.format(format).toLocaleUpperCase(), format);
                assert.equal(r.weekday(), m.weekday(), baseMsg + ' upper');
                r = moment(m.format(format).toLocaleLowerCase(), format);
                assert.equal(r.weekday(), m.weekday(), baseMsg + ' lower');

                r = moment(m.format(format), format, true);
                assert.equal(r.weekday(), m.weekday(), baseMsg + ' strict');
                r = moment(m.format(format).toLocaleUpperCase(), format, true);
                assert.equal(r.weekday(), m.weekday(), baseMsg + ' upper strict');
                r = moment(m.format(format).toLocaleLowerCase(), format, true);
                assert.equal(r.weekday(), m.weekday(), baseMsg + ' lower strict');
            }

            for (i = 0; i < 7; ++i) {
                m = moment.utc([2015, i, 15, 18]);
                tester('dd');
                tester('ddd');
                tester('dddd');
            }
        });
    }

    function setupDeprecationHandler(test, moment, scope) {
        test._expectedDeprecations = null;
        test._observedDeprecations = null;
        test._oldSupress = moment.suppressDeprecationWarnings;
        moment.suppressDeprecationWarnings = true;
        test.expectedDeprecations = function () {
            test._expectedDeprecations = arguments;
            test._observedDeprecations = [];
        };
        moment.deprecationHandler = function (name, msg) {
            var deprecationId = matchedDeprecation(name, msg, test._expectedDeprecations);
            if (deprecationId === -1) {
                throw new Error('Unexpected deprecation thrown name=' +
                        name + ' msg=' + msg);
            }
            test._observedDeprecations[deprecationId] = 1;
        };
    }

    function teardownDeprecationHandler(test, moment, scope) {
        moment.suppressDeprecationWarnings = test._oldSupress;

        if (test._expectedDeprecations != null) {
            var missedDeprecations = [];
            each(test._expectedDeprecations, function (deprecationPattern, id) {
                if (test._observedDeprecations[id] !== 1) {
                    missedDeprecations.push(deprecationPattern);
                }
            });
            if (missedDeprecations.length !== 0) {
                throw new Error('Expected deprecation warnings did not happen: ' +
                        missedDeprecations.join(' '));
            }
        }
    }

    function matchedDeprecation(name, msg, deprecations) {
        if (deprecations == null) {
            return -1;
        }
        for (var i = 0; i < deprecations.length; ++i) {
            if (name != null && name === deprecations[i]) {
                return i;
            }
            if (msg != null && msg.substring(0, deprecations[i].length) === deprecations[i]) {
                return i;
            }
        }
        return -1;
    }

    /*global QUnit:false*/

    var test = QUnit.test;

    var expect = QUnit.expect;

    function module (name, lifecycle) {
        QUnit.module(name, {
            setup : function () {
                moment.locale('en');
                moment.createFromInputFallback = function (config) {
                    throw new Error('input not handled by moment: ' + config._i);
                };
                setupDeprecationHandler(test, moment, 'core');
                if (lifecycle && lifecycle.setup) {
                    lifecycle.setup();
                }
            },
            teardown : function () {
                teardownDeprecationHandler(test, moment, 'core');
                if (lifecycle && lifecycle.teardown) {
                    lifecycle.teardown();
                }
            }
        });
    }

    function localeModule (name, lifecycle) {
        QUnit.module('locale:' + name, {
            setup : function () {
                moment.locale(name);
                moment.createFromInputFallback = function (config) {
                    throw new Error('input not handled by moment: ' + config._i);
                };
                setupDeprecationHandler(test, moment, 'locale');
                if (lifecycle && lifecycle.setup) {
                    lifecycle.setup();
                }
            },
            teardown : function () {
                moment.locale('en');
                teardownDeprecationHandler(test, moment, 'locale');
                if (lifecycle && lifecycle.teardown) {
                    lifecycle.teardown();
                }
            }
        });
        defineCommonLocaleTests(name, -1, -1);
    }

    localeModule('gl');

    test('parse', function (assert) {
        var tests = 'Xaneiro Xan._Febreiro Feb._Marzo Mar._Abril Abr._Maio Mai._XuÃ±o XuÃ±._Xullo Xul._Agosto Ago._Setembro Set._Outubro Out._Novembro Nov._Decembro Dec.'.split('_'), i;
        function equalTest(input, mmm, i) {
            assert.equal(moment(input, mmm).month(), i, input + ' should be month ' + (i + 1));
        }
        for (i = 0; i < 12; i++) {
            tests[i] = tests[i].split(' ');
            equalTest(tests[i][0], 'MMM', i);
            equalTest(tests[i][1], 'MMM', i);
            equalTest(tests[i][0], 'MMMM', i);
            equalTest(tests[i][1], 'MMMM', i);
            equalTest(tests[i][0].toLocaleLowerCase(), 'MMMM', i);
            equalTest(tests[i][1].toLocaleLowerCase(), 'MMMM', i);
            equalTest(tests[i][0].toLocaleUpperCase(), 'MMMM', i);
            equalTest(tests[i][1].toLocaleUpperCase(), 'MMMM', i);
        }
    });

    test('format', function (assert) {
        var a = [
                ['dddd, MMMM Do YYYY, h:mm:ss a',      'Domingo, Febreiro 14Âº 2010, 3:25:50 pm'],
                ['ddd, hA',                            'Dom., 3PM'],
                ['M Mo MM MMMM MMM',                   '2 2Âº 02 Febreiro Feb.'],
                ['YYYY YY',                            '2010 10'],
                ['D Do DD',                            '14 14Âº 14'],
                ['d do dddd ddd dd',                   '0 0Âº Domingo Dom. Do'],
                ['DDD DDDo DDDD',                      '45 45Âº 045'],
                ['w wo ww',                            '7 7Âº 07'],
                ['h hh',                               '3 03'],
                ['H HH',                               '15 15'],
                ['m mm',                               '25 25'],
                ['s ss',                               '50 50'],
                ['a A',                                'pm PM'],
                ['[the] DDDo [day of the year]',       'the 45Âº day of the year'],
                ['LTS',                                '15:25:50'],
                ['L',                                  '14/02/2010'],
                ['LL',                                 '14 Febreiro 2010'],
                ['LLL',                                '14 Febreiro 2010 15:25'],
                ['LLLL',                               'Domingo 14 Febreiro 2010 15:25'],
                ['l',                                  '14/2/2010'],
                ['ll',                                 '14 Feb. 2010'],
                ['lll',                                '14 Feb. 2010 15:25'],
                ['llll',                               'Dom. 14 Feb. 2010 15:25']
            ],
            b = moment(new Date(2010, 1, 14, 15, 25, 50, 125)),
            i;
        for (i = 0; i < a.length; i++) {
            assert.equal(b.format(a[i][0]), a[i][1], a[i][0] + ' ---> ' + a[i][1]);
        }
    });

    test('format ordinal', function (assert) {
        assert.equal(moment([2011, 0, 1]).format('DDDo'), '1Âº', '1Âº');
        assert.equal(moment([2011, 0, 2]).format('DDDo'), '2Âº', '2Âº');
        assert.equal(moment([2011, 0, 3]).format('DDDo'), '3Âº', '3Âº');
        assert.equal(moment([2011, 0, 4]).format('DDDo'), '4Âº', '4Âº');
        assert.equal(moment([2011, 0, 5]).format('DDDo'), '5Âº', '5Âº');
        assert.equal(moment([2011, 0, 6]).format('DDDo'), '6Âº', '6Âº');
        assert.equal(moment([2011, 0, 7]).format('DDDo'), '7Âº', '7Âº');
        assert.equal(moment([2011, 0, 8]).format('DDDo'), '8Âº', '8Âº');
        assert.equal(moment([2011, 0, 9]).format('DDDo'), '9Âº', '9Âº');
        assert.equal(moment([2011, 0, 10]).format('DDDo'), '10Âº', '10Âº');

        assert.equal(moment([2011, 0, 11]).format('DDDo'), '11Âº', '11Âº');
        assert.equal(moment([2011, 0, 12]).format('DDDo'), '12Âº', '12Âº');
        assert.equal(moment([2011, 0, 13]).format('DDDo'), '13Âº', '13Âº');
        assert.equal(moment([2011, 0, 14]).format('DDDo'), '14Âº', '14Âº');
        assert.equal(moment([2011, 0, 15]).format('DDDo'), '15Âº', '15Âº');
        assert.equal(moment([2011, 0, 16]).format('DDDo'), '16Âº', '16Âº');
        assert.equal(moment([2011, 0, 17]).format('DDDo'), '17Âº', '17Âº');
        assert.equal(moment([2011, 0, 18]).format('DDDo'), '18Âº', '18Âº');
        assert.equal(moment([2011, 0, 19]).format('DDDo'), '19Âº', '19Âº');
        assert.equal(moment([2011, 0, 20]).format('DDDo'), '20Âº', '20Âº');

        assert.equal(moment([2011, 0, 21]).format('DDDo'), '21Âº', '21Âº');
        assert.equal(moment([2011, 0, 22]).format('DDDo'), '22Âº', '22Âº');
        assert.equal(moment([2011, 0, 23]).format('DDDo'), '23Âº', '23Âº');
        assert.equal(moment([2011, 0, 24]).format('DDDo'), '24Âº', '24Âº');
        assert.equal(moment([2011, 0, 25]).format('DDDo'), '25Âº', '25Âº');
        assert.equal(moment([2011, 0, 26]).format('DDDo'), '26Âº', '26Âº');
        assert.equal(moment([2011, 0, 27]).format('DDDo'), '27Âº', '27Âº');
        assert.equal(moment([2011, 0, 28]).format('DDDo'), '28Âº', '28Âº');
        assert.equal(moment([2011, 0, 29]).format('DDDo'), '29Âº', '29Âº');
        assert.equal(moment([2011, 0, 30]).format('DDDo'), '30Âº', '30Âº');

        assert.equal(moment([2011, 0, 31]).format('DDDo'), '31Âº', '31Âº');
    });

    test('format month', function (assert) {
        var expected = 'Xaneiro Xan._Febreiro Feb._Marzo Mar._Abril Abr._Maio Mai._XuÃ±o XuÃ±._Xullo Xul._Agosto Ago._Setembro Set._Outubro Out._Novembro Nov._Decembro Dec.'.split('_'), i;
        for (i = 0; i < expected.length; i++) {
            assert.equal(moment([2011, i, 1]).format('MMMM MMM'), expected[i], expected[i]);
        }
    });

    test('format week', function (assert) {
        var expected = 'Domingo Dom. Do_Luns Lun. Lu_Martes Mar. Ma_MÃ©rcores MÃ©r. MÃ©_Xoves Xov. Xo_Venres Ven. Ve_SÃ¡bado SÃ¡b. SÃ¡'.split('_'),
        i;
        for (i = 0; i < expected.length; i++) {
            assert.equal(moment([2011, 0, 2 + i]).format('dddd ddd dd'), expected[i], expected[i]);
        }
    });

    test('from', function (assert) {
        var start = moment([2007, 1, 28]);

        assert.equal(start.from(moment([2007, 1, 28]).add({s: 44}), true),  'uns segundos', '44 seconds = a few seconds');
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 45}), true),  'un minuto',      '45 seconds = a minute');
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 89}), true),  'un minuto',      '89 seconds = a minute');
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 90}), true),  '2 minutos',     '90 seconds = 2 minutes');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 44}), true),  '44 minutos',    '44 minutes = 44 minutes');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 45}), true),  'unha hora',       '45 minutes = an hour');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 89}), true),  'unha hora',       '89 minutes = an hour');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 90}), true),  '2 horas',       '90 minutes = 2 hours');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 5}), true),   '5 horas',       '5 hours = 5 hours');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 21}), true),  '21 horas',      '21 hours = 21 hours');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 22}), true),  'un dÃ­a',         '22 hours = a day');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 35}), true),  'un dÃ­a',         '35 hours = a day');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 36}), true),  '2 dÃ­as',        '36 hours = 2 days');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 1}), true),   'un dÃ­a',         '1 day = a day');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 5}), true),   '5 dÃ­as',        '5 days = 5 days');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 25}), true),  '25 dÃ­as',       '25 days = 25 days');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 26}), true),  'un mes',       '26 days = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 30}), true),  'un mes',       '30 days = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 43}), true),  'un mes',       '43 days = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 46}), true),  '2 meses',      '46 days = 2 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 74}), true),  '2 meses',      '75 days = 2 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 76}), true),  '3 meses',      '76 days = 3 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({M: 1}), true),   'un mes',       '1 month = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({M: 5}), true),   '5 meses',      '5 months = 5 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 345}), true), 'un ano',        '345 days = a year');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 548}), true), '2 anos',       '548 days = 2 years');
        assert.equal(start.from(moment([2007, 1, 28]).add({y: 1}), true),   'un ano',        '1 year = a year');
        assert.equal(start.from(moment([2007, 1, 28]).add({y: 5}), true),   '5 anos',       '5 years = 5 years');
    });

    test('suffix', function (assert) {
        assert.equal(moment(30000).from(0), 'nuns segundos',  'prefix');
        assert.equal(moment(0).from(30000), 'hai uns segundos', 'suffix');
    });

    test('now from now', function (assert) {
        assert.equal(moment().fromNow(), 'hai uns segundos',  'now from now should display as in the past');
    });

    test('fromNow', function (assert) {
        assert.equal(moment().add({s: 30}).fromNow(), 'nuns segundos', 'en unos segundos');
        assert.equal(moment().add({d: 5}).fromNow(), 'en 5 dÃ­as', 'en 5 dÃ­as');
    });

    test('calendar day', function (assert) {
        var a = moment().hours(12).minutes(0).seconds(0);

        assert.equal(moment(a).calendar(),                       'hoxe Ã¡s 12:00',  'today at the same time');
        assert.equal(moment(a).add({m: 25}).calendar(),          'hoxe Ã¡s 12:25',  'Now plus 25 min');
        assert.equal(moment(a).add({h: 1}).calendar(),           'hoxe Ã¡s 13:00',  'Now plus 1 hour');
        assert.equal(moment(a).add({d: 1}).calendar(),           'maÃ±Ã¡ Ã¡s 12:00',  'tomorrow at the same time');
        assert.equal(moment(a).add({d: 1, h : -1}).calendar(),   'maÃ±Ã¡ Ã¡s 11:00',   'tomorrow minus 1 hour');
        assert.equal(moment(a).subtract({h: 1}).calendar(),      'hoxe Ã¡s 11:00',   'Now minus 1 hour');
        assert.equal(moment(a).subtract({d: 1}).calendar(),      'onte Ã¡ 12:00',   'yesterday at the same time');
    });

    test('calendar next week', function (assert) {
        var i, m;

        for (i = 2; i < 7; i++) {
            m = moment().add({d: i});
            assert.equal(m.calendar(),       m.format('dddd [' + ((m.hours() !== 1) ? 'Ã¡s' : 'a') + '] LT'),  'Today + ' + i + ' days current time');
            m.hours(0).minutes(0).seconds(0).milliseconds(0);
            assert.equal(m.calendar(),       m.format('dddd [' + ((m.hours() !== 1) ? 'Ã¡s' : 'a') + '] LT'),  'Today + ' + i + ' days beginning of day');
            m.hours(23).minutes(59).seconds(59).milliseconds(999);
            assert.equal(m.calendar(),       m.format('dddd [' + ((m.hours() !== 1) ? 'Ã¡s' : 'a') + '] LT'),  'Today + ' + i + ' days end of day');
        }
    });

    test('calendar last week', function (assert) {
        var i, m;
        for (i = 2; i < 7; i++) {
            m = moment().subtract({d: i});
            assert.equal(m.calendar(),       m.format('[o] dddd [pasado ' + ((m.hours() !== 1) ? 'Ã¡s' : 'a') + '] LT'),  'Today - ' + i + ' days current time');
            m.hours(0).minutes(0).seconds(0).milliseconds(0);
            assert.equal(m.calendar(),       m.format('[o] dddd [pasado ' + ((m.hours() !== 1) ? 'Ã¡s' : 'a') + '] LT'),  'Today - ' + i + ' days beginning of day');
            m.hours(23).minutes(59).seconds(59).milliseconds(999);
            assert.equal(m.calendar(),       m.format('[o] dddd [pasado ' + ((m.hours() !== 1) ? 'Ã¡s' : 'a') + '] LT'),  'Today - ' + i + ' days end of day');
        }
    });

    test('calendar all else', function (assert) {
        var weeksAgo = moment().subtract({w: 1}),
            weeksFromNow = moment().add({w: 1});

        assert.equal(weeksAgo.calendar(),       weeksAgo.format('L'),  '1 week ago');
        assert.equal(weeksFromNow.calendar(),   weeksFromNow.format('L'),  'in 1 week');

        weeksAgo = moment().subtract({w: 2});
        weeksFromNow = moment().add({w: 2});

        assert.equal(weeksAgo.calendar(),       weeksAgo.format('L'),  '2 weeks ago');
        assert.equal(weeksFromNow.calendar(),   weeksFromNow.format('L'),  'in 2 weeks');
    });

    test('regression tests', function (assert) {
        var lastWeek = moment().subtract({d: 4}).hours(1);
        assert.equal(lastWeek.calendar(), lastWeek.format('[o] dddd [pasado a] LT'), '1 o\'clock bug');
    });

    test('weeks year starting sunday formatted', function (assert) {
        assert.equal(moment([2011, 11, 26]).format('w ww wo'), '1 01 1Âº', 'Dec 26 2011 should be week 1');
        assert.equal(moment([2012,  0,  1]).format('w ww wo'), '1 01 1Âº', 'Jan  1 2012 should be week 1');
        assert.equal(moment([2012,  0,  2]).format('w ww wo'), '2 02 2Âº', 'Jan  2 2012 should be week 2');
        assert.equal(moment([2012,  0,  8]).format('w ww wo'), '2 02 2Âº', 'Jan  8 2012 should be week 2');
        assert.equal(moment([2012,  0,  9]).format('w ww wo'), '3 03 3Âº', 'Jan  9 2012 should be week 3');
    });

}));

;(function (global, factory) {
   typeof exports === 'object' && typeof module !== 'undefined'
       && typeof require === 'function' ? factory(require('../../moment')) :
   typeof define === 'function' && define.amd ? define(['../../moment'], factory) :
   factory(global.moment)
}(this, function (moment) { 'use strict';

    function each(array, callback) {
        var i;
        for (i = 0; i < array.length; i++) {
            callback(array[i], i, array);
        }
    }

    function objectKeys(obj) {
        if (Object.keys) {
            return Object.keys(obj);
        } else {
            // IE8
            var res = [], i;
            for (i in obj) {
                if (obj.hasOwnProperty(i)) {
                    res.push(i);
                }
            }
            return res;
        }
    }

    // Pick the first defined of two or three arguments.
    function defaults(a, b, c) {
        if (a != null) {
            return a;
        }
        if (b != null) {
            return b;
        }
        return c;
    }

    function defineCommonLocaleTests(locale, options) {
        test('lenient ordinal parsing', function (assert) {
            var i, ordinalStr, testMoment;
            for (i = 1; i <= 31; ++i) {
                ordinalStr = moment([2014, 0, i]).format('YYYY MM Do');
                testMoment = moment(ordinalStr, 'YYYY MM Do');
                assert.equal(testMoment.year(), 2014,
                        'lenient ordinal parsing ' + i + ' year check');
                assert.equal(testMoment.month(), 0,
                        'lenient ordinal parsing ' + i + ' month check');
                assert.equal(testMoment.date(), i,
                        'lenient ordinal parsing ' + i + ' date check');
            }
        });

        test('lenient ordinal parsing of number', function (assert) {
            var i, testMoment;
            for (i = 1; i <= 31; ++i) {
                testMoment = moment('2014 01 ' + i, 'YYYY MM Do');
                assert.equal(testMoment.year(), 2014,
                        'lenient ordinal parsing of number ' + i + ' year check');
                assert.equal(testMoment.month(), 0,
                        'lenient ordinal parsing of number ' + i + ' month check');
                assert.equal(testMoment.date(), i,
                        'lenient ordinal parsing of number ' + i + ' date check');
            }
        });

        test('strict ordinal parsing', function (assert) {
            var i, ordinalStr, testMoment;
            for (i = 1; i <= 31; ++i) {
                ordinalStr = moment([2014, 0, i]).format('YYYY MM Do');
                testMoment = moment(ordinalStr, 'YYYY MM Do', true);
                assert.ok(testMoment.isValid(), 'strict ordinal parsing ' + i);
            }
        });

        test('meridiem invariant', function (assert) {
            var h, m, t1, t2;
            for (h = 0; h < 24; ++h) {
                for (m = 0; m < 60; m += 15) {
                    t1 = moment.utc([2000, 0, 1, h, m]);
                    t2 = moment.utc(t1.format('A h:mm'), 'A h:mm');
                    assert.equal(t2.format('HH:mm'), t1.format('HH:mm'),
                            'meridiem at ' + t1.format('HH:mm'));
                }
            }
        });

        test('date format correctness', function (assert) {
            var data, tokens;
            data = moment.localeData()._longDateFormat;
            tokens = objectKeys(data);
            each(tokens, function (srchToken) {
                // Check each format string to make sure it does not contain any
                // tokens that need to be expanded.
                each(tokens, function (baseToken) {
                    // strip escaped sequences
                    var format = data[baseToken].replace(/(\[[^\]]*\])/g, '');
                    assert.equal(false, !!~format.indexOf(srchToken),
                            'contains ' + srchToken + ' in ' + baseToken);
                });
            });
        });

        test('month parsing correctness', function (assert) {
            var i, m;

            if (locale === 'tr') {
                // I can't fix it :(
                expect(0);
                return;
            }
            function tester(format) {
                var r;
                r = moment(m.format(format), format);
                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format);
                r = moment(m.format(format).toLocaleUpperCase(), format);
                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' upper');
                r = moment(m.format(format).toLocaleLowerCase(), format);
                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' lower');

                r = moment(m.format(format), format, true);
                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' strict');
                r = moment(m.format(format).toLocaleUpperCase(), format, true);
                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' upper strict');
                r = moment(m.format(format).toLocaleLowerCase(), format, true);
                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' lower strict');
            }

            for (i = 0; i < 12; ++i) {
                m = moment([2015, i, 15, 18]);
                tester('MMM');
                tester('MMM.');
                tester('MMMM');
                tester('MMMM.');
            }
        });

        test('weekday parsing correctness', function (assert) {
            var i, m;

            if (locale === 'tr' || locale === 'az') {
                // There is a lower-case letter (Ä±), that converted to upper then
                // lower changes to i
                expect(0);
                return;
            }
            function tester(format) {
                var r, baseMsg = 'weekday ' + m.weekday() + ' fmt ' + format;
                r = moment(m.format(format), format);
                assert.equal(r.weekday(), m.weekday(), baseMsg);
                r = moment(m.format(format).toLocaleUpperCase(), format);
                assert.equal(r.weekday(), m.weekday(), baseMsg + ' upper');
                r = moment(m.format(format).toLocaleLowerCase(), format);
                assert.equal(r.weekday(), m.weekday(), baseMsg + ' lower');

                r = moment(m.format(format), format, true);
                assert.equal(r.weekday(), m.weekday(), baseMsg + ' strict');
                r = moment(m.format(format).toLocaleUpperCase(), format, true);
                assert.equal(r.weekday(), m.weekday(), baseMsg + ' upper strict');
                r = moment(m.format(format).toLocaleLowerCase(), format, true);
                assert.equal(r.weekday(), m.weekday(), baseMsg + ' lower strict');
            }

            for (i = 0; i < 7; ++i) {
                m = moment.utc([2015, i, 15, 18]);
                tester('dd');
                tester('ddd');
                tester('dddd');
            }
        });
    }

    function setupDeprecationHandler(test, moment, scope) {
        test._expectedDeprecations = null;
        test._observedDeprecations = null;
        test._oldSupress = moment.suppressDeprecationWarnings;
        moment.suppressDeprecationWarnings = true;
        test.expectedDeprecations = function () {
            test._expectedDeprecations = arguments;
            test._observedDeprecations = [];
        };
        moment.deprecationHandler = function (name, msg) {
            var deprecationId = matchedDeprecation(name, msg, test._expectedDeprecations);
            if (deprecationId === -1) {
                throw new Error('Unexpected deprecation thrown name=' +
                        name + ' msg=' + msg);
            }
            test._observedDeprecations[deprecationId] = 1;
        };
    }

    function teardownDeprecationHandler(test, moment, scope) {
        moment.suppressDeprecationWarnings = test._oldSupress;

        if (test._expectedDeprecations != null) {
            var missedDeprecations = [];
            each(test._expectedDeprecations, function (deprecationPattern, id) {
                if (test._observedDeprecations[id] !== 1) {
                    missedDeprecations.push(deprecationPattern);
                }
            });
            if (missedDeprecations.length !== 0) {
                throw new Error('Expected deprecation warnings did not happen: ' +
                        missedDeprecations.join(' '));
            }
        }
    }

    function matchedDeprecation(name, msg, deprecations) {
        if (deprecations == null) {
            return -1;
        }
        for (var i = 0; i < deprecations.length; ++i) {
            if (name != null && name === deprecations[i]) {
                return i;
            }
            if (msg != null && msg.substring(0, deprecations[i].length) === deprecations[i]) {
                return i;
            }
        }
        return -1;
    }

    /*global QUnit:false*/

    var test = QUnit.test;

    var expect = QUnit.expect;

    function module (name, lifecycle) {
        QUnit.module(name, {
            setup : function () {
                moment.locale('en');
                moment.createFromInputFallback = function (config) {
                    throw new Error('input not handled by moment: ' + config._i);
                };
                setupDeprecationHandler(test, moment, 'core');
                if (lifecycle && lifecycle.setup) {
                    lifecycle.setup();
                }
            },
            teardown : function () {
                teardownDeprecationHandler(test, moment, 'core');
                if (lifecycle && lifecycle.teardown) {
                    lifecycle.teardown();
                }
            }
        });
    }

    function localeModule (name, lifecycle) {
        QUnit.module('locale:' + name, {
            setup : function () {
                moment.locale(name);
                moment.createFromInputFallback = function (config) {
                    throw new Error('input not handled by moment: ' + config._i);
                };
                setupDeprecationHandler(test, moment, 'locale');
                if (lifecycle && lifecycle.setup) {
                    lifecycle.setup();
                }
            },
            teardown : function () {
                moment.locale('en');
                teardownDeprecationHandler(test, moment, 'locale');
                if (lifecycle && lifecycle.teardown) {
                    lifecycle.teardown();
                }
            }
        });
        defineCommonLocaleTests(name, -1, -1);
    }

    localeModule('he');

    test('parse', function (assert) {
        var tests = '×× ×××¨ ×× ××³_×¤××¨×××¨ ×¤××¨×³_××¨×¥ ××¨×¥_××¤×¨×× ××¤×¨×³_××× ×××_××× × ××× ×_×××× ××××_×××××¡× ××××³_×¡×¤××××¨ ×¡×¤××³_×××§××××¨ ×××§×³_× ×××××¨ × ×××³_××¦×××¨ ××¦××³'.split('_'), i;
        function equalTest(input, mmm, i) {
            assert.equal(moment(input, mmm).month(), i, input + ' should be month ' + (i + 1));
        }
        for (i = 0; i < 12; i++) {
            tests[i] = tests[i].split(' ');
            equalTest(tests[i][0], 'MMM', i);
            equalTest(tests[i][1], 'MMM', i);
            equalTest(tests[i][0], 'MMMM', i);
            equalTest(tests[i][1], 'MMMM', i);
            equalTest(tests[i][0].toLocaleLowerCase(), 'MMMM', i);
            equalTest(tests[i][1].toLocaleLowerCase(), 'MMMM', i);
            equalTest(tests[i][0].toLocaleUpperCase(), 'MMMM', i);
            equalTest(tests[i][1].toLocaleUpperCase(), 'MMMM', i);
        }
    });

    test('format', function (assert) {
        var a = [
                ['dddd, MMMM Do YYYY, h:mm:ss a',      '×¨××©××, ×¤××¨×××¨ 14 2010, 3:25:50 ×××"×¦'],
                ['ddd, h A',                           '××³, 3 ×××¨× ××¦××¨×××'],
                ['M Mo MM MMMM MMM',                   '2 2 02 ×¤××¨×××¨ ×¤××¨×³'],
                ['YYYY YY',                            '2010 10'],
                ['D Do DD',                            '14 14 14'],
                ['d do dddd ddd dd',                   '0 0 ×¨××©×× ××³ ×'],
                ['DDD DDDo DDDD',                      '45 45 045'],
                ['w wo ww',                            '8 8 08'],
                ['h hh',                               '3 03'],
                ['H HH',                               '15 15'],
                ['m mm',                               '25 25'],
                ['s ss',                               '50 50'],
                ['a A',                                '×××"×¦ ×××¨× ××¦××¨×××'],
                ['[the] DDDo [day of the year]',       'the 45 day of the year'],
                ['LTS',                                '15:25:50'],
                ['L',                                  '14/02/2010'],
                ['LL',                                 '14 ××¤××¨×××¨ 2010'],
                ['LLL',                                '14 ××¤××¨×××¨ 2010 15:25'],
                ['LLLL',                               '×¨××©××, 14 ××¤××¨×××¨ 2010 15:25'],
                ['l',                                  '14/2/2010'],
                ['ll',                                 '14 ×¤××¨×³ 2010'],
                ['lll',                                '14 ×¤××¨×³ 2010 15:25'],
                ['llll',                               '××³, 14 ×¤××¨×³ 2010 15:25']
            ],
            b = moment(new Date(2010, 1, 14, 15, 25, 50, 125)),
            i;
        for (i = 0; i < a.length; i++) {
            assert.equal(b.format(a[i][0]), a[i][1], a[i][0] + ' ---> ' + a[i][1]);
        }
    });

    test('format month', function (assert) {
        var expected = '×× ×××¨ ×× ××³_×¤××¨×××¨ ×¤××¨×³_××¨×¥ ××¨×¥_××¤×¨×× ××¤×¨×³_××× ×××_××× × ××× ×_×××× ××××_×××××¡× ××××³_×¡×¤××××¨ ×¡×¤××³_×××§××××¨ ×××§×³_× ×××××¨ × ×××³_××¦×××¨ ××¦××³'.split('_'), i;
        for (i = 0; i < expected.length; i++) {
            assert.equal(moment([2011, i, 1]).format('MMMM MMM'), expected[i], expected[i]);
        }
    });

    test('format week', function (assert) {
        var expected = '×¨××©×× ××³ ×|×©× × ××³ ×|×©×××©× ××³ ×|×¨×××¢× ××³ ×|××××©× ××³ ×|×©××©× ××³ ×|×©××ª ×©×³ ×©'.split('|'), i;
        for (i = 0; i < expected.length; i++) {
            assert.equal(moment([2011, 0, 2 + i]).format('dddd ddd dd'), expected[i], expected[i]);
        }
    });

    test('from', function (assert) {
        var start = moment([2007, 1, 28]);
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 44}), true),  '××¡×¤×¨ ×©× ×××ª', '44 seconds = a few seconds');
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 45}), true),  '××§×',      '45 seconds = a minute');
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 89}), true),  '××§×',      '89 seconds = a minute');
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 90}), true),  '2 ××§××ª',     '90 seconds = 2 minutes');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 44}), true),  '44 ××§××ª',    '44 minutes = 44 minutes');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 45}), true),  '×©×¢×',       '45 minutes = an hour');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 89}), true),  '×©×¢×',       '89 minutes = an hour');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 90}), true),  '×©×¢×ª×××',       '90 minutes = 2 hours');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 5}), true),   '5 ×©×¢××ª',       '5 hours = 5 hours');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 21}), true),  '21 ×©×¢××ª',      '21 hours = 21 hours');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 22}), true),  '×××',         '22 hours = a day');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 35}), true),  '×××',         '35 hours = a day');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 36}), true),  '××××××',        '36 hours = 2 days');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 1}), true),   '×××',         '1 day = a day');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 5}), true),   '5 ××××',        '5 days = 5 days');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 25}), true),  '25 ××××',       '25 days = 25 days');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 26}), true),  '××××©',       '26 days = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 30}), true),  '××××©',       '30 days = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 43}), true),  '××××©',       '43 days = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 46}), true),  '××××©×××',      '46 days = 2 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 74}), true),  '××××©×××',      '75 days = 2 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 76}), true),  '3 ××××©××',      '76 days = 3 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({M: 1}), true),   '××××©',       '1 month = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({M: 5}), true),   '5 ××××©××',      '5 months = 5 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 345}), true), '×©× ×',        '345 days = a year');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 548}), true), '×©× ×ª×××',       '548 days = 2 years');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 3699}), true), '10 ×©× ××',        '345 days = 10 years');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 7340}), true), '20 ×©× ×',       '548 days = 20 years');
        assert.equal(start.from(moment([2007, 1, 28]).add({y: 1}), true),   '×©× ×',        '1 year = a year');
        assert.equal(start.from(moment([2007, 1, 28]).add({y: 5}), true),   '5 ×©× ××',       '5 years = 5 years');
    });

    test('suffix', function (assert) {
        assert.equal(moment(30000).from(0), '××¢×× ××¡×¤×¨ ×©× ×××ª',  'prefix');
        assert.equal(moment(0).from(30000), '××¤× × ××¡×¤×¨ ×©× ×××ª', 'suffix');
    });

    test('now from now', function (assert) {
        assert.equal(moment().fromNow(), '××¤× × ××¡×¤×¨ ×©× ×××ª',  'now from now should display as in the past');
    });

    test('fromNow', function (assert) {
        assert.equal(moment().add({s: 30}).fromNow(), '××¢×× ××¡×¤×¨ ×©× ×××ª', 'in a few seconds');
        assert.equal(moment().add({d: 5}).fromNow(), '××¢×× 5 ××××', 'in 5 days');
    });

    test('calendar day', function (assert) {
        var a = moment().hours(12).minutes(0).seconds(0);

        assert.equal(moment(a).calendar(),                   '×××× ×Ö¾12:00',   'today at the same time');
        assert.equal(moment(a).add({m: 25}).calendar(),      '×××× ×Ö¾12:25',   'Now plus 25 min');
        assert.equal(moment(a).add({h: 1}).calendar(),       '×××× ×Ö¾13:00',   'Now plus 1 hour');
        assert.equal(moment(a).add({d: 1}).calendar(),       '×××¨ ×Ö¾12:00',   'tomorrow at the same time');
        assert.equal(moment(a).subtract({h: 1}).calendar(),  '×××× ×Ö¾11:00',   'Now minus 1 hour');
        assert.equal(moment(a).subtract({d: 1}).calendar(),  '××ª××× ×Ö¾12:00',  'yesterday at the same time');
    });

    test('calendar next week', function (assert) {
        var i, m;
        for (i = 2; i < 7; i++) {
            m = moment().add({d: i});
            assert.equal(m.calendar(),       m.format('dddd [××©×¢×] LT'),  'Today + ' + i + ' days current time');
            m.hours(0).minutes(0).seconds(0).milliseconds(0);
            assert.equal(m.calendar(),       m.format('dddd [××©×¢×] LT'),  'Today + ' + i + ' days beginning of day');
            m.hours(23).minutes(59).seconds(59).milliseconds(999);
            assert.equal(m.calendar(),       m.format('dddd [××©×¢×] LT'),  'Today + ' + i + ' days end of day');
        }
    });

    test('calendar last week', function (assert) {
        var i, m;
        for (i = 2; i < 7; i++) {
            m = moment().subtract({d: i});
            assert.equal(m.calendar(),       m.format('[××××] dddd [××××¨×× ××©×¢×] LT'),  'Today - ' + i + ' days current time');
            m.hours(0).minutes(0).seconds(0).milliseconds(0);
            assert.equal(m.calendar(),       m.format('[××××] dddd [××××¨×× ××©×¢×] LT'),  'Today - ' + i + ' days beginning of day');
            m.hours(23).minutes(59).seconds(59).milliseconds(999);
            assert.equal(m.calendar(),       m.format('[××××] dddd [××××¨×× ××©×¢×] LT'),  'Today - ' + i + ' days end of day');
        }
    });

    test('calendar all else', function (assert) {
        var weeksAgo = moment().subtract({w: 1}),
            weeksFromNow = moment().add({w: 1});

        assert.equal(weeksAgo.calendar(),       weeksAgo.format('L'),  '1 week ago');
        assert.equal(weeksFromNow.calendar(),   weeksFromNow.format('L'),  'in 1 week');

        weeksAgo = moment().subtract({w: 2});
        weeksFromNow = moment().add({w: 2});

        assert.equal(weeksAgo.calendar(),       weeksAgo.format('L'),  '2 weeks ago');
        assert.equal(weeksFromNow.calendar(),   weeksFromNow.format('L'),  'in 2 weeks');
    });

    test('weeks year starting sunday format', function (assert) {
        assert.equal(moment([2012, 0,  1]).format('w ww wo'), '1 01 1', 'Jan  1 2012 should be week 1');
        assert.equal(moment([2012, 0,  7]).format('w ww wo'), '1 01 1', 'Jan  7 2012 should be week 1');
        assert.equal(moment([2012, 0,  8]).format('w ww wo'), '2 02 2', 'Jan  8 2012 should be week 2');
        assert.equal(moment([2012, 0, 14]).format('w ww wo'), '2 02 2', 'Jan 14 2012 should be week 2');
        assert.equal(moment([2012, 0, 15]).format('w ww wo'), '3 03 3', 'Jan 15 2012 should be week 3');
    });

}));

;(function (global, factory) {
   typeof exports === 'object' && typeof module !== 'undefined'
       && typeof require === 'function' ? factory(require('../../moment')) :
   typeof define === 'function' && define.amd ? define(['../../moment'], factory) :
   factory(global.moment)
}(this, function (moment) { 'use strict';

    function each(array, callback) {
        var i;
        for (i = 0; i < array.length; i++) {
            callback(array[i], i, array);
        }
    }

    function objectKeys(obj) {
        if (Object.keys) {
            return Object.keys(obj);
        } else {
            // IE8
            var res = [], i;
            for (i in obj) {
                if (obj.hasOwnProperty(i)) {
                    res.push(i);
                }
            }
            return res;
        }
    }

    // Pick the first defined of two or three arguments.
    function defaults(a, b, c) {
        if (a != null) {
            return a;
        }
        if (b != null) {
            return b;
        }
        return c;
    }

    function defineCommonLocaleTests(locale, options) {
        test('lenient ordinal parsing', function (assert) {
            var i, ordinalStr, testMoment;
            for (i = 1; i <= 31; ++i) {
                ordinalStr = moment([2014, 0, i]).format('YYYY MM Do');
                testMoment = moment(ordinalStr, 'YYYY MM Do');
                assert.equal(testMoment.year(), 2014,
                        'lenient ordinal parsing ' + i + ' year check');
                assert.equal(testMoment.month(), 0,
                        'lenient ordinal parsing ' + i + ' month check');
                assert.equal(testMoment.date(), i,
                        'lenient ordinal parsing ' + i + ' date check');
            }
        });

        test('lenient ordinal parsing of number', function (assert) {
            var i, testMoment;
            for (i = 1; i <= 31; ++i) {
                testMoment = moment('2014 01 ' + i, 'YYYY MM Do');
                assert.equal(testMoment.year(), 2014,
                        'lenient ordinal parsing of number ' + i + ' year check');
                assert.equal(testMoment.month(), 0,
                        'lenient ordinal parsing of number ' + i + ' month check');
                assert.equal(testMoment.date(), i,
                        'lenient ordinal parsing of number ' + i + ' date check');
            }
        });

        test('strict ordinal parsing', function (assert) {
            var i, ordinalStr, testMoment;
            for (i = 1; i <= 31; ++i) {
                ordinalStr = moment([2014, 0, i]).format('YYYY MM Do');
                testMoment = moment(ordinalStr, 'YYYY MM Do', true);
                assert.ok(testMoment.isValid(), 'strict ordinal parsing ' + i);
            }
        });

        test('meridiem invariant', function (assert) {
            var h, m, t1, t2;
            for (h = 0; h < 24; ++h) {
                for (m = 0; m < 60; m += 15) {
                    t1 = moment.utc([2000, 0, 1, h, m]);
                    t2 = moment.utc(t1.format('A h:mm'), 'A h:mm');
                    assert.equal(t2.format('HH:mm'), t1.format('HH:mm'),
                            'meridiem at ' + t1.format('HH:mm'));
                }
            }
        });

        test('date format correctness', function (assert) {
            var data, tokens;
            data = moment.localeData()._longDateFormat;
            tokens = objectKeys(data);
            each(tokens, function (srchToken) {
                // Check each format string to make sure it does not contain any
                // tokens that need to be expanded.
                each(tokens, function (baseToken) {
                    // strip escaped sequences
                    var format = data[baseToken].replace(/(\[[^\]]*\])/g, '');
                    assert.equal(false, !!~format.indexOf(srchToken),
                            'contains ' + srchToken + ' in ' + baseToken);
                });
            });
        });

        test('month parsing correctness', function (assert) {
            var i, m;

            if (locale === 'tr') {
                // I can't fix it :(
                expect(0);
                return;
            }
            function tester(format) {
                var r;
                r = moment(m.format(format), format);
                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format);
                r = moment(m.format(format).toLocaleUpperCase(), format);
                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' upper');
                r = moment(m.format(format).toLocaleLowerCase(), format);
                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' lower');

                r = moment(m.format(format), format, true);
                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' strict');
                r = moment(m.format(format).toLocaleUpperCase(), format, true);
                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' upper strict');
                r = moment(m.format(format).toLocaleLowerCase(), format, true);
                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' lower strict');
            }

            for (i = 0; i < 12; ++i) {
                m = moment([2015, i, 15, 18]);
                tester('MMM');
                tester('MMM.');
                tester('MMMM');
                tester('MMMM.');
            }
        });

        test('weekday parsing correctness', function (assert) {
            var i, m;

            if (locale === 'tr' || locale === 'az') {
                // There is a lower-case letter (Ä±), that converted to upper then
                // lower changes to i
                expect(0);
                return;
            }
            function tester(format) {
                var r, baseMsg = 'weekday ' + m.weekday() + ' fmt ' + format;
                r = moment(m.format(format), format);
                assert.equal(r.weekday(), m.weekday(), baseMsg);
                r = moment(m.format(format).toLocaleUpperCase(), format);
                assert.equal(r.weekday(), m.weekday(), baseMsg + ' upper');
                r = moment(m.format(format).toLocaleLowerCase(), format);
                assert.equal(r.weekday(), m.weekday(), baseMsg + ' lower');

                r = moment(m.format(format), format, true);
                assert.equal(r.weekday(), m.weekday(), baseMsg + ' strict');
                r = moment(m.format(format).toLocaleUpperCase(), format, true);
                assert.equal(r.weekday(), m.weekday(), baseMsg + ' upper strict');
                r = moment(m.format(format).toLocaleLowerCase(), format, true);
                assert.equal(r.weekday(), m.weekday(), baseMsg + ' lower strict');
            }

            for (i = 0; i < 7; ++i) {
                m = moment.utc([2015, i, 15, 18]);
                tester('dd');
                tester('ddd');
                tester('dddd');
            }
        });
    }

    function setupDeprecationHandler(test, moment, scope) {
        test._expectedDeprecations = null;
        test._observedDeprecations = null;
        test._oldSupress = moment.suppressDeprecationWarnings;
        moment.suppressDeprecationWarnings = true;
        test.expectedDeprecations = function () {
            test._expectedDeprecations = arguments;
            test._observedDeprecations = [];
        };
        moment.deprecationHandler = function (name, msg) {
            var deprecationId = matchedDeprecation(name, msg, test._expectedDeprecations);
            if (deprecationId === -1) {
                throw new Error('Unexpected deprecation thrown name=' +
                        name + ' msg=' + msg);
            }
            test._observedDeprecations[deprecationId] = 1;
        };
    }

    function teardownDeprecationHandler(test, moment, scope) {
        moment.suppressDeprecationWarnings = test._oldSupress;

        if (test._expectedDeprecations != null) {
            var missedDeprecations = [];
            each(test._expectedDeprecations, function (deprecationPattern, id) {
                if (test._observedDeprecations[id] !== 1) {
                    missedDeprecations.push(deprecationPattern);
                }
            });
            if (missedDeprecations.length !== 0) {
                throw new Error('Expected deprecation warnings did not happen: ' +
                        missedDeprecations.join(' '));
            }
        }
    }

    function matchedDeprecation(name, msg, deprecations) {
        if (deprecations == null) {
            return -1;
        }
        for (var i = 0; i < deprecations.length; ++i) {
            if (name != null && name === deprecations[i]) {
                return i;
            }
            if (msg != null && msg.substring(0, deprecations[i].length) === deprecations[i]) {
                return i;
            }
        }
        return -1;
    }

    /*global QUnit:false*/

    var test = QUnit.test;

    var expect = QUnit.expect;

    function module (name, lifecycle) {
        QUnit.module(name, {
            setup : function () {
                moment.locale('en');
                moment.createFromInputFallback = function (config) {
                    throw new Error('input not handled by moment: ' + config._i);
                };
                setupDeprecationHandler(test, moment, 'core');
                if (lifecycle && lifecycle.setup) {
                    lifecycle.setup();
                }
            },
            teardown : function () {
                teardownDeprecationHandler(test, moment, 'core');
                if (lifecycle && lifecycle.teardown) {
                    lifecycle.teardown();
                }
            }
        });
    }

    function localeModule (name, lifecycle) {
        QUnit.module('locale:' + name, {
            setup : function () {
                moment.locale(name);
                moment.createFromInputFallback = function (config) {
                    throw new Error('input not handled by moment: ' + config._i);
                };
                setupDeprecationHandler(test, moment, 'locale');
                if (lifecycle && lifecycle.setup) {
                    lifecycle.setup();
                }
            },
            teardown : function () {
                moment.locale('en');
                teardownDeprecationHandler(test, moment, 'locale');
                if (lifecycle && lifecycle.teardown) {
                    lifecycle.teardown();
                }
            }
        });
        defineCommonLocaleTests(name, -1, -1);
    }

    localeModule('hi');

    test('parse', function (assert) {
        var tests = 'à¤à¤¨à¤µà¤°à¥ à¤à¤¨._à¤«à¤¼à¤°à¤µà¤°à¥ à¤«à¤¼à¤°._à¤®à¤¾à¤°à¥à¤ à¤®à¤¾à¤°à¥à¤_à¤à¤ªà¥à¤°à¥à¤² à¤à¤ªà¥à¤°à¥._à¤®à¤ à¤®à¤_à¤à¥à¤¨ à¤à¥à¤¨_à¤à¥à¤²à¤¾à¤ à¤à¥à¤²._à¤à¤à¤¸à¥à¤¤ à¤à¤._à¤¸à¤¿à¤¤à¤®à¥à¤¬à¤° à¤¸à¤¿à¤¤._à¤à¤à¥à¤à¥à¤¬à¤° à¤à¤à¥à¤à¥._à¤¨à¤µà¤®à¥à¤¬à¤° à¤¨à¤µ._à¤¦à¤¿à¤¸à¤®à¥à¤¬à¤° à¤¦à¤¿à¤¸.'.split('_'), i;
        function equalTest(input, mmm, i) {
            assert.equal(moment(input, mmm).month(), i, input + ' should be month ' + (i + 1));
        }
        for (i = 0; i < 12; i++) {
            tests[i] = tests[i].split(' ');
            equalTest(tests[i][0], 'MMM', i);
            equalTest(tests[i][1], 'MMM', i);
            equalTest(tests[i][0], 'MMMM', i);
            equalTest(tests[i][1], 'MMMM', i);
            equalTest(tests[i][0].toLocaleLowerCase(), 'MMMM', i);
            equalTest(tests[i][1].toLocaleLowerCase(), 'MMMM', i);
            equalTest(tests[i][0].toLocaleUpperCase(), 'MMMM', i);
            equalTest(tests[i][1].toLocaleUpperCase(), 'MMMM', i);
        }
    });

    test('format', function (assert) {
        var a = [
                ['dddd, Do MMMM YYYY, a h:mm:ss à¤¬à¤à¥',  'à¤°à¤µà¤¿à¤µà¤¾à¤°, à¥§à¥ª à¤«à¤¼à¤°à¤µà¤°à¥ à¥¨à¥¦à¥§à¥¦, à¤¦à¥à¤ªà¤¹à¤° à¥©:à¥¨à¥«:à¥«à¥¦ à¤¬à¤à¥'],
                ['ddd, a h à¤¬à¤à¥',                       'à¤°à¤µà¤¿, à¤¦à¥à¤ªà¤¹à¤° à¥© à¤¬à¤à¥'],
                ['M Mo MM MMMM MMM',                   'à¥¨ à¥¨ à¥¦à¥¨ à¤«à¤¼à¤°à¤µà¤°à¥ à¤«à¤¼à¤°.'],
                ['YYYY YY',                            'à¥¨à¥¦à¥§à¥¦ à¥§à¥¦'],
                ['D Do DD',                            'à¥§à¥ª à¥§à¥ª à¥§à¥ª'],
                ['d do dddd ddd dd',                   'à¥¦ à¥¦ à¤°à¤µà¤¿à¤µà¤¾à¤° à¤°à¤µà¤¿ à¤°'],
                ['DDD DDDo DDDD',                      'à¥ªà¥« à¥ªà¥« à¥¦à¥ªà¥«'],
                ['w wo ww',                            'à¥® à¥® à¥¦à¥®'],
                ['h hh',                               'à¥© à¥¦à¥©'],
                ['H HH',                               'à¥§à¥« à¥§à¥«'],
                ['m mm',                               'à¥¨à¥« à¥¨à¥«'],
                ['s ss',                               'à¥«à¥¦ à¥«à¥¦'],
                ['a A',                                'à¤¦à¥à¤ªà¤¹à¤° à¤¦à¥à¤ªà¤¹à¤°'],
                ['LTS',                                'à¤¦à¥à¤ªà¤¹à¤° à¥©:à¥¨à¥«:à¥«à¥¦ à¤¬à¤à¥'],
                ['L',                                  'à¥§à¥ª/à¥¦à¥¨/à¥¨à¥¦à¥§à¥¦'],
                ['LL',                                 'à¥§à¥ª à¤«à¤¼à¤°à¤µà¤°à¥ à¥¨à¥¦à¥§à¥¦'],
                ['LLL',                                'à¥§à¥ª à¤«à¤¼à¤°à¤µà¤°à¥ à¥¨à¥¦à¥§à¥¦, à¤¦à¥à¤ªà¤¹à¤° à¥©:à¥¨à¥« à¤¬à¤à¥'],
                ['LLLL',                               'à¤°à¤µà¤¿à¤µà¤¾à¤°, à¥§à¥ª à¤«à¤¼à¤°à¤µà¤°à¥ à¥¨à¥¦à¥§à¥¦, à¤¦à¥à¤ªà¤¹à¤° à¥©:à¥¨à¥« à¤¬à¤à¥'],
                ['l',                                  'à¥§à¥ª/à¥¨/à¥¨à¥¦à¥§à¥¦'],
                ['ll',                                 'à¥§à¥ª à¤«à¤¼à¤°. à¥¨à¥¦à¥§à¥¦'],
                ['lll',                                'à¥§à¥ª à¤«à¤¼à¤°. à¥¨à¥¦à¥§à¥¦, à¤¦à¥à¤ªà¤¹à¤° à¥©:à¥¨à¥« à¤¬à¤à¥'],
                ['llll',                               'à¤°à¤µà¤¿, à¥§à¥ª à¤«à¤¼à¤°. à¥¨à¥¦à¥§à¥¦, à¤¦à¥à¤ªà¤¹à¤° à¥©:à¥¨à¥« à¤¬à¤à¥']
            ],
            b = moment(new Date(2010, 1, 14, 15, 25, 50, 125)),
            i;
        for (i = 0; i < a.length; i++) {
            assert.equal(b.format(a[i][0]), a[i][1], a[i][0] + ' ---> ' + a[i][1]);
        }
    });

    test('format ordinal', function (assert) {
        assert.equal(moment([2011, 0, 1]).format('DDDo'), 'à¥§', 'à¥§');
        assert.equal(moment([2011, 0, 2]).format('DDDo'), 'à¥¨', 'à¥¨');
        assert.equal(moment([2011, 0, 3]).format('DDDo'), 'à¥©', 'à¥©');
        assert.equal(moment([2011, 0, 4]).format('DDDo'), 'à¥ª', 'à¥ª');
        assert.equal(moment([2011, 0, 5]).format('DDDo'), 'à¥«', 'à¥«');
        assert.equal(moment([2011, 0, 6]).format('DDDo'), 'à¥¬', 'à¥¬');
        assert.equal(moment([2011, 0, 7]).format('DDDo'), 'à¥­', 'à¥­');
        assert.equal(moment([2011, 0, 8]).format('DDDo'), 'à¥®', 'à¥®');
        assert.equal(moment([2011, 0, 9]).format('DDDo'), 'à¥¯', 'à¥¯');
        assert.equal(moment([2011, 0, 10]).format('DDDo'), 'à¥§à¥¦', 'à¥§à¥¦');

        assert.equal(moment([2011, 0, 11]).format('DDDo'), 'à¥§à¥§', 'à¥§à¥§');
        assert.equal(moment([2011, 0, 12]).format('DDDo'), 'à¥§à¥¨', 'à¥§à¥¨');
        assert.equal(moment([2011, 0, 13]).format('DDDo'), 'à¥§à¥©', 'à¥§à¥©');
        assert.equal(moment([2011, 0, 14]).format('DDDo'), 'à¥§à¥ª', 'à¥§à¥ª');
        assert.equal(moment([2011, 0, 15]).format('DDDo'), 'à¥§à¥«', 'à¥§à¥«');
        assert.equal(moment([2011, 0, 16]).format('DDDo'), 'à¥§à¥¬', 'à¥§à¥¬');
        assert.equal(moment([2011, 0, 17]).format('DDDo'), 'à¥§à¥­', 'à¥§à¥­');
        assert.equal(moment([2011, 0, 18]).format('DDDo'), 'à¥§à¥®', 'à¥§à¥®');
        assert.equal(moment([2011, 0, 19]).format('DDDo'), 'à¥§à¥¯', 'à¥§à¥¯');
        assert.equal(moment([2011, 0, 20]).format('DDDo'), 'à¥¨à¥¦', 'à¥¨à¥¦');

        assert.equal(moment([2011, 0, 21]).format('DDDo'), 'à¥¨à¥§', 'à¥¨à¥§');
        assert.equal(moment([2011, 0, 22]).format('DDDo'), 'à¥¨à¥¨', 'à¥¨à¥¨');
        assert.equal(moment([2011, 0, 23]).format('DDDo'), 'à¥¨à¥©', 'à¥¨à¥©');
        assert.equal(moment([2011, 0, 24]).format('DDDo'), 'à¥¨à¥ª', 'à¥¨à¥ª');
        assert.equal(moment([2011, 0, 25]).format('DDDo'), 'à¥¨à¥«', 'à¥¨à¥«');
        assert.equal(moment([2011, 0, 26]).format('DDDo'), 'à¥¨à¥¬', 'à¥¨à¥¬');
        assert.equal(moment([2011, 0, 27]).format('DDDo'), 'à¥¨à¥­', 'à¥¨à¥­');
        assert.equal(moment([2011, 0, 28]).format('DDDo'), 'à¥¨à¥®', 'à¥¨à¥®');
        assert.equal(moment([2011, 0, 29]).format('DDDo'), 'à¥¨à¥¯', 'à¥¨à¥¯');
        assert.equal(moment([2011, 0, 30]).format('DDDo'), 'à¥©à¥¦', 'à¥©à¥¦');

        assert.equal(moment([2011, 0, 31]).format('DDDo'), 'à¥©à¥§', 'à¥©à¥§');
    });

    test('format month', function (assert) {
        var expected = 'à¤à¤¨à¤µà¤°à¥ à¤à¤¨._à¤«à¤¼à¤°à¤µà¤°à¥ à¤«à¤¼à¤°._à¤®à¤¾à¤°à¥à¤ à¤®à¤¾à¤°à¥à¤_à¤à¤ªà¥à¤°à¥à¤² à¤à¤ªà¥à¤°à¥._à¤®à¤ à¤®à¤_à¤à¥à¤¨ à¤à¥à¤¨_à¤à¥à¤²à¤¾à¤ à¤à¥à¤²._à¤à¤à¤¸à¥à¤¤ à¤à¤._à¤¸à¤¿à¤¤à¤®à¥à¤¬à¤° à¤¸à¤¿à¤¤._à¤à¤à¥à¤à¥à¤¬à¤° à¤à¤à¥à¤à¥._à¤¨à¤µà¤®à¥à¤¬à¤° à¤¨à¤µ._à¤¦à¤¿à¤¸à¤®à¥à¤¬à¤° à¤¦à¤¿à¤¸.'.split('_'), i;
        for (i = 0; i < expected.length; i++) {
            assert.equal(moment([2011, i, 1]).format('MMMM MMM'), expected[i], expected[i]);
        }
    });

    test('format week', function (assert) {
        var expected = 'à¤°à¤µà¤¿à¤µà¤¾à¤° à¤°à¤µà¤¿ à¤°_à¤¸à¥à¤®à¤µà¤¾à¤° à¤¸à¥à¤® à¤¸à¥_à¤®à¤à¤à¤²à¤µà¤¾à¤° à¤®à¤à¤à¤² à¤®à¤_à¤¬à¥à¤§à¤µà¤¾à¤° à¤¬à¥à¤§ à¤¬à¥_à¤à¥à¤°à¥à¤µà¤¾à¤° à¤à¥à¤°à¥ à¤à¥_à¤¶à¥à¤à¥à¤°à¤µà¤¾à¤° à¤¶à¥à¤à¥à¤° à¤¶à¥_à¤¶à¤¨à¤¿à¤µà¤¾à¤° à¤¶à¤¨à¤¿ à¤¶'.split('_'), i;
        for (i = 0; i < expected.length; i++) {
            assert.equal(moment([2011, 0, 2 + i]).format('dddd ddd dd'), expected[i], expected[i]);
        }
    });

    test('from', function (assert) {
        var start = moment([2007, 1, 28]);
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 44}), true),  'à¤à¥à¤ à¤¹à¥ à¤à¥à¤·à¤£', '44 seconds = a few seconds');
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 45}), true),  'à¤à¤ à¤®à¤¿à¤¨à¤',      '45 seconds = a minute');
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 89}), true),  'à¤à¤ à¤®à¤¿à¤¨à¤',      '89 seconds = a minute');
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 90}), true),  'à¥¨ à¤®à¤¿à¤¨à¤',     '90 seconds = 2 minutes');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 44}), true),  'à¥ªà¥ª à¤®à¤¿à¤¨à¤',    '44 minutes = 44 minutes');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 45}), true),  'à¤à¤ à¤à¤à¤à¤¾',       '45 minutes = an hour');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 89}), true),  'à¤à¤ à¤à¤à¤à¤¾',       '89 minutes = an hour');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 90}), true),  'à¥¨ à¤à¤à¤à¥',       '90 minutes = 2 hours');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 5}), true),   'à¥« à¤à¤à¤à¥',       '5 hours = 5 hours');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 21}), true),  'à¥¨à¥§ à¤à¤à¤à¥',      '21 hours = 21 hours');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 22}), true),  'à¤à¤ à¤¦à¤¿à¤¨',         '22 hours = a day');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 35}), true),  'à¤à¤ à¤¦à¤¿à¤¨',         '35 hours = a day');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 36}), true),  'à¥¨ à¤¦à¤¿à¤¨',        '36 hours = 2 days');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 1}), true),   'à¤à¤ à¤¦à¤¿à¤¨',         '1 day = a day');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 5}), true),   'à¥« à¤¦à¤¿à¤¨',        '5 days = 5 days');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 25}), true),  'à¥¨à¥« à¤¦à¤¿à¤¨',       '25 days = 25 days');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 26}), true),  'à¤à¤ à¤®à¤¹à¥à¤¨à¥',       '26 days = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 30}), true),  'à¤à¤ à¤®à¤¹à¥à¤¨à¥',       '30 days = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 43}), true),  'à¤à¤ à¤®à¤¹à¥à¤¨à¥',       '43 days = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 46}), true),  'à¥¨ à¤®à¤¹à¥à¤¨à¥',      '46 days = 2 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 74}), true),  'à¥¨ à¤®à¤¹à¥à¤¨à¥',      '75 days = 2 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 76}), true),  'à¥© à¤®à¤¹à¥à¤¨à¥',      '76 days = 3 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({M: 1}), true),   'à¤à¤ à¤®à¤¹à¥à¤¨à¥',       '1 month = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({M: 5}), true),   'à¥« à¤®à¤¹à¥à¤¨à¥',      '5 months = 5 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 345}), true), 'à¤à¤ à¤µà¤°à¥à¤·',        '345 days = a year');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 548}), true), 'à¥¨ à¤µà¤°à¥à¤·',       '548 days = 2 years');
        assert.equal(start.from(moment([2007, 1, 28]).add({y: 1}), true),   'à¤à¤ à¤µà¤°à¥à¤·',        '1 year = a year');
        assert.equal(start.from(moment([2007, 1, 28]).add({y: 5}), true),   'à¥« à¤µà¤°à¥à¤·',       '5 years = 5 years');
    });

    test('suffix', function (assert) {
        assert.equal(moment(30000).from(0), 'à¤à¥à¤ à¤¹à¥ à¤à¥à¤·à¤£ à¤®à¥à¤',  'prefix');
        assert.equal(moment(0).from(30000), 'à¤à¥à¤ à¤¹à¥ à¤à¥à¤·à¤£ à¤ªà¤¹à¤²à¥', 'suffix');
    });

    test('now from now', function (assert) {
        assert.equal(moment().fromNow(), 'à¤à¥à¤ à¤¹à¥ à¤à¥à¤·à¤£ à¤ªà¤¹à¤²à¥',  'now from now should display as in the past');
    });

    test('fromNow', function (assert) {
        assert.equal(moment().add({s: 30}).fromNow(), 'à¤à¥à¤ à¤¹à¥ à¤à¥à¤·à¤£ à¤®à¥à¤', 'à¤à¥à¤ à¤¹à¥ à¤à¥à¤·à¤£ à¤®à¥à¤');
        assert.equal(moment().add({d: 5}).fromNow(), 'à¥« à¤¦à¤¿à¤¨ à¤®à¥à¤', 'à¥« à¤¦à¤¿à¤¨ à¤®à¥à¤');
    });

    test('calendar day', function (assert) {
        var a = moment().hours(12).minutes(0).seconds(0);

        assert.equal(moment(a).calendar(),                   'à¤à¤ à¤¦à¥à¤ªà¤¹à¤° à¥§à¥¨:à¥¦à¥¦ à¤¬à¤à¥',    'today at the same time');
        assert.equal(moment(a).add({m: 25}).calendar(),      'à¤à¤ à¤¦à¥à¤ªà¤¹à¤° à¥§à¥¨:à¥¨à¥« à¤¬à¤à¥',    'Now plus 25 min');
        assert.equal(moment(a).add({h: 3}).calendar(),       'à¤à¤ à¤¦à¥à¤ªà¤¹à¤° à¥©:à¥¦à¥¦ à¤¬à¤à¥',     'Now plus 3 hours');
        assert.equal(moment(a).add({d: 1}).calendar(),       'à¤à¤² à¤¦à¥à¤ªà¤¹à¤° à¥§à¥¨:à¥¦à¥¦ à¤¬à¤à¥',    'tomorrow at the same time');
        assert.equal(moment(a).subtract({h: 1}).calendar(),  'à¤à¤ à¤¦à¥à¤ªà¤¹à¤° à¥§à¥§:à¥¦à¥¦ à¤¬à¤à¥',    'Now minus 1 hour');
        assert.equal(moment(a).subtract({d: 1}).calendar(),  'à¤à¤² à¤¦à¥à¤ªà¤¹à¤° à¥§à¥¨:à¥¦à¥¦ à¤¬à¤à¥',    'yesterday at the same time');
    });

    test('calendar next week', function (assert) {
        var i, m;
        for (i = 2; i < 7; i++) {
            m = moment().add({d: i});
            assert.equal(m.calendar(),       m.format('dddd[,] LT'),  'Today + ' + i + ' days current time');
            m.hours(0).minutes(0).seconds(0).milliseconds(0);
            assert.equal(m.calendar(),       m.format('dddd[,] LT'),  'Today + ' + i + ' days beginning of day');
            m.hours(23).minutes(59).seconds(59).milliseconds(999);
            assert.equal(m.calendar(),       m.format('dddd[,] LT'),  'Today + ' + i + ' days end of day');
        }
    });

    test('calendar last week', function (assert) {
        var i, m;

        for (i = 2; i < 7; i++) {
            m = moment().subtract({d: i});
            assert.equal(m.calendar(),       m.format('[à¤ªà¤¿à¤à¤²à¥] dddd[,] LT'),  'Today - ' + i + ' days current time');
            m.hours(0).minutes(0).seconds(0).milliseconds(0);
            assert.equal(m.calendar(),       m.format('[à¤ªà¤¿à¤à¤²à¥] dddd[,] LT'),  'Today - ' + i + ' days beginning of day');
            m.hours(23).minutes(59).seconds(59).milliseconds(999);
            assert.equal(m.calendar(),       m.format('[à¤ªà¤¿à¤à¤²à¥] dddd[,] LT'),  'Today - ' + i + ' days end of day');
        }
    });

    test('calendar all else', function (assert) {
        var weeksAgo = moment().subtract({w: 1}),
            weeksFromNow = moment().add({w: 1});

        assert.equal(weeksAgo.calendar(),       weeksAgo.format('L'),  '1 week ago');
        assert.equal(weeksFromNow.calendar(),   weeksFromNow.format('L'),  'in 1 week');

        weeksAgo = moment().subtract({w: 2});
        weeksFromNow = moment().add({w: 2});

        assert.equal(weeksAgo.calendar(),       weeksAgo.format('L'),  '2 weeks ago');
        assert.equal(weeksFromNow.calendar(),   weeksFromNow.format('L'),  'in 2 weeks');
    });

    test('meridiem', function (assert) {
        assert.equal(moment([2011, 2, 23,  2, 30]).format('a'), 'à¤°à¤¾à¤¤', 'before dawn');
        assert.equal(moment([2011, 2, 23,  9, 30]).format('a'), 'à¤¸à¥à¤¬à¤¹', 'morning');
        assert.equal(moment([2011, 2, 23, 14, 30]).format('a'), 'à¤¦à¥à¤ªà¤¹à¤°', 'during day');
        assert.equal(moment([2011, 2, 23, 17, 30]).format('a'), 'à¤¶à¤¾à¤®', 'evening');
        assert.equal(moment([2011, 2, 23, 19, 30]).format('a'), 'à¤¶à¤¾à¤®', 'late evening');
        assert.equal(moment([2011, 2, 23, 21, 20]).format('a'), 'à¤°à¤¾à¤¤', 'night');

        assert.equal(moment([2011, 2, 23,  2, 30]).format('A'), 'à¤°à¤¾à¤¤', 'before dawn');
        assert.equal(moment([2011, 2, 23,  9, 30]).format('A'), 'à¤¸à¥à¤¬à¤¹', 'morning');
        assert.equal(moment([2011, 2, 23, 14, 30]).format('A'), 'à¤¦à¥à¤ªà¤¹à¤°', ' during day');
        assert.equal(moment([2011, 2, 23, 17, 30]).format('A'), 'à¤¶à¤¾à¤®', 'evening');
        assert.equal(moment([2011, 2, 23, 19, 30]).format('A'), 'à¤¶à¤¾à¤®', 'late evening');
        assert.equal(moment([2011, 2, 23, 21, 20]).format('A'), 'à¤°à¤¾à¤¤', 'night');
    });

    test('weeks year starting sunday formatted', function (assert) {
        assert.equal(moment([2012, 0,  1]).format('w ww wo'), 'à¥§ à¥¦à¥§ à¥§', 'Jan  1 2012 should be week 1');
        assert.equal(moment([2012, 0,  7]).format('w ww wo'), 'à¥§ à¥¦à¥§ à¥§', 'Jan  7 2012 should be week 1');
        assert.equal(moment([2012, 0,  8]).format('w ww wo'), 'à¥¨ à¥¦à¥¨ à¥¨', 'Jan  8 2012 should be week 2');
        assert.equal(moment([2012, 0, 14]).format('w ww wo'), 'à¥¨ à¥¦à¥¨ à¥¨', 'Jan 14 2012 should be week 2');
        assert.equal(moment([2012, 0, 15]).format('w ww wo'), 'à¥© à¥¦à¥© à¥©', 'Jan 15 2012 should be week 3');
    });

}));

;(function (global, factory) {
   typeof exports === 'object' && typeof module !== 'undefined'
       && typeof require === 'function' ? factory(require('../../moment')) :
   typeof define === 'function' && define.amd ? define(['../../moment'], factory) :
   factory(global.moment)
}(this, function (moment) { 'use strict';

    function each(array, callback) {
        var i;
        for (i = 0; i < array.length; i++) {
            callback(array[i], i, array);
        }
    }

    function objectKeys(obj) {
        if (Object.keys) {
            return Object.keys(obj);
        } else {
            // IE8
            var res = [], i;
            for (i in obj) {
                if (obj.hasOwnProperty(i)) {
                    res.push(i);
                }
            }
            return res;
        }
    }

    // Pick the first defined of two or three arguments.
    function defaults(a, b, c) {
        if (a != null) {
            return a;
        }
        if (b != null) {
            return b;
        }
        return c;
    }

    function defineCommonLocaleTests(locale, options) {
        test('lenient ordinal parsing', function (assert) {
            var i, ordinalStr, testMoment;
            for (i = 1; i <= 31; ++i) {
                ordinalStr = moment([2014, 0, i]).format('YYYY MM Do');
                testMoment = moment(ordinalStr, 'YYYY MM Do');
                assert.equal(testMoment.year(), 2014,
                        'lenient ordinal parsing ' + i + ' year check');
                assert.equal(testMoment.month(), 0,
                        'lenient ordinal parsing ' + i + ' month check');
                assert.equal(testMoment.date(), i,
                        'lenient ordinal parsing ' + i + ' date check');
            }
        });

        test('lenient ordinal parsing of number', function (assert) {
            var i, testMoment;
            for (i = 1; i <= 31; ++i) {
                testMoment = moment('2014 01 ' + i, 'YYYY MM Do');
                assert.equal(testMoment.year(), 2014,
                        'lenient ordinal parsing of number ' + i + ' year check');
                assert.equal(testMoment.month(), 0,
                        'lenient ordinal parsing of number ' + i + ' month check');
                assert.equal(testMoment.date(), i,
                        'lenient ordinal parsing of number ' + i + ' date check');
            }
        });

        test('strict ordinal parsing', function (assert) {
            var i, ordinalStr, testMoment;
            for (i = 1; i <= 31; ++i) {
                ordinalStr = moment([2014, 0, i]).format('YYYY MM Do');
                testMoment = moment(ordinalStr, 'YYYY MM Do', true);
                assert.ok(testMoment.isValid(), 'strict ordinal parsing ' + i);
            }
        });

        test('meridiem invariant', function (assert) {
            var h, m, t1, t2;
            for (h = 0; h < 24; ++h) {
                for (m = 0; m < 60; m += 15) {
                    t1 = moment.utc([2000, 0, 1, h, m]);
                    t2 = moment.utc(t1.format('A h:mm'), 'A h:mm');
                    assert.equal(t2.format('HH:mm'), t1.format('HH:mm'),
                            'meridiem at ' + t1.format('HH:mm'));
                }
            }
        });

        test('date format correctness', function (assert) {
            var data, tokens;
            data = moment.localeData()._longDateFormat;
            tokens = objectKeys(data);
            each(tokens, function (srchToken) {
                // Check each format string to make sure it does not contain any
                // tokens that need to be expanded.
                each(tokens, function (baseToken) {
                    // strip escaped sequences
                    var format = data[baseToken].replace(/(\[[^\]]*\])/g, '');
                    assert.equal(false, !!~format.indexOf(srchToken),
                            'contains ' + srchToken + ' in ' + baseToken);
                });
            });
        });

        test('month parsing correctness', function (assert) {
            var i, m;

            if (locale === 'tr') {
                // I can't fix it :(
                expect(0);
                return;
            }
            function tester(format) {
                var r;
                r = moment(m.format(format), format);
                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format);
                r = moment(m.format(format).toLocaleUpperCase(), format);
                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' upper');
                r = moment(m.format(format).toLocaleLowerCase(), format);
                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' lower');

                r = moment(m.format(format), format, true);
                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' strict');
                r = moment(m.format(format).toLocaleUpperCase(), format, true);
                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' upper strict');
                r = moment(m.format(format).toLocaleLowerCase(), format, true);
                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' lower strict');
            }

            for (i = 0; i < 12; ++i) {
                m = moment([2015, i, 15, 18]);
                tester('MMM');
                tester('MMM.');
                tester('MMMM');
                tester('MMMM.');
            }
        });

        test('weekday parsing correctness', function (assert) {
            var i, m;

            if (locale === 'tr' || locale === 'az') {
                // There is a lower-case letter (Ä±), that converted to upper then
                // lower changes to i
                expect(0);
                return;
            }
            function tester(format) {
                var r, baseMsg = 'weekday ' + m.weekday() + ' fmt ' + format;
                r = moment(m.format(format), format);
                assert.equal(r.weekday(), m.weekday(), baseMsg);
                r = moment(m.format(format).toLocaleUpperCase(), format);
                assert.equal(r.weekday(), m.weekday(), baseMsg + ' upper');
                r = moment(m.format(format).toLocaleLowerCase(), format);
                assert.equal(r.weekday(), m.weekday(), baseMsg + ' lower');

                r = moment(m.format(format), format, true);
                assert.equal(r.weekday(), m.weekday(), baseMsg + ' strict');
                r = moment(m.format(format).toLocaleUpperCase(), format, true);
                assert.equal(r.weekday(), m.weekday(), baseMsg + ' upper strict');
                r = moment(m.format(format).toLocaleLowerCase(), format, true);
                assert.equal(r.weekday(), m.weekday(), baseMsg + ' lower strict');
            }

            for (i = 0; i < 7; ++i) {
                m = moment.utc([2015, i, 15, 18]);
                tester('dd');
                tester('ddd');
                tester('dddd');
            }
        });
    }

    function setupDeprecationHandler(test, moment, scope) {
        test._expectedDeprecations = null;
        test._observedDeprecations = null;
        test._oldSupress = moment.suppressDeprecationWarnings;
        moment.suppressDeprecationWarnings = true;
        test.expectedDeprecations = function () {
            test._expectedDeprecations = arguments;
            test._observedDeprecations = [];
        };
        moment.deprecationHandler = function (name, msg) {
            var deprecationId = matchedDeprecation(name, msg, test._expectedDeprecations);
            if (deprecationId === -1) {
                throw new Error('Unexpected deprecation thrown name=' +
                        name + ' msg=' + msg);
            }
            test._observedDeprecations[deprecationId] = 1;
        };
    }

    function teardownDeprecationHandler(test, moment, scope) {
        moment.suppressDeprecationWarnings = test._oldSupress;

        if (test._expectedDeprecations != null) {
            var missedDeprecations = [];
            each(test._expectedDeprecations, function (deprecationPattern, id) {
                if (test._observedDeprecations[id] !== 1) {
                    missedDeprecations.push(deprecationPattern);
                }
            });
            if (missedDeprecations.length !== 0) {
                throw new Error('Expected deprecation warnings did not happen: ' +
                        missedDeprecations.join(' '));
            }
        }
    }

    function matchedDeprecation(name, msg, deprecations) {
        if (deprecations == null) {
            return -1;
        }
        for (var i = 0; i < deprecations.length; ++i) {
            if (name != null && name === deprecations[i]) {
                return i;
            }
            if (msg != null && msg.substring(0, deprecations[i].length) === deprecations[i]) {
                return i;
            }
        }
        return -1;
    }

    /*global QUnit:false*/

    var test = QUnit.test;

    var expect = QUnit.expect;

    function module (name, lifecycle) {
        QUnit.module(name, {
            setup : function () {
                moment.locale('en');
                moment.createFromInputFallback = function (config) {
                    throw new Error('input not handled by moment: ' + config._i);
                };
                setupDeprecationHandler(test, moment, 'core');
                if (lifecycle && lifecycle.setup) {
                    lifecycle.setup();
                }
            },
            teardown : function () {
                teardownDeprecationHandler(test, moment, 'core');
                if (lifecycle && lifecycle.teardown) {
                    lifecycle.teardown();
                }
            }
        });
    }

    function localeModule (name, lifecycle) {
        QUnit.module('locale:' + name, {
            setup : function () {
                moment.locale(name);
                moment.createFromInputFallback = function (config) {
                    throw new Error('input not handled by moment: ' + config._i);
                };
                setupDeprecationHandler(test, moment, 'locale');
                if (lifecycle && lifecycle.setup) {
                    lifecycle.setup();
                }
            },
            teardown : function () {
                moment.locale('en');
                teardownDeprecationHandler(test, moment, 'locale');
                if (lifecycle && lifecycle.teardown) {
                    lifecycle.teardown();
                }
            }
        });
        defineCommonLocaleTests(name, -1, -1);
    }

    localeModule('hr');

    test('parse', function (assert) {
        var tests = 'sijeÄanj sij._veljaÄa velj._oÅ¾ujak oÅ¾u._travanj tra._svibanj svi._lipanj lip._srpanj srp._kolovoz kol._rujan ruj._listopad lis._studeni stu._prosinac pro.'.split('_'), i;
        function equalTest(input, mmm, i) {
            assert.equal(moment(input, mmm).month(), i, input + ' should be month ' + (i + 1));
        }
        for (i = 0; i < 12; i++) {
            tests[i] = tests[i].split(' ');
            equalTest(tests[i][0], 'MMM', i);
            equalTest(tests[i][1], 'MMM', i);
            equalTest(tests[i][0], 'MMMM', i);
            equalTest(tests[i][1], 'MMMM', i);
            equalTest(tests[i][0].toLocaleLowerCase(), 'MMMM', i);
            equalTest(tests[i][1].toLocaleLowerCase(), 'MMMM', i);
            equalTest(tests[i][0].toLocaleUpperCase(), 'MMMM', i);
            equalTest(tests[i][1].toLocaleUpperCase(), 'MMMM', i);
        }
    });

    test('format', function (assert) {
        var a = [
                ['dddd, Do MMMM YYYY, h:mm:ss a',      'nedjelja, 14. veljaÄe 2010, 3:25:50 pm'],
                ['ddd, hA',                            'ned., 3PM'],
                ['M Mo MM MMMM MMM',                   '2 2. 02 veljaÄa velj.'],
                ['YYYY YY',                            '2010 10'],
                ['D Do DD',                            '14 14. 14'],
                ['d do dddd ddd dd',                   '0 0. nedjelja ned. ne'],
                ['DDD DDDo DDDD',                      '45 45. 045'],
                ['w wo ww',                            '7 7. 07'],
                ['h hh',                               '3 03'],
                ['H HH',                               '15 15'],
                ['m mm',                               '25 25'],
                ['s ss',                               '50 50'],
                ['a A',                                'pm PM'],
                ['[the] DDDo [day of the year]',       'the 45. day of the year'],
                ['LTS',                                '15:25:50'],
                ['L',                                  '14. 02. 2010'],
                ['LL',                                 '14. veljaÄa 2010'],
                ['LLL',                                '14. veljaÄa 2010 15:25'],
                ['LLLL',                               'nedjelja, 14. veljaÄa 2010 15:25'],
                ['l',                                  '14. 2. 2010'],
                ['ll',                                 '14. velj. 2010'],
                ['lll',                                '14. velj. 2010 15:25'],
                ['llll',                               'ned., 14. velj. 2010 15:25']
            ],
            b = moment(new Date(2010, 1, 14, 15, 25, 50, 125)),
            i;
        for (i = 0; i < a.length; i++) {
            assert.equal(b.format(a[i][0]), a[i][1], a[i][0] + ' ---> ' + a[i][1]);
        }
    });

    test('format ordinal', function (assert) {
        assert.equal(moment([2011, 0, 1]).format('DDDo'), '1.', '1.');
        assert.equal(moment([2011, 0, 2]).format('DDDo'), '2.', '2.');
        assert.equal(moment([2011, 0, 3]).format('DDDo'), '3.', '3.');
        assert.equal(moment([2011, 0, 4]).format('DDDo'), '4.', '4.');
        assert.equal(moment([2011, 0, 5]).format('DDDo'), '5.', '5.');
        assert.equal(moment([2011, 0, 6]).format('DDDo'), '6.', '6.');
        assert.equal(moment([2011, 0, 7]).format('DDDo'), '7.', '7.');
        assert.equal(moment([2011, 0, 8]).format('DDDo'), '8.', '8.');
        assert.equal(moment([2011, 0, 9]).format('DDDo'), '9.', '9.');
        assert.equal(moment([2011, 0, 10]).format('DDDo'), '10.', '10.');

        assert.equal(moment([2011, 0, 11]).format('DDDo'), '11.', '11.');
        assert.equal(moment([2011, 0, 12]).format('DDDo'), '12.', '12.');
        assert.equal(moment([2011, 0, 13]).format('DDDo'), '13.', '13.');
        assert.equal(moment([2011, 0, 14]).format('DDDo'), '14.', '14.');
        assert.equal(moment([2011, 0, 15]).format('DDDo'), '15.', '15.');
        assert.equal(moment([2011, 0, 16]).format('DDDo'), '16.', '16.');
        assert.equal(moment([2011, 0, 17]).format('DDDo'), '17.', '17.');
        assert.equal(moment([2011, 0, 18]).format('DDDo'), '18.', '18.');
        assert.equal(moment([2011, 0, 19]).format('DDDo'), '19.', '19.');
        assert.equal(moment([2011, 0, 20]).format('DDDo'), '20.', '20.');

        assert.equal(moment([2011, 0, 21]).format('DDDo'), '21.', '21.');
        assert.equal(moment([2011, 0, 22]).format('DDDo'), '22.', '22.');
        assert.equal(moment([2011, 0, 23]).format('DDDo'), '23.', '23.');
        assert.equal(moment([2011, 0, 24]).format('DDDo'), '24.', '24.');
        assert.equal(moment([2011, 0, 25]).format('DDDo'), '25.', '25.');
        assert.equal(moment([2011, 0, 26]).format('DDDo'), '26.', '26.');
        assert.equal(moment([2011, 0, 27]).format('DDDo'), '27.', '27.');
        assert.equal(moment([2011, 0, 28]).format('DDDo'), '28.', '28.');
        assert.equal(moment([2011, 0, 29]).format('DDDo'), '29.', '29.');
        assert.equal(moment([2011, 0, 30]).format('DDDo'), '30.', '30.');

        assert.equal(moment([2011, 0, 31]).format('DDDo'), '31.', '31.');
    });

    test('format month', function (assert) {
        var expected = 'sijeÄanj sij._veljaÄa velj._oÅ¾ujak oÅ¾u._travanj tra._svibanj svi._lipanj lip._srpanj srp._kolovoz kol._rujan ruj._listopad lis._studeni stu._prosinac pro.'.split('_'), i;
        for (i = 0; i < expected.length; i++) {
            assert.equal(moment([2011, i, 1]).format('MMMM MMM'), expected[i], expected[i]);
        }
    });

    test('format week', function (assert) {
        var expected = 'nedjelja ned. ne_ponedjeljak pon. po_utorak uto. ut_srijeda sri. sr_Äetvrtak Äet. Äe_petak pet. pe_subota sub. su'.split('_'), i;
        for (i = 0; i < expected.length; i++) {
            assert.equal(moment([2011, 0, 2 + i]).format('dddd ddd dd'), expected[i], expected[i]);
        }
    });

    test('from', function (assert) {
        var start = moment([2007, 1, 28]);
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 44}), true),  'par sekundi', '44 seconds = a few seconds');
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 45}), true),  'jedna minuta',   '45 seconds = a minute');
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 89}), true),  'jedna minuta',   '89 seconds = a minute');
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 90}), true),  '2 minute',     '90 seconds = 2 minutes');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 44}), true),  '44 minuta',     '44 minutes = 44 minutes');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 45}), true),  'jedan sat',      '45 minutes = an hour');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 89}), true),  'jedan sat',      '89 minutes = an hour');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 90}), true),  '2 sata',        '90 minutes = 2 hours');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 5}), true),   '5 sati',         '5 hours = 5 hours');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 21}), true),  '21 sati',        '21 hours = 21 hours');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 22}), true),  'dan',       '22 hours = a day');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 35}), true),  'dan',       '35 hours = a day');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 36}), true),  '2 dana',        '36 hours = 2 days');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 1}), true),   'dan',       '1 day = a day');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 5}), true),   '5 dana',        '5 days = 5 days');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 25}), true),  '25 dana',       '25 days = 25 days');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 26}), true),  'mjesec',     '26 days = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 30}), true),  'mjesec',     '30 days = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 43}), true),  'mjesec',     '43 days = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 46}), true),  '2 mjeseca',     '46 days = 2 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 74}), true),  '2 mjeseca',     '75 days = 2 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 76}), true),  '3 mjeseca',     '76 days = 3 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({M: 1}), true),   'mjesec',     '1 month = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({M: 5}), true),   '5 mjeseci',    '5 months = 5 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 345}), true), 'godinu',     '345 days = a year');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 548}), true), '2 godine',       '548 days = 2 years');
        assert.equal(start.from(moment([2007, 1, 28]).add({y: 1}), true),   'godinu',     '1 year = a year');
        assert.equal(start.from(moment([2007, 1, 28]).add({y: 5}), true),   '5 godina',        '5 years = 5 years');
    });

    test('suffix', function (assert) {
        assert.equal(moment(30000).from(0), 'za par sekundi',  'prefix');
        assert.equal(moment(0).from(30000), 'prije par sekundi', 'prefix');
    });

    test('now from now', function (assert) {
        assert.equal(moment().fromNow(), 'prije par sekundi',  'now from now should display as in the past');
    });

    test('fromNow', function (assert) {
        assert.equal(moment().add({s: 30}).fromNow(), 'za par sekundi', 'in a few seconds');
        assert.equal(moment().add({d: 5}).fromNow(), 'za 5 dana', 'in 5 days');
    });

    test('calendar day', function (assert) {
        var a = moment().hours(12).minutes(0).seconds(0);

        assert.equal(moment(a).calendar(),                   'danas u 12:00',  'today at the same time');
        assert.equal(moment(a).add({m: 25}).calendar(),      'danas u 12:25',  'Now plus 25 min');
        assert.equal(moment(a).add({h: 1}).calendar(),       'danas u 13:00',  'Now plus 1 hour');
        assert.equal(moment(a).add({d: 1}).calendar(),       'sutra u 12:00',  'tomorrow at the same time');
        assert.equal(moment(a).subtract({h: 1}).calendar(),  'danas u 11:00',  'Now minus 1 hour');
        assert.equal(moment(a).subtract({d: 1}).calendar(),  'juÄer u 12:00',  'yesterday at the same time');
    });

    test('calendar next week', function (assert) {
        var i, m;

        function makeFormat(d) {
            switch (d.day()) {
            case 0:
                return '[u] [nedjelju] [u] LT';
            case 3:
                return '[u] [srijedu] [u] LT';
            case 6:
                return '[u] [subotu] [u] LT';
            case 1:
            case 2:
            case 4:
            case 5:
                return '[u] dddd [u] LT';
            }
        }

        for (i = 2; i < 7; i++) {
            m = moment().add({d: i});
            assert.equal(m.calendar(),       m.format(makeFormat(m)),  'Today + ' + i + ' days current time');
            m.hours(0).minutes(0).seconds(0).milliseconds(0);
            assert.equal(m.calendar(),       m.format(makeFormat(m)),  'Today + ' + i + ' days beginning of day');
            m.hours(23).minutes(59).seconds(59).milliseconds(999);
            assert.equal(m.calendar(),       m.format(makeFormat(m)),  'Today + ' + i + ' days end of day');
        }
    });

    test('calendar last week', function (assert) {
        var i, m;

        function makeFormat(d) {
            switch (d.day()) {
            case 0:
            case 3:
                return '[proÅ¡lu] dddd [u] LT';
            case 6:
                return '[proÅ¡le] [subote] [u] LT';
            case 1:
            case 2:
            case 4:
            case 5:
                return '[proÅ¡li] dddd [u] LT';
            }
        }

        for (i = 2; i < 7; i++) {
            m = moment().subtract({d: i});
            assert.equal(m.calendar(),       m.format(makeFormat(m)),  'Today - ' + i + ' days current time');
            m.hours(0).minutes(0).seconds(0).milliseconds(0);
            assert.equal(m.calendar(),       m.format(makeFormat(m)),  'Today - ' + i + ' days beginning of day');
            m.hours(23).minutes(59).seconds(59).milliseconds(999);
            assert.equal(m.calendar(),       m.format(makeFormat(m)),  'Today - ' + i + ' days end of day');
        }
    });

    test('calendar all else', function (assert) {
        var weeksAgo = moment().subtract({w: 1}),
            weeksFromNow = moment().add({w: 1});

        assert.equal(weeksAgo.calendar(),       weeksAgo.format('L'),  '1 week ago');
        assert.equal(weeksFromNow.calendar(),   weeksFromNow.format('L'),  'in 1 week');

        weeksAgo = moment().subtract({w: 2});
        weeksFromNow = moment().add({w: 2});

        assert.equal(weeksAgo.calendar(),       weeksAgo.format('L'),  '2 weeks ago');
        assert.equal(weeksFromNow.calendar(),   weeksFromNow.format('L'),  'in 2 weeks');
    });

    test('weeks year starting sunday formatted', function (assert) {
        assert.equal(moment([2011, 11, 26]).format('w ww wo'), '1 01 1.', 'Dec 26 2011 should be week 1');
        assert.equal(moment([2012,  0,  1]).format('w ww wo'), '1 01 1.', 'Jan  1 2012 should be week 1');
        assert.equal(moment([2012,  0,  2]).format('w ww wo'), '2 02 2.', 'Jan  2 2012 should be week 2');
        assert.equal(moment([2012,  0,  8]).format('w ww wo'), '2 02 2.', 'Jan  8 2012 should be week 2');
        assert.equal(moment([2012,  0,  9]).format('w ww wo'), '3 03 3.', 'Jan  9 2012 should be week 3');
    });

}));

;(function (global, factory) {
   typeof exports === 'object' && typeof module !== 'undefined'
       && typeof require === 'function' ? factory(require('../../moment')) :
   typeof define === 'function' && define.amd ? define(['../../moment'], factory) :
   factory(global.moment)
}(this, function (moment) { 'use strict';

    function each(array, callback) {
        var i;
        for (i = 0; i < array.length; i++) {
            callback(array[i], i, array);
        }
    }

    function objectKeys(obj) {
        if (Object.keys) {
            return Object.keys(obj);
        } else {
            // IE8
            var res = [], i;
            for (i in obj) {
                if (obj.hasOwnProperty(i)) {
                    res.push(i);
                }
            }
            return res;
        }
    }

    // Pick the first defined of two or three arguments.
    function defaults(a, b, c) {
        if (a != null) {
            return a;
        }
        if (b != null) {
            return b;
        }
        return c;
    }

    function defineCommonLocaleTests(locale, options) {
        test('lenient ordinal parsing', function (assert) {
            var i, ordinalStr, testMoment;
            for (i = 1; i <= 31; ++i) {
                ordinalStr = moment([2014, 0, i]).format('YYYY MM Do');
                testMoment = moment(ordinalStr, 'YYYY MM Do');
                assert.equal(testMoment.year(), 2014,
                        'lenient ordinal parsing ' + i + ' year check');
                assert.equal(testMoment.month(), 0,
                        'lenient ordinal parsing ' + i + ' month check');
                assert.equal(testMoment.date(), i,
                        'lenient ordinal parsing ' + i + ' date check');
            }
        });

        test('lenient ordinal parsing of number', function (assert) {
            var i, testMoment;
            for (i = 1; i <= 31; ++i) {
                testMoment = moment('2014 01 ' + i, 'YYYY MM Do');
                assert.equal(testMoment.year(), 2014,
                        'lenient ordinal parsing of number ' + i + ' year check');
                assert.equal(testMoment.month(), 0,
                        'lenient ordinal parsing of number ' + i + ' month check');
                assert.equal(testMoment.date(), i,
                        'lenient ordinal parsing of number ' + i + ' date check');
            }
        });

        test('strict ordinal parsing', function (assert) {
            var i, ordinalStr, testMoment;
            for (i = 1; i <= 31; ++i) {
                ordinalStr = moment([2014, 0, i]).format('YYYY MM Do');
                testMoment = moment(ordinalStr, 'YYYY MM Do', true);
                assert.ok(testMoment.isValid(), 'strict ordinal parsing ' + i);
            }
        });

        test('meridiem invariant', function (assert) {
            var h, m, t1, t2;
            for (h = 0; h < 24; ++h) {
                for (m = 0; m < 60; m += 15) {
                    t1 = moment.utc([2000, 0, 1, h, m]);
                    t2 = moment.utc(t1.format('A h:mm'), 'A h:mm');
                    assert.equal(t2.format('HH:mm'), t1.format('HH:mm'),
                            'meridiem at ' + t1.format('HH:mm'));
                }
            }
        });

        test('date format correctness', function (assert) {
            var data, tokens;
            data = moment.localeData()._longDateFormat;
            tokens = objectKeys(data);
            each(tokens, function (srchToken) {
                // Check each format string to make sure it does not contain any
                // tokens that need to be expanded.
                each(tokens, function (baseToken) {
                    // strip escaped sequences
                    var format = data[baseToken].replace(/(\[[^\]]*\])/g, '');
                    assert.equal(false, !!~format.indexOf(srchToken),
                            'contains ' + srchToken + ' in ' + baseToken);
                });
            });
        });

        test('month parsing correctness', function (assert) {
            var i, m;

            if (locale === 'tr') {
                // I can't fix it :(
                expect(0);
                return;
            }
            function tester(format) {
                var r;
                r = moment(m.format(format), format);
                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format);
                r = moment(m.format(format).toLocaleUpperCase(), format);
                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' upper');
                r = moment(m.format(format).toLocaleLowerCase(), format);
                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' lower');

                r = moment(m.format(format), format, true);
                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' strict');
                r = moment(m.format(format).toLocaleUpperCase(), format, true);
                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' upper strict');
                r = moment(m.format(format).toLocaleLowerCase(), format, true);
                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' lower strict');
            }

            for (i = 0; i < 12; ++i) {
                m = moment([2015, i, 15, 18]);
                tester('MMM');
                tester('MMM.');
                tester('MMMM');
                tester('MMMM.');
            }
        });

        test('weekday parsing correctness', function (assert) {
            var i, m;

            if (locale === 'tr' || locale === 'az') {
                // There is a lower-case letter (Ä±), that converted to upper then
                // lower changes to i
                expect(0);
                return;
            }
            function tester(format) {
                var r, baseMsg = 'weekday ' + m.weekday() + ' fmt ' + format;
                r = moment(m.format(format), format);
                assert.equal(r.weekday(), m.weekday(), baseMsg);
                r = moment(m.format(format).toLocaleUpperCase(), format);
                assert.equal(r.weekday(), m.weekday(), baseMsg + ' upper');
                r = moment(m.format(format).toLocaleLowerCase(), format);
                assert.equal(r.weekday(), m.weekday(), baseMsg + ' lower');

                r = moment(m.format(format), format, true);
                assert.equal(r.weekday(), m.weekday(), baseMsg + ' strict');
                r = moment(m.format(format).toLocaleUpperCase(), format, true);
                assert.equal(r.weekday(), m.weekday(), baseMsg + ' upper strict');
                r = moment(m.format(format).toLocaleLowerCase(), format, true);
                assert.equal(r.weekday(), m.weekday(), baseMsg + ' lower strict');
            }

            for (i = 0; i < 7; ++i) {
                m = moment.utc([2015, i, 15, 18]);
                tester('dd');
                tester('ddd');
                tester('dddd');
            }
        });
    }

    function setupDeprecationHandler(test, moment, scope) {
        test._expectedDeprecations = null;
        test._observedDeprecations = null;
        test._oldSupress = moment.suppressDeprecationWarnings;
        moment.suppressDeprecationWarnings = true;
        test.expectedDeprecations = function () {
            test._expectedDeprecations = arguments;
            test._observedDeprecations = [];
        };
        moment.deprecationHandler = function (name, msg) {
            var deprecationId = matchedDeprecation(name, msg, test._expectedDeprecations);
            if (deprecationId === -1) {
                throw new Error('Unexpected deprecation thrown name=' +
                        name + ' msg=' + msg);
            }
            test._observedDeprecations[deprecationId] = 1;
        };
    }

    function teardownDeprecationHandler(test, moment, scope) {
        moment.suppressDeprecationWarnings = test._oldSupress;

        if (test._expectedDeprecations != null) {
            var missedDeprecations = [];
            each(test._expectedDeprecations, function (deprecationPattern, id) {
                if (test._observedDeprecations[id] !== 1) {
                    missedDeprecations.push(deprecationPattern);
                }
            });
            if (missedDeprecations.length !== 0) {
                throw new Error('Expected deprecation warnings did not happen: ' +
                        missedDeprecations.join(' '));
            }
        }
    }

    function matchedDeprecation(name, msg, deprecations) {
        if (deprecations == null) {
            return -1;
        }
        for (var i = 0; i < deprecations.length; ++i) {
            if (name != null && name === deprecations[i]) {
                return i;
            }
            if (msg != null && msg.substring(0, deprecations[i].length) === deprecations[i]) {
                return i;
            }
        }
        return -1;
    }

    /*global QUnit:false*/

    var test = QUnit.test;

    var expect = QUnit.expect;

    function module (name, lifecycle) {
        QUnit.module(name, {
            setup : function () {
                moment.locale('en');
                moment.createFromInputFallback = function (config) {
                    throw new Error('input not handled by moment: ' + config._i);
                };
                setupDeprecationHandler(test, moment, 'core');
                if (lifecycle && lifecycle.setup) {
                    lifecycle.setup();
                }
            },
            teardown : function () {
                teardownDeprecationHandler(test, moment, 'core');
                if (lifecycle && lifecycle.teardown) {
                    lifecycle.teardown();
                }
            }
        });
    }

    function localeModule (name, lifecycle) {
        QUnit.module('locale:' + name, {
            setup : function () {
                moment.locale(name);
                moment.createFromInputFallback = function (config) {
                    throw new Error('input not handled by moment: ' + config._i);
                };
                setupDeprecationHandler(test, moment, 'locale');
                if (lifecycle && lifecycle.setup) {
                    lifecycle.setup();
                }
            },
            teardown : function () {
                moment.locale('en');
                teardownDeprecationHandler(test, moment, 'locale');
                if (lifecycle && lifecycle.teardown) {
                    lifecycle.teardown();
                }
            }
        });
        defineCommonLocaleTests(name, -1, -1);
    }

    localeModule('hu');

    test('parse', function (assert) {
        var tests = 'januÃ¡r jan_februÃ¡r feb_mÃ¡rcius mÃ¡rc_Ã¡prilis Ã¡pr_mÃ¡jus mÃ¡j_jÃºnius jÃºn_jÃºlius jÃºl_augusztus aug_szeptember szept_oktÃ³ber okt_november nov_december dec'.split('_'),
            i;
        function equalTest(input, mmm, i) {
            assert.equal(moment(input, mmm).month(), i, input + ' should be month ' + (i + 1));
        }
        for (i = 0; i < 12; i++) {
            tests[i] = tests[i].split(' ');
            equalTest(tests[i][0], 'MMM', i);
            equalTest(tests[i][1], 'MMM', i);
            equalTest(tests[i][0], 'MMMM', i);
            equalTest(tests[i][1], 'MMMM', i);
            equalTest(tests[i][0].toLocaleLowerCase(), 'MMMM', i);
            equalTest(tests[i][1].toLocaleLowerCase(), 'MMMM', i);
            equalTest(tests[i][0].toLocaleUpperCase(), 'MMMM', i);
            equalTest(tests[i][1].toLocaleUpperCase(), 'MMMM', i);
        }
    });

    test('format', function (assert) {
        var a = [
                ['dddd, MMMM Do YYYY, HH:mm:ss',      'vasÃ¡rnap, februÃ¡r 14. 2010, 15:25:50'],
                ['ddd, HH',                            'vas, 15'],
                ['M Mo MM MMMM MMM',                   '2 2. 02 februÃ¡r feb'],
                ['YYYY YY',                            '2010 10'],
                ['D Do DD',                            '14 14. 14'],
                ['d do dddd ddd dd',                   '0 0. vasÃ¡rnap vas v'],
                ['DDD DDDo DDDD',                      '45 45. 045'],
                ['w wo ww',                            '7 7. 07'],
                ['H HH',                               '15 15'],
                ['m mm',                               '25 25'],
                ['s ss',                               '50 50'],
                ['[az Ã©v] DDDo [napja]',               'az Ã©v 45. napja'],
                ['LTS',                                '15:25:50'],
                ['L',                                  '2010.02.14.'],
                ['LL',                                 '2010. februÃ¡r 14.'],
                ['LLL',                                '2010. februÃ¡r 14. 15:25'],
                ['LLLL',                               '2010. februÃ¡r 14., vasÃ¡rnap 15:25'],
                ['l',                                  '2010.2.14.'],
                ['ll',                                 '2010. feb 14.'],
                ['lll',                                '2010. feb 14. 15:25'],
                ['llll',                               '2010. feb 14., vas 15:25']
            ],
            b = moment(new Date(2010, 1, 14, 15, 25, 50, 125)),
            i;
        for (i = 0; i < a.length; i++) {
            assert.equal(b.format(a[i][0]), a[i][1], a[i][0] + ' ---> ' + a[i][1]);
        }
    });

    test('meridiem', function (assert) {
        assert.equal(moment([2011, 2, 23,  0,  0]).format('a'), 'de', 'am');
        assert.equal(moment([2011, 2, 23, 11, 59]).format('a'), 'de', 'am');
        assert.equal(moment([2011, 2, 23, 12,  0]).format('a'), 'du', 'pm');
        assert.equal(moment([2011, 2, 23, 23, 59]).format('a'), 'du', 'pm');

        assert.equal(moment([2011, 2, 23,  0,  0]).format('A'), 'DE', 'AM');
        assert.equal(moment([2011, 2, 23, 11, 59]).format('A'), 'DE', 'AM');
        assert.equal(moment([2011, 2, 23, 12,  0]).format('A'), 'DU', 'PM');
        assert.equal(moment([2011, 2, 23, 23, 59]).format('A'), 'DU', 'PM');
    });

    test('format ordinal', function (assert) {
        assert.equal(moment([2011, 0, 1]).format('DDDo'), '1.', '1.');
        assert.equal(moment([2011, 0, 2]).format('DDDo'), '2.', '2.');
        assert.equal(moment([2011, 0, 3]).format('DDDo'), '3.', '3.');
        assert.equal(moment([2011, 0, 4]).format('DDDo'), '4.', '4.');
        assert.equal(moment([2011, 0, 5]).format('DDDo'), '5.', '5.');
        assert.equal(moment([2011, 0, 6]).format('DDDo'), '6.', '6.');
        assert.equal(moment([2011, 0, 7]).format('DDDo'), '7.', '7.');
        assert.equal(moment([2011, 0, 8]).format('DDDo'), '8.', '8.');
        assert.equal(moment([2011, 0, 9]).format('DDDo'), '9.', '9.');
        assert.equal(moment([2011, 0, 10]).format('DDDo'), '10.', '10.');

        assert.equal(moment([2011, 0, 11]).format('DDDo'), '11.', '11.');
        assert.equal(moment([2011, 0, 12]).format('DDDo'), '12.', '12.');
        assert.equal(moment([2011, 0, 13]).format('DDDo'), '13.', '13.');
        assert.equal(moment([2011, 0, 14]).format('DDDo'), '14.', '14.');
        assert.equal(moment([2011, 0, 15]).format('DDDo'), '15.', '15.');
        assert.equal(moment([2011, 0, 16]).format('DDDo'), '16.', '16.');
        assert.equal(moment([2011, 0, 17]).format('DDDo'), '17.', '17.');
        assert.equal(moment([2011, 0, 18]).format('DDDo'), '18.', '18.');
        assert.equal(moment([2011, 0, 19]).format('DDDo'), '19.', '19.');
        assert.equal(moment([2011, 0, 20]).format('DDDo'), '20.', '20.');

        assert.equal(moment([2011, 0, 21]).format('DDDo'), '21.', '21.');
        assert.equal(moment([2011, 0, 22]).format('DDDo'), '22.', '22.');
        assert.equal(moment([2011, 0, 23]).format('DDDo'), '23.', '23.');
        assert.equal(moment([2011, 0, 24]).format('DDDo'), '24.', '24.');
        assert.equal(moment([2011, 0, 25]).format('DDDo'), '25.', '25.');
        assert.equal(moment([2011, 0, 26]).format('DDDo'), '26.', '26.');
        assert.equal(moment([2011, 0, 27]).format('DDDo'), '27.', '27.');
        assert.equal(moment([2011, 0, 28]).format('DDDo'), '28.', '28.');
        assert.equal(moment([2011, 0, 29]).format('DDDo'), '29.', '29.');
        assert.equal(moment([2011, 0, 30]).format('DDDo'), '30.', '30.');

        assert.equal(moment([2011, 0, 31]).format('DDDo'), '31.', '31.');
    });

    test('format month', function (assert) {
        var expected = 'januÃ¡r jan_februÃ¡r feb_mÃ¡rcius mÃ¡rc_Ã¡prilis Ã¡pr_mÃ¡jus mÃ¡j_jÃºnius jÃºn_jÃºlius jÃºl_augusztus aug_szeptember szept_oktÃ³ber okt_november nov_december dec'.split('_'),
            i;
        for (i = 0; i < expected.length; i++) {
            assert.equal(moment([2011, i, 1]).format('MMMM MMM'), expected[i], expected[i]);
        }
    });

    test('format week', function (assert) {
        var expected = 'vasÃ¡rnap vas_hÃ©tfÅ hÃ©t_kedd kedd_szerda sze_csÃ¼tÃ¶rtÃ¶k csÃ¼t_pÃ©ntek pÃ©n_szombat szo'.split('_'),
            i;
        for (i = 0; i < expected.length; i++) {
            assert.equal(moment([2011, 0, 2 + i]).format('dddd ddd'), expected[i], expected[i]);
        }
    });

    test('from', function (assert) {
        var start = moment([2007, 1, 28]);
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 44}), true),  'nÃ©hÃ¡ny mÃ¡sodperc', '44 mÃ¡sodperc = nÃ©hÃ¡ny mÃ¡sodperc');
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 45}), true),  'egy perc',         '45 mÃ¡sodperc = egy perc');
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 89}), true),  'egy perc',         '89 mÃ¡sodperc = egy perc');
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 90}), true),  '2 perc',           '90 mÃ¡sodperc = 2 perc');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 44}), true),  '44 perc',          '44 perc = 44 perc');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 45}), true),  'egy Ã³ra',          '45 perc = egy Ã³ra');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 89}), true),  'egy Ã³ra',          '89 perc = egy Ã³ra');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 90}), true),  '2 Ã³ra',            '90 perc = 2 Ã³ra');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 5}), true),   '5 Ã³ra',            '5 Ã³ra = 5 Ã³ra');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 21}), true),  '21 Ã³ra',           '21 Ã³ra = 21 Ã³ra');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 22}), true),  'egy nap',          '22 Ã³ra = egy nap');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 35}), true),  'egy nap',          '35 Ã³ra = egy nap');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 36}), true),  '2 nap',            '36 Ã³ra = 2 nap');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 1}), true),   'egy nap',          '1 nap = egy nap');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 5}), true),   '5 nap',            '5 nap = 5 nap');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 25}), true),  '25 nap',           '25 nap = 25 nap');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 26}), true),  'egy hÃ³nap',        '26 nap = egy hÃ³nap');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 30}), true),  'egy hÃ³nap',        '30 nap = egy hÃ³nap');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 43}), true),  'egy hÃ³nap',        '45 nap = egy hÃ³nap');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 46}), true),  '2 hÃ³nap',          '46 nap = 2 hÃ³nap');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 74}), true),  '2 hÃ³nap',          '75 nap = 2 hÃ³nap');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 76}), true),  '3 hÃ³nap',          '76 nap = 3 hÃ³nap');
        assert.equal(start.from(moment([2007, 1, 28]).add({M: 1}), true),   'egy hÃ³nap',        '1 hÃ³nap = egy hÃ³nap');
        assert.equal(start.from(moment([2007, 1, 28]).add({M: 5}), true),   '5 hÃ³nap',          '5 hÃ³nap = 5 hÃ³nap');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 345}), true), 'egy Ã©v',           '345 nap = egy Ã©v');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 548}), true), '2 Ã©v',             '548 nap = 2 Ã©v');
        assert.equal(start.from(moment([2007, 1, 28]).add({y: 1}), true),   'egy Ã©v',           '1 Ã©v = egy Ã©v');
        assert.equal(start.from(moment([2007, 1, 28]).add({y: 5}), true),   '5 Ã©v',             '5 Ã©v = 5 Ã©v');
    });

    test('suffix', function (assert) {
        assert.equal(moment(30000).from(0), 'nÃ©hÃ¡ny mÃ¡sodperc mÃºlva',  'prefix');
        assert.equal(moment(0).from(30000), 'nÃ©hÃ¡ny mÃ¡sodperce', 'suffix');
    });

    test('now from now', function (assert) {
        assert.equal(moment().fromNow(), 'nÃ©hÃ¡ny mÃ¡sodperce',  'now from now should display as in the past');
    });

    test('fromNow', function (assert) {
        assert.equal(moment().add({s: 30}).fromNow(), 'nÃ©hÃ¡ny mÃ¡sodperc mÃºlva', 'nÃ©hÃ¡ny mÃ¡sodperc mÃºlva');
        assert.equal(moment().add({d: 5}).fromNow(), '5 nap mÃºlva', '5 nap mÃºlva');
    });

    test('calendar day', function (assert) {
        var a = moment().hours(12).minutes(0).seconds(0);

        assert.equal(moment(a).calendar(),                   'ma 12:00-kor',     'today at the same time');
        assert.equal(moment(a).add({m: 25}).calendar(),      'ma 12:25-kor',     'Now plus 25 min');
        assert.equal(moment(a).add({h: 1}).calendar(),       'ma 13:00-kor',     'Now plus 1 hour');
        assert.equal(moment(a).add({d: 1}).calendar(),       'holnap 12:00-kor', 'tomorrow at the same time');
        assert.equal(moment(a).subtract({h: 1}).calendar(),  'ma 11:00-kor',     'Now minus 1 hour');
        assert.equal(moment(a).subtract({d: 1}).calendar(),  'tegnap 12:00-kor', 'yesterday at the same time');
    });

    test('calendar next week', function (assert) {
        var i, m, days = 'vasÃ¡rnap_hÃ©tfÅn_kedden_szerdÃ¡n_csÃ¼tÃ¶rtÃ¶kÃ¶n_pÃ©nteken_szombaton'.split('_');
        for (i = 2; i < 7; i++) {
            m = moment().add({d: i});
            assert.equal(m.calendar(),       m.format('[' + days[m.day()] + '] LT[-kor]'),  'today + ' + i + ' days current time');
            m.hours(0).minutes(0).seconds(0).milliseconds(0);
            assert.equal(m.calendar(),       m.format('[' + days[m.day()] + '] LT[-kor]'),  'today + ' + i + ' days beginning of day');
            m.hours(23).minutes(59).seconds(59).milliseconds(999);
            assert.equal(m.calendar(),       m.format('[' + days[m.day()] + '] LT[-kor]'),  'today + ' + i + ' days end of day');
        }
    });

    test('calendar last week', function (assert) {
        var i, m, days = 'vasÃ¡rnap_hÃ©tfÅn_kedden_szerdÃ¡n_csÃ¼tÃ¶rtÃ¶kÃ¶n_pÃ©nteken_szombaton'.split('_');

        for (i = 2; i < 7; i++) {
            m = moment().subtract({d: i});
            assert.equal(m.calendar(),       m.format('[mÃºlt ' + days[m.day()] + '] LT[-kor]'),  'today - ' + i + ' days current time');
            m.hours(0).minutes(0).seconds(0).milliseconds(0);
            assert.equal(m.calendar(),       m.format('[mÃºlt ' + days[m.day()] + '] LT[-kor]'),  'today - ' + i + ' days beginning of day');
            m.hours(23).minutes(59).seconds(59).milliseconds(999);
            assert.equal(m.calendar(),       m.format('[mÃºlt ' + days[m.day()] + '] LT[-kor]'),  'today - ' + i + ' days end of day');
        }
    });

    test('calendar all else', function (assert) {
        var weeksAgo = moment().subtract({w: 1}),
            weeksFromNow = moment().add({w: 1});

        assert.equal(weeksAgo.calendar(),       weeksAgo.format('L'),  'egy hÃ©te');
        assert.equal(weeksFromNow.calendar(),   weeksFromNow.format('L'),  'egy hÃ©t mÃºlva');

        weeksAgo = moment().subtract({w: 2});
        weeksFromNow = moment().add({w: 2});

        assert.equal(weeksAgo.calendar(),       weeksAgo.format('L'),  '2 hete');
        assert.equal(weeksFromNow.calendar(),   weeksFromNow.format('L'),  '2 hÃ©t mÃºlva');
    });

    test('weeks year starting sunday formatted', function (assert) {
        assert.equal(moment([2011, 11, 26]).format('w ww wo'), '1 01 1.', 'Dec 26 2011 should be week 1');
        assert.equal(moment([2012,  0,  1]).format('w ww wo'), '1 01 1.', 'Jan  1 2012 should be week 1');
        assert.equal(moment([2012,  0,  2]).format('w ww wo'), '2 02 2.', 'Jan  2 2012 should be week 2');
        assert.equal(moment([2012,  0,  8]).format('w ww wo'), '2 02 2.', 'Jan  8 2012 should be week 2');
        assert.equal(moment([2012,  0,  9]).format('w ww wo'), '3 03 3.', 'Jan  9 2012 should be week 3');
    });

}));

;(function (global, factory) {
   typeof exports === 'object' && typeof module !== 'undefined'
       && typeof require === 'function' ? factory(require('../../moment')) :
   typeof define === 'function' && define.amd ? define(['../../moment'], factory) :
   factory(global.moment)
}(this, function (moment) { 'use strict';

    function each(array, callback) {
        var i;
        for (i = 0; i < array.length; i++) {
            callback(array[i], i, array);
        }
    }

    function objectKeys(obj) {
        if (Object.keys) {
            return Object.keys(obj);
        } else {
            // IE8
            var res = [], i;
            for (i in obj) {
                if (obj.hasOwnProperty(i)) {
                    res.push(i);
                }
            }
            return res;
        }
    }

    // Pick the first defined of two or three arguments.
    function defaults(a, b, c) {
        if (a != null) {
            return a;
        }
        if (b != null) {
            return b;
        }
        return c;
    }

    function defineCommonLocaleTests(locale, options) {
        test('lenient ordinal parsing', function (assert) {
            var i, ordinalStr, testMoment;
            for (i = 1; i <= 31; ++i) {
                ordinalStr = moment([2014, 0, i]).format('YYYY MM Do');
                testMoment = moment(ordinalStr, 'YYYY MM Do');
                assert.equal(testMoment.year(), 2014,
                        'lenient ordinal parsing ' + i + ' year check');
                assert.equal(testMoment.month(), 0,
                        'lenient ordinal parsing ' + i + ' month check');
                assert.equal(testMoment.date(), i,
                        'lenient ordinal parsing ' + i + ' date check');
            }
        });

        test('lenient ordinal parsing of number', function (assert) {
            var i, testMoment;
            for (i = 1; i <= 31; ++i) {
                testMoment = moment('2014 01 ' + i, 'YYYY MM Do');
                assert.equal(testMoment.year(), 2014,
                        'lenient ordinal parsing of number ' + i + ' year check');
                assert.equal(testMoment.month(), 0,
                        'lenient ordinal parsing of number ' + i + ' month check');
                assert.equal(testMoment.date(), i,
                        'lenient ordinal parsing of number ' + i + ' date check');
            }
        });

        test('strict ordinal parsing', function (assert) {
            var i, ordinalStr, testMoment;
            for (i = 1; i <= 31; ++i) {
                ordinalStr = moment([2014, 0, i]).format('YYYY MM Do');
                testMoment = moment(ordinalStr, 'YYYY MM Do', true);
                assert.ok(testMoment.isValid(), 'strict ordinal parsing ' + i);
            }
        });

        test('meridiem invariant', function (assert) {
            var h, m, t1, t2;
            for (h = 0; h < 24; ++h) {
                for (m = 0; m < 60; m += 15) {
                    t1 = moment.utc([2000, 0, 1, h, m]);
                    t2 = moment.utc(t1.format('A h:mm'), 'A h:mm');
                    assert.equal(t2.format('HH:mm'), t1.format('HH:mm'),
                            'meridiem at ' + t1.format('HH:mm'));
                }
            }
        });

        test('date format correctness', function (assert) {
            var data, tokens;
            data = moment.localeData()._longDateFormat;
            tokens = objectKeys(data);
            each(tokens, function (srchToken) {
                // Check each format string to make sure it does not contain any
                // tokens that need to be expanded.
                each(tokens, function (baseToken) {
                    // strip escaped sequences
                    var format = data[baseToken].replace(/(\[[^\]]*\])/g, '');
                    assert.equal(false, !!~format.indexOf(srchToken),
                            'contains ' + srchToken + ' in ' + baseToken);
                });
            });
        });

        test('month parsing correctness', function (assert) {
            var i, m;

            if (locale === 'tr') {
                // I can't fix it :(
                expect(0);
                return;
            }
            function tester(format) {
                var r;
                r = moment(m.format(format), format);
                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format);
                r = moment(m.format(format).toLocaleUpperCase(), format);
                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' upper');
                r = moment(m.format(format).toLocaleLowerCase(), format);
                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' lower');

                r = moment(m.format(format), format, true);
                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' strict');
                r = moment(m.format(format).toLocaleUpperCase(), format, true);
                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' upper strict');
                r = moment(m.format(format).toLocaleLowerCase(), format, true);
                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' lower strict');
            }

            for (i = 0; i < 12; ++i) {
                m = moment([2015, i, 15, 18]);
                tester('MMM');
                tester('MMM.');
                tester('MMMM');
                tester('MMMM.');
            }
        });

        test('weekday parsing correctness', function (assert) {
            var i, m;

            if (locale === 'tr' || locale === 'az') {
                // There is a lower-case letter (Ä±), that converted to upper then
                // lower changes to i
                expect(0);
                return;
            }
            function tester(format) {
                var r, baseMsg = 'weekday ' + m.weekday() + ' fmt ' + format;
                r = moment(m.format(format), format);
                assert.equal(r.weekday(), m.weekday(), baseMsg);
                r = moment(m.format(format).toLocaleUpperCase(), format);
                assert.equal(r.weekday(), m.weekday(), baseMsg + ' upper');
                r = moment(m.format(format).toLocaleLowerCase(), format);
                assert.equal(r.weekday(), m.weekday(), baseMsg + ' lower');

                r = moment(m.format(format), format, true);
                assert.equal(r.weekday(), m.weekday(), baseMsg + ' strict');
                r = moment(m.format(format).toLocaleUpperCase(), format, true);
                assert.equal(r.weekday(), m.weekday(), baseMsg + ' upper strict');
                r = moment(m.format(format).toLocaleLowerCase(), format, true);
                assert.equal(r.weekday(), m.weekday(), baseMsg + ' lower strict');
            }

            for (i = 0; i < 7; ++i) {
                m = moment.utc([2015, i, 15, 18]);
                tester('dd');
                tester('ddd');
                tester('dddd');
            }
        });
    }

    function setupDeprecationHandler(test, moment, scope) {
        test._expectedDeprecations = null;
        test._observedDeprecations = null;
        test._oldSupress = moment.suppressDeprecationWarnings;
        moment.suppressDeprecationWarnings = true;
        test.expectedDeprecations = function () {
            test._expectedDeprecations = arguments;
            test._observedDeprecations = [];
        };
        moment.deprecationHandler = function (name, msg) {
            var deprecationId = matchedDeprecation(name, msg, test._expectedDeprecations);
            if (deprecationId === -1) {
                throw new Error('Unexpected deprecation thrown name=' +
                        name + ' msg=' + msg);
            }
            test._observedDeprecations[deprecationId] = 1;
        };
    }

    function teardownDeprecationHandler(test, moment, scope) {
        moment.suppressDeprecationWarnings = test._oldSupress;

        if (test._expectedDeprecations != null) {
            var missedDeprecations = [];
            each(test._expectedDeprecations, function (deprecationPattern, id) {
                if (test._observedDeprecations[id] !== 1) {
                    missedDeprecations.push(deprecationPattern);
                }
            });
            if (missedDeprecations.length !== 0) {
                throw new Error('Expected deprecation warnings did not happen: ' +
                        missedDeprecations.join(' '));
            }
        }
    }

    function matchedDeprecation(name, msg, deprecations) {
        if (deprecations == null) {
            return -1;
        }
        for (var i = 0; i < deprecations.length; ++i) {
            if (name != null && name === deprecations[i]) {
                return i;
            }
            if (msg != null && msg.substring(0, deprecations[i].length) === deprecations[i]) {
                return i;
            }
        }
        return -1;
    }

    /*global QUnit:false*/

    var test = QUnit.test;

    var expect = QUnit.expect;

    function module (name, lifecycle) {
        QUnit.module(name, {
            setup : function () {
                moment.locale('en');
                moment.createFromInputFallback = function (config) {
                    throw new Error('input not handled by moment: ' + config._i);
                };
                setupDeprecationHandler(test, moment, 'core');
                if (lifecycle && lifecycle.setup) {
                    lifecycle.setup();
                }
            },
            teardown : function () {
                teardownDeprecationHandler(test, moment, 'core');
                if (lifecycle && lifecycle.teardown) {
                    lifecycle.teardown();
                }
            }
        });
    }

    function localeModule (name, lifecycle) {
        QUnit.module('locale:' + name, {
            setup : function () {
                moment.locale(name);
                moment.createFromInputFallback = function (config) {
                    throw new Error('input not handled by moment: ' + config._i);
                };
                setupDeprecationHandler(test, moment, 'locale');
                if (lifecycle && lifecycle.setup) {
                    lifecycle.setup();
                }
            },
            teardown : function () {
                moment.locale('en');
                teardownDeprecationHandler(test, moment, 'locale');
                if (lifecycle && lifecycle.teardown) {
                    lifecycle.teardown();
                }
            }
        });
        defineCommonLocaleTests(name, -1, -1);
    }

    localeModule('hy-am');

    test('parse', function (assert) {
        var tests = 'Õ°Õ¸ÖÕ¶Õ¾Õ¡Ö Õ°Õ¶Õ¾_ÖÕ¥Õ¿ÖÕ¾Õ¡Ö ÖÕ¿Ö_Õ´Õ¡ÖÕ¿ Õ´ÖÕ¿_Õ¡ÕºÖÕ«Õ¬ Õ¡ÕºÖ_Õ´Õ¡ÕµÕ«Õ½ Õ´ÕµÕ½_Õ°Õ¸ÖÕ¶Õ«Õ½ Õ°Õ¶Õ½_Õ°Õ¸ÖÕ¬Õ«Õ½ Õ°Õ¬Õ½_ÖÕ£Õ¸Õ½Õ¿Õ¸Õ½ ÖÕ£Õ½_Õ½Õ¥ÕºÕ¿Õ¥Õ´Õ¢Õ¥Ö Õ½ÕºÕ¿_Õ°Õ¸Õ¯Õ¿Õ¥Õ´Õ¢Õ¥Ö Õ°Õ¯Õ¿_Õ¶Õ¸ÕµÕ¥Õ´Õ¢Õ¥Ö Õ¶Õ´Õ¢_Õ¤Õ¥Õ¯Õ¿Õ¥Õ´Õ¢Õ¥Ö Õ¤Õ¯Õ¿'.split('_'), i;
        function equalTest(input, mmm, i) {
            assert.equal(moment(input, mmm).month(), i, input + ' should be month ' + (i + 1));
        }
        for (i = 0; i < 12; i++) {
            tests[i] = tests[i].split(' ');
            equalTest(tests[i][0], 'MMM', i);
            equalTest(tests[i][1], 'MMM', i);
            equalTest(tests[i][0], 'MMMM', i);
            equalTest(tests[i][1], 'MMMM', i);
            equalTest(tests[i][0].toLocaleLowerCase(), 'MMMM', i);
            equalTest(tests[i][1].toLocaleLowerCase(), 'MMMM', i);
            equalTest(tests[i][0].toLocaleUpperCase(), 'MMMM', i);
            equalTest(tests[i][1].toLocaleUpperCase(), 'MMMM', i);
        }
    });

    test('parse exceptional case', function (assert) {
        assert.equal(moment('11 Õ´Õ¡ÕµÕ«Õ½Õ« 1989', ['DD MMMM YYYY']).format('DD-MM-YYYY'), '11-05-1989');
    });

    test('format', function (assert) {
        var a = [
                ['dddd, Do MMMM YYYY, HH:mm:ss',       'Õ¯Õ«ÖÕ¡Õ¯Õ«, 14 ÖÕ¥Õ¿ÖÕ¾Õ¡ÖÕ« 2010, 15:25:50'],
                ['ddd, h A',                           'Õ¯ÖÕ¯, 3 ÖÕ¥ÖÕ¥Õ¯Õ¾Õ¡'],
                ['M Mo MM MMMM MMM',                   '2 2 02 ÖÕ¥Õ¿ÖÕ¾Õ¡Ö ÖÕ¿Ö'],
                ['YYYY YY',                            '2010 10'],
                ['D Do DD',                            '14 14 14'],
                ['d do dddd ddd dd',                   '0 0 Õ¯Õ«ÖÕ¡Õ¯Õ« Õ¯ÖÕ¯ Õ¯ÖÕ¯'],
                ['DDD DDDo DDDD',                      '45 45-ÖÕ¤ 045'],
                ['w wo ww',                            '7 7-ÖÕ¤ 07'],
                ['h hh',                               '3 03'],
                ['H HH',                               '15 15'],
                ['m mm',                               '25 25'],
                ['s ss',                               '50 50'],
                ['a A',                                'ÖÕ¥ÖÕ¥Õ¯Õ¾Õ¡ ÖÕ¥ÖÕ¥Õ¯Õ¾Õ¡'],
                ['[Õ¿Õ¡ÖÕ¾Õ¡] DDDo [ÖÖÕ¨]',                 'Õ¿Õ¡ÖÕ¾Õ¡ 45-ÖÕ¤ ÖÖÕ¨'],
                ['LTS',                                '15:25:50'],
                ['L',                                  '14.02.2010'],
                ['LL',                                 '14 ÖÕ¥Õ¿ÖÕ¾Õ¡ÖÕ« 2010 Õ©.'],
                ['LLL',                                '14 ÖÕ¥Õ¿ÖÕ¾Õ¡ÖÕ« 2010 Õ©., 15:25'],
                ['LLLL',                               'Õ¯Õ«ÖÕ¡Õ¯Õ«, 14 ÖÕ¥Õ¿ÖÕ¾Õ¡ÖÕ« 2010 Õ©., 15:25'],
                ['l',                                  '14.2.2010'],
                ['ll',                                 '14 ÖÕ¿Ö 2010 Õ©.'],
                ['lll',                                '14 ÖÕ¿Ö 2010 Õ©., 15:25'],
                ['llll',                               'Õ¯ÖÕ¯, 14 ÖÕ¿Ö 2010 Õ©., 15:25']
            ],
            b = moment(new Date(2010, 1, 14, 15, 25, 50, 125)),
            i;
        for (i = 0; i < a.length; i++) {
            assert.equal(b.format(a[i][0]), a[i][1], a[i][0] + ' ---> ' + a[i][1]);
        }
    });

    test('format meridiem', function (assert) {
        assert.equal(moment([2012, 11, 28, 0, 0]).format('A'), 'Õ£Õ«Õ·Õ¥ÖÕ¾Õ¡', 'night');
        assert.equal(moment([2012, 11, 28, 3, 59]).format('A'), 'Õ£Õ«Õ·Õ¥ÖÕ¾Õ¡', 'night');
        assert.equal(moment([2012, 11, 28, 4, 0]).format('A'), 'Õ¡Õ¼Õ¡Õ¾Õ¸Õ¿Õ¾Õ¡', 'morning');
        assert.equal(moment([2012, 11, 28, 11, 59]).format('A'), 'Õ¡Õ¼Õ¡Õ¾Õ¸Õ¿Õ¾Õ¡', 'morning');
        assert.equal(moment([2012, 11, 28, 12, 0]).format('A'), 'ÖÕ¥ÖÕ¥Õ¯Õ¾Õ¡', 'afternoon');
        assert.equal(moment([2012, 11, 28, 16, 59]).format('A'), 'ÖÕ¥ÖÕ¥Õ¯Õ¾Õ¡', 'afternoon');
        assert.equal(moment([2012, 11, 28, 17, 0]).format('A'), 'Õ¥ÖÕ¥Õ¯Õ¸ÕµÕ¡Õ¶', 'evening');
        assert.equal(moment([2012, 11, 28, 23, 59]).format('A'), 'Õ¥ÖÕ¥Õ¯Õ¸ÕµÕ¡Õ¶', 'evening');
    });

    test('format ordinal', function (assert) {
        assert.equal(moment([2011, 0, 1]).format('DDDo'), '1-Õ«Õ¶', '1-Õ«Õ¶');
        assert.equal(moment([2011, 0, 2]).format('DDDo'), '2-ÖÕ¤', '2-ÖÕ¤');
        assert.equal(moment([2011, 0, 3]).format('DDDo'), '3-ÖÕ¤', '3-ÖÕ¤');
        assert.equal(moment([2011, 0, 4]).format('DDDo'), '4-ÖÕ¤', '4-ÖÕ¤');
        assert.equal(moment([2011, 0, 5]).format('DDDo'), '5-ÖÕ¤', '5-ÖÕ¤');
        assert.equal(moment([2011, 0, 6]).format('DDDo'), '6-ÖÕ¤', '6-ÖÕ¤');
        assert.equal(moment([2011, 0, 7]).format('DDDo'), '7-ÖÕ¤', '7-ÖÕ¤');
        assert.equal(moment([2011, 0, 8]).format('DDDo'), '8-ÖÕ¤', '8-ÖÕ¤');
        assert.equal(moment([2011, 0, 9]).format('DDDo'), '9-ÖÕ¤', '9-ÖÕ¤');
        assert.equal(moment([2011, 0, 10]).format('DDDo'), '10-ÖÕ¤', '10-ÖÕ¤');

        assert.equal(moment([2011, 0, 11]).format('DDDo'), '11-ÖÕ¤', '11-ÖÕ¤');
        assert.equal(moment([2011, 0, 12]).format('DDDo'), '12-ÖÕ¤', '12-ÖÕ¤');
        assert.equal(moment([2011, 0, 13]).format('DDDo'), '13-ÖÕ¤', '13-ÖÕ¤');
        assert.equal(moment([2011, 0, 14]).format('DDDo'), '14-ÖÕ¤', '14-ÖÕ¤');
        assert.equal(moment([2011, 0, 15]).format('DDDo'), '15-ÖÕ¤', '15-ÖÕ¤');
        assert.equal(moment([2011, 0, 16]).format('DDDo'), '16-ÖÕ¤', '16-ÖÕ¤');
        assert.equal(moment([2011, 0, 17]).format('DDDo'), '17-ÖÕ¤', '17-ÖÕ¤');
        assert.equal(moment([2011, 0, 18]).format('DDDo'), '18-ÖÕ¤', '18-ÖÕ¤');
        assert.equal(moment([2011, 0, 19]).format('DDDo'), '19-ÖÕ¤', '19-ÖÕ¤');
        assert.equal(moment([2011, 0, 20]).format('DDDo'), '20-ÖÕ¤', '20-ÖÕ¤');

        assert.equal(moment([2011, 0, 21]).format('DDDo'), '21-ÖÕ¤', '21-ÖÕ¤');
        assert.equal(moment([2011, 0, 22]).format('DDDo'), '22-ÖÕ¤', '22-ÖÕ¤');
        assert.equal(moment([2011, 0, 23]).format('DDDo'), '23-ÖÕ¤', '23-ÖÕ¤');
        assert.equal(moment([2011, 0, 24]).format('DDDo'), '24-ÖÕ¤', '24-ÖÕ¤');
        assert.equal(moment([2011, 0, 25]).format('DDDo'), '25-ÖÕ¤', '25-ÖÕ¤');
        assert.equal(moment([2011, 0, 26]).format('DDDo'), '26-ÖÕ¤', '26-ÖÕ¤');
        assert.equal(moment([2011, 0, 27]).format('DDDo'), '27-ÖÕ¤', '27-ÖÕ¤');
        assert.equal(moment([2011, 0, 28]).format('DDDo'), '28-ÖÕ¤', '28-ÖÕ¤');
        assert.equal(moment([2011, 0, 29]).format('DDDo'), '29-ÖÕ¤', '29-ÖÕ¤');
        assert.equal(moment([2011, 0, 30]).format('DDDo'), '30-ÖÕ¤', '30-ÖÕ¤');

        assert.equal(moment([2011, 0, 31]).format('DDDo'), '31-ÖÕ¤', '31-ÖÕ¤');
    });

    test('format month', function (assert) {
        var expected = 'Õ°Õ¸ÖÕ¶Õ¾Õ¡Ö Õ°Õ¶Õ¾_ÖÕ¥Õ¿ÖÕ¾Õ¡Ö ÖÕ¿Ö_Õ´Õ¡ÖÕ¿ Õ´ÖÕ¿_Õ¡ÕºÖÕ«Õ¬ Õ¡ÕºÖ_Õ´Õ¡ÕµÕ«Õ½ Õ´ÕµÕ½_Õ°Õ¸ÖÕ¶Õ«Õ½ Õ°Õ¶Õ½_Õ°Õ¸ÖÕ¬Õ«Õ½ Õ°Õ¬Õ½_ÖÕ£Õ¸Õ½Õ¿Õ¸Õ½ ÖÕ£Õ½_Õ½Õ¥ÕºÕ¿Õ¥Õ´Õ¢Õ¥Ö Õ½ÕºÕ¿_Õ°Õ¸Õ¯Õ¿Õ¥Õ´Õ¢Õ¥Ö Õ°Õ¯Õ¿_Õ¶Õ¸ÕµÕ¥Õ´Õ¢Õ¥Ö Õ¶Õ´Õ¢_Õ¤Õ¥Õ¯Õ¿Õ¥Õ´Õ¢Õ¥Ö Õ¤Õ¯Õ¿'.split('_'), i;
        for (i = 0; i < expected.length; i++) {
            assert.equal(moment([2011, i, 1]).format('MMMM MMM'), expected[i], expected[i]);
        }
    });

    test('format month case', function (assert) {
        var months = {
            'nominative': 'Õ°Õ¸ÖÕ¶Õ¾Õ¡Ö_ÖÕ¥Õ¿ÖÕ¾Õ¡Ö_Õ´Õ¡ÖÕ¿_Õ¡ÕºÖÕ«Õ¬_Õ´Õ¡ÕµÕ«Õ½_Õ°Õ¸ÖÕ¶Õ«Õ½_Õ°Õ¸ÖÕ¬Õ«Õ½_ÖÕ£Õ¸Õ½Õ¿Õ¸Õ½_Õ½Õ¥ÕºÕ¿Õ¥Õ´Õ¢Õ¥Ö_Õ°Õ¸Õ¯Õ¿Õ¥Õ´Õ¢Õ¥Ö_Õ¶Õ¸ÕµÕ¥Õ´Õ¢Õ¥Ö_Õ¤Õ¥Õ¯Õ¿Õ¥Õ´Õ¢Õ¥Ö'.split('_'),
            'accusative': 'Õ°Õ¸ÖÕ¶Õ¾Õ¡ÖÕ«_ÖÕ¥Õ¿ÖÕ¾Õ¡ÖÕ«_Õ´Õ¡ÖÕ¿Õ«_Õ¡ÕºÖÕ«Õ¬Õ«_Õ´Õ¡ÕµÕ«Õ½Õ«_Õ°Õ¸ÖÕ¶Õ«Õ½Õ«_Õ°Õ¸ÖÕ¬Õ«Õ½Õ«_ÖÕ£Õ¸Õ½Õ¿Õ¸Õ½Õ«_Õ½Õ¥ÕºÕ¿Õ¥Õ´Õ¢Õ¥ÖÕ«_Õ°Õ¸Õ¯Õ¿Õ¥Õ´Õ¢Õ¥ÖÕ«_Õ¶Õ¸ÕµÕ¥Õ´Õ¢Õ¥ÖÕ«_Õ¤Õ¥Õ¯Õ¿Õ¥Õ´Õ¢Õ¥ÖÕ«'.split('_')
        }, i;
        for (i = 0; i < 12; i++) {
            assert.equal(moment([2011, i, 1]).format('D MMMM'), '1 ' + months.accusative[i], '1 ' + months.accusative[i]);
            assert.equal(moment([2011, i, 1]).format('MMMM'), months.nominative[i], '1 ' + months.nominative[i]);
        }
    });

    test('format month short case', function (assert) {
        var monthsShort = {
            'nominative': 'Õ°Õ¶Õ¾_ÖÕ¿Ö_Õ´ÖÕ¿_Õ¡ÕºÖ_Õ´ÕµÕ½_Õ°Õ¶Õ½_Õ°Õ¬Õ½_ÖÕ£Õ½_Õ½ÕºÕ¿_Õ°Õ¯Õ¿_Õ¶Õ´Õ¢_Õ¤Õ¯Õ¿'.split('_'),
            'accusative': 'Õ°Õ¶Õ¾_ÖÕ¿Ö_Õ´ÖÕ¿_Õ¡ÕºÖ_Õ´ÕµÕ½_Õ°Õ¶Õ½_Õ°Õ¬Õ½_ÖÕ£Õ½_Õ½ÕºÕ¿_Õ°Õ¯Õ¿_Õ¶Õ´Õ¢_Õ¤Õ¯Õ¿'.split('_')
        }, i;
        for (i = 0; i < 12; i++) {
            assert.equal(moment([2011, i, 1]).format('D MMM'), '1 ' + monthsShort.accusative[i], '1 ' + monthsShort.accusative[i]);
            assert.equal(moment([2011, i, 1]).format('MMM'), monthsShort.nominative[i], '1 ' + monthsShort.nominative[i]);
        }
    });

    test('format month case with escaped symbols', function (assert) {
        var months = {
            'nominative': 'Õ°Õ¸ÖÕ¶Õ¾Õ¡Ö_ÖÕ¥Õ¿ÖÕ¾Õ¡Ö_Õ´Õ¡ÖÕ¿_Õ¡ÕºÖÕ«Õ¬_Õ´Õ¡ÕµÕ«Õ½_Õ°Õ¸ÖÕ¶Õ«Õ½_Õ°Õ¸ÖÕ¬Õ«Õ½_ÖÕ£Õ¸Õ½Õ¿Õ¸Õ½_Õ½Õ¥ÕºÕ¿Õ¥Õ´Õ¢Õ¥Ö_Õ°Õ¸Õ¯Õ¿Õ¥Õ´Õ¢Õ¥Ö_Õ¶Õ¸ÕµÕ¥Õ´Õ¢Õ¥Ö_Õ¤Õ¥Õ¯Õ¿Õ¥Õ´Õ¢Õ¥Ö'.split('_'),
            'accusative': 'Õ°Õ¸ÖÕ¶Õ¾Õ¡ÖÕ«_ÖÕ¥Õ¿ÖÕ¾Õ¡ÖÕ«_Õ´Õ¡ÖÕ¿Õ«_Õ¡ÕºÖÕ«Õ¬Õ«_Õ´Õ¡ÕµÕ«Õ½Õ«_Õ°Õ¸ÖÕ¶Õ«Õ½Õ«_Õ°Õ¸ÖÕ¬Õ«Õ½Õ«_ÖÕ£Õ¸Õ½Õ¿Õ¸Õ½Õ«_Õ½Õ¥ÕºÕ¿Õ¥Õ´Õ¢Õ¥ÖÕ«_Õ°Õ¸Õ¯Õ¿Õ¥Õ´Õ¢Õ¥ÖÕ«_Õ¶Õ¸ÕµÕ¥Õ´Õ¢Õ¥ÖÕ«_Õ¤Õ¥Õ¯Õ¿Õ¥Õ´Õ¢Õ¥ÖÕ«'.split('_')
        }, i;
        for (i = 0; i < 12; i++) {
            assert.equal(moment([2013, i, 1]).format('D[] MMMM'), '1 ' + months.accusative[i], '1 ' + months.accusative[i]);
            assert.equal(moment([2013, i, 1]).format('[<i>]D[</i>] [<b>]MMMM[</b>]'), '<i>1</i> <b>' + months.accusative[i] + '</b>', '1 <b>' + months.accusative[i] + '</b>');
            assert.equal(moment([2013, i, 1]).format('D[-Õ«Õ¶ ÖÖÕ¨] MMMM'), '1-Õ«Õ¶ ÖÖÕ¨ ' + months.accusative[i], '1-Õ«Õ¶ ÖÖÕ¨ ' + months.accusative[i]);
            assert.equal(moment([2013, i, 1]).format('D, MMMM'), '1, ' + months.nominative[i], '1, ' + months.nominative[i]);
        }
    });

    test('format month short case with escaped symbols', function (assert) {
        var monthsShort = {
            'nominative': 'Õ°Õ¶Õ¾_ÖÕ¿Ö_Õ´ÖÕ¿_Õ¡ÕºÖ_Õ´ÕµÕ½_Õ°Õ¶Õ½_Õ°Õ¬Õ½_ÖÕ£Õ½_Õ½ÕºÕ¿_Õ°Õ¯Õ¿_Õ¶Õ´Õ¢_Õ¤Õ¯Õ¿'.split('_'),
            'accusative': 'Õ°Õ¶Õ¾_ÖÕ¿Ö_Õ´ÖÕ¿_Õ¡ÕºÖ_Õ´ÕµÕ½_Õ°Õ¶Õ½_Õ°Õ¬Õ½_ÖÕ£Õ½_Õ½ÕºÕ¿_Õ°Õ¯Õ¿_Õ¶Õ´Õ¢_Õ¤Õ¯Õ¿'.split('_')
        }, i;
        for (i = 0; i < 12; i++) {
            assert.equal(moment([2013, i, 1]).format('D[] MMM'), '1 ' + monthsShort.accusative[i], '1 ' + monthsShort.accusative[i]);
            assert.equal(moment([2013, i, 1]).format('[<i>]D[</i>] [<b>]MMM[</b>]'), '<i>1</i> <b>' + monthsShort.accusative[i] + '</b>', '1 <b>' + monthsShort.accusative[i] + '</b>');
            assert.equal(moment([2013, i, 1]).format('D[-Õ«Õ¶ ÖÖÕ¨] MMM'), '1-Õ«Õ¶ ÖÖÕ¨ ' + monthsShort.accusative[i], '1-Õ«Õ¶ ÖÖÕ¨ ' + monthsShort.accusative[i]);
            assert.equal(moment([2013, i, 1]).format('D, MMM'), '1, ' + monthsShort.nominative[i], '1, ' + monthsShort.nominative[i]);
        }
    });

    test('format week', function (assert) {
        var expected = 'Õ¯Õ«ÖÕ¡Õ¯Õ« Õ¯ÖÕ¯ Õ¯ÖÕ¯_Õ¥ÖÕ¯Õ¸ÖÕ·Õ¡Õ¢Õ©Õ« Õ¥ÖÕ¯ Õ¥ÖÕ¯_Õ¥ÖÕ¥ÖÕ·Õ¡Õ¢Õ©Õ« Õ¥ÖÖ Õ¥ÖÖ_Õ¹Õ¸ÖÕ¥ÖÕ·Õ¡Õ¢Õ©Õ« Õ¹ÖÖ Õ¹ÖÖ_Õ°Õ«Õ¶Õ£Õ·Õ¡Õ¢Õ©Õ« Õ°Õ¶Õ£ Õ°Õ¶Õ£_Õ¸ÖÖÕ¢Õ¡Õ© Õ¸ÖÖÕ¢ Õ¸ÖÖÕ¢_Õ·Õ¡Õ¢Õ¡Õ© Õ·Õ¢Õ© Õ·Õ¢Õ©'.split('_'), i;
        for (i = 0; i < expected.length; i++) {
            assert.equal(moment([2011, 0, 2 + i]).format('dddd ddd dd'), expected[i], expected[i]);
        }
    });

    test('from', function (assert) {
        var start = moment([2007, 1, 28]);
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 44}), true),  'Õ´Õ« ÖÕ¡Õ¶Õ« Õ¾Õ¡ÕµÖÕ¯ÕµÕ¡Õ¶',    '44 seconds = seconds');
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 45}), true),  'ÖÕ¸ÕºÕ¥',   '45 seconds = a minute');
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 89}), true),  'ÖÕ¸ÕºÕ¥',   '89 seconds = a minute');
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 90}), true),  '2 ÖÕ¸ÕºÕ¥',  '90 seconds = 2 minutes');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 44}), true),  '44 ÖÕ¸ÕºÕ¥', '44 minutes = 44 minutes');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 45}), true),  'ÕªÕ¡Õ´',    '45 minutes = an hour');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 89}), true),  'ÕªÕ¡Õ´',    '89 minutes = an hour');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 90}), true),  '2 ÕªÕ¡Õ´',    '90 minutes = 2 hours');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 5}), true),   '5 ÕªÕ¡Õ´',    '5 hours = 5 hours');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 21}), true),  '21 ÕªÕ¡Õ´',   '21 hours = 21 hours');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 22}), true),  'ÖÖ',      '22 hours = a day');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 35}), true),  'ÖÖ',      '35 hours = a day');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 36}), true),  '2 ÖÖ',     '36 hours = 2 days');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 1}), true),   'ÖÖ',      '1 day = a day');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 5}), true),   '5 ÖÖ',     '5 days = 5 days');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 11}), true),  '11 ÖÖ',     '11 days = 11 days');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 21}), true),  '21 ÖÖ',     '21 days = 21 days');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 25}), true),  '25 ÖÖ',    '25 days = 25 days');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 26}), true),  'Õ¡Õ´Õ«Õ½',    '26 days = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 30}), true),  'Õ¡Õ´Õ«Õ½',    '30 days = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 43}), true),  'Õ¡Õ´Õ«Õ½',    '43 days = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 46}), true),  '2 Õ¡Õ´Õ«Õ½',   '46 days = 2 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 74}), true),  '2 Õ¡Õ´Õ«Õ½',   '75 days = 2 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 76}), true),  '3 Õ¡Õ´Õ«Õ½',   '76 days = 3 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({M: 1}), true),   'Õ¡Õ´Õ«Õ½',    '1 month = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({M: 5}), true),   '5 Õ¡Õ´Õ«Õ½',   '5 months = 5 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 345}), true), 'Õ¿Õ¡ÖÕ«',     '345 days = a year');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 548}), true), '2 Õ¿Õ¡ÖÕ«',    '548 days = 2 years');
        assert.equal(start.from(moment([2007, 1, 28]).add({y: 1}), true),   'Õ¿Õ¡ÖÕ«',     '1 year = a year');
        assert.equal(start.from(moment([2007, 1, 28]).add({y: 5}), true),   '5 Õ¿Õ¡ÖÕ«',    '5 years = 5 years');
    });

    test('suffix', function (assert) {
        assert.equal(moment(30000).from(0), 'Õ´Õ« ÖÕ¡Õ¶Õ« Õ¾Õ¡ÕµÖÕ¯ÕµÕ¡Õ¶ Õ°Õ¥Õ¿Õ¸', 'prefix');
        assert.equal(moment(0).from(30000), 'Õ´Õ« ÖÕ¡Õ¶Õ« Õ¾Õ¡ÕµÖÕ¯ÕµÕ¡Õ¶ Õ¡Õ¼Õ¡Õ»', 'suffix');
    });

    test('fromNow', function (assert) {
        assert.equal(moment().add({s: 30}).fromNow(), 'Õ´Õ« ÖÕ¡Õ¶Õ« Õ¾Õ¡ÕµÖÕ¯ÕµÕ¡Õ¶ Õ°Õ¥Õ¿Õ¸', 'in seconds');
        assert.equal(moment().add({d: 5}).fromNow(), '5 ÖÖ Õ°Õ¥Õ¿Õ¸', 'in 5 days');
    });

    test('calendar day', function (assert) {
        var a = moment().hours(12).minutes(0).seconds(0);

        assert.equal(moment(a).calendar(),                   'Õ¡ÕµÕ½ÖÖ 12:00',   'today at the same time');
        assert.equal(moment(a).add({m: 25}).calendar(),      'Õ¡ÕµÕ½ÖÖ 12:25',   'Now plus 25 min');
        assert.equal(moment(a).add({h: 1}).calendar(),       'Õ¡ÕµÕ½ÖÖ 13:00',   'Now plus 1 hour');
        assert.equal(moment(a).add({d: 1}).calendar(),       'Õ¾Õ¡Õ²Õ¨ 12:00',    'tomorrow at the same time');
        assert.equal(moment(a).subtract({h: 1}).calendar(),  'Õ¡ÕµÕ½ÖÖ 11:00',   'Now minus 1 hour');
        assert.equal(moment(a).subtract({d: 1}).calendar(),  'Õ¥ÖÕ¥Õ¯ 12:00',    'yesterday at the same time');
    });

    test('calendar next week', function (assert) {
        var i, m;
        function makeFormat(d) {
            return 'dddd [ÖÖÕ¨ ÕªÕ¡Õ´Õ¨] LT';
        }

        for (i = 2; i < 7; i++) {
            m = moment().add({d: i});
            assert.equal(m.calendar(),       m.format(makeFormat(m)),  'Today + ' + i + ' days current time');
            m.hours(0).minutes(0).seconds(0).milliseconds(0);
            assert.equal(m.calendar(),       m.format(makeFormat(m)),  'Today + ' + i + ' days beginning of day');
            m.hours(23).minutes(59).seconds(59).milliseconds(999);
            assert.equal(m.calendar(),       m.format(makeFormat(m)),  'Today + ' + i + ' days end of day');
        }
    });

    test('calendar last week', function (assert) {
        var i, m;

        function makeFormat(d) {
            return '[Õ¡Õ¶ÖÕ¡Õ®] dddd [ÖÖÕ¨ ÕªÕ¡Õ´Õ¨] LT';
        }

        for (i = 2; i < 7; i++) {
            m = moment().subtract({d: i});
            assert.equal(m.calendar(),       m.format(makeFormat(m)),  'Today - ' + i + ' days current time');
            m.hours(0).minutes(0).seconds(0).milliseconds(0);
            assert.equal(m.calendar(),       m.format(makeFormat(m)),  'Today - ' + i + ' days beginning of day');
            m.hours(23).minutes(59).seconds(59).milliseconds(999);
            assert.equal(m.calendar(),       m.format(makeFormat(m)),  'Today - ' + i + ' days end of day');
        }
    });

    test('calendar all else', function (assert) {
        var weeksAgo = moment().subtract({w: 1}),
            weeksFromNow = moment().add({w: 1});

        assert.equal(weeksAgo.calendar(),       weeksAgo.format('L'),  '1 week ago');
        assert.equal(weeksFromNow.calendar(),   weeksFromNow.format('L'),  'in 1 week');

        weeksAgo = moment().subtract({w: 2});
        weeksFromNow = moment().add({w: 2});

        assert.equal(weeksAgo.calendar(),       weeksAgo.format('L'),  '2 weeks ago');
        assert.equal(weeksFromNow.calendar(),   weeksFromNow.format('L'),  'in 2 weeks');
    });

    test('weeks year starting sunday formatted', function (assert) {
        assert.equal(moment([2011, 11, 26]).format('w ww wo'), '1 01 1-Õ«Õ¶', 'Dec 26 2011 should be week 1');
        assert.equal(moment([2012,  0,  1]).format('w ww wo'), '1 01 1-Õ«Õ¶', 'Jan  1 2012 should be week 1');
        assert.equal(moment([2012,  0,  2]).format('w ww wo'), '2 02 2-ÖÕ¤', 'Jan  2 2012 should be week 2');
        assert.equal(moment([2012,  0,  8]).format('w ww wo'), '2 02 2-ÖÕ¤', 'Jan  8 2012 should be week 2');
        assert.equal(moment([2012,  0,  9]).format('w ww wo'), '3 03 3-ÖÕ¤', 'Jan  9 2012 should be week 3');
    });

}));

;(function (global, factory) {
   typeof exports === 'object' && typeof module !== 'undefined'
       && typeof require === 'function' ? factory(require('../../moment')) :
   typeof define === 'function' && define.amd ? define(['../../moment'], factory) :
   factory(global.moment)
}(this, function (moment) { 'use strict';

    function each(array, callback) {
        var i;
        for (i = 0; i < array.length; i++) {
            callback(array[i], i, array);
        }
    }

    function objectKeys(obj) {
        if (Object.keys) {
            return Object.keys(obj);
        } else {
            // IE8
            var res = [], i;
            for (i in obj) {
                if (obj.hasOwnProperty(i)) {
                    res.push(i);
                }
            }
            return res;
        }
    }

    // Pick the first defined of two or three arguments.
    function defaults(a, b, c) {
        if (a != null) {
            return a;
        }
        if (b != null) {
            return b;
        }
        return c;
    }

    function defineCommonLocaleTests(locale, options) {
        test('lenient ordinal parsing', function (assert) {
            var i, ordinalStr, testMoment;
            for (i = 1; i <= 31; ++i) {
                ordinalStr = moment([2014, 0, i]).format('YYYY MM Do');
                testMoment = moment(ordinalStr, 'YYYY MM Do');
                assert.equal(testMoment.year(), 2014,
                        'lenient ordinal parsing ' + i + ' year check');
                assert.equal(testMoment.month(), 0,
                        'lenient ordinal parsing ' + i + ' month check');
                assert.equal(testMoment.date(), i,
                        'lenient ordinal parsing ' + i + ' date check');
            }
        });

        test('lenient ordinal parsing of number', function (assert) {
            var i, testMoment;
            for (i = 1; i <= 31; ++i) {
                testMoment = moment('2014 01 ' + i, 'YYYY MM Do');
                assert.equal(testMoment.year(), 2014,
                        'lenient ordinal parsing of number ' + i + ' year check');
                assert.equal(testMoment.month(), 0,
                        'lenient ordinal parsing of number ' + i + ' month check');
                assert.equal(testMoment.date(), i,
                        'lenient ordinal parsing of number ' + i + ' date check');
            }
        });

        test('strict ordinal parsing', function (assert) {
            var i, ordinalStr, testMoment;
            for (i = 1; i <= 31; ++i) {
                ordinalStr = moment([2014, 0, i]).format('YYYY MM Do');
                testMoment = moment(ordinalStr, 'YYYY MM Do', true);
                assert.ok(testMoment.isValid(), 'strict ordinal parsing ' + i);
            }
        });

        test('meridiem invariant', function (assert) {
            var h, m, t1, t2;
            for (h = 0; h < 24; ++h) {
                for (m = 0; m < 60; m += 15) {
                    t1 = moment.utc([2000, 0, 1, h, m]);
                    t2 = moment.utc(t1.format('A h:mm'), 'A h:mm');
                    assert.equal(t2.format('HH:mm'), t1.format('HH:mm'),
                            'meridiem at ' + t1.format('HH:mm'));
                }
            }
        });

        test('date format correctness', function (assert) {
            var data, tokens;
            data = moment.localeData()._longDateFormat;
            tokens = objectKeys(data);
            each(tokens, function (srchToken) {
                // Check each format string to make sure it does not contain any
                // tokens that need to be expanded.
                each(tokens, function (baseToken) {
                    // strip escaped sequences
                    var format = data[baseToken].replace(/(\[[^\]]*\])/g, '');
                    assert.equal(false, !!~format.indexOf(srchToken),
                            'contains ' + srchToken + ' in ' + baseToken);
                });
            });
        });

        test('month parsing correctness', function (assert) {
            var i, m;

            if (locale === 'tr') {
                // I can't fix it :(
                expect(0);
                return;
            }
            function tester(format) {
                var r;
                r = moment(m.format(format), format);
                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format);
                r = moment(m.format(format).toLocaleUpperCase(), format);
                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' upper');
                r = moment(m.format(format).toLocaleLowerCase(), format);
                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' lower');

                r = moment(m.format(format), format, true);
                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' strict');
                r = moment(m.format(format).toLocaleUpperCase(), format, true);
                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' upper strict');
                r = moment(m.format(format).toLocaleLowerCase(), format, true);
                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' lower strict');
            }

            for (i = 0; i < 12; ++i) {
                m = moment([2015, i, 15, 18]);
                tester('MMM');
                tester('MMM.');
                tester('MMMM');
                tester('MMMM.');
            }
        });

        test('weekday parsing correctness', function (assert) {
            var i, m;

            if (locale === 'tr' || locale === 'az') {
                // There is a lower-case letter (Ä±), that converted to upper then
                // lower changes to i
                expect(0);
                return;
            }
            function tester(format) {
                var r, baseMsg = 'weekday ' + m.weekday() + ' fmt ' + format;
                r = moment(m.format(format), format);
                assert.equal(r.weekday(), m.weekday(), baseMsg);
                r = moment(m.format(format).toLocaleUpperCase(), format);
                assert.equal(r.weekday(), m.weekday(), baseMsg + ' upper');
                r = moment(m.format(format).toLocaleLowerCase(), format);
                assert.equal(r.weekday(), m.weekday(), baseMsg + ' lower');

                r = moment(m.format(format), format, true);
                assert.equal(r.weekday(), m.weekday(), baseMsg + ' strict');
                r = moment(m.format(format).toLocaleUpperCase(), format, true);
                assert.equal(r.weekday(), m.weekday(), baseMsg + ' upper strict');
                r = moment(m.format(format).toLocaleLowerCase(), format, true);
                assert.equal(r.weekday(), m.weekday(), baseMsg + ' lower strict');
            }

            for (i = 0; i < 7; ++i) {
                m = moment.utc([2015, i, 15, 18]);
                tester('dd');
                tester('ddd');
                tester('dddd');
            }
        });
    }

    function setupDeprecationHandler(test, moment, scope) {
        test._expectedDeprecations = null;
        test._observedDeprecations = null;
        test._oldSupress = moment.suppressDeprecationWarnings;
        moment.suppressDeprecationWarnings = true;
        test.expectedDeprecations = function () {
            test._expectedDeprecations = arguments;
            test._observedDeprecations = [];
        };
        moment.deprecationHandler = function (name, msg) {
            var deprecationId = matchedDeprecation(name, msg, test._expectedDeprecations);
            if (deprecationId === -1) {
                throw new Error('Unexpected deprecation thrown name=' +
                        name + ' msg=' + msg);
            }
            test._observedDeprecations[deprecationId] = 1;
        };
    }

    function teardownDeprecationHandler(test, moment, scope) {
        moment.suppressDeprecationWarnings = test._oldSupress;

        if (test._expectedDeprecations != null) {
            var missedDeprecations = [];
            each(test._expectedDeprecations, function (deprecationPattern, id) {
                if (test._observedDeprecations[id] !== 1) {
                    missedDeprecations.push(deprecationPattern);
                }
            });
            if (missedDeprecations.length !== 0) {
                throw new Error('Expected deprecation warnings did not happen: ' +
                        missedDeprecations.join(' '));
            }
        }
    }

    function matchedDeprecation(name, msg, deprecations) {
        if (deprecations == null) {
            return -1;
        }
        for (var i = 0; i < deprecations.length; ++i) {
            if (name != null && name === deprecations[i]) {
                return i;
            }
            if (msg != null && msg.substring(0, deprecations[i].length) === deprecations[i]) {
                return i;
            }
        }
        return -1;
    }

    /*global QUnit:false*/

    var test = QUnit.test;

    var expect = QUnit.expect;

    function module (name, lifecycle) {
        QUnit.module(name, {
            setup : function () {
                moment.locale('en');
                moment.createFromInputFallback = function (config) {
                    throw new Error('input not handled by moment: ' + config._i);
                };
                setupDeprecationHandler(test, moment, 'core');
                if (lifecycle && lifecycle.setup) {
                    lifecycle.setup();
                }
            },
            teardown : function () {
                teardownDeprecationHandler(test, moment, 'core');
                if (lifecycle && lifecycle.teardown) {
                    lifecycle.teardown();
                }
            }
        });
    }

    function localeModule (name, lifecycle) {
        QUnit.module('locale:' + name, {
            setup : function () {
                moment.locale(name);
                moment.createFromInputFallback = function (config) {
                    throw new Error('input not handled by moment: ' + config._i);
                };
                setupDeprecationHandler(test, moment, 'locale');
                if (lifecycle && lifecycle.setup) {
                    lifecycle.setup();
                }
            },
            teardown : function () {
                moment.locale('en');
                teardownDeprecationHandler(test, moment, 'locale');
                if (lifecycle && lifecycle.teardown) {
                    lifecycle.teardown();
                }
            }
        });
        defineCommonLocaleTests(name, -1, -1);
    }

    localeModule('id');

    test('parse', function (assert) {
        var tests = 'Januari Jan_Februari Feb_Maret Mar_April Apr_Mei Mei_Juni Jun_Juli Jul_Agustus Ags_September Sep_Oktober Okt_November Nov_Desember Des'.split('_'), i;
        function equalTest(input, mmm, i) {
            assert.equal(moment(input, mmm).month(), i, input + ' should be month ' + (i + 1));
        }
        for (i = 0; i < 12; i++) {
            tests[i] = tests[i].split(' ');
            equalTest(tests[i][0], 'MMM', i);
            equalTest(tests[i][1], 'MMM', i);
            equalTest(tests[i][0], 'MMMM', i);
            equalTest(tests[i][1], 'MMMM', i);
            equalTest(tests[i][0].toLocaleLowerCase(), 'MMMM', i);
            equalTest(tests[i][1].toLocaleLowerCase(), 'MMMM', i);
            equalTest(tests[i][0].toLocaleUpperCase(), 'MMMM', i);
            equalTest(tests[i][1].toLocaleUpperCase(), 'MMMM', i);
        }
    });

    test('format', function (assert) {
        var a = [
                ['dddd, MMMM Do YYYY, h:mm:ss a',      'Minggu, Februari 14 2010, 3:25:50 sore'],
                ['ddd, hA',                            'Min, 3sore'],
                ['M Mo MM MMMM MMM',                   '2 2 02 Februari Feb'],
                ['YYYY YY',                            '2010 10'],
                ['D Do DD',                            '14 14 14'],
                ['d do dddd ddd dd',                   '0 0 Minggu Min Mg'],
                ['DDD DDDo DDDD',                      '45 45 045'],
                ['w wo ww',                            '7 7 07'],
                ['h hh',                               '3 03'],
                ['H HH',                               '15 15'],
                ['m mm',                               '25 25'],
                ['s ss',                               '50 50'],
                ['a A',                                'sore sore'],
                ['[the] DDDo [day of the year]',       'the 45 day of the year'],
                ['LTS',                                '15.25.50'],
                ['L',                                  '14/02/2010'],
                ['LL',                                 '14 Februari 2010'],
                ['LLL',                                '14 Februari 2010 pukul 15.25'],
                ['LLLL',                               'Minggu, 14 Februari 2010 pukul 15.25'],
                ['l',                                  '14/2/2010'],
                ['ll',                                 '14 Feb 2010'],
                ['lll',                                '14 Feb 2010 pukul 15.25'],
                ['llll',                               'Min, 14 Feb 2010 pukul 15.25']
            ],
            b = moment(new Date(2010, 1, 14, 15, 25, 50, 125)),
            i;
        for (i = 0; i < a.length; i++) {
            assert.equal(b.format(a[i][0]), a[i][1], a[i][0] + ' ---> ' + a[i][1]);
        }
    });

    test('format month', function (assert) {
        var expected = 'Januari Jan_Februari Feb_Maret Mar_April Apr_Mei Mei_Juni Jun_Juli Jul_Agustus Ags_September Sep_Oktober Okt_November Nov_Desember Des'.split('_'), i;
        for (i = 0; i < expected.length; i++) {
            assert.equal(moment([2011, i, 1]).format('MMMM MMM'), expected[i], expected[i]);
        }
    });

    test('format week', function (assert) {
        var expected = 'Minggu Min Mg_Senin Sen Sn_Selasa Sel Sl_Rabu Rab Rb_Kamis Kam Km_Jumat Jum Jm_Sabtu Sab Sb'.split('_'), i;
        for (i = 0; i < expected.length; i++) {
            assert.equal(moment([2011, 0, 2 + i]).format('dddd ddd dd'), expected[i], expected[i]);
        }
    });

    test('from', function (assert) {
        var start = moment([2007, 1, 28]);
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 44}), true),  'beberapa detik', '44 seconds = a few seconds');
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 45}), true),  'semenit',      '45 seconds = a minute');
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 89}), true),  'semenit',      '89 seconds = a minute');
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 90}), true),  '2 menit',     '90 seconds = 2 minutes');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 44}), true),  '44 menit',    '44 minutes = 44 minutes');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 45}), true),  'sejam',       '45 minutes = an hour');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 89}), true),  'sejam',       '89 minutes = an hour');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 90}), true),  '2 jam',       '90 minutes = 2 hours');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 5}), true),   '5 jam',       '5 hours = 5 hours');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 21}), true),  '21 jam',      '21 hours = 21 hours');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 22}), true),  'sehari',         '22 hours = a day');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 35}), true),  'sehari',         '35 hours = a day');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 36}), true),  '2 hari',        '36 hours = 2 days');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 1}), true),   'sehari',         '1 day = a day');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 5}), true),   '5 hari',        '5 days = 5 days');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 25}), true),  '25 hari',       '25 days = 25 days');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 26}), true),  'sebulan',       '26 days = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 30}), true),  'sebulan',       '30 days = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 43}), true),  'sebulan',       '43 days = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 46}), true),  '2 bulan',      '46 days = 2 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 74}), true),  '2 bulan',      '75 days = 2 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 76}), true),  '3 bulan',      '76 days = 3 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({M: 1}), true),   'sebulan',       '1 month = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({M: 5}), true),   '5 bulan',      '5 months = 5 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 345}), true), 'setahun',        '345 days = a year');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 548}), true), '2 tahun',       '548 days = 2 years');
        assert.equal(start.from(moment([2007, 1, 28]).add({y: 1}), true),   'setahun',        '1 year = a year');
        assert.equal(start.from(moment([2007, 1, 28]).add({y: 5}), true),   '5 tahun',       '5 years = 5 years');
    });

    test('suffix', function (assert) {
        assert.equal(moment(30000).from(0), 'dalam beberapa detik',  'prefix');
        assert.equal(moment(0).from(30000), 'beberapa detik yang lalu', 'suffix');
    });

    test('now from now', function (assert) {
        assert.equal(moment().fromNow(), 'beberapa detik yang lalu',  'now from now should display as in the past');
    });

    test('fromNow', function (assert) {
        assert.equal(moment().add({s: 30}).fromNow(), 'dalam beberapa detik', 'in a few seconds');
        assert.equal(moment().add({d: 5}).fromNow(), 'dalam 5 hari', 'in 5 days');
    });

    test('calendar day', function (assert) {
        var a = moment().hours(12).minutes(0).seconds(0);

        assert.equal(moment(a).calendar(),                   'Hari ini pukul 12.00', 'today at the same time');
        assert.equal(moment(a).add({m: 25}).calendar(),      'Hari ini pukul 12.25', 'Now plus 25 min');
        assert.equal(moment(a).add({h: 1}).calendar(),       'Hari ini pukul 13.00', 'Now plus 1 hour');
        assert.equal(moment(a).add({d: 1}).calendar(),       'Besok pukul 12.00',    'tomorrow at the same time');
        assert.equal(moment(a).subtract({h: 1}).calendar(),  'Hari ini pukul 11.00', 'Now minus 1 hour');
        assert.equal(moment(a).subtract({d: 1}).calendar(),  'Kemarin pukul 12.00',  'yesterday at the same time');
    });

    test('calendar next week', function (assert) {
        var i, m;
        for (i = 2; i < 7; i++) {
            m = moment().add({d: i});
            assert.equal(m.calendar(),       m.format('dddd [pukul] LT'),  'Today + ' + i + ' days current time');
            m.hours(0).minutes(0).seconds(0).milliseconds(0);
            assert.equal(m.calendar(),       m.format('dddd [pukul] LT'),  'Today + ' + i + ' days beginning of day');
            m.hours(23).minutes(59).seconds(59).milliseconds(999);
            assert.equal(m.calendar(),       m.format('dddd [pukul] LT'),  'Today + ' + i + ' days end of day');
        }
    });

    test('calendar last week', function (assert) {
        var i, m;
        for (i = 2; i < 7; i++) {
            m = moment().subtract({d: i});
            assert.equal(m.calendar(),       m.format('dddd [lalu pukul] LT'),  'Today - ' + i + ' days current time');
            m.hours(0).minutes(0).seconds(0).milliseconds(0);
            assert.equal(m.calendar(),       m.format('dddd [lalu pukul] LT'),  'Today - ' + i + ' days beginning of day');
            m.hours(23).minutes(59).seconds(59).milliseconds(999);
            assert.equal(m.calendar(),       m.format('dddd [lalu pukul] LT'),  'Today - ' + i + ' days end of day');
        }
    });

    test('calendar all else', function (assert) {
        var weeksAgo = moment().subtract({w: 1}),
            weeksFromNow = moment().add({w: 1});

        assert.equal(weeksAgo.calendar(),       weeksAgo.format('L'),  '1 week ago');
        assert.equal(weeksFromNow.calendar(),   weeksFromNow.format('L'),  'in 1 week');

        weeksAgo = moment().subtract({w: 2});
        weeksFromNow = moment().add({w: 2});

        assert.equal(weeksAgo.calendar(),       weeksAgo.format('L'),  '2 weeks ago');
        assert.equal(weeksFromNow.calendar(),   weeksFromNow.format('L'),  'in 2 weeks');
    });

    test('weeks year starting sunday formatted', function (assert) {
        assert.equal(moment([2011, 11, 26]).format('w ww wo'), '1 01 1', 'Dec 26 2011 should be week 1');
        assert.equal(moment([2012,  0,  1]).format('w ww wo'), '1 01 1', 'Jan  1 2012 should be week 1');
        assert.equal(moment([2012,  0,  2]).format('w ww wo'), '2 02 2', 'Jan  2 2012 should be week 2');
        assert.equal(moment([2012,  0,  8]).format('w ww wo'), '2 02 2', 'Jan  8 2012 should be week 2');
        assert.equal(moment([2012,  0,  9]).format('w ww wo'), '3 03 3', 'Jan  9 2012 should be week 3');
    });

}));

;(function (global, factory) {
   typeof exports === 'object' && typeof module !== 'undefined'
       && typeof require === 'function' ? factory(require('../../moment')) :
   typeof define === 'function' && define.amd ? define(['../../moment'], factory) :
   factory(global.moment)
}(this, function (moment) { 'use strict';

    function each(array, callback) {
        var i;
        for (i = 0; i < array.length; i++) {
            callback(array[i], i, array);
        }
    }

    function objectKeys(obj) {
        if (Object.keys) {
            return Object.keys(obj);
        } else {
            // IE8
            var res = [], i;
            for (i in obj) {
                if (obj.hasOwnProperty(i)) {
                    res.push(i);
                }
            }
            return res;
        }
    }

    // Pick the first defined of two or three arguments.
    function defaults(a, b, c) {
        if (a != null) {
            return a;
        }
        if (b != null) {
            return b;
        }
        return c;
    }

    function defineCommonLocaleTests(locale, options) {
        test('lenient ordinal parsing', function (assert) {
            var i, ordinalStr, testMoment;
            for (i = 1; i <= 31; ++i) {
                ordinalStr = moment([2014, 0, i]).format('YYYY MM Do');
                testMoment = moment(ordinalStr, 'YYYY MM Do');
                assert.equal(testMoment.year(), 2014,
                        'lenient ordinal parsing ' + i + ' year check');
                assert.equal(testMoment.month(), 0,
                        'lenient ordinal parsing ' + i + ' month check');
                assert.equal(testMoment.date(), i,
                        'lenient ordinal parsing ' + i + ' date check');
            }
        });

        test('lenient ordinal parsing of number', function (assert) {
            var i, testMoment;
            for (i = 1; i <= 31; ++i) {
                testMoment = moment('2014 01 ' + i, 'YYYY MM Do');
                assert.equal(testMoment.year(), 2014,
                        'lenient ordinal parsing of number ' + i + ' year check');
                assert.equal(testMoment.month(), 0,
                        'lenient ordinal parsing of number ' + i + ' month check');
                assert.equal(testMoment.date(), i,
                        'lenient ordinal parsing of number ' + i + ' date check');
            }
        });

        test('strict ordinal parsing', function (assert) {
            var i, ordinalStr, testMoment;
            for (i = 1; i <= 31; ++i) {
                ordinalStr = moment([2014, 0, i]).format('YYYY MM Do');
                testMoment = moment(ordinalStr, 'YYYY MM Do', true);
                assert.ok(testMoment.isValid(), 'strict ordinal parsing ' + i);
            }
        });

        test('meridiem invariant', function (assert) {
            var h, m, t1, t2;
            for (h = 0; h < 24; ++h) {
                for (m = 0; m < 60; m += 15) {
                    t1 = moment.utc([2000, 0, 1, h, m]);
                    t2 = moment.utc(t1.format('A h:mm'), 'A h:mm');
                    assert.equal(t2.format('HH:mm'), t1.format('HH:mm'),
                            'meridiem at ' + t1.format('HH:mm'));
                }
            }
        });

        test('date format correctness', function (assert) {
            var data, tokens;
            data = moment.localeData()._longDateFormat;
            tokens = objectKeys(data);
            each(tokens, function (srchToken) {
                // Check each format string to make sure it does not contain any
                // tokens that need to be expanded.
                each(tokens, function (baseToken) {
                    // strip escaped sequences
                    var format = data[baseToken].replace(/(\[[^\]]*\])/g, '');
                    assert.equal(false, !!~format.indexOf(srchToken),
                            'contains ' + srchToken + ' in ' + baseToken);
                });
            });
        });

        test('month parsing correctness', function (assert) {
            var i, m;

            if (locale === 'tr') {
                // I can't fix it :(
                expect(0);
                return;
            }
            function tester(format) {
                var r;
                r = moment(m.format(format), format);
                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format);
                r = moment(m.format(format).toLocaleUpperCase(), format);
                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' upper');
                r = moment(m.format(format).toLocaleLowerCase(), format);
                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' lower');

                r = moment(m.format(format), format, true);
                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' strict');
                r = moment(m.format(format).toLocaleUpperCase(), format, true);
                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' upper strict');
                r = moment(m.format(format).toLocaleLowerCase(), format, true);
                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' lower strict');
            }

            for (i = 0; i < 12; ++i) {
                m = moment([2015, i, 15, 18]);
                tester('MMM');
                tester('MMM.');
                tester('MMMM');
                tester('MMMM.');
            }
        });

        test('weekday parsing correctness', function (assert) {
            var i, m;

            if (locale === 'tr' || locale === 'az') {
                // There is a lower-case letter (Ä±), that converted to upper then
                // lower changes to i
                expect(0);
                return;
            }
            function tester(format) {
                var r, baseMsg = 'weekday ' + m.weekday() + ' fmt ' + format;
                r = moment(m.format(format), format);
                assert.equal(r.weekday(), m.weekday(), baseMsg);
                r = moment(m.format(format).toLocaleUpperCase(), format);
                assert.equal(r.weekday(), m.weekday(), baseMsg + ' upper');
                r = moment(m.format(format).toLocaleLowerCase(), format);
                assert.equal(r.weekday(), m.weekday(), baseMsg + ' lower');

                r = moment(m.format(format), format, true);
                assert.equal(r.weekday(), m.weekday(), baseMsg + ' strict');
                r = moment(m.format(format).toLocaleUpperCase(), format, true);
                assert.equal(r.weekday(), m.weekday(), baseMsg + ' upper strict');
                r = moment(m.format(format).toLocaleLowerCase(), format, true);
                assert.equal(r.weekday(), m.weekday(), baseMsg + ' lower strict');
            }

            for (i = 0; i < 7; ++i) {
                m = moment.utc([2015, i, 15, 18]);
                tester('dd');
                tester('ddd');
                tester('dddd');
            }
        });
    }

    function setupDeprecationHandler(test, moment, scope) {
        test._expectedDeprecations = null;
        test._observedDeprecations = null;
        test._oldSupress = moment.suppressDeprecationWarnings;
        moment.suppressDeprecationWarnings = true;
        test.expectedDeprecations = function () {
            test._expectedDeprecations = arguments;
            test._observedDeprecations = [];
        };
        moment.deprecationHandler = function (name, msg) {
            var deprecationId = matchedDeprecation(name, msg, test._expectedDeprecations);
            if (deprecationId === -1) {
                throw new Error('Unexpected deprecation thrown name=' +
                        name + ' msg=' + msg);
            }
            test._observedDeprecations[deprecationId] = 1;
        };
    }

    function teardownDeprecationHandler(test, moment, scope) {
        moment.suppressDeprecationWarnings = test._oldSupress;

        if (test._expectedDeprecations != null) {
            var missedDeprecations = [];
            each(test._expectedDeprecations, function (deprecationPattern, id) {
                if (test._observedDeprecations[id] !== 1) {
                    missedDeprecations.push(deprecationPattern);
                }
            });
            if (missedDeprecations.length !== 0) {
                throw new Error('Expected deprecation warnings did not happen: ' +
                        missedDeprecations.join(' '));
            }
        }
    }

    function matchedDeprecation(name, msg, deprecations) {
        if (deprecations == null) {
            return -1;
        }
        for (var i = 0; i < deprecations.length; ++i) {
            if (name != null && name === deprecations[i]) {
                return i;
            }
            if (msg != null && msg.substring(0, deprecations[i].length) === deprecations[i]) {
                return i;
            }
        }
        return -1;
    }

    /*global QUnit:false*/

    var test = QUnit.test;

    var expect = QUnit.expect;

    function module (name, lifecycle) {
        QUnit.module(name, {
            setup : function () {
                moment.locale('en');
                moment.createFromInputFallback = function (config) {
                    throw new Error('input not handled by moment: ' + config._i);
                };
                setupDeprecationHandler(test, moment, 'core');
                if (lifecycle && lifecycle.setup) {
                    lifecycle.setup();
                }
            },
            teardown : function () {
                teardownDeprecationHandler(test, moment, 'core');
                if (lifecycle && lifecycle.teardown) {
                    lifecycle.teardown();
                }
            }
        });
    }

    function localeModule (name, lifecycle) {
        QUnit.module('locale:' + name, {
            setup : function () {
                moment.locale(name);
                moment.createFromInputFallback = function (config) {
                    throw new Error('input not handled by moment: ' + config._i);
                };
                setupDeprecationHandler(test, moment, 'locale');
                if (lifecycle && lifecycle.setup) {
                    lifecycle.setup();
                }
            },
            teardown : function () {
                moment.locale('en');
                teardownDeprecationHandler(test, moment, 'locale');
                if (lifecycle && lifecycle.teardown) {
                    lifecycle.teardown();
                }
            }
        });
        defineCommonLocaleTests(name, -1, -1);
    }

    localeModule('is');

    test('parse', function (assert) {
        var tests = 'janÃºar jan_febrÃºar feb_mars mar_aprÃ­l apr_maÃ­ maÃ­_jÃºnÃ­ jÃºn_jÃºlÃ­ jÃºl_Ã¡gÃºst Ã¡gÃº_september sep_oktÃ³ber okt_nÃ³vember nÃ³v_desember des'.split('_'), i;
        function equalTest(input, mmm, i) {
            assert.equal(moment(input, mmm).month(), i, input + ' should be month ' + (i + 1));
        }
        for (i = 0; i < 12; i++) {
            tests[i] = tests[i].split(' ');
            equalTest(tests[i][0], 'MMM', i);
            equalTest(tests[i][1], 'MMM', i);
            equalTest(tests[i][0], 'MMMM', i);
            equalTest(tests[i][1], 'MMMM', i);
            equalTest(tests[i][0].toLocaleLowerCase(), 'MMMM', i);
            equalTest(tests[i][1].toLocaleLowerCase(), 'MMMM', i);
            equalTest(tests[i][0].toLocaleUpperCase(), 'MMMM', i);
            equalTest(tests[i][1].toLocaleUpperCase(), 'MMMM', i);
        }
    });

    test('format', function (assert) {
        var a = [
                ['dddd, Do MMMM YYYY, h:mm:ss a',      'sunnudagur, 14. febrÃºar 2010, 3:25:50 pm'],
                ['ddd, hA',                            'sun, 3PM'],
                ['M Mo MM MMMM MMM',                   '2 2. 02 febrÃºar feb'],
                ['YYYY YY',                            '2010 10'],
                ['D Do DD',                            '14 14. 14'],
                ['d do dddd ddd dd',                   '0 0. sunnudagur sun Su'],
                ['DDD DDDo DDDD',                      '45 45. 045'],
                ['w wo ww',                            '6 6. 06'],
                ['h hh',                               '3 03'],
                ['H HH',                               '15 15'],
                ['m mm',                               '25 25'],
                ['s ss',                               '50 50'],
                ['a A',                                'pm PM'],
                ['[the] DDDo [day of the year]',       'the 45. day of the year'],
                ['LTS',                                '15:25:50'],
                ['L',                                  '14.02.2010'],
                ['LL',                                 '14. febrÃºar 2010'],
                ['LLL',                                '14. febrÃºar 2010 kl. 15:25'],
                ['LLLL',                               'sunnudagur, 14. febrÃºar 2010 kl. 15:25'],
                ['l',                                  '14.2.2010'],
                ['ll',                                 '14. feb 2010'],
                ['lll',                                '14. feb 2010 kl. 15:25'],
                ['llll',                               'sun, 14. feb 2010 kl. 15:25']
            ],
            b = moment(new Date(2010, 1, 14, 15, 25, 50, 125)),
            i;
        for (i = 0; i < a.length; i++) {
            assert.equal(b.format(a[i][0]), a[i][1], a[i][0] + ' ---> ' + a[i][1]);
        }
    });

    test('format ordinal', function (assert) {
        assert.equal(moment([2011, 0, 1]).format('DDDo'), '1.', '1.');
        assert.equal(moment([2011, 0, 2]).format('DDDo'), '2.', '2.');
        assert.equal(moment([2011, 0, 3]).format('DDDo'), '3.', '3.');
        assert.equal(moment([2011, 0, 4]).format('DDDo'), '4.', '4.');
        assert.equal(moment([2011, 0, 5]).format('DDDo'), '5.', '5.');
        assert.equal(moment([2011, 0, 6]).format('DDDo'), '6.', '6.');
        assert.equal(moment([2011, 0, 7]).format('DDDo'), '7.', '7.');
        assert.equal(moment([2011, 0, 8]).format('DDDo'), '8.', '8.');
        assert.equal(moment([2011, 0, 9]).format('DDDo'), '9.', '9.');
        assert.equal(moment([2011, 0, 10]).format('DDDo'), '10.', '10.');

        assert.equal(moment([2011, 0, 11]).format('DDDo'), '11.', '11.');
        assert.equal(moment([2011, 0, 12]).format('DDDo'), '12.', '12.');
        assert.equal(moment([2011, 0, 13]).format('DDDo'), '13.', '13.');
        assert.equal(moment([2011, 0, 14]).format('DDDo'), '14.', '14.');
        assert.equal(moment([2011, 0, 15]).format('DDDo'), '15.', '15.');
        assert.equal(moment([2011, 0, 16]).format('DDDo'), '16.', '16.');
        assert.equal(moment([2011, 0, 17]).format('DDDo'), '17.', '17.');
        assert.equal(moment([2011, 0, 18]).format('DDDo'), '18.', '18.');
        assert.equal(moment([2011, 0, 19]).format('DDDo'), '19.', '19.');
        assert.equal(moment([2011, 0, 20]).format('DDDo'), '20.', '20.');

        assert.equal(moment([2011, 0, 21]).format('DDDo'), '21.', '21.');
        assert.equal(moment([2011, 0, 22]).format('DDDo'), '22.', '22.');
        assert.equal(moment([2011, 0, 23]).format('DDDo'), '23.', '23.');
        assert.equal(moment([2011, 0, 24]).format('DDDo'), '24.', '24.');
        assert.equal(moment([2011, 0, 25]).format('DDDo'), '25.', '25.');
        assert.equal(moment([2011, 0, 26]).format('DDDo'), '26.', '26.');
        assert.equal(moment([2011, 0, 27]).format('DDDo'), '27.', '27.');
        assert.equal(moment([2011, 0, 28]).format('DDDo'), '28.', '28.');
        assert.equal(moment([2011, 0, 29]).format('DDDo'), '29.', '29.');
        assert.equal(moment([2011, 0, 30]).format('DDDo'), '30.', '30.');

        assert.equal(moment([2011, 0, 31]).format('DDDo'), '31.', '31.');
    });

    test('format month', function (assert) {
        var expected = 'janÃºar jan_febrÃºar feb_mars mar_aprÃ­l apr_maÃ­ maÃ­_jÃºnÃ­ jÃºn_jÃºlÃ­ jÃºl_Ã¡gÃºst Ã¡gÃº_september sep_oktÃ³ber okt_nÃ³vember nÃ³v_desember des'.split('_'), i;
        for (i = 0; i < expected.length; i++) {
            assert.equal(moment([2011, i, 1]).format('MMMM MMM'), expected[i], expected[i]);
        }
    });

    test('format week', function (assert) {
        var expected = 'sunnudagur sun Su_mÃ¡nudagur mÃ¡n MÃ¡_Ã¾riÃ°judagur Ã¾ri Ãr_miÃ°vikudagur miÃ° Mi_fimmtudagur fim Fi_fÃ¶studagur fÃ¶s FÃ¶_laugardagur lau La'.split('_'), i;
        for (i = 0; i < expected.length; i++) {
            assert.equal(moment([2011, 0, 2 + i]).format('dddd ddd dd'), expected[i], expected[i]);
        }
    });

    test('from', function (assert) {
        var start = moment([2007, 1, 28]);
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 44}), true),  'nokkrar sekÃºndur', '44 seconds = a few seconds');
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 45}), true),  'mÃ­nÃºta',      '45 seconds = a minute');
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 89}), true),  'mÃ­nÃºta',      '89 seconds = a minute');
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 90}), true),  '2 mÃ­nÃºtur',     '90 seconds = 2 minutes');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 44}), true),  '44 mÃ­nÃºtur',    '44 minutes = 44 minutes');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 21}), true),  '21 mÃ­nÃºta',    '21 minutes = 21 minutes');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 45}), true),  'klukkustund',       '45 minutes = an hour');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 89}), true),  'klukkustund',       '89 minutes = an hour');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 90}), true),  '2 klukkustundir',       '90 minutes = 2 hours');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 5}), true),   '5 klukkustundir',       '5 hours = 5 hours');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 21}), true),  '21 klukkustund',      '21 hours = 21 hours');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 22}), true),  'dagur',         '22 hours = a day');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 35}), true),  'dagur',         '35 hours = a day');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 36}), true),  '2 dagar',        '36 hours = 2 days');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 1}), true),   'dagur',         '1 day = a day');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 5}), true),   '5 dagar',        '5 days = 5 days');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 25}), true),  '25 dagar',       '25 days = 25 days');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 11}), true),  '11 dagar',       '11 days = 11 days');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 21}), true),  '21 dagur',       '21 days = 21 days');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 26}), true),  'mÃ¡nuÃ°ur',       '26 days = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 30}), true),  'mÃ¡nuÃ°ur',       '30 days = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 43}), true),  'mÃ¡nuÃ°ur',       '43 days = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 46}), true),  '2 mÃ¡nuÃ°ir',      '46 days = 2 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 74}), true),  '2 mÃ¡nuÃ°ir',      '75 days = 2 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 76}), true),  '3 mÃ¡nuÃ°ir',      '76 days = 3 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({M: 1}), true),   'mÃ¡nuÃ°ur',       '1 month = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({M: 5}), true),   '5 mÃ¡nuÃ°ir',      '5 months = 5 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 345}), true), 'Ã¡r',        '345 days = a year');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 548}), true), '2 Ã¡r',       '548 days = 2 years');
        assert.equal(start.from(moment([2007, 1, 28]).add({y: 1}), true),   'Ã¡r',        '1 year = a year');
        assert.equal(start.from(moment([2007, 1, 28]).add({y: 5}), true),   '5 Ã¡r',       '5 years = 5 years');
        assert.equal(start.from(moment([2007, 1, 28]).add({y: 21}), true),  '21 Ã¡r',       '21 years = 21 years');
    });

    test('suffix', function (assert) {
        assert.equal(moment(30000).from(0), 'eftir nokkrar sekÃºndur',  'prefix');
        assert.equal(moment(0).from(30000), 'fyrir nokkrum sekÃºndum sÃ­Ã°an', 'suffix');
        assert.equal(moment().subtract({m: 1}).fromNow(), 'fyrir mÃ­nÃºtu sÃ­Ã°an', 'a minute ago');
    });

    test('now from now', function (assert) {
        assert.equal(moment().fromNow(), 'fyrir nokkrum sekÃºndum sÃ­Ã°an',  'now from now should display as in the past');
    });

    test('fromNow', function (assert) {
        assert.equal(moment().add({s: 30}).fromNow(), 'eftir nokkrar sekÃºndur', 'in a few seconds');
        assert.equal(moment().add({m: 1}).fromNow(), 'eftir mÃ­nÃºtu', 'in a minute');
        assert.equal(moment().add({d: 5}).fromNow(), 'eftir 5 daga', 'in 5 days');
    });

    test('calendar day', function (assert) {
        var a = moment().hours(12).minutes(0).seconds(0);

        assert.equal(moment(a).calendar(),                   'Ã­ dag kl. 12:00',     'today at the same time');
        assert.equal(moment(a).add({m: 25}).calendar(),      'Ã­ dag kl. 12:25',     'Now plus 25 min');
        assert.equal(moment(a).add({h: 1}).calendar(),       'Ã­ dag kl. 13:00',     'Now plus 1 hour');
        assert.equal(moment(a).add({d: 1}).calendar(),       'Ã¡ morgun kl. 12:00',  'tomorrow at the same time');
        assert.equal(moment(a).subtract({h: 1}).calendar(),  'Ã­ dag kl. 11:00',     'Now minus 1 hour');
        assert.equal(moment(a).subtract({d: 1}).calendar(),  'Ã­ gÃ¦r kl. 12:00',     'yesterday at the same time');
    });

    test('calendar next week', function (assert) {
        var i, m;
        for (i = 2; i < 7; i++) {
            m = moment().add({d: i});
            assert.equal(m.calendar(),       m.format('dddd [kl.] LT'),  'Today + ' + i + ' days current time');
            m.hours(0).minutes(0).seconds(0).milliseconds(0);
            assert.equal(m.calendar(),       m.format('dddd [kl.] LT'),  'Today + ' + i + ' days beginning of day');
            m.hours(23).minutes(59).seconds(59).milliseconds(999);
            assert.equal(m.calendar(),       m.format('dddd [kl.] LT'),  'Today + ' + i + ' days end of day');
        }
    });

    test('calendar last week', function (assert) {
        var i, m;

        for (i = 2; i < 7; i++) {
            m = moment().subtract({d: i});
            assert.equal(m.calendar(),       m.format('[sÃ­Ã°asta] dddd [kl.] LT'),  'Today - ' + i + ' days current time');
            m.hours(0).minutes(0).seconds(0).milliseconds(0);
            assert.equal(m.calendar(),       m.format('[sÃ­Ã°asta] dddd [kl.] LT'),  'Today - ' + i + ' days beginning of day');
            m.hours(23).minutes(59).seconds(59).milliseconds(999);
            assert.equal(m.calendar(),       m.format('[sÃ­Ã°asta] dddd [kl.] LT'),  'Today - ' + i + ' days end of day');
        }
    });

    test('calendar all else', function (assert) {
        var weeksAgo = moment().subtract({w: 1}),
            weeksFromNow = moment().add({w: 1});

        assert.equal(weeksAgo.calendar(),       weeksAgo.format('L'),  '1 week ago');
        assert.equal(weeksFromNow.calendar(),   weeksFromNow.format('L'),  'in 1 week');

        weeksAgo = moment().subtract({w: 2});
        weeksFromNow = moment().add({w: 2});

        assert.equal(weeksAgo.calendar(),       weeksAgo.format('L'),  '2 weeks ago');
        assert.equal(weeksFromNow.calendar(),   weeksFromNow.format('L'),  'in 2 weeks');
    });

    test('weeks year starting sunday formatted', function (assert) {
        assert.equal(moment([2012, 0,  1]).format('w ww wo'), '52 52 52.', 'Jan  1 2012 should be week 52');
        assert.equal(moment([2012, 0,  2]).format('w ww wo'),  '1 01 1.', 'Jan  2 2012 should be week 1');
        assert.equal(moment([2012, 0,  8]).format('w ww wo'),  '1 01 1.', 'Jan  8 2012 should be week 1');
        assert.equal(moment([2012, 0,  9]).format('w ww wo'),  '2 02 2.', 'Jan  9 2012 should be week 2');
        assert.equal(moment([2012, 0, 15]).format('w ww wo'),  '2 02 2.', 'Jan 15 2012 should be week 2');
    });

}));

;(function (global, factory) {
   typeof exports === 'object' && typeof module !== 'undefined'
       && typeof require === 'function' ? factory(require('../../moment')) :
   typeof define === 'function' && define.amd ? define(['../../moment'], factory) :
   factory(global.moment)
}(this, function (moment) { 'use strict';

    function each(array, callback) {
        var i;
        for (i = 0; i < array.length; i++) {
            callback(array[i], i, array);
        }
    }

    function objectKeys(obj) {
        if (Object.keys) {
            return Object.keys(obj);
        } else {
            // IE8
            var res = [], i;
            for (i in obj) {
                if (obj.hasOwnProperty(i)) {
                    res.push(i);
                }
            }
            return res;
        }
    }

    // Pick the first defined of two or three arguments.
    function defaults(a, b, c) {
        if (a != null) {
            return a;
        }
        if (b != null) {
            return b;
        }
        return c;
    }

    function defineCommonLocaleTests(locale, options) {
        test('lenient ordinal parsing', function (assert) {
            var i, ordinalStr, testMoment;
            for (i = 1; i <= 31; ++i) {
                ordinalStr = moment([2014, 0, i]).format('YYYY MM Do');
                testMoment = moment(ordinalStr, 'YYYY MM Do');
                assert.equal(testMoment.year(), 2014,
                        'lenient ordinal parsing ' + i + ' year check');
                assert.equal(testMoment.month(), 0,
                        'lenient ordinal parsing ' + i + ' month check');
                assert.equal(testMoment.date(), i,
                        'lenient ordinal parsing ' + i + ' date check');
            }
        });

        test('lenient ordinal parsing of number', function (assert) {
            var i, testMoment;
            for (i = 1; i <= 31; ++i) {
                testMoment = moment('2014 01 ' + i, 'YYYY MM Do');
                assert.equal(testMoment.year(), 2014,
                        'lenient ordinal parsing of number ' + i + ' year check');
                assert.equal(testMoment.month(), 0,
                        'lenient ordinal parsing of number ' + i + ' month check');
                assert.equal(testMoment.date(), i,
                        'lenient ordinal parsing of number ' + i + ' date check');
            }
        });

        test('strict ordinal parsing', function (assert) {
            var i, ordinalStr, testMoment;
            for (i = 1; i <= 31; ++i) {
                ordinalStr = moment([2014, 0, i]).format('YYYY MM Do');
                testMoment = moment(ordinalStr, 'YYYY MM Do', true);
                assert.ok(testMoment.isValid(), 'strict ordinal parsing ' + i);
            }
        });

        test('meridiem invariant', function (assert) {
            var h, m, t1, t2;
            for (h = 0; h < 24; ++h) {
                for (m = 0; m < 60; m += 15) {
                    t1 = moment.utc([2000, 0, 1, h, m]);
                    t2 = moment.utc(t1.format('A h:mm'), 'A h:mm');
                    assert.equal(t2.format('HH:mm'), t1.format('HH:mm'),
                            'meridiem at ' + t1.format('HH:mm'));
                }
            }
        });

        test('date format correctness', function (assert) {
            var data, tokens;
            data = moment.localeData()._longDateFormat;
            tokens = objectKeys(data);
            each(tokens, function (srchToken) {
                // Check each format string to make sure it does not contain any
                // tokens that need to be expanded.
                each(tokens, function (baseToken) {
                    // strip escaped sequences
                    var format = data[baseToken].replace(/(\[[^\]]*\])/g, '');
                    assert.equal(false, !!~format.indexOf(srchToken),
                            'contains ' + srchToken + ' in ' + baseToken);
                });
            });
        });

        test('month parsing correctness', function (assert) {
            var i, m;

            if (locale === 'tr') {
                // I can't fix it :(
                expect(0);
                return;
            }
            function tester(format) {
                var r;
                r = moment(m.format(format), format);
                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format);
                r = moment(m.format(format).toLocaleUpperCase(), format);
                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' upper');
                r = moment(m.format(format).toLocaleLowerCase(), format);
                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' lower');

                r = moment(m.format(format), format, true);
                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' strict');
                r = moment(m.format(format).toLocaleUpperCase(), format, true);
                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' upper strict');
                r = moment(m.format(format).toLocaleLowerCase(), format, true);
                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' lower strict');
            }

            for (i = 0; i < 12; ++i) {
                m = moment([2015, i, 15, 18]);
                tester('MMM');
                tester('MMM.');
                tester('MMMM');
                tester('MMMM.');
            }
        });

        test('weekday parsing correctness', function (assert) {
            var i, m;

            if (locale === 'tr' || locale === 'az') {
                // There is a lower-case letter (Ä±), that converted to upper then
                // lower changes to i
                expect(0);
                return;
            }
            function tester(format) {
                var r, baseMsg = 'weekday ' + m.weekday() + ' fmt ' + format;
                r = moment(m.format(format), format);
                assert.equal(r.weekday(), m.weekday(), baseMsg);
                r = moment(m.format(format).toLocaleUpperCase(), format);
                assert.equal(r.weekday(), m.weekday(), baseMsg + ' upper');
                r = moment(m.format(format).toLocaleLowerCase(), format);
                assert.equal(r.weekday(), m.weekday(), baseMsg + ' lower');

                r = moment(m.format(format), format, true);
                assert.equal(r.weekday(), m.weekday(), baseMsg + ' strict');
                r = moment(m.format(format).toLocaleUpperCase(), format, true);
                assert.equal(r.weekday(), m.weekday(), baseMsg + ' upper strict');
                r = moment(m.format(format).toLocaleLowerCase(), format, true);
                assert.equal(r.weekday(), m.weekday(), baseMsg + ' lower strict');
            }

            for (i = 0; i < 7; ++i) {
                m = moment.utc([2015, i, 15, 18]);
                tester('dd');
                tester('ddd');
                tester('dddd');
            }
        });
    }

    function setupDeprecationHandler(test, moment, scope) {
        test._expectedDeprecations = null;
        test._observedDeprecations = null;
        test._oldSupress = moment.suppressDeprecationWarnings;
        moment.suppressDeprecationWarnings = true;
        test.expectedDeprecations = function () {
            test._expectedDeprecations = arguments;
            test._observedDeprecations = [];
        };
        moment.deprecationHandler = function (name, msg) {
            var deprecationId = matchedDeprecation(name, msg, test._expectedDeprecations);
            if (deprecationId === -1) {
                throw new Error('Unexpected deprecation thrown name=' +
                        name + ' msg=' + msg);
            }
            test._observedDeprecations[deprecationId] = 1;
        };
    }

    function teardownDeprecationHandler(test, moment, scope) {
        moment.suppressDeprecationWarnings = test._oldSupress;

        if (test._expectedDeprecations != null) {
            var missedDeprecations = [];
            each(test._expectedDeprecations, function (deprecationPattern, id) {
                if (test._observedDeprecations[id] !== 1) {
                    missedDeprecations.push(deprecationPattern);
                }
            });
            if (missedDeprecations.length !== 0) {
                throw new Error('Expected deprecation warnings did not happen: ' +
                        missedDeprecations.join(' '));
            }
        }
    }

    function matchedDeprecation(name, msg, deprecations) {
        if (deprecations == null) {
            return -1;
        }
        for (var i = 0; i < deprecations.length; ++i) {
            if (name != null && name === deprecations[i]) {
                return i;
            }
            if (msg != null && msg.substring(0, deprecations[i].length) === deprecations[i]) {
                return i;
            }
        }
        return -1;
    }

    /*global QUnit:false*/

    var test = QUnit.test;

    var expect = QUnit.expect;

    function module (name, lifecycle) {
        QUnit.module(name, {
            setup : function () {
                moment.locale('en');
                moment.createFromInputFallback = function (config) {
                    throw new Error('input not handled by moment: ' + config._i);
                };
                setupDeprecationHandler(test, moment, 'core');
                if (lifecycle && lifecycle.setup) {
                    lifecycle.setup();
                }
            },
            teardown : function () {
                teardownDeprecationHandler(test, moment, 'core');
                if (lifecycle && lifecycle.teardown) {
                    lifecycle.teardown();
                }
            }
        });
    }

    function localeModule (name, lifecycle) {
        QUnit.module('locale:' + name, {
            setup : function () {
                moment.locale(name);
                moment.createFromInputFallback = function (config) {
                    throw new Error('input not handled by moment: ' + config._i);
                };
                setupDeprecationHandler(test, moment, 'locale');
                if (lifecycle && lifecycle.setup) {
                    lifecycle.setup();
                }
            },
            teardown : function () {
                moment.locale('en');
                teardownDeprecationHandler(test, moment, 'locale');
                if (lifecycle && lifecycle.teardown) {
                    lifecycle.teardown();
                }
            }
        });
        defineCommonLocaleTests(name, -1, -1);
    }

    localeModule('it');

    test('parse', function (assert) {
        var tests = 'gennaio gen_febbraio feb_marzo mar_aprile apr_maggio mag_giugno giu_luglio lug_agosto ago_settembre set_ottobre ott_novembre nov_dicembre dic'.split('_'), i;
        function equalTest(input, mmm, i) {
            assert.equal(moment(input, mmm).month(), i, input + ' should be month ' + (i + 1));
        }
        for (i = 0; i < 12; i++) {
            tests[i] = tests[i].split(' ');
            equalTest(tests[i][0], 'MMM', i);
            equalTest(tests[i][1], 'MMM', i);
            equalTest(tests[i][0], 'MMMM', i);
            equalTest(tests[i][1], 'MMMM', i);
            equalTest(tests[i][0].toLocaleLowerCase(), 'MMMM', i);
            equalTest(tests[i][1].toLocaleLowerCase(), 'MMMM', i);
            equalTest(tests[i][0].toLocaleUpperCase(), 'MMMM', i);
            equalTest(tests[i][1].toLocaleUpperCase(), 'MMMM', i);
        }
    });

    test('format', function (assert) {
        var a = [
                ['dddd, MMMM Do YYYY, h:mm:ss a',      'Domenica, febbraio 14Âº 2010, 3:25:50 pm'],
                ['ddd, hA',                            'Dom, 3PM'],
                ['M Mo MM MMMM MMM',                   '2 2Âº 02 febbraio feb'],
                ['YYYY YY',                            '2010 10'],
                ['D Do DD',                            '14 14Âº 14'],
                ['d do dddd ddd dd',                   '0 0Âº Domenica Dom Do'],
                ['DDD DDDo DDDD',                      '45 45Âº 045'],
                ['w wo ww',                            '6 6Âº 06'],
                ['h hh',                               '3 03'],
                ['H HH',                               '15 15'],
                ['m mm',                               '25 25'],
                ['s ss',                               '50 50'],
                ['a A',                                'pm PM'],
                ['[the] DDDo [day of the year]',       'the 45Âº day of the year'],
                ['LTS',                                '15:25:50'],
                ['L',                                  '14/02/2010'],
                ['LL',                                 '14 febbraio 2010'],
                ['LLL',                                '14 febbraio 2010 15:25'],
                ['LLLL',                               'Domenica, 14 febbraio 2010 15:25'],
                ['l',                                  '14/2/2010'],
                ['ll',                                 '14 feb 2010'],
                ['lll',                                '14 feb 2010 15:25'],
                ['llll',                               'Dom, 14 feb 2010 15:25']
            ],
            b = moment(new Date(2010, 1, 14, 15, 25, 50, 125)),
            i;
        for (i = 0; i < a.length; i++) {
            assert.equal(b.format(a[i][0]), a[i][1], a[i][0] + ' ---> ' + a[i][1]);
        }
    });

    test('format ordinal', function (assert) {
        assert.equal(moment([2011, 0, 1]).format('DDDo'), '1Âº', '1Âº');
        assert.equal(moment([2011, 0, 2]).format('DDDo'), '2Âº', '2Âº');
        assert.equal(moment([2011, 0, 3]).format('DDDo'), '3Âº', '3Âº');
        assert.equal(moment([2011, 0, 4]).format('DDDo'), '4Âº', '4Âº');
        assert.equal(moment([2011, 0, 5]).format('DDDo'), '5Âº', '5Âº');
        assert.equal(moment([2011, 0, 6]).format('DDDo'), '6Âº', '6Âº');
        assert.equal(moment([2011, 0, 7]).format('DDDo'), '7Âº', '7Âº');
        assert.equal(moment([2011, 0, 8]).format('DDDo'), '8Âº', '8Âº');
        assert.equal(moment([2011, 0, 9]).format('DDDo'), '9Âº', '9Âº');
        assert.equal(moment([2011, 0, 10]).format('DDDo'), '10Âº', '10Âº');

        assert.equal(moment([2011, 0, 11]).format('DDDo'), '11Âº', '11Âº');
        assert.equal(moment([2011, 0, 12]).format('DDDo'), '12Âº', '12Âº');
        assert.equal(moment([2011, 0, 13]).format('DDDo'), '13Âº', '13Âº');
        assert.equal(moment([2011, 0, 14]).format('DDDo'), '14Âº', '14Âº');
        assert.equal(moment([2011, 0, 15]).format('DDDo'), '15Âº', '15Âº');
        assert.equal(moment([2011, 0, 16]).format('DDDo'), '16Âº', '16Âº');
        assert.equal(moment([2011, 0, 17]).format('DDDo'), '17Âº', '17Âº');
        assert.equal(moment([2011, 0, 18]).format('DDDo'), '18Âº', '18Âº');
        assert.equal(moment([2011, 0, 19]).format('DDDo'), '19Âº', '19Âº');
        assert.equal(moment([2011, 0, 20]).format('DDDo'), '20Âº', '20Âº');

        assert.equal(moment([2011, 0, 21]).format('DDDo'), '21Âº', '21Âº');
        assert.equal(moment([2011, 0, 22]).format('DDDo'), '22Âº', '22Âº');
        assert.equal(moment([2011, 0, 23]).format('DDDo'), '23Âº', '23Âº');
        assert.equal(moment([2011, 0, 24]).format('DDDo'), '24Âº', '24Âº');
        assert.equal(moment([2011, 0, 25]).format('DDDo'), '25Âº', '25Âº');
        assert.equal(moment([2011, 0, 26]).format('DDDo'), '26Âº', '26Âº');
        assert.equal(moment([2011, 0, 27]).format('DDDo'), '27Âº', '27Âº');
        assert.equal(moment([2011, 0, 28]).format('DDDo'), '28Âº', '28Âº');
        assert.equal(moment([2011, 0, 29]).format('DDDo'), '29Âº', '29Âº');
        assert.equal(moment([2011, 0, 30]).format('DDDo'), '30Âº', '30Âº');

        assert.equal(moment([2011, 0, 31]).format('DDDo'), '31Âº', '31Âº');
    });

    test('format month', function (assert) {
        var expected = 'gennaio gen_febbraio feb_marzo mar_aprile apr_maggio mag_giugno giu_luglio lug_agosto ago_settembre set_ottobre ott_novembre nov_dicembre dic'.split('_'), i;
        for (i = 0; i < expected.length; i++) {
            assert.equal(moment([2011, i, 1]).format('MMMM MMM'), expected[i], expected[i]);
        }
    });

    test('format week', function (assert) {
        var expected = 'Domenica Dom Do_LunedÃ¬ Lun Lu_MartedÃ¬ Mar Ma_MercoledÃ¬ Mer Me_GiovedÃ¬ Gio Gi_VenerdÃ¬ Ven Ve_Sabato Sab Sa'.split('_'), i;
        for (i = 0; i < expected.length; i++) {
            assert.equal(moment([2011, 0, 2 + i]).format('dddd ddd dd'), expected[i], expected[i]);
        }
    });

    test('from', function (assert) {
        var start = moment([2007, 1, 28]);
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 44}), true),  'alcuni secondi', '44 seconds = seconds');
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 45}), true),  'un minuto',      '45 seconds = a minute');
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 89}), true),  'un minuto',      '89 seconds = a minute');
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 90}), true),  '2 minuti',       '90 seconds = 2 minutes');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 44}), true),  '44 minuti',      '44 minutes = 44 minutes');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 45}), true),  'un\'ora',        '45 minutes = an hour');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 89}), true),  'un\'ora',        '89 minutes = an hour');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 90}), true),  '2 ore',          '90 minutes = 2 hours');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 5}), true),   '5 ore',          '5 hours = 5 hours');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 21}), true),  '21 ore',         '21 hours = 21 hours');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 22}), true),  'un giorno',      '22 hours = a day');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 35}), true),  'un giorno',      '35 hours = a day');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 36}), true),  '2 giorni',       '36 hours = 2 days');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 1}), true),   'un giorno',      '1 day = a day');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 5}), true),   '5 giorni',       '5 days = 5 days');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 25}), true),  '25 giorni',      '25 days = 25 days');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 26}), true),  'un mese',        '26 days = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 30}), true),  'un mese',        '30 days = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 43}), true),  'un mese',        '43 days = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 46}), true),  '2 mesi',         '46 days = 2 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 74}), true),  '2 mesi',         '75 days = 2 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 76}), true),  '3 mesi',         '76 days = 3 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({M: 1}), true),   'un mese',        '1 month = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({M: 5}), true),   '5 mesi',         '5 months = 5 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 345}), true), 'un anno',        '345 days = a year');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 548}), true), '2 anni',         '548 days = 2 years');
        assert.equal(start.from(moment([2007, 1, 28]).add({y: 1}), true),   'un anno',        '1 year = a year');
        assert.equal(start.from(moment([2007, 1, 28]).add({y: 5}), true),   '5 anni',         '5 years = 5 years');
    });

    test('suffix', function (assert) {
        assert.equal(moment(30000).from(0), 'in alcuni secondi', 'prefix');
        assert.equal(moment(0).from(30000), 'alcuni secondi fa', 'suffix');
    });

    test('fromNow', function (assert) {
        assert.equal(moment().add({s: 30}).fromNow(), 'in alcuni secondi', 'in seconds');
        assert.equal(moment().add({d: 5}).fromNow(), 'tra 5 giorni', 'in 5 days');
    });

    test('calendar day', function (assert) {
        var a = moment().hours(12).minutes(0).seconds(0);

        assert.equal(moment(a).calendar(),                   'Oggi alle 12:00',     'today at the same time');
        assert.equal(moment(a).add({m: 25}).calendar(),      'Oggi alle 12:25',     'Now plus 25 min');
        assert.equal(moment(a).add({h: 1}).calendar(),       'Oggi alle 13:00',     'Now plus 1 hour');
        assert.equal(moment(a).add({d: 1}).calendar(),       'Domani alle 12:00',   'tomorrow at the same time');
        assert.equal(moment(a).subtract({h: 1}).calendar(),  'Oggi alle 11:00',     'Now minus 1 hour');
        assert.equal(moment(a).subtract({d: 1}).calendar(),  'Ieri alle 12:00',     'yesterday at the same time');
    });

    test('calendar next week', function (assert) {
        var i, m;
        for (i = 2; i < 7; i++) {
            m = moment().add({d: i});
            assert.equal(m.calendar(),       m.format('dddd [alle] LT'),  'Today + ' + i + ' days current time');
            m.hours(0).minutes(0).seconds(0).milliseconds(0);
            assert.equal(m.calendar(),       m.format('dddd [alle] LT'),  'Today + ' + i + ' days beginning of day');
            m.hours(23).minutes(59).seconds(59).milliseconds(999);
            assert.equal(m.calendar(),       m.format('dddd [alle] LT'),  'Today + ' + i + ' days end of day');
        }
    });

    test('calendar last week', function (assert) {
        var i, m, weekday, datestring;
        for (i = 2; i < 7; i++) {
            m = moment().subtract({d: i});
            // Different date string
            weekday = parseInt(m.format('d'), 10);
            datestring = (weekday === 0) ? '[la scorsa] dddd [alle] LT' : '[lo scorso] dddd [alle] LT';
            assert.equal(m.calendar(), m.format(datestring), 'Today - ' + i + ' days current time');
            m.hours(0).minutes(0).seconds(0).milliseconds(0);
            assert.equal(m.calendar(), m.format(datestring), 'Today - ' + i + ' days beginning of day');
            m.hours(23).minutes(59).seconds(59).milliseconds(999);
            assert.equal(m.calendar(), m.format(datestring), 'Today - ' + i + ' days end of day');
        }
    });

    test('calendar all else', function (assert) {
        var weeksAgo = moment().subtract({w: 1}),
            weeksFromNow = moment().add({w: 1});

        assert.equal(weeksAgo.calendar(),       weeksAgo.format('L'),  '1 week ago');
        assert.equal(weeksFromNow.calendar(),   weeksFromNow.format('L'),  'in 1 week');

        weeksAgo = moment().subtract({w: 2});
        weeksFromNow = moment().add({w: 2});

        assert.equal(weeksAgo.calendar(),       weeksAgo.format('L'),  '2 weeks ago');
        assert.equal(weeksFromNow.calendar(),   weeksFromNow.format('L'),  'in 2 weeks');
    });

    test('weeks year starting sunday formatted', function (assert) {
        assert.equal(moment([2012, 0,  1]).format('w ww wo'), '52 52 52Âº', 'Jan  1 2012 should be week 52');
        assert.equal(moment([2012, 0,  2]).format('w ww wo'),  '1 01 1Âº', 'Jan  2 2012 should be week 1');
        assert.equal(moment([2012, 0,  8]).format('w ww wo'),  '1 01 1Âº', 'Jan  8 2012 should be week 1');
        assert.equal(moment([2012, 0,  9]).format('w ww wo'),  '2 02 2Âº', 'Jan  9 2012 should be week 2');
        assert.equal(moment([2012, 0, 15]).format('w ww wo'),  '2 02 2Âº', 'Jan 15 2012 should be week 2');
    });

}));

;(function (global, factory) {
   typeof exports === 'object' && typeof module !== 'undefined'
       && typeof require === 'function' ? factory(require('../../moment')) :
   typeof define === 'function' && define.amd ? define(['../../moment'], factory) :
   factory(global.moment)
}(this, function (moment) { 'use strict';

    function each(array, callback) {
        var i;
        for (i = 0; i < array.length; i++) {
            callback(array[i], i, array);
        }
    }

    function objectKeys(obj) {
        if (Object.keys) {
            return Object.keys(obj);
        } else {
            // IE8
            var res = [], i;
            for (i in obj) {
                if (obj.hasOwnProperty(i)) {
                    res.push(i);
                }
            }
            return res;
        }
    }

    // Pick the first defined of two or three arguments.
    function defaults(a, b, c) {
        if (a != null) {
            return a;
        }
        if (b != null) {
            return b;
        }
        return c;
    }

    function defineCommonLocaleTests(locale, options) {
        test('lenient ordinal parsing', function (assert) {
            var i, ordinalStr, testMoment;
            for (i = 1; i <= 31; ++i) {
                ordinalStr = moment([2014, 0, i]).format('YYYY MM Do');
                testMoment = moment(ordinalStr, 'YYYY MM Do');
                assert.equal(testMoment.year(), 2014,
                        'lenient ordinal parsing ' + i + ' year check');
                assert.equal(testMoment.month(), 0,
                        'lenient ordinal parsing ' + i + ' month check');
                assert.equal(testMoment.date(), i,
                        'lenient ordinal parsing ' + i + ' date check');
            }
        });

        test('lenient ordinal parsing of number', function (assert) {
            var i, testMoment;
            for (i = 1; i <= 31; ++i) {
                testMoment = moment('2014 01 ' + i, 'YYYY MM Do');
                assert.equal(testMoment.year(), 2014,
                        'lenient ordinal parsing of number ' + i + ' year check');
                assert.equal(testMoment.month(), 0,
                        'lenient ordinal parsing of number ' + i + ' month check');
                assert.equal(testMoment.date(), i,
                        'lenient ordinal parsing of number ' + i + ' date check');
            }
        });

        test('strict ordinal parsing', function (assert) {
            var i, ordinalStr, testMoment;
            for (i = 1; i <= 31; ++i) {
                ordinalStr = moment([2014, 0, i]).format('YYYY MM Do');
                testMoment = moment(ordinalStr, 'YYYY MM Do', true);
                assert.ok(testMoment.isValid(), 'strict ordinal parsing ' + i);
            }
        });

        test('meridiem invariant', function (assert) {
            var h, m, t1, t2;
            for (h = 0; h < 24; ++h) {
                for (m = 0; m < 60; m += 15) {
                    t1 = moment.utc([2000, 0, 1, h, m]);
                    t2 = moment.utc(t1.format('A h:mm'), 'A h:mm');
                    assert.equal(t2.format('HH:mm'), t1.format('HH:mm'),
                            'meridiem at ' + t1.format('HH:mm'));
                }
            }
        });

        test('date format correctness', function (assert) {
            var data, tokens;
            data = moment.localeData()._longDateFormat;
            tokens = objectKeys(data);
            each(tokens, function (srchToken) {
                // Check each format string to make sure it does not contain any
                // tokens that need to be expanded.
                each(tokens, function (baseToken) {
                    // strip escaped sequences
                    var format = data[baseToken].replace(/(\[[^\]]*\])/g, '');
                    assert.equal(false, !!~format.indexOf(srchToken),
                            'contains ' + srchToken + ' in ' + baseToken);
                });
            });
        });

        test('month parsing correctness', function (assert) {
            var i, m;

            if (locale === 'tr') {
                // I can't fix it :(
                expect(0);
                return;
            }
            function tester(format) {
                var r;
                r = moment(m.format(format), format);
                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format);
                r = moment(m.format(format).toLocaleUpperCase(), format);
                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' upper');
                r = moment(m.format(format).toLocaleLowerCase(), format);
                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' lower');

                r = moment(m.format(format), format, true);
                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' strict');
                r = moment(m.format(format).toLocaleUpperCase(), format, true);
                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' upper strict');
                r = moment(m.format(format).toLocaleLowerCase(), format, true);
                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' lower strict');
            }

            for (i = 0; i < 12; ++i) {
                m = moment([2015, i, 15, 18]);
                tester('MMM');
                tester('MMM.');
                tester('MMMM');
                tester('MMMM.');
            }
        });

        test('weekday parsing correctness', function (assert) {
            var i, m;

            if (locale === 'tr' || locale === 'az') {
                // There is a lower-case letter (Ä±), that converted to upper then
                // lower changes to i
                expect(0);
                return;
            }
            function tester(format) {
                var r, baseMsg = 'weekday ' + m.weekday() + ' fmt ' + format;
                r = moment(m.format(format), format);
                assert.equal(r.weekday(), m.weekday(), baseMsg);
                r = moment(m.format(format).toLocaleUpperCase(), format);
                assert.equal(r.weekday(), m.weekday(), baseMsg + ' upper');
                r = moment(m.format(format).toLocaleLowerCase(), format);
                assert.equal(r.weekday(), m.weekday(), baseMsg + ' lower');

                r = moment(m.format(format), format, true);
                assert.equal(r.weekday(), m.weekday(), baseMsg + ' strict');
                r = moment(m.format(format).toLocaleUpperCase(), format, true);
                assert.equal(r.weekday(), m.weekday(), baseMsg + ' upper strict');
                r = moment(m.format(format).toLocaleLowerCase(), format, true);
                assert.equal(r.weekday(), m.weekday(), baseMsg + ' lower strict');
            }

            for (i = 0; i < 7; ++i) {
                m = moment.utc([2015, i, 15, 18]);
                tester('dd');
                tester('ddd');
                tester('dddd');
            }
        });
    }

    function setupDeprecationHandler(test, moment, scope) {
        test._expectedDeprecations = null;
        test._observedDeprecations = null;
        test._oldSupress = moment.suppressDeprecationWarnings;
        moment.suppressDeprecationWarnings = true;
        test.expectedDeprecations = function () {
            test._expectedDeprecations = arguments;
            test._observedDeprecations = [];
        };
        moment.deprecationHandler = function (name, msg) {
            var deprecationId = matchedDeprecation(name, msg, test._expectedDeprecations);
            if (deprecationId === -1) {
                throw new Error('Unexpected deprecation thrown name=' +
                        name + ' msg=' + msg);
            }
            test._observedDeprecations[deprecationId] = 1;
        };
    }

    function teardownDeprecationHandler(test, moment, scope) {
        moment.suppressDeprecationWarnings = test._oldSupress;

        if (test._expectedDeprecations != null) {
            var missedDeprecations = [];
            each(test._expectedDeprecations, function (deprecationPattern, id) {
                if (test._observedDeprecations[id] !== 1) {
                    missedDeprecations.push(deprecationPattern);
                }
            });
            if (missedDeprecations.length !== 0) {
                throw new Error('Expected deprecation warnings did not happen: ' +
                        missedDeprecations.join(' '));
            }
        }
    }

    function matchedDeprecation(name, msg, deprecations) {
        if (deprecations == null) {
            return -1;
        }
        for (var i = 0; i < deprecations.length; ++i) {
            if (name != null && name === deprecations[i]) {
                return i;
            }
            if (msg != null && msg.substring(0, deprecations[i].length) === deprecations[i]) {
                return i;
            }
        }
        return -1;
    }

    /*global QUnit:false*/

    var test = QUnit.test;

    var expect = QUnit.expect;

    function module (name, lifecycle) {
        QUnit.module(name, {
            setup : function () {
                moment.locale('en');
                moment.createFromInputFallback = function (config) {
                    throw new Error('input not handled by moment: ' + config._i);
                };
                setupDeprecationHandler(test, moment, 'core');
                if (lifecycle && lifecycle.setup) {
                    lifecycle.setup();
                }
            },
            teardown : function () {
                teardownDeprecationHandler(test, moment, 'core');
                if (lifecycle && lifecycle.teardown) {
                    lifecycle.teardown();
                }
            }
        });
    }

    function localeModule (name, lifecycle) {
        QUnit.module('locale:' + name, {
            setup : function () {
                moment.locale(name);
                moment.createFromInputFallback = function (config) {
                    throw new Error('input not handled by moment: ' + config._i);
                };
                setupDeprecationHandler(test, moment, 'locale');
                if (lifecycle && lifecycle.setup) {
                    lifecycle.setup();
                }
            },
            teardown : function () {
                moment.locale('en');
                teardownDeprecationHandler(test, moment, 'locale');
                if (lifecycle && lifecycle.teardown) {
                    lifecycle.teardown();
                }
            }
        });
        defineCommonLocaleTests(name, -1, -1);
    }

    localeModule('ja');

    test('parse', function (assert) {
        var tests = '1æ 1æ_2æ 2æ_3æ 3æ_4æ 4æ_5æ 5æ_6æ 6æ_7æ 7æ_8æ 8æ_9æ 9æ_10æ 10æ_11æ 11æ_12æ 12æ'.split('_'), i;
        function equalTest(input, mmm, i) {
            assert.equal(moment(input, mmm).month(), i, input + ' should be month ' + (i + 1));
        }
        for (i = 0; i < 12; i++) {
            tests[i] = tests[i].split(' ');
            equalTest(tests[i][0], 'MMM', i);
            equalTest(tests[i][1], 'MMM', i);
            equalTest(tests[i][0], 'MMMM', i);
            equalTest(tests[i][1], 'MMMM', i);
            equalTest(tests[i][0].toLocaleLowerCase(), 'MMMM', i);
            equalTest(tests[i][1].toLocaleLowerCase(), 'MMMM', i);
            equalTest(tests[i][0].toLocaleUpperCase(), 'MMMM', i);
            equalTest(tests[i][1].toLocaleUpperCase(), 'MMMM', i);
        }
    });

    test('format', function (assert) {
        var a = [
                ['dddd, MMMM Do YYYY, a h:mm:ss',      'æ¥ææ¥, 2æ 14æ¥ 2010, åå¾ 3:25:50'],
                ['ddd, Ah',                            'æ¥, åå¾3'],
                ['M Mo MM MMMM MMM',                   '2 2 02 2æ 2æ'],
                ['YYYY YY',                            '2010 10'],
                ['D Do DD',                            '14 14æ¥ 14'],
                ['d do dddd ddd dd',                   '0 0æ¥ æ¥ææ¥ æ¥ æ¥'],
                ['DDD DDDo DDDD',                      '45 45æ¥ 045'],
                ['w wo ww',                            '8 8 08'],
                ['h hh',                               '3 03'],
                ['H HH',                               '15 15'],
                ['m mm',                               '25 25'],
                ['s ss',                               '50 50'],
                ['a A',                                'åå¾ åå¾'],
                ['[the] DDDo [day of the year]',       'the 45æ¥ day of the year'],
                ['LTS',                                'åå¾3æ25å50ç§'],
                ['L',                                  '2010/02/14'],
                ['LL',                                 '2010å¹´2æ14æ¥'],
                ['LLL',                                '2010å¹´2æ14æ¥åå¾3æ25å'],
                ['LLLL',                               '2010å¹´2æ14æ¥åå¾3æ25å æ¥ææ¥'],
                ['l',                                  '2010/2/14'],
                ['ll',                                 '2010å¹´2æ14æ¥'],
                ['lll',                                '2010å¹´2æ14æ¥åå¾3æ25å'],
                ['llll',                               '2010å¹´2æ14æ¥åå¾3æ25å æ¥']
            ],
            b = moment(new Date(2010, 1, 14, 15, 25, 50, 125)),
            i;
        for (i = 0; i < a.length; i++) {
            assert.equal(b.format(a[i][0]), a[i][1], a[i][0] + ' ---> ' + a[i][1]);
        }
    });

    test('format month', function (assert) {
        var expected = '1æ 1æ_2æ 2æ_3æ 3æ_4æ 4æ_5æ 5æ_6æ 6æ_7æ 7æ_8æ 8æ_9æ 9æ_10æ 10æ_11æ 11æ_12æ 12æ'.split('_'), i;
        for (i = 0; i < expected.length; i++) {
            assert.equal(moment([2011, i, 1]).format('MMMM MMM'), expected[i], expected[i]);
        }
    });

    test('format week', function (assert) {
        var expected = 'æ¥ææ¥ æ¥ æ¥_æææ¥ æ æ_ç«ææ¥ ç« ç«_æ°´ææ¥ æ°´ æ°´_æ¨ææ¥ æ¨ æ¨_éææ¥ é é_åææ¥ å å'.split('_'), i;
        for (i = 0; i < expected.length; i++) {
            assert.equal(moment([2011, 0, 2 + i]).format('dddd ddd dd'), expected[i], expected[i]);
        }
    });

    test('from', function (assert) {
        var start = moment([2007, 1, 28]);
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 44}), true),  'æ°ç§',   '44 seconds = a few seconds');
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 45}), true),  '1å', '45 seconds = a minute');
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 89}), true),  '1å', '89 seconds = a minute');
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 90}), true),  '2å',  '90 seconds = 2 minutes');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 44}), true),  '44å', '44 minutes = 44 minutes');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 45}), true),  '1æé', '45 minutes = an hour');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 89}), true),  '1æé', '89 minutes = an hour');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 90}), true),  '2æé',  '90 minutes = 2 hours');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 5}), true),   '5æé',  '5 hours = 5 hours');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 21}), true),  '21æé', '21 hours = 21 hours');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 22}), true),  '1æ¥',   '22 hours = a day');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 35}), true),  '1æ¥',   '35 hours = a day');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 36}), true),  '2æ¥',   '36 hours = 2 days');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 1}), true),   '1æ¥',   '1 day = a day');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 5}), true),   '5æ¥',   '5 days = 5 days');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 25}), true),  '25æ¥',  '25 days = 25 days');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 26}), true),  '1ã¶æ', '26 days = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 30}), true),  '1ã¶æ', '30 days = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 43}), true),  '1ã¶æ', '43 days = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 46}), true),  '2ã¶æ',  '46 days = 2 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 74}), true),  '2ã¶æ',  '75 days = 2 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 76}), true),  '3ã¶æ',  '76 days = 3 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({M: 1}), true),   '1ã¶æ', '1 month = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({M: 5}), true),   '5ã¶æ',  '5 months = 5 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 345}), true), '1å¹´',   '345 days = a year');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 548}), true), '2å¹´',   '548 days = 2 years');
        assert.equal(start.from(moment([2007, 1, 28]).add({y: 1}), true),   '1å¹´',   '1 year = a year');
        assert.equal(start.from(moment([2007, 1, 28]).add({y: 5}), true),   '5å¹´',   '5 years = 5 years');
    });

    test('suffix', function (assert) {
        assert.equal(moment(30000).from(0), 'æ°ç§å¾',  'prefix');
        assert.equal(moment(0).from(30000), 'æ°ç§å', 'suffix');
    });

    test('now from now', function (assert) {
        assert.equal(moment().fromNow(), 'æ°ç§å',  'now from now should display as in the past');
    });

    test('fromNow', function (assert) {
        assert.equal(moment().add({s: 30}).fromNow(), 'æ°ç§å¾', 'in a few seconds');
        assert.equal(moment().add({d: 5}).fromNow(), '5æ¥å¾', 'in 5 days');
    });

    test('calendar day', function (assert) {
        var a = moment().hours(12).minutes(0).seconds(0);

        assert.equal(moment(a).calendar(),                   'ä»æ¥ åå¾12æ0å',     'today at the same time');
        assert.equal(moment(a).add({m: 25}).calendar(),      'ä»æ¥ åå¾12æ25å',    'Now plus 25 min');
        assert.equal(moment(a).add({h: 1}).calendar(),       'ä»æ¥ åå¾1æ0å',      'Now plus 1 hour');
        assert.equal(moment(a).add({d: 1}).calendar(),       'ææ¥ åå¾12æ0å',     'tomorrow at the same time');
        assert.equal(moment(a).subtract({h: 1}).calendar(),  'ä»æ¥ åå11æ0å',     'Now minus 1 hour');
        assert.equal(moment(a).subtract({d: 1}).calendar(),  'æ¨æ¥ åå¾12æ0å',     'yesterday at the same time');
    });

    test('calendar next week', function (assert) {
        var i, m;
        for (i = 2; i < 7; i++) {
            m = moment().add({d: i});
            assert.equal(m.calendar(),       m.format('[æ¥é±]dddd LT'),  'Today + ' + i + ' days current time');
            m.hours(0).minutes(0).seconds(0).milliseconds(0);
            assert.equal(m.calendar(),       m.format('[æ¥é±]dddd LT'),  'Today + ' + i + ' days beginning of day');
            m.hours(23).minutes(59).seconds(59).milliseconds(999);
            assert.equal(m.calendar(),       m.format('[æ¥é±]dddd LT'),  'Today + ' + i + ' days end of day');
        }
    });

    test('calendar last week', function (assert) {
        var i, m;
        for (i = 2; i < 7; i++) {
            m = moment().subtract({d: i});
            assert.equal(m.calendar(),       m.format('[åé±]dddd LT'),  'Today - ' + i + ' days current time');
            m.hours(0).minutes(0).seconds(0).milliseconds(0);
            assert.equal(m.calendar(),       m.format('[åé±]dddd LT'),  'Today - ' + i + ' days beginning of day');
            m.hours(23).minutes(59).seconds(59).milliseconds(999);
            assert.equal(m.calendar(),       m.format('[åé±]dddd LT'),  'Today - ' + i + ' days end of day');
        }
    });

    test('calendar all else', function (assert) {
        var weeksAgo = moment().subtract({w: 1}),
            weeksFromNow = moment().add({w: 1});

        assert.equal(weeksAgo.calendar(),       weeksAgo.format('L'),      '1 week ago');
        assert.equal(weeksFromNow.calendar(),   weeksFromNow.format('L'),  'in 1 week');

        weeksAgo = moment().subtract({w: 2});
        weeksFromNow = moment().add({w: 2});

        assert.equal(weeksAgo.calendar(),       weeksAgo.format('L'),      '2 weeks ago');
        assert.equal(weeksFromNow.calendar(),   weeksFromNow.format('L'),  'in 2 weeks');
    });

    test('weeks year starting sunday format', function (assert) {
        assert.equal(moment([2012, 0,  1]).format('w ww wo'), '1 01 1', 'Jan  1 2012 should be week 1');
        assert.equal(moment([2012, 0,  7]).format('w ww wo'), '1 01 1', 'Jan  7 2012 should be week 1');
        assert.equal(moment([2012, 0,  8]).format('w ww wo'), '2 02 2', 'Jan  8 2012 should be week 2');
        assert.equal(moment([2012, 0, 14]).format('w ww wo'), '2 02 2', 'Jan 14 2012 should be week 2');
        assert.equal(moment([2012, 0, 15]).format('w ww wo'), '3 03 3', 'Jan 15 2012 should be week 3');
    });

}));

;(function (global, factory) {
   typeof exports === 'object' && typeof module !== 'undefined'
       && typeof require === 'function' ? factory(require('../../moment')) :
   typeof define === 'function' && define.amd ? define(['../../moment'], factory) :
   factory(global.moment)
}(this, function (moment) { 'use strict';

    function each(array, callback) {
        var i;
        for (i = 0; i < array.length; i++) {
            callback(array[i], i, array);
        }
    }

    function objectKeys(obj) {
        if (Object.keys) {
            return Object.keys(obj);
        } else {
            // IE8
            var res = [], i;
            for (i in obj) {
                if (obj.hasOwnProperty(i)) {
                    res.push(i);
                }
            }
            return res;
        }
    }

    // Pick the first defined of two or three arguments.
    function defaults(a, b, c) {
        if (a != null) {
            return a;
        }
        if (b != null) {
            return b;
        }
        return c;
    }

    function defineCommonLocaleTests(locale, options) {
        test('lenient ordinal parsing', function (assert) {
            var i, ordinalStr, testMoment;
            for (i = 1; i <= 31; ++i) {
                ordinalStr = moment([2014, 0, i]).format('YYYY MM Do');
                testMoment = moment(ordinalStr, 'YYYY MM Do');
                assert.equal(testMoment.year(), 2014,
                        'lenient ordinal parsing ' + i + ' year check');
                assert.equal(testMoment.month(), 0,
                        'lenient ordinal parsing ' + i + ' month check');
                assert.equal(testMoment.date(), i,
                        'lenient ordinal parsing ' + i + ' date check');
            }
        });

        test('lenient ordinal parsing of number', function (assert) {
            var i, testMoment;
            for (i = 1; i <= 31; ++i) {
                testMoment = moment('2014 01 ' + i, 'YYYY MM Do');
                assert.equal(testMoment.year(), 2014,
                        'lenient ordinal parsing of number ' + i + ' year check');
                assert.equal(testMoment.month(), 0,
                        'lenient ordinal parsing of number ' + i + ' month check');
                assert.equal(testMoment.date(), i,
                        'lenient ordinal parsing of number ' + i + ' date check');
            }
        });

        test('strict ordinal parsing', function (assert) {
            var i, ordinalStr, testMoment;
            for (i = 1; i <= 31; ++i) {
                ordinalStr = moment([2014, 0, i]).format('YYYY MM Do');
                testMoment = moment(ordinalStr, 'YYYY MM Do', true);
                assert.ok(testMoment.isValid(), 'strict ordinal parsing ' + i);
            }
        });

        test('meridiem invariant', function (assert) {
            var h, m, t1, t2;
            for (h = 0; h < 24; ++h) {
                for (m = 0; m < 60; m += 15) {
                    t1 = moment.utc([2000, 0, 1, h, m]);
                    t2 = moment.utc(t1.format('A h:mm'), 'A h:mm');
                    assert.equal(t2.format('HH:mm'), t1.format('HH:mm'),
                            'meridiem at ' + t1.format('HH:mm'));
                }
            }
        });

        test('date format correctness', function (assert) {
            var data, tokens;
            data = moment.localeData()._longDateFormat;
            tokens = objectKeys(data);
            each(tokens, function (srchToken) {
                // Check each format string to make sure it does not contain any
                // tokens that need to be expanded.
                each(tokens, function (baseToken) {
                    // strip escaped sequences
                    var format = data[baseToken].replace(/(\[[^\]]*\])/g, '');
                    assert.equal(false, !!~format.indexOf(srchToken),
                            'contains ' + srchToken + ' in ' + baseToken);
                });
            });
        });

        test('month parsing correctness', function (assert) {
            var i, m;

            if (locale === 'tr') {
                // I can't fix it :(
                expect(0);
                return;
            }
            function tester(format) {
                var r;
                r = moment(m.format(format), format);
                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format);
                r = moment(m.format(format).toLocaleUpperCase(), format);
                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' upper');
                r = moment(m.format(format).toLocaleLowerCase(), format);
                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' lower');

                r = moment(m.format(format), format, true);
                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' strict');
                r = moment(m.format(format).toLocaleUpperCase(), format, true);
                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' upper strict');
                r = moment(m.format(format).toLocaleLowerCase(), format, true);
                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' lower strict');
            }

            for (i = 0; i < 12; ++i) {
                m = moment([2015, i, 15, 18]);
                tester('MMM');
                tester('MMM.');
                tester('MMMM');
                tester('MMMM.');
            }
        });

        test('weekday parsing correctness', function (assert) {
            var i, m;

            if (locale === 'tr' || locale === 'az') {
                // There is a lower-case letter (Ä±), that converted to upper then
                // lower changes to i
                expect(0);
                return;
            }
            function tester(format) {
                var r, baseMsg = 'weekday ' + m.weekday() + ' fmt ' + format;
                r = moment(m.format(format), format);
                assert.equal(r.weekday(), m.weekday(), baseMsg);
                r = moment(m.format(format).toLocaleUpperCase(), format);
                assert.equal(r.weekday(), m.weekday(), baseMsg + ' upper');
                r = moment(m.format(format).toLocaleLowerCase(), format);
                assert.equal(r.weekday(), m.weekday(), baseMsg + ' lower');

                r = moment(m.format(format), format, true);
                assert.equal(r.weekday(), m.weekday(), baseMsg + ' strict');
                r = moment(m.format(format).toLocaleUpperCase(), format, true);
                assert.equal(r.weekday(), m.weekday(), baseMsg + ' upper strict');
                r = moment(m.format(format).toLocaleLowerCase(), format, true);
                assert.equal(r.weekday(), m.weekday(), baseMsg + ' lower strict');
            }

            for (i = 0; i < 7; ++i) {
                m = moment.utc([2015, i, 15, 18]);
                tester('dd');
                tester('ddd');
                tester('dddd');
            }
        });
    }

    function setupDeprecationHandler(test, moment, scope) {
        test._expectedDeprecations = null;
        test._observedDeprecations = null;
        test._oldSupress = moment.suppressDeprecationWarnings;
        moment.suppressDeprecationWarnings = true;
        test.expectedDeprecations = function () {
            test._expectedDeprecations = arguments;
            test._observedDeprecations = [];
        };
        moment.deprecationHandler = function (name, msg) {
            var deprecationId = matchedDeprecation(name, msg, test._expectedDeprecations);
            if (deprecationId === -1) {
                throw new Error('Unexpected deprecation thrown name=' +
                        name + ' msg=' + msg);
            }
            test._observedDeprecations[deprecationId] = 1;
        };
    }

    function teardownDeprecationHandler(test, moment, scope) {
        moment.suppressDeprecationWarnings = test._oldSupress;

        if (test._expectedDeprecations != null) {
            var missedDeprecations = [];
            each(test._expectedDeprecations, function (deprecationPattern, id) {
                if (test._observedDeprecations[id] !== 1) {
                    missedDeprecations.push(deprecationPattern);
                }
            });
            if (missedDeprecations.length !== 0) {
                throw new Error('Expected deprecation warnings did not happen: ' +
                        missedDeprecations.join(' '));
            }
        }
    }

    function matchedDeprecation(name, msg, deprecations) {
        if (deprecations == null) {
            return -1;
        }
        for (var i = 0; i < deprecations.length; ++i) {
            if (name != null && name === deprecations[i]) {
                return i;
            }
            if (msg != null && msg.substring(0, deprecations[i].length) === deprecations[i]) {
                return i;
            }
        }
        return -1;
    }

    /*global QUnit:false*/

    var test = QUnit.test;

    var expect = QUnit.expect;

    function module (name, lifecycle) {
        QUnit.module(name, {
            setup : function () {
                moment.locale('en');
                moment.createFromInputFallback = function (config) {
                    throw new Error('input not handled by moment: ' + config._i);
                };
                setupDeprecationHandler(test, moment, 'core');
                if (lifecycle && lifecycle.setup) {
                    lifecycle.setup();
                }
            },
            teardown : function () {
                teardownDeprecationHandler(test, moment, 'core');
                if (lifecycle && lifecycle.teardown) {
                    lifecycle.teardown();
                }
            }
        });
    }

    function localeModule (name, lifecycle) {
        QUnit.module('locale:' + name, {
            setup : function () {
                moment.locale(name);
                moment.createFromInputFallback = function (config) {
                    throw new Error('input not handled by moment: ' + config._i);
                };
                setupDeprecationHandler(test, moment, 'locale');
                if (lifecycle && lifecycle.setup) {
                    lifecycle.setup();
                }
            },
            teardown : function () {
                moment.locale('en');
                teardownDeprecationHandler(test, moment, 'locale');
                if (lifecycle && lifecycle.teardown) {
                    lifecycle.teardown();
                }
            }
        });
        defineCommonLocaleTests(name, -1, -1);
    }

    localeModule('jv');

    test('parse', function (assert) {
        var tests = 'Januari Jan_Februari Feb_Maret Mar_April Apr_Mei Mei_Juni Jun_Juli Jul_Agustus Ags_September Sep_Oktober Okt_Nopember Nop_Desember Des'.split('_'), i;
        function equalTest(input, mmm, i) {
            assert.equal(moment(input, mmm).month(), i, input + ' should be month ' + (i + 1));
        }
        for (i = 0; i < 12; i++) {
            tests[i] = tests[i].split(' ');
            equalTest(tests[i][0], 'MMM', i);
            equalTest(tests[i][1], 'MMM', i);
            equalTest(tests[i][0], 'MMMM', i);
            equalTest(tests[i][1], 'MMMM', i);
            equalTest(tests[i][0].toLocaleLowerCase(), 'MMMM', i);
            equalTest(tests[i][1].toLocaleLowerCase(), 'MMMM', i);
            equalTest(tests[i][0].toLocaleUpperCase(), 'MMMM', i);
            equalTest(tests[i][1].toLocaleUpperCase(), 'MMMM', i);
        }
    });

    test('format', function (assert) {
        var a = [
                ['dddd, MMMM Do YYYY, h:mm:ss a',      'Minggu, Februari 14 2010, 3:25:50 sonten'],
                ['ddd, hA',                            'Min, 3sonten'],
                ['M Mo MM MMMM MMM',                   '2 2 02 Februari Feb'],
                ['YYYY YY',                            '2010 10'],
                ['D Do DD',                            '14 14 14'],
                ['d do dddd ddd dd',                   '0 0 Minggu Min Mg'],
                ['DDD DDDo DDDD',                      '45 45 045'],
                ['w wo ww',                            '7 7 07'],
                ['h hh',                               '3 03'],
                ['H HH',                               '15 15'],
                ['m mm',                               '25 25'],
                ['s ss',                               '50 50'],
                ['a A',                                'sonten sonten'],
                ['[the] DDDo [day of the year]',       'the 45 day of the year'],
                ['LTS',                                '15.25.50'],
                ['L',                                  '14/02/2010'],
                ['LL',                                 '14 Februari 2010'],
                ['LLL',                                '14 Februari 2010 pukul 15.25'],
                ['LLLL',                               'Minggu, 14 Februari 2010 pukul 15.25'],
                ['l',                                  '14/2/2010'],
                ['ll',                                 '14 Feb 2010'],
                ['lll',                                '14 Feb 2010 pukul 15.25'],
                ['llll',                               'Min, 14 Feb 2010 pukul 15.25']
            ],
            b = moment(new Date(2010, 1, 14, 15, 25, 50, 125)),
            i;
        for (i = 0; i < a.length; i++) {
            assert.equal(b.format(a[i][0]), a[i][1], a[i][0] + ' ---> ' + a[i][1]);
        }
    });

    test('format month', function (assert) {
        var expected = 'Januari Jan_Februari Feb_Maret Mar_April Apr_Mei Mei_Juni Jun_Juli Jul_Agustus Ags_September Sep_Oktober Okt_Nopember Nop_Desember Des'.split('_'), i;
        for (i = 0; i < expected.length; i++) {
            assert.equal(moment([2011, i, 1]).format('MMMM MMM'), expected[i], expected[i]);
        }
    });

    test('format week', function (assert) {
        var expected = 'Minggu Min Mg_Senen Sen Sn_Seloso Sel Sl_Rebu Reb Rb_Kemis Kem Km_Jemuwah Jem Jm_Septu Sep Sp'.split('_'), i;
        for (i = 0; i < expected.length; i++) {
            assert.equal(moment([2011, 0, 2 + i]).format('dddd ddd dd'), expected[i], expected[i]);
        }
    });

    test('from', function (assert) {
        var start = moment([2007, 1, 28]);
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 44}), true),  'sawetawis detik', '44 seconds = a few seconds');
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 45}), true),  'setunggal menit',      '45 seconds = a minute');
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 89}), true),  'setunggal menit',      '89 seconds = a minute');
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 90}), true),  '2 menit',     '90 seconds = 2 minutes');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 44}), true),  '44 menit',    '44 minutes = 44 minutes');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 45}), true),  'setunggal jam',       '45 minutes = an hour');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 89}), true),  'setunggal jam',       '89 minutes = an hour');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 90}), true),  '2 jam',       '90 minutes = 2 hours');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 5}), true),   '5 jam',       '5 hours = 5 hours');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 21}), true),  '21 jam',      '21 hours = 21 hours');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 22}), true),  'sedinten',         '22 hours = a day');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 35}), true),  'sedinten',         '35 hours = a day');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 36}), true),  '2 dinten',        '36 hours = 2 days');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 1}), true),   'sedinten',         '1 day = a day');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 5}), true),   '5 dinten',        '5 days = 5 days');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 25}), true),  '25 dinten',       '25 days = 25 days');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 26}), true),  'sewulan',       '26 days = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 30}), true),  'sewulan',       '30 days = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 43}), true),  'sewulan',       '43 days = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 46}), true),  '2 wulan',      '46 days = 2 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 74}), true),  '2 wulan',      '75 days = 2 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 76}), true),  '3 wulan',      '76 days = 3 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({M: 1}), true),   'sewulan',       '1 month = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({M: 5}), true),   '5 wulan',      '5 months = 5 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 345}), true), 'setaun',        '345 days = a year');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 548}), true), '2 taun',       '548 days = 2 years');
        assert.equal(start.from(moment([2007, 1, 28]).add({y: 1}), true),   'setaun',        '1 year = a year');
        assert.equal(start.from(moment([2007, 1, 28]).add({y: 5}), true),   '5 taun',       '5 years = 5 years');
    });

    test('suffix', function (assert) {
        assert.equal(moment(30000).from(0), 'wonten ing sawetawis detik',  'prefix');
        assert.equal(moment(0).from(30000), 'sawetawis detik ingkang kepengker', 'suffix');
    });

    test('now from now', function (assert) {
        assert.equal(moment().fromNow(), 'sawetawis detik ingkang kepengker',  'now from now should display as in the past');
    });

    test('fromNow', function (assert) {
        assert.equal(moment().add({s: 30}).fromNow(), 'wonten ing sawetawis detik', 'in a few seconds');
        assert.equal(moment().add({d: 5}).fromNow(), 'wonten ing 5 dinten', 'in 5 days');
    });

    test('calendar day', function (assert) {
        var a = moment().hours(12).minutes(0).seconds(0);

        assert.equal(moment(a).calendar(),                   'Dinten puniko pukul 12.00', 'today at the same time');
        assert.equal(moment(a).add({m: 25}).calendar(),      'Dinten puniko pukul 12.25', 'Now plus 25 min');
        assert.equal(moment(a).add({h: 1}).calendar(),       'Dinten puniko pukul 13.00', 'Now plus 1 hour');
        assert.equal(moment(a).add({d: 1}).calendar(),       'Mbenjang pukul 12.00',      'tomorrow at the same time');
        assert.equal(moment(a).subtract({h: 1}).calendar(),  'Dinten puniko pukul 11.00', 'Now minus 1 hour');
        assert.equal(moment(a).subtract({d: 1}).calendar(),  'Kala wingi pukul 12.00',    'yesterday at the same time');
    });

    test('calendar next week', function (assert) {
        var i, m;
        for (i = 2; i < 7; i++) {
            m = moment().add({d: i});
            assert.equal(m.calendar(),       m.format('dddd [pukul] LT'),  'Today + ' + i + ' days current time');
            m.hours(0).minutes(0).seconds(0).milliseconds(0);
            assert.equal(m.calendar(),       m.format('dddd [pukul] LT'),  'Today + ' + i + ' days beginning of day');
            m.hours(23).minutes(59).seconds(59).milliseconds(999);
            assert.equal(m.calendar(),       m.format('dddd [pukul] LT'),  'Today + ' + i + ' days end of day');
        }
    });

    test('calendar last week', function (assert) {
        var i, m;
        for (i = 2; i < 7; i++) {
            m = moment().subtract({d: i});
            assert.equal(m.calendar(),       m.format('dddd [kepengker pukul] LT'),  'Today - ' + i + ' days current time');
            m.hours(0).minutes(0).seconds(0).milliseconds(0);
            assert.equal(m.calendar(),       m.format('dddd [kepengker pukul] LT'),  'Today - ' + i + ' days beginning of day');
            m.hours(23).minutes(59).seconds(59).milliseconds(999);
            assert.equal(m.calendar(),       m.format('dddd [kepengker pukul] LT'),  'Today - ' + i + ' days end of day');
        }
    });

    test('calendar all else', function (assert) {
        var weeksAgo = moment().subtract({w: 1}),
            weeksFromNow = moment().add({w: 1});

        assert.equal(weeksAgo.calendar(),       weeksAgo.format('L'),  '1 week ago');
        assert.equal(weeksFromNow.calendar(),   weeksFromNow.format('L'),  'in 1 week');

        weeksAgo = moment().subtract({w: 2});
        weeksFromNow = moment().add({w: 2});

        assert.equal(weeksAgo.calendar(),       weeksAgo.format('L'),  '2 weeks ago');
        assert.equal(weeksFromNow.calendar(),   weeksFromNow.format('L'),  'in 2 weeks');
    });

    // Monday is the first day of the week.
    // The week that contains Jan 1st is the first week of the year.

    test('weeks year starting sunday formatted', function (assert) {
        assert.equal(moment([2011, 11, 26]).format('w ww wo'), '1 01 1', 'Dec 26 2011 should be week 1');
        assert.equal(moment([2012,  0,  1]).format('w ww wo'), '1 01 1', 'Jan  1 2012 should be week 1');
        assert.equal(moment([2012,  0,  2]).format('w ww wo'), '2 02 2', 'Jan  2 2012 should be week 2');
        assert.equal(moment([2012,  0,  8]).format('w ww wo'), '2 02 2', 'Jan  8 2012 should be week 2');
        assert.equal(moment([2012,  0,  9]).format('w ww wo'), '3 03 3', 'Jan  9 2012 should be week 3');
    });

}));

;(function (global, factory) {
   typeof exports === 'object' && typeof module !== 'undefined'
       && typeof require === 'function' ? factory(require('../../moment')) :
   typeof define === 'function' && define.amd ? define(['../../moment'], factory) :
   factory(global.moment)
}(this, function (moment) { 'use strict';

    function each(array, callback) {
        var i;
        for (i = 0; i < array.length; i++) {
            callback(array[i], i, array);
        }
    }

    function objectKeys(obj) {
        if (Object.keys) {
            return Object.keys(obj);
        } else {
            // IE8
            var res = [], i;
            for (i in obj) {
                if (obj.hasOwnProperty(i)) {
                    res.push(i);
                }
            }
            return res;
        }
    }

    // Pick the first defined of two or three arguments.
    function defaults(a, b, c) {
        if (a != null) {
            return a;
        }
        if (b != null) {
            return b;
        }
        return c;
    }

    function defineCommonLocaleTests(locale, options) {
        test('lenient ordinal parsing', function (assert) {
            var i, ordinalStr, testMoment;
            for (i = 1; i <= 31; ++i) {
                ordinalStr = moment([2014, 0, i]).format('YYYY MM Do');
                testMoment = moment(ordinalStr, 'YYYY MM Do');
                assert.equal(testMoment.year(), 2014,
                        'lenient ordinal parsing ' + i + ' year check');
                assert.equal(testMoment.month(), 0,
                        'lenient ordinal parsing ' + i + ' month check');
                assert.equal(testMoment.date(), i,
                        'lenient ordinal parsing ' + i + ' date check');
            }
        });

        test('lenient ordinal parsing of number', function (assert) {
            var i, testMoment;
            for (i = 1; i <= 31; ++i) {
                testMoment = moment('2014 01 ' + i, 'YYYY MM Do');
                assert.equal(testMoment.year(), 2014,
                        'lenient ordinal parsing of number ' + i + ' year check');
                assert.equal(testMoment.month(), 0,
                        'lenient ordinal parsing of number ' + i + ' month check');
                assert.equal(testMoment.date(), i,
                        'lenient ordinal parsing of number ' + i + ' date check');
            }
        });

        test('strict ordinal parsing', function (assert) {
            var i, ordinalStr, testMoment;
            for (i = 1; i <= 31; ++i) {
                ordinalStr = moment([2014, 0, i]).format('YYYY MM Do');
                testMoment = moment(ordinalStr, 'YYYY MM Do', true);
                assert.ok(testMoment.isValid(), 'strict ordinal parsing ' + i);
            }
        });

        test('meridiem invariant', function (assert) {
            var h, m, t1, t2;
            for (h = 0; h < 24; ++h) {
                for (m = 0; m < 60; m += 15) {
                    t1 = moment.utc([2000, 0, 1, h, m]);
                    t2 = moment.utc(t1.format('A h:mm'), 'A h:mm');
                    assert.equal(t2.format('HH:mm'), t1.format('HH:mm'),
                            'meridiem at ' + t1.format('HH:mm'));
                }
            }
        });

        test('date format correctness', function (assert) {
            var data, tokens;
            data = moment.localeData()._longDateFormat;
            tokens = objectKeys(data);
            each(tokens, function (srchToken) {
                // Check each format string to make sure it does not contain any
                // tokens that need to be expanded.
                each(tokens, function (baseToken) {
                    // strip escaped sequences
                    var format = data[baseToken].replace(/(\[[^\]]*\])/g, '');
                    assert.equal(false, !!~format.indexOf(srchToken),
                            'contains ' + srchToken + ' in ' + baseToken);
                });
            });
        });

        test('month parsing correctness', function (assert) {
            var i, m;

            if (locale === 'tr') {
                // I can't fix it :(
                expect(0);
                return;
            }
            function tester(format) {
                var r;
                r = moment(m.format(format), format);
                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format);
                r = moment(m.format(format).toLocaleUpperCase(), format);
                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' upper');
                r = moment(m.format(format).toLocaleLowerCase(), format);
                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' lower');

                r = moment(m.format(format), format, true);
                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' strict');
                r = moment(m.format(format).toLocaleUpperCase(), format, true);
                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' upper strict');
                r = moment(m.format(format).toLocaleLowerCase(), format, true);
                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' lower strict');
            }

            for (i = 0; i < 12; ++i) {
                m = moment([2015, i, 15, 18]);
                tester('MMM');
                tester('MMM.');
                tester('MMMM');
                tester('MMMM.');
            }
        });

        test('weekday parsing correctness', function (assert) {
            var i, m;

            if (locale === 'tr' || locale === 'az') {
                // There is a lower-case letter (Ä±), that converted to upper then
                // lower changes to i
                expect(0);
                return;
            }
            function tester(format) {
                var r, baseMsg = 'weekday ' + m.weekday() + ' fmt ' + format;
                r = moment(m.format(format), format);
                assert.equal(r.weekday(), m.weekday(), baseMsg);
                r = moment(m.format(format).toLocaleUpperCase(), format);
                assert.equal(r.weekday(), m.weekday(), baseMsg + ' upper');
                r = moment(m.format(format).toLocaleLowerCase(), format);
                assert.equal(r.weekday(), m.weekday(), baseMsg + ' lower');

                r = moment(m.format(format), format, true);
                assert.equal(r.weekday(), m.weekday(), baseMsg + ' strict');
                r = moment(m.format(format).toLocaleUpperCase(), format, true);
                assert.equal(r.weekday(), m.weekday(), baseMsg + ' upper strict');
                r = moment(m.format(format).toLocaleLowerCase(), format, true);
                assert.equal(r.weekday(), m.weekday(), baseMsg + ' lower strict');
            }

            for (i = 0; i < 7; ++i) {
                m = moment.utc([2015, i, 15, 18]);
                tester('dd');
                tester('ddd');
                tester('dddd');
            }
        });
    }

    function setupDeprecationHandler(test, moment, scope) {
        test._expectedDeprecations = null;
        test._observedDeprecations = null;
        test._oldSupress = moment.suppressDeprecationWarnings;
        moment.suppressDeprecationWarnings = true;
        test.expectedDeprecations = function () {
            test._expectedDeprecations = arguments;
            test._observedDeprecations = [];
        };
        moment.deprecationHandler = function (name, msg) {
            var deprecationId = matchedDeprecation(name, msg, test._expectedDeprecations);
            if (deprecationId === -1) {
                throw new Error('Unexpected deprecation thrown name=' +
                        name + ' msg=' + msg);
            }
            test._observedDeprecations[deprecationId] = 1;
        };
    }

    function teardownDeprecationHandler(test, moment, scope) {
        moment.suppressDeprecationWarnings = test._oldSupress;

        if (test._expectedDeprecations != null) {
            var missedDeprecations = [];
            each(test._expectedDeprecations, function (deprecationPattern, id) {
                if (test._observedDeprecations[id] !== 1) {
                    missedDeprecations.push(deprecationPattern);
                }
            });
            if (missedDeprecations.length !== 0) {
                throw new Error('Expected deprecation warnings did not happen: ' +
                        missedDeprecations.join(' '));
            }
        }
    }

    function matchedDeprecation(name, msg, deprecations) {
        if (deprecations == null) {
            return -1;
        }
        for (var i = 0; i < deprecations.length; ++i) {
            if (name != null && name === deprecations[i]) {
                return i;
            }
            if (msg != null && msg.substring(0, deprecations[i].length) === deprecations[i]) {
                return i;
            }
        }
        return -1;
    }

    /*global QUnit:false*/

    var test = QUnit.test;

    var expect = QUnit.expect;

    function module (name, lifecycle) {
        QUnit.module(name, {
            setup : function () {
                moment.locale('en');
                moment.createFromInputFallback = function (config) {
                    throw new Error('input not handled by moment: ' + config._i);
                };
                setupDeprecationHandler(test, moment, 'core');
                if (lifecycle && lifecycle.setup) {
                    lifecycle.setup();
                }
            },
            teardown : function () {
                teardownDeprecationHandler(test, moment, 'core');
                if (lifecycle && lifecycle.teardown) {
                    lifecycle.teardown();
                }
            }
        });
    }

    function localeModule (name, lifecycle) {
        QUnit.module('locale:' + name, {
            setup : function () {
                moment.locale(name);
                moment.createFromInputFallback = function (config) {
                    throw new Error('input not handled by moment: ' + config._i);
                };
                setupDeprecationHandler(test, moment, 'locale');
                if (lifecycle && lifecycle.setup) {
                    lifecycle.setup();
                }
            },
            teardown : function () {
                moment.locale('en');
                teardownDeprecationHandler(test, moment, 'locale');
                if (lifecycle && lifecycle.teardown) {
                    lifecycle.teardown();
                }
            }
        });
        defineCommonLocaleTests(name, -1, -1);
    }

    localeModule('ka');

    test('parse', function (assert) {
        var i,
            tests = 'áááááá á ááá_ááááá áááá ááá_ááá á¢á ááá _ááá ááá ááá _áááá¡á ááá_ááááá¡á ááá_ááááá¡á ááá_ááááá¡á¢á ááá_á¡áá¥á¢ááááá á á¡áá¥_áá¥á¢ááááá á áá¥á¢_ááááááá á ááá_áááááááá á ááá'.split('_');

        function equalTest(input, mmm, i) {
            assert.equal(moment(input, mmm).month(), i, input + ' á£ááá áá§áá¡ ááá ' + (i + 1));
        }

        for (i = 0; i < 12; i++) {
            tests[i] = tests[i].split(' ');
            equalTest(tests[i][0], 'MMM', i);
            equalTest(tests[i][1], 'MMM', i);
            equalTest(tests[i][0], 'MMMM', i);
            equalTest(tests[i][1], 'MMMM', i);
            equalTest(tests[i][0].toLocaleLowerCase(), 'MMMM', i);
            equalTest(tests[i][1].toLocaleLowerCase(), 'MMMM', i);
            equalTest(tests[i][0].toLocaleUpperCase(), 'MMMM', i);
            equalTest(tests[i][1].toLocaleUpperCase(), 'MMMM', i);
        }
    });

    test('format', function (assert) {
        var a = [
                ['dddd, MMMM Do YYYY, h:mm:ss a', 'áááá á, ááááá áááá áá-14 2010, 3:25:50 pm'],
                ['ddd, hA',                       'ááá, 3PM'],
                ['M Mo MM MMMM MMM',              '2 áá-2 02 ááááá áááá ááá'],
                ['YYYY YY',                       '2010 10'],
                ['D Do DD',                       '14 áá-14 14'],
                ['d do dddd ddd dd',              '0 0 áááá á ááá áá'],
                ['DDD DDDo DDDD',                 '45 45-á 045'],
                ['w wo ww',                       '7 áá-7 07'],
                ['h hh',                          '3 03'],
                ['H HH',                          '15 15'],
                ['m mm',                          '25 25'],
                ['s ss',                          '50 50'],
                ['a A',                           'pm PM'],
                ['á¬ááá¡ DDDo áá¦á',                 'á¬ááá¡ 45-á áá¦á'],
                ['LTS',                           '3:25:50 PM'],
                ['L',                             '14/02/2010'],
                ['LL',                            '14 ááááá áááá¡ 2010'],
                ['LLL',                           '14 ááááá áááá¡ 2010 3:25 PM'],
                ['LLLL',                          'áááá á, 14 ááááá áááá¡ 2010 3:25 PM'],
                ['l',                             '14/2/2010'],
                ['ll',                            '14 ááá 2010'],
                ['lll',                           '14 ááá 2010 3:25 PM'],
                ['llll',                          'ááá, 14 ááá 2010 3:25 PM']
            ],
            b = moment(new Date(2010, 1, 14, 15, 25, 50, 125)),
            i;

        for (i = 0; i < a.length; i++) {
            assert.equal(b.format(a[i][0]), a[i][1], a[i][0] + ' ---> ' + a[i][1]);
        }
    });

    test('format ordinal', function (assert) {
        assert.equal(moment([2011, 0, 1]).format('DDDo'),  '1-áá',  '1-áá');
        assert.equal(moment([2011, 0, 2]).format('DDDo'),  'áá-2',  'áá-2');
        assert.equal(moment([2011, 0, 3]).format('DDDo'),  'áá-3',  'áá-3');
        assert.equal(moment([2011, 0, 4]).format('DDDo'),  'áá-4',  'áá-4');
        assert.equal(moment([2011, 0, 5]).format('DDDo'),  'áá-5',  'áá-5');
        assert.equal(moment([2011, 0, 6]).format('DDDo'),  'áá-6',  'áá-6');
        assert.equal(moment([2011, 0, 7]).format('DDDo'),  'áá-7',  'áá-7');
        assert.equal(moment([2011, 0, 8]).format('DDDo'),  'áá-8',  'áá-8');
        assert.equal(moment([2011, 0, 9]).format('DDDo'),  'áá-9',  'áá-9');
        assert.equal(moment([2011, 0, 10]).format('DDDo'), 'áá-10', 'áá-10');

        assert.equal(moment([2011, 0, 11]).format('DDDo'), 'áá-11', 'áá-11');
        assert.equal(moment([2011, 0, 12]).format('DDDo'), 'áá-12', 'áá-12');
        assert.equal(moment([2011, 0, 13]).format('DDDo'), 'áá-13', 'áá-13');
        assert.equal(moment([2011, 0, 14]).format('DDDo'), 'áá-14', 'áá-14');
        assert.equal(moment([2011, 0, 15]).format('DDDo'), 'áá-15', 'áá-15');
        assert.equal(moment([2011, 0, 16]).format('DDDo'), 'áá-16', 'áá-16');
        assert.equal(moment([2011, 0, 17]).format('DDDo'), 'áá-17', 'áá-17');
        assert.equal(moment([2011, 0, 18]).format('DDDo'), 'áá-18', 'áá-18');
        assert.equal(moment([2011, 0, 19]).format('DDDo'), 'áá-19', 'áá-19');
        assert.equal(moment([2011, 0, 20]).format('DDDo'), 'áá-20', 'áá-20');

        assert.equal(moment([2011, 0, 21]).format('DDDo'), '21-á', '21-á');
        assert.equal(moment([2011, 0, 22]).format('DDDo'), '22-á', '22-á');
        assert.equal(moment([2011, 0, 23]).format('DDDo'), '23-á', '23-á');
        assert.equal(moment([2011, 0, 24]).format('DDDo'), '24-á', '24-á');
        assert.equal(moment([2011, 0, 25]).format('DDDo'), '25-á', '25-á');
        assert.equal(moment([2011, 0, 26]).format('DDDo'), '26-á', '26-á');
        assert.equal(moment([2011, 0, 27]).format('DDDo'), '27-á', '27-á');
        assert.equal(moment([2011, 0, 28]).format('DDDo'), '28-á', '28-á');
        assert.equal(moment([2011, 0, 29]).format('DDDo'), '29-á', '29-á');
        assert.equal(moment([2011, 0, 30]).format('DDDo'), '30-á', '30-á');

        assert.equal(moment('2011 40', 'YYYY DDD').format('DDDo'),  'áá-40',  'áá-40');
        assert.equal(moment('2011 50', 'YYYY DDD').format('DDDo'),  '50-á',   '50-á');
        assert.equal(moment('2011 60', 'YYYY DDD').format('DDDo'),  'áá-60',  'áá-60');
        assert.equal(moment('2011 100', 'YYYY DDD').format('DDDo'), 'áá-100', 'áá-100');
        assert.equal(moment('2011 101', 'YYYY DDD').format('DDDo'), '101-á',  '101-á');
    });

    test('format month', function (assert) {
        var i,
            expected = 'áááááá á ááá_ááááá áááá ááá_ááá á¢á ááá _ááá ááá ááá _áááá¡á ááá_ááááá¡á ááá_ááááá¡á ááá_ááááá¡á¢á ááá_á¡áá¥á¢ááááá á á¡áá¥_áá¥á¢ááááá á áá¥á¢_ááááááá á ááá_áááááááá á ááá'.split('_');

        for (i = 0; i < expected.length; i++) {
            assert.equal(moment([2011, i, 1]).format('MMMM MMM'), expected[i], expected[i]);
        }
    });

    test('format week', function (assert) {
        var i,
            expected = 'áááá á ááá áá_áá á¨ááááá áá á¨ áá _á¡ááá¨ááááá á¡áá á¡á_ááá®á¨ááááá ááá® áá_á®á£áá¨ááááá á®á£á á®á£_ááá áá¡áááá ááá  áá_á¨ááááá á¨áá á¨á'.split('_');

        for (i = 0; i < expected.length; i++) {
            assert.equal(moment([2011, 0, 2 + i]).format('dddd ddd dd'), expected[i], expected[i]);
        }
    });

    test('from', function (assert) {
        var start = moment([2007, 1, 28]);

        assert.equal(start.from(moment([2007, 1, 28]).add({s: 44}),  true), 'á áááááááá á¬ááá', '44 á¬ááá  = á áááááááá á¬ááá');
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 45}),  true), 'á¬á£áá',           '45 á¬ááá  = á¬á£áá');
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 89}),  true), 'á¬á£áá',           '89 á¬ááá  = á¬á£áá');
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 90}),  true), '2 á¬á£áá',         '90 á¬ááá  = 2 á¬á£áá');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 44}),  true), '44 á¬á£áá',        '44 á¬ááá  = 44 á¬á£áá');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 45}),  true), 'á¡áááá',          '45 á¬ááá  = á¡áááá');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 89}),  true), 'á¡áááá',          '89 á¬ááá  = á¡áááá');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 90}),  true), '2 á¡áááá',        '90 á¬ááá  = 2 á¡áááá');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 5}),   true), '5 á¡áááá',        '5 á¡áááá  = 5 á¡áááá');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 21}),  true), '21 á¡áááá',       '21 á¡áááá = 21 á¡áááá');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 22}),  true), 'áá¦á',            '22 á¡áááá = áá¦á');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 35}),  true), 'áá¦á',            '35 á¡áááá = áá¦á');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 36}),  true), '2 áá¦á',          '36 á¡áááá = 2 áá¦á');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 1}),   true), 'áá¦á',            '1 áá¦á    = áá¦á');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 5}),   true), '5 áá¦á',          '5 áá¦á    = 5 áá¦á');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 25}),  true), '25 áá¦á',         '25 áá¦á   = 25 áá¦á');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 26}),  true), 'ááá',            '26 áá¦á   = ááá');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 30}),  true), 'ááá',            '30 áá¦á   = ááá');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 43}),  true), 'ááá',            '45 áá¦á   = ááá');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 46}),  true), '2 ááá',          '46 áá¦á   = 2 ááá');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 74}),  true), '2 ááá',          '75 áá¦á   = 2 ááá');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 76}),  true), '3 ááá',          '76 áá¦á   = 3 ááá');
        assert.equal(start.from(moment([2007, 1, 28]).add({M: 1}),   true), 'ááá',            '1 ááá    = ááá');
        assert.equal(start.from(moment([2007, 1, 28]).add({M: 5}),   true), '5 ááá',          '5 ááá    = 5 ááá');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 345}), true), 'á¬ááá',           '345 áá¦á  = á¬ááá');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 548}), true), '2 á¬ááá',         '548 áá¦á  = 2 á¬ááá');
        assert.equal(start.from(moment([2007, 1, 28]).add({y: 1}),   true), 'á¬ááá',           '1 á¬ááá   = á¬ááá');
        assert.equal(start.from(moment([2007, 1, 28]).add({y: 5}),   true), '5 á¬ááá',         '5 á¬ááá   = 5 á¬ááá');
    });

    test('suffix', function (assert) {
        assert.equal(moment(30000).from(0), 'á áááááááá á¬ááá¨á',     'á¨á á¡á£á¤áá¥á¡á');
        assert.equal(moment(0).from(30000), 'á áááááááá á¬áááá¡ á¬áá', 'á¬áá á¡á£á¤áá¥á¡á');
    });

    test('now from now', function (assert) {
        assert.equal(moment().fromNow(), 'á áááááááá á¬áááá¡ á¬áá', 'á£ááá áá©ááááá¡ á áááá áª á¬áá á¡á£áá');
    });

    test('fromNow', function (assert) {
        assert.equal(moment().add({s: 30}).fromNow(), 'á áááááááá á¬ááá¨á', 'á áááááááá á¬ááá¨á');
        assert.equal(moment().add({d: 5}).fromNow(), '5 áá¦áá¨á', '5 áá¦áá¨á');
    });

    test('calendar day', function (assert) {
        var a = moment().hours(12).minutes(0).seconds(0);

        assert.equal(moment(a).calendar(),                   'áá¦áá¡ 12:00 PM-áá',  'áá¦áá¡ ááááá áá áá¡');
        assert.equal(moment(a).add({m: 25}).calendar(),      'áá¦áá¡ 12:25 PM-áá',  'áá®áááááá áá áá¡ ááááá¢ááá£áá 25 á¬á£áá');
        assert.equal(moment(a).add({h: 1}).calendar(),       'áá¦áá¡ 1:00 PM-áá',   'áá®áááááá áá áá¡ ááááá¢ááá£áá 1 á¡áááá');
        assert.equal(moment(a).add({d: 1}).calendar(),       'á®ááá 12:00 PM-áá',  'á®ááá ááááá áá áá¡');
        assert.equal(moment(a).subtract({h: 1}).calendar(),  'áá¦áá¡ 11:00 AM-áá',  'áá®áááááá áá áá¡ ááááááááá£áá 1 á¡áááá');
        assert.equal(moment(a).subtract({d: 1}).calendar(),  'áá£á¨áá 12:00 PM-áá', 'áá£á¨áá ááááá áá áá¡');
    });

    test('calendar next week', function (assert) {
        var i, m;
        for (i = 2; i < 7; i++) {
            m = moment().add({d: i});
            assert.equal(m.calendar(),       m.format('[á¨ááááá] dddd LT[-áá]'),  'áá¦áá¡ + ' + i + ' áá¦á áá®áááááá áá áá¡');
            m.hours(0).minutes(0).seconds(0).milliseconds(0);
            assert.equal(m.calendar(),       m.format('[á¨ááááá] dddd LT[-áá]'),  'áá¦áá¡ + ' + i + ' áá¦á áá¦áá¡ ááá¡áá¬á§áá¡á¨á');
            m.hours(23).minutes(59).seconds(59).milliseconds(999);
            assert.equal(m.calendar(),       m.format('[á¨ááááá] dddd LT[-áá]'),  'áá¦áá¡ + ' + i + ' áá¦á áá¦áá¡ ááá¡áá¡á á£áá¡');
        }
    });

    test('calendar last week', function (assert) {
        var i, m;
        for (i = 2; i < 7; i++) {
            m = moment().subtract({d: i});
            assert.equal(m.calendar(),       m.format('[á¬ááá] dddd LT[-áá]'),  'áá¦áá¡ - ' + i + ' áá¦á áá®áááááá áá áá¡');
            m.hours(0).minutes(0).seconds(0).milliseconds(0);
            assert.equal(m.calendar(),       m.format('[á¬ááá] dddd LT[-áá]'),  'áá¦áá¡ - ' + i + ' áá¦á áá¦áá¡ ááá¡áá¬á§áá¡á¨á');
            m.hours(23).minutes(59).seconds(59).milliseconds(999);
            assert.equal(m.calendar(),       m.format('[á¬ááá] dddd LT[-áá]'),  'áá¦áá¡ - ' + i + ' áá¦á áá¦áá¡ ááá¡áá¡á á£áá¡');
        }
    });

    test('calendar all else', function (assert) {
        var weeksAgo = moment().subtract({w: 1}),
            weeksFromNow = moment().add({w: 1});

        assert.equal(weeksAgo.calendar(),       weeksAgo.format('L'),  '1 áááá áá¡ á¬áá');
        assert.equal(weeksFromNow.calendar(),   weeksFromNow.format('L'),  '1 áááá áá¨á');

        weeksAgo = moment().subtract({w: 2});
        weeksFromNow = moment().add({w: 2});

        assert.equal(weeksAgo.calendar(),       weeksAgo.format('L'),  '2 áááá áá¡ á¬áá');
        assert.equal(weeksFromNow.calendar(),   weeksFromNow.format('L'),  '2 áááá áá¨á');
    });

    test('weeks year starting sunday formatted', function (assert) {
        assert.equal(moment([2011, 11, 26]).format('w ww wo'), '1 01 1-áá', 'ááá 26 2011 á£ááá áá§áá¡ áááá á 1');
        assert.equal(moment([2012,  0,  1]).format('w ww wo'), '1 01 1-áá', 'ááá  1 2012 á£ááá áá§áá¡ áááá á 1');
        assert.equal(moment([2012,  0,  2]).format('w ww wo'), '2 02 áá-2', 'ááá  2 2012 á£ááá áá§áá¡ áááá á 2');
        assert.equal(moment([2012,  0,  8]).format('w ww wo'), '2 02 áá-2', 'ááá  8 2012 á£ááá áá§áá¡ áááá á 2');
        assert.equal(moment([2012,  0,  9]).format('w ww wo'), '3 03 áá-3', 'ááá  9 2012 á£ááá áá§áá¡ áááá á 3');
    });

}));

;(function (global, factory) {
   typeof exports === 'object' && typeof module !== 'undefined'
       && typeof require === 'function' ? factory(require('../../moment')) :
   typeof define === 'function' && define.amd ? define(['../../moment'], factory) :
   factory(global.moment)
}(this, function (moment) { 'use strict';

    function each(array, callback) {
        var i;
        for (i = 0; i < array.length; i++) {
            callback(array[i], i, array);
        }
    }

    function objectKeys(obj) {
        if (Object.keys) {
            return Object.keys(obj);
        } else {
            // IE8
            var res = [], i;
            for (i in obj) {
                if (obj.hasOwnProperty(i)) {
                    res.push(i);
                }
            }
            return res;
        }
    }

    // Pick the first defined of two or three arguments.
    function defaults(a, b, c) {
        if (a != null) {
            return a;
        }
        if (b != null) {
            return b;
        }
        return c;
    }

    function defineCommonLocaleTests(locale, options) {
        test('lenient ordinal parsing', function (assert) {
            var i, ordinalStr, testMoment;
            for (i = 1; i <= 31; ++i) {
                ordinalStr = moment([2014, 0, i]).format('YYYY MM Do');
                testMoment = moment(ordinalStr, 'YYYY MM Do');
                assert.equal(testMoment.year(), 2014,
                        'lenient ordinal parsing ' + i + ' year check');
                assert.equal(testMoment.month(), 0,
                        'lenient ordinal parsing ' + i + ' month check');
                assert.equal(testMoment.date(), i,
                        'lenient ordinal parsing ' + i + ' date check');
            }
        });

        test('lenient ordinal parsing of number', function (assert) {
            var i, testMoment;
            for (i = 1; i <= 31; ++i) {
                testMoment = moment('2014 01 ' + i, 'YYYY MM Do');
                assert.equal(testMoment.year(), 2014,
                        'lenient ordinal parsing of number ' + i + ' year check');
                assert.equal(testMoment.month(), 0,
                        'lenient ordinal parsing of number ' + i + ' month check');
                assert.equal(testMoment.date(), i,
                        'lenient ordinal parsing of number ' + i + ' date check');
            }
        });

        test('strict ordinal parsing', function (assert) {
            var i, ordinalStr, testMoment;
            for (i = 1; i <= 31; ++i) {
                ordinalStr = moment([2014, 0, i]).format('YYYY MM Do');
                testMoment = moment(ordinalStr, 'YYYY MM Do', true);
                assert.ok(testMoment.isValid(), 'strict ordinal parsing ' + i);
            }
        });

        test('meridiem invariant', function (assert) {
            var h, m, t1, t2;
            for (h = 0; h < 24; ++h) {
                for (m = 0; m < 60; m += 15) {
                    t1 = moment.utc([2000, 0, 1, h, m]);
                    t2 = moment.utc(t1.format('A h:mm'), 'A h:mm');
                    assert.equal(t2.format('HH:mm'), t1.format('HH:mm'),
                            'meridiem at ' + t1.format('HH:mm'));
                }
            }
        });

        test('date format correctness', function (assert) {
            var data, tokens;
            data = moment.localeData()._longDateFormat;
            tokens = objectKeys(data);
            each(tokens, function (srchToken) {
                // Check each format string to make sure it does not contain any
                // tokens that need to be expanded.
                each(tokens, function (baseToken) {
                    // strip escaped sequences
                    var format = data[baseToken].replace(/(\[[^\]]*\])/g, '');
                    assert.equal(false, !!~format.indexOf(srchToken),
                            'contains ' + srchToken + ' in ' + baseToken);
                });
            });
        });

        test('month parsing correctness', function (assert) {
            var i, m;

            if (locale === 'tr') {
                // I can't fix it :(
                expect(0);
                return;
            }
            function tester(format) {
                var r;
                r = moment(m.format(format), format);
                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format);
                r = moment(m.format(format).toLocaleUpperCase(), format);
                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' upper');
                r = moment(m.format(format).toLocaleLowerCase(), format);
                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' lower');

                r = moment(m.format(format), format, true);
                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' strict');
                r = moment(m.format(format).toLocaleUpperCase(), format, true);
                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' upper strict');
                r = moment(m.format(format).toLocaleLowerCase(), format, true);
                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' lower strict');
            }

            for (i = 0; i < 12; ++i) {
                m = moment([2015, i, 15, 18]);
                tester('MMM');
                tester('MMM.');
                tester('MMMM');
                tester('MMMM.');
            }
        });

        test('weekday parsing correctness', function (assert) {
            var i, m;

            if (locale === 'tr' || locale === 'az') {
                // There is a lower-case letter (Ä±), that converted to upper then
                // lower changes to i
                expect(0);
                return;
            }
            function tester(format) {
                var r, baseMsg = 'weekday ' + m.weekday() + ' fmt ' + format;
                r = moment(m.format(format), format);
                assert.equal(r.weekday(), m.weekday(), baseMsg);
                r = moment(m.format(format).toLocaleUpperCase(), format);
                assert.equal(r.weekday(), m.weekday(), baseMsg + ' upper');
                r = moment(m.format(format).toLocaleLowerCase(), format);
                assert.equal(r.weekday(), m.weekday(), baseMsg + ' lower');

                r = moment(m.format(format), format, true);
                assert.equal(r.weekday(), m.weekday(), baseMsg + ' strict');
                r = moment(m.format(format).toLocaleUpperCase(), format, true);
                assert.equal(r.weekday(), m.weekday(), baseMsg + ' upper strict');
                r = moment(m.format(format).toLocaleLowerCase(), format, true);
                assert.equal(r.weekday(), m.weekday(), baseMsg + ' lower strict');
            }

            for (i = 0; i < 7; ++i) {
                m = moment.utc([2015, i, 15, 18]);
                tester('dd');
                tester('ddd');
                tester('dddd');
            }
        });
    }

    function setupDeprecationHandler(test, moment, scope) {
        test._expectedDeprecations = null;
        test._observedDeprecations = null;
        test._oldSupress = moment.suppressDeprecationWarnings;
        moment.suppressDeprecationWarnings = true;
        test.expectedDeprecations = function () {
            test._expectedDeprecations = arguments;
            test._observedDeprecations = [];
        };
        moment.deprecationHandler = function (name, msg) {
            var deprecationId = matchedDeprecation(name, msg, test._expectedDeprecations);
            if (deprecationId === -1) {
                throw new Error('Unexpected deprecation thrown name=' +
                        name + ' msg=' + msg);
            }
            test._observedDeprecations[deprecationId] = 1;
        };
    }

    function teardownDeprecationHandler(test, moment, scope) {
        moment.suppressDeprecationWarnings = test._oldSupress;

        if (test._expectedDeprecations != null) {
            var missedDeprecations = [];
            each(test._expectedDeprecations, function (deprecationPattern, id) {
                if (test._observedDeprecations[id] !== 1) {
                    missedDeprecations.push(deprecationPattern);
                }
            });
            if (missedDeprecations.length !== 0) {
                throw new Error('Expected deprecation warnings did not happen: ' +
                        missedDeprecations.join(' '));
            }
        }
    }

    function matchedDeprecation(name, msg, deprecations) {
        if (deprecations == null) {
            return -1;
        }
        for (var i = 0; i < deprecations.length; ++i) {
            if (name != null && name === deprecations[i]) {
                return i;
            }
            if (msg != null && msg.substring(0, deprecations[i].length) === deprecations[i]) {
                return i;
            }
        }
        return -1;
    }

    /*global QUnit:false*/

    var test = QUnit.test;

    var expect = QUnit.expect;

    function module (name, lifecycle) {
        QUnit.module(name, {
            setup : function () {
                moment.locale('en');
                moment.createFromInputFallback = function (config) {
                    throw new Error('input not handled by moment: ' + config._i);
                };
                setupDeprecationHandler(test, moment, 'core');
                if (lifecycle && lifecycle.setup) {
                    lifecycle.setup();
                }
            },
            teardown : function () {
                teardownDeprecationHandler(test, moment, 'core');
                if (lifecycle && lifecycle.teardown) {
                    lifecycle.teardown();
                }
            }
        });
    }

    function localeModule (name, lifecycle) {
        QUnit.module('locale:' + name, {
            setup : function () {
                moment.locale(name);
                moment.createFromInputFallback = function (config) {
                    throw new Error('input not handled by moment: ' + config._i);
                };
                setupDeprecationHandler(test, moment, 'locale');
                if (lifecycle && lifecycle.setup) {
                    lifecycle.setup();
                }
            },
            teardown : function () {
                moment.locale('en');
                teardownDeprecationHandler(test, moment, 'locale');
                if (lifecycle && lifecycle.teardown) {
                    lifecycle.teardown();
                }
            }
        });
        defineCommonLocaleTests(name, -1, -1);
    }

    localeModule('kk');

    test('parse', function (assert) {
        var tests = 'ÒÐ°Ò£ÑÐ°Ñ ÒÐ°Ò£_Ð°ÒÐ¿Ð°Ð½ Ð°ÒÐ¿_Ð½Ð°ÑÑÑÐ· Ð½Ð°Ñ_ÑÓÑÑÑ ÑÓÑ_Ð¼Ð°Ð¼ÑÑ Ð¼Ð°Ð¼_Ð¼Ð°ÑÑÑÐ¼ Ð¼Ð°Ñ_ÑÑÐ»Ð´Ðµ ÑÑÐ»_ÑÐ°Ð¼ÑÐ· ÑÐ°Ð¼_ÒÑÑÐºÒ¯Ð¹ÐµÐº ÒÑÑ_ÒÐ°Ð·Ð°Ð½ ÒÐ°Ð·_ÒÐ°ÑÐ°ÑÐ° ÒÐ°Ñ_Ð¶ÐµÐ»ÑÐ¾ÒÑÐ°Ð½ Ð¶ÐµÐ»'.split('_'), i;
        function equalTest(input, mmm, i) {
            assert.equal(moment(input, mmm).month(), i, input + ' should be month ' + (i + 1));
        }
        for (i = 0; i < 12; i++) {
            tests[i] = tests[i].split(' ');
            equalTest(tests[i][0], 'MMM', i);
            equalTest(tests[i][1], 'MMM', i);
            equalTest(tests[i][0], 'MMMM', i);
            equalTest(tests[i][1], 'MMMM', i);
            equalTest(tests[i][0].toLocaleLowerCase(), 'MMMM', i);
            equalTest(tests[i][1].toLocaleLowerCase(), 'MMMM', i);
            equalTest(tests[i][0].toLocaleUpperCase(), 'MMMM', i);
            equalTest(tests[i][1].toLocaleUpperCase(), 'MMMM', i);
        }
    });

    test('format', function (assert) {
        var a = [
                ['dddd, Do MMMM YYYY, HH:mm:ss',       'Ð¶ÐµÐºÑÐµÐ½Ð±Ñ, 14-ÑÑ Ð°ÒÐ¿Ð°Ð½ 2010, 15:25:50'],
                ['ddd, hA',                            'Ð¶ÐµÐº, 3PM'],
                ['M Mo MM MMMM MMM',                   '2 2-ÑÑ 02 Ð°ÒÐ¿Ð°Ð½ Ð°ÒÐ¿'],
                ['YYYY YY',                            '2010 10'],
                ['D Do DD',                            '14 14-ÑÑ 14'],
                ['d do dddd ddd dd',                   '0 0-ÑÑ Ð¶ÐµÐºÑÐµÐ½Ð±Ñ Ð¶ÐµÐº Ð¶Ðº'],
                ['DDD DDDo DDDD',                      '45 45-ÑÑ 045'],
                ['w wo ww',                            '7 7-ÑÑ 07'],
                ['h hh',                               '3 03'],
                ['H HH',                               '15 15'],
                ['m mm',                               '25 25'],
                ['s ss',                               '50 50'],
                ['a A',                                'pm PM'],
                ['[Ð¶ÑÐ»Ð´ÑÒ£] DDDo [ÐºÒ¯Ð½Ñ]',               'Ð¶ÑÐ»Ð´ÑÒ£ 45-ÑÑ ÐºÒ¯Ð½Ñ'],
                ['LTS',                                '15:25:50'],
                ['L',                                  '14.02.2010'],
                ['LL',                                 '14 Ð°ÒÐ¿Ð°Ð½ 2010'],
                ['LLL',                                '14 Ð°ÒÐ¿Ð°Ð½ 2010 15:25'],
                ['LLLL',                               'Ð¶ÐµÐºÑÐµÐ½Ð±Ñ, 14 Ð°ÒÐ¿Ð°Ð½ 2010 15:25'],
                ['l',                                  '14.2.2010'],
                ['ll',                                 '14 Ð°ÒÐ¿ 2010'],
                ['lll',                                '14 Ð°ÒÐ¿ 2010 15:25'],
                ['llll',                               'Ð¶ÐµÐº, 14 Ð°ÒÐ¿ 2010 15:25']
            ],
            b = moment(new Date(2010, 1, 14, 15, 25, 50, 125)),
            i;
        for (i = 0; i < a.length; i++) {
            assert.equal(b.format(a[i][0]), a[i][1], a[i][0] + ' ---> ' + a[i][1]);
        }
    });

    test('format ordinal', function (assert) {
        assert.equal(moment([2011, 0, 1]).format('DDDo'), '1-ÑÑ', '1st');
        assert.equal(moment([2011, 0, 2]).format('DDDo'), '2-ÑÑ', '2nd');
        assert.equal(moment([2011, 0, 3]).format('DDDo'), '3-ÑÑ', '3rd');
        assert.equal(moment([2011, 0, 4]).format('DDDo'), '4-ÑÑ', '4th');
        assert.equal(moment([2011, 0, 5]).format('DDDo'), '5-ÑÑ', '5th');
        assert.equal(moment([2011, 0, 6]).format('DDDo'), '6-ÑÑ', '6th');
        assert.equal(moment([2011, 0, 7]).format('DDDo'), '7-ÑÑ', '7th');
        assert.equal(moment([2011, 0, 8]).format('DDDo'), '8-ÑÑ', '8th');
        assert.equal(moment([2011, 0, 9]).format('DDDo'), '9-ÑÑ', '9th');
        assert.equal(moment([2011, 0, 10]).format('DDDo'), '10-ÑÑ', '10th');

        assert.equal(moment([2011, 0, 11]).format('DDDo'), '11-ÑÑ', '11th');
        assert.equal(moment([2011, 0, 12]).format('DDDo'), '12-ÑÑ', '12th');
        assert.equal(moment([2011, 0, 13]).format('DDDo'), '13-ÑÑ', '13th');
        assert.equal(moment([2011, 0, 14]).format('DDDo'), '14-ÑÑ', '14th');
        assert.equal(moment([2011, 0, 15]).format('DDDo'), '15-ÑÑ', '15th');
        assert.equal(moment([2011, 0, 16]).format('DDDo'), '16-ÑÑ', '16th');
        assert.equal(moment([2011, 0, 17]).format('DDDo'), '17-ÑÑ', '17th');
        assert.equal(moment([2011, 0, 18]).format('DDDo'), '18-ÑÑ', '18th');
        assert.equal(moment([2011, 0, 19]).format('DDDo'), '19-ÑÑ', '19th');
        assert.equal(moment([2011, 0, 20]).format('DDDo'), '20-ÑÑ', '20th');

        assert.equal(moment([2011, 0, 21]).format('DDDo'), '21-ÑÑ', '21st');
        assert.equal(moment([2011, 0, 22]).format('DDDo'), '22-ÑÑ', '22nd');
        assert.equal(moment([2011, 0, 23]).format('DDDo'), '23-ÑÑ', '23rd');
        assert.equal(moment([2011, 0, 24]).format('DDDo'), '24-ÑÑ', '24th');
        assert.equal(moment([2011, 0, 25]).format('DDDo'), '25-ÑÑ', '25th');
        assert.equal(moment([2011, 0, 26]).format('DDDo'), '26-ÑÑ', '26th');
        assert.equal(moment([2011, 0, 27]).format('DDDo'), '27-ÑÑ', '27th');
        assert.equal(moment([2011, 0, 28]).format('DDDo'), '28-ÑÑ', '28th');
        assert.equal(moment([2011, 0, 29]).format('DDDo'), '29-ÑÑ', '29th');
        assert.equal(moment([2011, 0, 30]).format('DDDo'), '30-ÑÑ', '30th');

        assert.equal(moment([2011, 0, 31]).format('DDDo'), '31-ÑÑ', '31st');
    });

    test('format month', function (assert) {
        var expected = 'ÒÐ°Ò£ÑÐ°Ñ ÒÐ°Ò£_Ð°ÒÐ¿Ð°Ð½ Ð°ÒÐ¿_Ð½Ð°ÑÑÑÐ· Ð½Ð°Ñ_ÑÓÑÑÑ ÑÓÑ_Ð¼Ð°Ð¼ÑÑ Ð¼Ð°Ð¼_Ð¼Ð°ÑÑÑÐ¼ Ð¼Ð°Ñ_ÑÑÐ»Ð´Ðµ ÑÑÐ»_ÑÐ°Ð¼ÑÐ· ÑÐ°Ð¼_ÒÑÑÐºÒ¯Ð¹ÐµÐº ÒÑÑ_ÒÐ°Ð·Ð°Ð½ ÒÐ°Ð·_ÒÐ°ÑÐ°ÑÐ° ÒÐ°Ñ_Ð¶ÐµÐ»ÑÐ¾ÒÑÐ°Ð½ Ð¶ÐµÐ»'.split('_'), i;
        for (i = 0; i < expected.length; i++) {
            assert.equal(moment([2011, i, 1]).format('MMMM MMM'), expected[i], expected[i]);
        }
    });

    test('format week', function (assert) {
        var expected = 'Ð¶ÐµÐºÑÐµÐ½Ð±Ñ Ð¶ÐµÐº Ð¶Ðº_Ð´Ò¯Ð¹ÑÐµÐ½Ð±Ñ Ð´Ò¯Ð¹ Ð´Ð¹_ÑÐµÐ¹ÑÐµÐ½Ð±Ñ ÑÐµÐ¹ ÑÐ¹_ÑÓÑÑÐµÐ½Ð±Ñ ÑÓÑ ÑÑ_Ð±ÐµÐ¹ÑÐµÐ½Ð±Ñ Ð±ÐµÐ¹ Ð±Ð¹_Ð¶Ò±Ð¼Ð° Ð¶Ò±Ð¼ Ð¶Ð¼_ÑÐµÐ½Ð±Ñ ÑÐµÐ½ ÑÐ½'.split('_'), i;
        for (i = 0; i < expected.length; i++) {
            assert.equal(moment([2011, 0, 2 + i]).format('dddd ddd dd'), expected[i], expected[i]);
        }
    });

    test('from', function (assert) {
        var start = moment([2007, 1, 28]);
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 44}), true),  'Ð±ÑÑÐ½ÐµÑÐµ ÑÐµÐºÑÐ½Ð´', '44 seconds = a few seconds');
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 45}), true),  'Ð±ÑÑ Ð¼Ð¸Ð½ÑÑ',      '45 seconds = a minute');
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 89}), true),  'Ð±ÑÑ Ð¼Ð¸Ð½ÑÑ',      '89 seconds = a minute');
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 90}), true),  '2 Ð¼Ð¸Ð½ÑÑ',     '90 seconds = 2 minutes');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 44}), true),  '44 Ð¼Ð¸Ð½ÑÑ',    '44 minutes = 44 minutes');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 45}), true),  'Ð±ÑÑ ÑÐ°ÒÐ°Ñ',       '45 minutes = an hour');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 89}), true),  'Ð±ÑÑ ÑÐ°ÒÐ°Ñ',       '89 minutes = an hour');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 90}), true),  '2 ÑÐ°ÒÐ°Ñ',       '90 minutes = 2 hours');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 5}), true),   '5 ÑÐ°ÒÐ°Ñ',       '5 hours = 5 hours');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 21}), true),  '21 ÑÐ°ÒÐ°Ñ',      '21 hours = 21 hours');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 22}), true),  'Ð±ÑÑ ÐºÒ¯Ð½',         '22 hours = a day');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 35}), true),  'Ð±ÑÑ ÐºÒ¯Ð½',         '35 hours = a day');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 36}), true),  '2 ÐºÒ¯Ð½',        '36 hours = 2 days');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 1}), true),   'Ð±ÑÑ ÐºÒ¯Ð½',         '1 day = a day');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 5}), true),   '5 ÐºÒ¯Ð½',        '5 days = 5 days');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 25}), true),  '25 ÐºÒ¯Ð½',       '25 days = 25 days');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 26}), true),  'Ð±ÑÑ Ð°Ð¹',       '26 days = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 30}), true),  'Ð±ÑÑ Ð°Ð¹',       '30 days = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 43}), true),  'Ð±ÑÑ Ð°Ð¹',       '43 days = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 46}), true),  '2 Ð°Ð¹',      '46 days = 2 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 74}), true),  '2 Ð°Ð¹',      '75 days = 2 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 76}), true),  '3 Ð°Ð¹',      '76 days = 3 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({M: 1}), true),   'Ð±ÑÑ Ð°Ð¹',       '1 month = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({M: 5}), true),   '5 Ð°Ð¹',      '5 months = 5 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 345}), true), 'Ð±ÑÑ Ð¶ÑÐ»',        '345 days = a year');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 548}), true), '2 Ð¶ÑÐ»',       '548 days = 2 years');
        assert.equal(start.from(moment([2007, 1, 28]).add({y: 1}), true),   'Ð±ÑÑ Ð¶ÑÐ»',        '1 year = a year');
        assert.equal(start.from(moment([2007, 1, 28]).add({y: 5}), true),   '5 Ð¶ÑÐ»',       '5 years = 5 years');
    });

    test('suffix', function (assert) {
        assert.equal(moment(30000).from(0), 'Ð±ÑÑÐ½ÐµÑÐµ ÑÐµÐºÑÐ½Ð´ ÑÑÑÐ½Ð´Ðµ',  'prefix');
        assert.equal(moment(0).from(30000), 'Ð±ÑÑÐ½ÐµÑÐµ ÑÐµÐºÑÐ½Ð´ Ð±Ò±ÑÑÐ½', 'suffix');
    });

    test('now from now', function (assert) {
        assert.equal(moment().fromNow(), 'Ð±ÑÑÐ½ÐµÑÐµ ÑÐµÐºÑÐ½Ð´ Ð±Ò±ÑÑÐ½',  'now from now should display as in the past');
    });

    test('fromNow', function (assert) {
        assert.equal(moment().add({s: 30}).fromNow(), 'Ð±ÑÑÐ½ÐµÑÐµ ÑÐµÐºÑÐ½Ð´ ÑÑÑÐ½Ð´Ðµ', 'in a few seconds');
        assert.equal(moment().add({d: 5}).fromNow(), '5 ÐºÒ¯Ð½ ÑÑÑÐ½Ð´Ðµ', 'in 5 days');
    });

    test('calendar day', function (assert) {
        var a = moment().hours(12).minutes(0).seconds(0);

        assert.equal(moment(a).calendar(),                   'ÐÒ¯Ð³ÑÐ½ ÑÐ°ÒÐ°Ñ 12:00',  'today at the same time');
        assert.equal(moment(a).add({m: 25}).calendar(),      'ÐÒ¯Ð³ÑÐ½ ÑÐ°ÒÐ°Ñ 12:25',  'Now plus 25 min');
        assert.equal(moment(a).add({h: 1}).calendar(),       'ÐÒ¯Ð³ÑÐ½ ÑÐ°ÒÐ°Ñ 13:00',  'Now plus 1 hour');
        assert.equal(moment(a).add({d: 1}).calendar(),       'ÐÑÑÐµÒ£ ÑÐ°ÒÐ°Ñ 12:00',  'tomorrow at the same time');
        assert.equal(moment(a).subtract({h: 1}).calendar(),  'ÐÒ¯Ð³ÑÐ½ ÑÐ°ÒÐ°Ñ 11:00',  'Now minus 1 hour');
        assert.equal(moment(a).subtract({d: 1}).calendar(),  'ÐÐµÑÐµ ÑÐ°ÒÐ°Ñ 12:00',   'yesterday at the same time');
    });

    test('calendar next week', function (assert) {
        var i, m;
        for (i = 2; i < 7; i++) {
            m = moment().add({d: i});
            assert.equal(m.calendar(),       m.format('dddd [ÑÐ°ÒÐ°Ñ] LT'),  'Today + ' + i + ' days current time');
            m.hours(0).minutes(0).seconds(0).milliseconds(0);
            assert.equal(m.calendar(),       m.format('dddd [ÑÐ°ÒÐ°Ñ] LT'),  'Today + ' + i + ' days beginning of day');
            m.hours(23).minutes(59).seconds(59).milliseconds(999);
            assert.equal(m.calendar(),       m.format('dddd [ÑÐ°ÒÐ°Ñ] LT'),  'Today + ' + i + ' days end of day');
        }
    });

    test('calendar last week', function (assert) {
        var i, m;

        for (i = 2; i < 7; i++) {
            m = moment().subtract({d: i});
            assert.equal(m.calendar(),       m.format('[Ó¨ÑÐºÐµÐ½ Ð°Ð¿ÑÐ°Ð½ÑÒ£] dddd [ÑÐ°ÒÐ°Ñ] LT'),  'Today - ' + i + ' days current time');
            m.hours(0).minutes(0).seconds(0).milliseconds(0);
            assert.equal(m.calendar(),       m.format('[Ó¨ÑÐºÐµÐ½ Ð°Ð¿ÑÐ°Ð½ÑÒ£] dddd [ÑÐ°ÒÐ°Ñ] LT'),  'Today - ' + i + ' days beginning of day');
            m.hours(23).minutes(59).seconds(59).milliseconds(999);
            assert.equal(m.calendar(),       m.format('[Ó¨ÑÐºÐµÐ½ Ð°Ð¿ÑÐ°Ð½ÑÒ£] dddd [ÑÐ°ÒÐ°Ñ] LT'),  'Today - ' + i + ' days end of day');
        }
    });

    test('calendar all else', function (assert) {
        var weeksAgo = moment().subtract({w: 1}),
            weeksFromNow = moment().add({w: 1});

        assert.equal(weeksAgo.calendar(),       weeksAgo.format('L'),  '1 week ago');
        assert.equal(weeksFromNow.calendar(),   weeksFromNow.format('L'),  'in 1 week');

        weeksAgo = moment().subtract({w: 2});
        weeksFromNow = moment().add({w: 2});

        assert.equal(weeksAgo.calendar(),       weeksAgo.format('L'),  '2 weeks ago');
        assert.equal(weeksFromNow.calendar(),   weeksFromNow.format('L'),  'in 2 weeks');
    });

    test('weeks year starting sunday formatted', function (assert) {
        assert.equal(moment([2012, 0,  1]).format('w ww wo'),   '1 01 1-ÑÑ', 'Jan  1 2012 should be week 1');
        assert.equal(moment([2012, 0,  2]).format('w ww wo'),   '2 02 2-ÑÑ', 'Jan  2 2012 should be week 2');
        assert.equal(moment([2012, 0,  8]).format('w ww wo'),   '2 02 2-ÑÑ', 'Jan  8 2012 should be week 2');
        assert.equal(moment([2012, 0,  9]).format('w ww wo'),   '3 03 3-ÑÑ', 'Jan  9 2012 should be week 3');
        assert.equal(moment([2012, 0, 15]).format('w ww wo'),   '3 03 3-ÑÑ', 'Jan 15 2012 should be week 3');
    });

}));

;(function (global, factory) {
   typeof exports === 'object' && typeof module !== 'undefined'
       && typeof require === 'function' ? factory(require('../../moment')) :
   typeof define === 'function' && define.amd ? define(['../../moment'], factory) :
   factory(global.moment)
}(this, function (moment) { 'use strict';

    function each(array, callback) {
        var i;
        for (i = 0; i < array.length; i++) {
            callback(array[i], i, array);
        }
    }

    function objectKeys(obj) {
        if (Object.keys) {
            return Object.keys(obj);
        } else {
            // IE8
            var res = [], i;
            for (i in obj) {
                if (obj.hasOwnProperty(i)) {
                    res.push(i);
                }
            }
            return res;
        }
    }

    // Pick the first defined of two or three arguments.
    function defaults(a, b, c) {
        if (a != null) {
            return a;
        }
        if (b != null) {
            return b;
        }
        return c;
    }

    function defineCommonLocaleTests(locale, options) {
        test('lenient ordinal parsing', function (assert) {
            var i, ordinalStr, testMoment;
            for (i = 1; i <= 31; ++i) {
                ordinalStr = moment([2014, 0, i]).format('YYYY MM Do');
                testMoment = moment(ordinalStr, 'YYYY MM Do');
                assert.equal(testMoment.year(), 2014,
                        'lenient ordinal parsing ' + i + ' year check');
                assert.equal(testMoment.month(), 0,
                        'lenient ordinal parsing ' + i + ' month check');
                assert.equal(testMoment.date(), i,
                        'lenient ordinal parsing ' + i + ' date check');
            }
        });

        test('lenient ordinal parsing of number', function (assert) {
            var i, testMoment;
            for (i = 1; i <= 31; ++i) {
                testMoment = moment('2014 01 ' + i, 'YYYY MM Do');
                assert.equal(testMoment.year(), 2014,
                        'lenient ordinal parsing of number ' + i + ' year check');
                assert.equal(testMoment.month(), 0,
                        'lenient ordinal parsing of number ' + i + ' month check');
                assert.equal(testMoment.date(), i,
                        'lenient ordinal parsing of number ' + i + ' date check');
            }
        });

        test('strict ordinal parsing', function (assert) {
            var i, ordinalStr, testMoment;
            for (i = 1; i <= 31; ++i) {
                ordinalStr = moment([2014, 0, i]).format('YYYY MM Do');
                testMoment = moment(ordinalStr, 'YYYY MM Do', true);
                assert.ok(testMoment.isValid(), 'strict ordinal parsing ' + i);
            }
        });

        test('meridiem invariant', function (assert) {
            var h, m, t1, t2;
            for (h = 0; h < 24; ++h) {
                for (m = 0; m < 60; m += 15) {
                    t1 = moment.utc([2000, 0, 1, h, m]);
                    t2 = moment.utc(t1.format('A h:mm'), 'A h:mm');
                    assert.equal(t2.format('HH:mm'), t1.format('HH:mm'),
                            'meridiem at ' + t1.format('HH:mm'));
                }
            }
        });

        test('date format correctness', function (assert) {
            var data, tokens;
            data = moment.localeData()._longDateFormat;
            tokens = objectKeys(data);
            each(tokens, function (srchToken) {
                // Check each format string to make sure it does not contain any
                // tokens that need to be expanded.
                each(tokens, function (baseToken) {
                    // strip escaped sequences
                    var format = data[baseToken].replace(/(\[[^\]]*\])/g, '');
                    assert.equal(false, !!~format.indexOf(srchToken),
                            'contains ' + srchToken + ' in ' + baseToken);
                });
            });
        });

        test('month parsing correctness', function (assert) {
            var i, m;

            if (locale === 'tr') {
                // I can't fix it :(
                expect(0);
                return;
            }
            function tester(format) {
                var r;
                r = moment(m.format(format), format);
                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format);
                r = moment(m.format(format).toLocaleUpperCase(), format);
                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' upper');
                r = moment(m.format(format).toLocaleLowerCase(), format);
                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' lower');

                r = moment(m.format(format), format, true);
                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' strict');
                r = moment(m.format(format).toLocaleUpperCase(), format, true);
                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' upper strict');
                r = moment(m.format(format).toLocaleLowerCase(), format, true);
                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' lower strict');
            }

            for (i = 0; i < 12; ++i) {
                m = moment([2015, i, 15, 18]);
                tester('MMM');
                tester('MMM.');
                tester('MMMM');
                tester('MMMM.');
            }
        });

        test('weekday parsing correctness', function (assert) {
            var i, m;

            if (locale === 'tr' || locale === 'az') {
                // There is a lower-case letter (Ä±), that converted to upper then
                // lower changes to i
                expect(0);
                return;
            }
            function tester(format) {
                var r, baseMsg = 'weekday ' + m.weekday() + ' fmt ' + format;
                r = moment(m.format(format), format);
                assert.equal(r.weekday(), m.weekday(), baseMsg);
                r = moment(m.format(format).toLocaleUpperCase(), format);
                assert.equal(r.weekday(), m.weekday(), baseMsg + ' upper');
                r = moment(m.format(format).toLocaleLowerCase(), format);
                assert.equal(r.weekday(), m.weekday(), baseMsg + ' lower');

                r = moment(m.format(format), format, true);
                assert.equal(r.weekday(), m.weekday(), baseMsg + ' strict');
                r = moment(m.format(format).toLocaleUpperCase(), format, true);
                assert.equal(r.weekday(), m.weekday(), baseMsg + ' upper strict');
                r = moment(m.format(format).toLocaleLowerCase(), format, true);
                assert.equal(r.weekday(), m.weekday(), baseMsg + ' lower strict');
            }

            for (i = 0; i < 7; ++i) {
                m = moment.utc([2015, i, 15, 18]);
                tester('dd');
                tester('ddd');
                tester('dddd');
            }
        });
    }

    function setupDeprecationHandler(test, moment, scope) {
        test._expectedDeprecations = null;
        test._observedDeprecations = null;
        test._oldSupress = moment.suppressDeprecationWarnings;
        moment.suppressDeprecationWarnings = true;
        test.expectedDeprecations = function () {
            test._expectedDeprecations = arguments;
            test._observedDeprecations = [];
        };
        moment.deprecationHandler = function (name, msg) {
            var deprecationId = matchedDeprecation(name, msg, test._expectedDeprecations);
            if (deprecationId === -1) {
                throw new Error('Unexpected deprecation thrown name=' +
                        name + ' msg=' + msg);
            }
            test._observedDeprecations[deprecationId] = 1;
        };
    }

    function teardownDeprecationHandler(test, moment, scope) {
        moment.suppressDeprecationWarnings = test._oldSupress;

        if (test._expectedDeprecations != null) {
            var missedDeprecations = [];
            each(test._expectedDeprecations, function (deprecationPattern, id) {
                if (test._observedDeprecations[id] !== 1) {
                    missedDeprecations.push(deprecationPattern);
                }
            });
            if (missedDeprecations.length !== 0) {
                throw new Error('Expected deprecation warnings did not happen: ' +
                        missedDeprecations.join(' '));
            }
        }
    }

    function matchedDeprecation(name, msg, deprecations) {
        if (deprecations == null) {
            return -1;
        }
        for (var i = 0; i < deprecations.length; ++i) {
            if (name != null && name === deprecations[i]) {
                return i;
            }
            if (msg != null && msg.substring(0, deprecations[i].length) === deprecations[i]) {
                return i;
            }
        }
        return -1;
    }

    /*global QUnit:false*/

    var test = QUnit.test;

    var expect = QUnit.expect;

    function module (name, lifecycle) {
        QUnit.module(name, {
            setup : function () {
                moment.locale('en');
                moment.createFromInputFallback = function (config) {
                    throw new Error('input not handled by moment: ' + config._i);
                };
                setupDeprecationHandler(test, moment, 'core');
                if (lifecycle && lifecycle.setup) {
                    lifecycle.setup();
                }
            },
            teardown : function () {
                teardownDeprecationHandler(test, moment, 'core');
                if (lifecycle && lifecycle.teardown) {
                    lifecycle.teardown();
                }
            }
        });
    }

    function localeModule (name, lifecycle) {
        QUnit.module('locale:' + name, {
            setup : function () {
                moment.locale(name);
                moment.createFromInputFallback = function (config) {
                    throw new Error('input not handled by moment: ' + config._i);
                };
                setupDeprecationHandler(test, moment, 'locale');
                if (lifecycle && lifecycle.setup) {
                    lifecycle.setup();
                }
            },
            teardown : function () {
                moment.locale('en');
                teardownDeprecationHandler(test, moment, 'locale');
                if (lifecycle && lifecycle.teardown) {
                    lifecycle.teardown();
                }
            }
        });
        defineCommonLocaleTests(name, -1, -1);
    }

    localeModule('km');

    test('parse', function (assert) {
        var tests = 'áááá¶ áááá¶_áá»áááá áá»áááá_áá¸áá¶ áá¸áá¶_áááá¶ áááá¶_á§ááá¶ á§ááá¶_áá·áá»áá¶ áá·áá»áá¶_áááááá¶ áááááá¶_áá¸á á¶ áá¸á á¶_ááááá¶ ááááá¶_áá»áá¶ áá»áá¶_áá·áááá·áá¶ áá·áááá·áá¶_áááá¼ áááá¼'.split('_'),
            i;

        function equalTest(input, mmm, i) {
            assert.equal(moment(input, mmm).month(), i, input + ' should be month ' + (i + 1));
        }
        for (i = 0; i < 12; i++) {
            tests[i] = tests[i].split(' ');
            equalTest(tests[i][0], 'MMM', i);
            equalTest(tests[i][1], 'MMM', i);
            equalTest(tests[i][0], 'MMMM', i);
            equalTest(tests[i][1], 'MMMM', i);
            equalTest(tests[i][0].toLocaleLowerCase(), 'MMMM', i);
            equalTest(tests[i][1].toLocaleLowerCase(), 'MMMM', i);
            equalTest(tests[i][0].toLocaleUpperCase(), 'MMMM', i);
            equalTest(tests[i][1].toLocaleUpperCase(), 'MMMM', i);
        }
    });

    test('format', function (assert) {
        var a = [
                ['dddd, MMMM Do YYYY, h:mm:ss a', 'á¢á¶áá·ááá, áá»áááá 14 2010, 3:25:50 pm'],
                ['ddd, hA', 'á¢á¶áá·ááá, 3PM'],
                ['M Mo MM MMMM MMM', '2 2 02 áá»áááá áá»áááá'],
                ['YYYY YY', '2010 10'],
                ['D Do DD', '14 14 14'],
                ['d do dddd ddd dd', '0 0 á¢á¶áá·ááá á¢á¶áá·ááá á¢á¶áá·ááá'],
                ['DDD DDDo DDDD', '45 45 045'],
                ['w wo ww', '6 6 06'],
                ['h hh', '3 03'],
                ['H HH', '15 15'],
                ['m mm', '25 25'],
                ['s ss', '50 50'],
                ['a A', 'pm PM'],
                ['[the] DDDo [day of the year]', 'the 45 day of the year'],
                ['LTS', '15:25:50'],
                ['L', '14/02/2010'],
                ['LL', '14 áá»áááá 2010'],
                ['LLL', '14 áá»áááá 2010 15:25'],
                ['LLLL', 'á¢á¶áá·ááá, 14 áá»áááá 2010 15:25'],
                ['l', '14/2/2010'],
                ['ll', '14 áá»áááá 2010'],
                ['lll', '14 áá»áááá 2010 15:25'],
                ['llll', 'á¢á¶áá·ááá, 14 áá»áááá 2010 15:25']
            ],
            b = moment(new Date(2010, 1, 14, 15, 25, 50, 125)),
            i;
        for (i = 0; i < a.length; i++) {
            assert.equal(b.format(a[i][0]), a[i][1], a[i][0] + ' ---> ' + a[i][1]);
        }
    });

    test('format ordinal', function (assert) {
        assert.equal(moment([2011, 0, 1]).format('DDDo'), '1', '1st');
        assert.equal(moment([2011, 0, 2]).format('DDDo'), '2', '2nd');
        assert.equal(moment([2011, 0, 3]).format('DDDo'), '3', '3rd');
        assert.equal(moment([2011, 0, 4]).format('DDDo'), '4', '4th');
        assert.equal(moment([2011, 0, 5]).format('DDDo'), '5', '5th');
        assert.equal(moment([2011, 0, 6]).format('DDDo'), '6', '6th');
        assert.equal(moment([2011, 0, 7]).format('DDDo'), '7', '7th');
        assert.equal(moment([2011, 0, 8]).format('DDDo'), '8', '8th');
        assert.equal(moment([2011, 0, 9]).format('DDDo'), '9', '9th');
        assert.equal(moment([2011, 0, 10]).format('DDDo'), '10', '10th');

        assert.equal(moment([2011, 0, 11]).format('DDDo'), '11', '11th');
        assert.equal(moment([2011, 0, 12]).format('DDDo'), '12', '12th');
        assert.equal(moment([2011, 0, 13]).format('DDDo'), '13', '13th');
        assert.equal(moment([2011, 0, 14]).format('DDDo'), '14', '14th');
        assert.equal(moment([2011, 0, 15]).format('DDDo'), '15', '15th');
        assert.equal(moment([2011, 0, 16]).format('DDDo'), '16', '16th');
        assert.equal(moment([2011, 0, 17]).format('DDDo'), '17', '17th');
        assert.equal(moment([2011, 0, 18]).format('DDDo'), '18', '18th');
        assert.equal(moment([2011, 0, 19]).format('DDDo'), '19', '19th');
        assert.equal(moment([2011, 0, 20]).format('DDDo'), '20', '20th');

        assert.equal(moment([2011, 0, 21]).format('DDDo'), '21', '21st');
        assert.equal(moment([2011, 0, 22]).format('DDDo'), '22', '22nd');
        assert.equal(moment([2011, 0, 23]).format('DDDo'), '23', '23rd');
        assert.equal(moment([2011, 0, 24]).format('DDDo'), '24', '24th');
        assert.equal(moment([2011, 0, 25]).format('DDDo'), '25', '25th');
        assert.equal(moment([2011, 0, 26]).format('DDDo'), '26', '26th');
        assert.equal(moment([2011, 0, 27]).format('DDDo'), '27', '27th');
        assert.equal(moment([2011, 0, 28]).format('DDDo'), '28', '28th');
        assert.equal(moment([2011, 0, 29]).format('DDDo'), '29', '29th');
        assert.equal(moment([2011, 0, 30]).format('DDDo'), '30', '30th');

        assert.equal(moment([2011, 0, 31]).format('DDDo'), '31', '31st');
    });

    test('format month', function (assert) {
        var expected = 'áááá¶ áááá¶_áá»áááá áá»áááá_áá¸áá¶ áá¸áá¶_áááá¶ áááá¶_á§ááá¶ á§ááá¶_áá·áá»áá¶ áá·áá»áá¶_áááááá¶ áááááá¶_áá¸á á¶ áá¸á á¶_ááááá¶ ááááá¶_áá»áá¶ áá»áá¶_áá·áááá·áá¶ áá·áááá·áá¶_áááá¼ áááá¼'.split('_'),
            i;
        for (i = 0; i < expected.length; i++) {
            assert.equal(moment([2011, i, 1]).format('MMMM MMM'), expected[i], expected[i]);
        }
    });

    test('format week', function (assert) {
        var expected = 'á¢á¶áá·ááá á¢á¶áá·ááá á¢á¶áá·ááá_ááááá ááááá ááááá_á¢áááá¶á á¢áááá¶á á¢áááá¶á_áá»á áá»á áá»á_áááá ááááá·á áááá ááááá·á áááá ááááá·á_áá»ááá áá»ááá áá»ááá_áááá áááá áááá'.split('_'),
            i;
        for (i = 0; i < expected.length; i++) {
            assert.equal(moment([2011, 0, 2 + i]).format('dddd ddd dd'), expected[i], expected[i]);
        }
    });

    test('from', function (assert) {
        var start = moment([2007, 1, 28]);
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 44}), true), 'ááá»áááá¶ááá·áá¶áá¸', '44 seconds = ááá»áááá¶ááá·áá¶áá¸');
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 45}), true), 'áá½ááá¶áá¸', '45 seconds = áá½ááá¶áá¸');
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 89}), true), 'áá½ááá¶áá¸', '89 seconds = áá½ááá¶áá¸');
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 90}), true), '2 áá¶áá¸', '90 seconds = 2 áá¶áá¸');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 44}), true), '44 áá¶áá¸', '44 minutes = 44 áá¶áá¸');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 45}), true), 'áá½ááááá', '45 minutes = áá½ááááá');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 89}), true), 'áá½ááááá', '89 minutes = áá½ááááá');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 90}), true), '2 áááá', '90 minutes = 2 áááá');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 5}), true), '5 áááá', '5 hours = 5 áááá');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 21}), true), '21 áááá', '21 hours = 21 áááá');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 22}), true), 'áá½ááááá', '22 hours = áá½ááááá');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 35}), true), 'áá½ááááá', '35 hours = áá½ááááá');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 36}), true), '2 áááá', '36 hours = 2 áááá');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 1}), true), 'áá½ááááá', '1 day = áá½ááááá');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 5}), true), '5 áááá', '5 days = 5 áááá');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 25}), true), '25 áááá', '25 days = 25 áááá');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 26}), true), 'áá½ááá', '26 days = áá½ááá');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 30}), true), 'áá½ááá', '30 days = áá½ááá');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 43}), true), 'áá½ááá', '43 days = áá½ááá');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 46}), true), '2 áá', '46 days = 2 áá');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 74}), true), '2 áá', '75 days = 2 áá');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 76}), true), '3 áá', '76 days = 3 áá');
        assert.equal(start.from(moment([2007, 1, 28]).add({M: 1}), true), 'áá½ááá', '1 month = áá½ááá');
        assert.equal(start.from(moment([2007, 1, 28]).add({M: 5}), true), '5 áá', '5 months = 5 áá');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 345}), true), 'áá½ááááá¶á', '345 days = áá½ááááá¶á');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 548}), true), '2 áááá¶á', '548 days = 2 áááá¶á');
        assert.equal(start.from(moment([2007, 1, 28]).add({y: 1}), true), 'áá½ááááá¶á', '1 year = áá½ááááá¶á');
        assert.equal(start.from(moment([2007, 1, 28]).add({y: 5}), true), '5 áááá¶á', '5 years = 5 áááá¶á');
    });

    test('suffix', function (assert) {
        assert.equal(moment(30000).from(0), 'ááá»áááá¶ááá·áá¶áá¸ááá', 'prefix');
        assert.equal(moment(0).from(30000), 'ááá»áááá¶ááá·áá¶áá¸áá»á', 'suffix');
    });

    test('now from now', function (assert) {
        assert.equal(moment().fromNow(), 'ááá»áááá¶ááá·áá¶áá¸áá»á', 'now from now should display as in the past');
    });

    test('fromNow', function (assert) {
        assert.equal(moment().add({
            s: 30
        }).fromNow(), 'ááá»áááá¶ááá·áá¶áá¸ááá', 'in a few seconds');
        assert.equal(moment().add({
            d: 5
        }).fromNow(), '5 ááááááá', 'in 5 days');
    });

    test('calendar day', function (assert) {
        var a = moment().hours(12).minutes(0).seconds(0);

        assert.equal(moment(a).calendar(),                  'ááááááá áááá 12:00',  'today at the same time');
        assert.equal(moment(a).add({m: 25}).calendar(),     'ááááááá áááá 12:25',  'Now plus 25 min');
        assert.equal(moment(a).add({h: 1}).calendar(),      'ááááááá áááá 13:00',  'Now plus 1 hour');
        assert.equal(moment(a).add({d: 1}).calendar(),      'ááá¢áá áááá 12:00',    'tomorrow at the same time');
        assert.equal(moment(a).subtract({h: 1}).calendar(), 'ááááááá áááá 11:00',  'Now minus 1 hour');
        assert.equal(moment(a).subtract({d: 1}).calendar(), 'áááá·ááá·á áááá 12:00', 'yesterday at the same time');
    });

    test('calendar next week', function (assert) {
        var i, m;
        for (i = 2; i < 7; i++) {
            m = moment().add({
                d: i
            });
            assert.equal(m.calendar(), m.format('dddd [áááá] LT'), 'Today + ' + i + ' days current time');
            m.hours(0).minutes(0).seconds(0).milliseconds(0);
            assert.equal(m.calendar(), m.format('dddd [áááá] LT'), 'Today + ' + i + ' days beginning of day');
            m.hours(23).minutes(59).seconds(59).milliseconds(999);
            assert.equal(m.calendar(), m.format('dddd [áááá] LT'), 'Today + ' + i + ' days end of day');
        }
    });

    test('calendar last week', function (assert) {
        var i, m;

        for (i = 2; i < 7; i++) {
            m = moment().subtract({
                d: i
            });
            assert.equal(m.calendar(), m.format('dddd [ááááá¶á ááá»á] [áááá] LT'), 'Today - ' + i + ' days current time');
            m.hours(0).minutes(0).seconds(0).milliseconds(0);
            assert.equal(m.calendar(), m.format('dddd [ááááá¶á ááá»á] [áááá] LT'), 'Today - ' + i + ' days beginning of day');
            m.hours(23).minutes(59).seconds(59).milliseconds(999);
            assert.equal(m.calendar(), m.format('dddd [ááááá¶á ááá»á] [áááá] LT'), 'Today - ' + i + ' days end of day');
        }
    });

    test('calendar all else', function (assert) {
        var weeksAgo = moment().subtract({
                w: 1
            }),
            weeksFromNow = moment().add({
                w: 1
            });

        assert.equal(weeksAgo.calendar(), weeksAgo.format('L'), '1 week ago');
        assert.equal(weeksFromNow.calendar(), weeksFromNow.format('L'), 'in 1 week');

        weeksAgo = moment().subtract({
            w: 2
        });
        weeksFromNow = moment().add({
            w: 2
        });

        assert.equal(weeksAgo.calendar(), weeksAgo.format('L'), '2 weeks ago');
        assert.equal(weeksFromNow.calendar(), weeksFromNow.format('L'), 'in 2 weeks');
    });

    test('weeks year starting sunday formatted', function (assert) {
        assert.equal(moment([2012, 0, 1]).format('w ww wo'), '52 52 52', 'Jan  1 2012 should be week 52');
        assert.equal(moment([2012, 0, 2]).format('w ww wo'), '1 01 1', 'Jan  2 2012 should be week 1');
        assert.equal(moment([2012, 0, 8]).format('w ww wo'), '1 01 1', 'Jan  8 2012 should be week 1');
        assert.equal(moment([2012, 0, 9]).format('w ww wo'), '2 02 2', 'Jan  9 2012 should be week 2');
        assert.equal(moment([2012, 0, 15]).format('w ww wo'), '2 02 2', 'Jan 15 2012 should be week 2');
    });

}));

;(function (global, factory) {
   typeof exports === 'object' && typeof module !== 'undefined'
       && typeof require === 'function' ? factory(require('../../moment')) :
   typeof define === 'function' && define.amd ? define(['../../moment'], factory) :
   factory(global.moment)
}(this, function (moment) { 'use strict';

    function each(array, callback) {
        var i;
        for (i = 0; i < array.length; i++) {
            callback(array[i], i, array);
        }
    }

    function objectKeys(obj) {
        if (Object.keys) {
            return Object.keys(obj);
        } else {
            // IE8
            var res = [], i;
            for (i in obj) {
                if (obj.hasOwnProperty(i)) {
                    res.push(i);
                }
            }
            return res;
        }
    }

    // Pick the first defined of two or three arguments.
    function defaults(a, b, c) {
        if (a != null) {
            return a;
        }
        if (b != null) {
            return b;
        }
        return c;
    }

    function defineCommonLocaleTests(locale, options) {
        test('lenient ordinal parsing', function (assert) {
            var i, ordinalStr, testMoment;
            for (i = 1; i <= 31; ++i) {
                ordinalStr = moment([2014, 0, i]).format('YYYY MM Do');
                testMoment = moment(ordinalStr, 'YYYY MM Do');
                assert.equal(testMoment.year(), 2014,
                        'lenient ordinal parsing ' + i + ' year check');
                assert.equal(testMoment.month(), 0,
                        'lenient ordinal parsing ' + i + ' month check');
                assert.equal(testMoment.date(), i,
                        'lenient ordinal parsing ' + i + ' date check');
            }
        });

        test('lenient ordinal parsing of number', function (assert) {
            var i, testMoment;
            for (i = 1; i <= 31; ++i) {
                testMoment = moment('2014 01 ' + i, 'YYYY MM Do');
                assert.equal(testMoment.year(), 2014,
                        'lenient ordinal parsing of number ' + i + ' year check');
                assert.equal(testMoment.month(), 0,
                        'lenient ordinal parsing of number ' + i + ' month check');
                assert.equal(testMoment.date(), i,
                        'lenient ordinal parsing of number ' + i + ' date check');
            }
        });

        test('strict ordinal parsing', function (assert) {
            var i, ordinalStr, testMoment;
            for (i = 1; i <= 31; ++i) {
                ordinalStr = moment([2014, 0, i]).format('YYYY MM Do');
                testMoment = moment(ordinalStr, 'YYYY MM Do', true);
                assert.ok(testMoment.isValid(), 'strict ordinal parsing ' + i);
            }
        });

        test('meridiem invariant', function (assert) {
            var h, m, t1, t2;
            for (h = 0; h < 24; ++h) {
                for (m = 0; m < 60; m += 15) {
                    t1 = moment.utc([2000, 0, 1, h, m]);
                    t2 = moment.utc(t1.format('A h:mm'), 'A h:mm');
                    assert.equal(t2.format('HH:mm'), t1.format('HH:mm'),
                            'meridiem at ' + t1.format('HH:mm'));
                }
            }
        });

        test('date format correctness', function (assert) {
            var data, tokens;
            data = moment.localeData()._longDateFormat;
            tokens = objectKeys(data);
            each(tokens, function (srchToken) {
                // Check each format string to make sure it does not contain any
                // tokens that need to be expanded.
                each(tokens, function (baseToken) {
                    // strip escaped sequences
                    var format = data[baseToken].replace(/(\[[^\]]*\])/g, '');
                    assert.equal(false, !!~format.indexOf(srchToken),
                            'contains ' + srchToken + ' in ' + baseToken);
                });
            });
        });

        test('month parsing correctness', function (assert) {
            var i, m;

            if (locale === 'tr') {
                // I can't fix it :(
                expect(0);
                return;
            }
            function tester(format) {
                var r;
                r = moment(m.format(format), format);
                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format);
                r = moment(m.format(format).toLocaleUpperCase(), format);
                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' upper');
                r = moment(m.format(format).toLocaleLowerCase(), format);
                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' lower');

                r = moment(m.format(format), format, true);
                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' strict');
                r = moment(m.format(format).toLocaleUpperCase(), format, true);
                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' upper strict');
                r = moment(m.format(format).toLocaleLowerCase(), format, true);
                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' lower strict');
            }

            for (i = 0; i < 12; ++i) {
                m = moment([2015, i, 15, 18]);
                tester('MMM');
                tester('MMM.');
                tester('MMMM');
                tester('MMMM.');
            }
        });

        test('weekday parsing correctness', function (assert) {
            var i, m;

            if (locale === 'tr' || locale === 'az') {
                // There is a lower-case letter (Ä±), that converted to upper then
                // lower changes to i
                expect(0);
                return;
            }
            function tester(format) {
                var r, baseMsg = 'weekday ' + m.weekday() + ' fmt ' + format;
                r = moment(m.format(format), format);
                assert.equal(r.weekday(), m.weekday(), baseMsg);
                r = moment(m.format(format).toLocaleUpperCase(), format);
                assert.equal(r.weekday(), m.weekday(), baseMsg + ' upper');
                r = moment(m.format(format).toLocaleLowerCase(), format);
                assert.equal(r.weekday(), m.weekday(), baseMsg + ' lower');

                r = moment(m.format(format), format, true);
                assert.equal(r.weekday(), m.weekday(), baseMsg + ' strict');
                r = moment(m.format(format).toLocaleUpperCase(), format, true);
                assert.equal(r.weekday(), m.weekday(), baseMsg + ' upper strict');
                r = moment(m.format(format).toLocaleLowerCase(), format, true);
                assert.equal(r.weekday(), m.weekday(), baseMsg + ' lower strict');
            }

            for (i = 0; i < 7; ++i) {
                m = moment.utc([2015, i, 15, 18]);
                tester('dd');
                tester('ddd');
                tester('dddd');
            }
        });
    }

    function setupDeprecationHandler(test, moment, scope) {
        test._expectedDeprecations = null;
        test._observedDeprecations = null;
        test._oldSupress = moment.suppressDeprecationWarnings;
        moment.suppressDeprecationWarnings = true;
        test.expectedDeprecations = function () {
            test._expectedDeprecations = arguments;
            test._observedDeprecations = [];
        };
        moment.deprecationHandler = function (name, msg) {
            var deprecationId = matchedDeprecation(name, msg, test._expectedDeprecations);
            if (deprecationId === -1) {
                throw new Error('Unexpected deprecation thrown name=' +
                        name + ' msg=' + msg);
            }
            test._observedDeprecations[deprecationId] = 1;
        };
    }

    function teardownDeprecationHandler(test, moment, scope) {
        moment.suppressDeprecationWarnings = test._oldSupress;

        if (test._expectedDeprecations != null) {
            var missedDeprecations = [];
            each(test._expectedDeprecations, function (deprecationPattern, id) {
                if (test._observedDeprecations[id] !== 1) {
                    missedDeprecations.push(deprecationPattern);
                }
            });
            if (missedDeprecations.length !== 0) {
                throw new Error('Expected deprecation warnings did not happen: ' +
                        missedDeprecations.join(' '));
            }
        }
    }

    function matchedDeprecation(name, msg, deprecations) {
        if (deprecations == null) {
            return -1;
        }
        for (var i = 0; i < deprecations.length; ++i) {
            if (name != null && name === deprecations[i]) {
                return i;
            }
            if (msg != null && msg.substring(0, deprecations[i].length) === deprecations[i]) {
                return i;
            }
        }
        return -1;
    }

    /*global QUnit:false*/

    var test = QUnit.test;

    var expect = QUnit.expect;

    function module (name, lifecycle) {
        QUnit.module(name, {
            setup : function () {
                moment.locale('en');
                moment.createFromInputFallback = function (config) {
                    throw new Error('input not handled by moment: ' + config._i);
                };
                setupDeprecationHandler(test, moment, 'core');
                if (lifecycle && lifecycle.setup) {
                    lifecycle.setup();
                }
            },
            teardown : function () {
                teardownDeprecationHandler(test, moment, 'core');
                if (lifecycle && lifecycle.teardown) {
                    lifecycle.teardown();
                }
            }
        });
    }

    function localeModule (name, lifecycle) {
        QUnit.module('locale:' + name, {
            setup : function () {
                moment.locale(name);
                moment.createFromInputFallback = function (config) {
                    throw new Error('input not handled by moment: ' + config._i);
                };
                setupDeprecationHandler(test, moment, 'locale');
                if (lifecycle && lifecycle.setup) {
                    lifecycle.setup();
                }
            },
            teardown : function () {
                moment.locale('en');
                teardownDeprecationHandler(test, moment, 'locale');
                if (lifecycle && lifecycle.teardown) {
                    lifecycle.teardown();
                }
            }
        });
        defineCommonLocaleTests(name, -1, -1);
    }

    localeModule('ko');

    test('parse', function (assert) {
        var tests = '1ì 1ì_2ì 2ì_3ì 3ì_4ì 4ì_5ì 5ì_6ì 6ì_7ì 7ì_8ì 8ì_9ì 9ì_10ì 10ì_11ì 11ì_12ì 12ì'.split('_'), i;
        function equalTest(input, mmm, i) {
            assert.equal(moment(input, mmm).month(), i, input + ' should be month ' + (i + 1));
        }
        for (i = 0; i < 12; i++) {
            tests[i] = tests[i].split(' ');
            equalTest(tests[i][0], 'MMM', i);
            equalTest(tests[i][1], 'MMM', i);
            equalTest(tests[i][0], 'MMMM', i);
            equalTest(tests[i][1], 'MMMM', i);
            equalTest(tests[i][0].toLocaleLowerCase(), 'MMMM', i);
            equalTest(tests[i][1].toLocaleLowerCase(), 'MMMM', i);
            equalTest(tests[i][0].toLocaleUpperCase(), 'MMMM', i);
            equalTest(tests[i][1].toLocaleUpperCase(), 'MMMM', i);
        }
    });

    test('parse meridiem', function (assert) {
        var elements = [{
            expression : '1981ë 9ì 8ì¼ ì¤í 2ì 30ë¶',
            inputFormat : 'YYYY[ë] M[ì] D[ì¼] A h[ì] m[ë¶]',
            outputFormat : 'A',
            expected : 'ì¤í'
        }, {
            expression : '1981ë 9ì 8ì¼ ì¤ì  2ì 30ë¶',
            inputFormat : 'YYYY[ë] M[ì] D[ì¼] A h[ì] m[ë¶]',
            outputFormat : 'A hì',
            expected : 'ì¤ì  2ì'
        }, {
            expression : '14ì 30ë¶',
            inputFormat : 'H[ì] m[ë¶]',
            outputFormat : 'A',
            expected : 'ì¤í'
        }, {
            expression : 'ì¤í 4ì',
            inputFormat : 'A h[ì]',
            outputFormat : 'H',
            expected : '16'
        }], i, l, it, actual;

        for (i = 0, l = elements.length; i < l; ++i) {
            it = elements[i];
            actual = moment(it.expression, it.inputFormat).format(it.outputFormat);

            assert.equal(
                actual,
                it.expected,
                '\'' + it.outputFormat + '\' of \'' + it.expression + '\' must be \'' + it.expected + '\' but was \'' + actual + '\'.'
            );
        }
    });

    test('format', function (assert) {
        var a = [
                ['YYYYë MMMM Do dddd a h:mm:ss',      '2010ë 2ì 14ì¼ ì¼ìì¼ ì¤í 3:25:50'],
                ['ddd A h',                            'ì¼ ì¤í 3'],
                ['M Mo MM MMMM MMM',                   '2 2ì¼ 02 2ì 2ì'],
                ['YYYY YY',                            '2010 10'],
                ['D Do DD',                            '14 14ì¼ 14'],
                ['d do dddd ddd dd',                   '0 0ì¼ ì¼ìì¼ ì¼ ì¼'],
                ['DDD DDDo DDDD',                      '45 45ì¼ 045'],
                ['w wo ww',                            '8 8ì¼ 08'],
                ['h hh',                               '3 03'],
                ['H HH',                               '15 15'],
                ['m mm',                               '25 25'],
                ['s ss',                               '50 50'],
                ['a A',                                'ì¤í ì¤í'],
                ['ì¼ë ì¤ DDDoì§¸ ëë ë ',                 'ì¼ë ì¤ 45ì¼ì§¸ ëë ë '],
                ['LTS',                                'ì¤í 3ì 25ë¶ 50ì´'],
                ['L',                                  '2010.02.14'],
                ['LL',                                 '2010ë 2ì 14ì¼'],
                ['LLL',                                '2010ë 2ì 14ì¼ ì¤í 3ì 25ë¶'],
                ['LLLL',                               '2010ë 2ì 14ì¼ ì¼ìì¼ ì¤í 3ì 25ë¶'],
                ['l',                                  '2010.2.14'],
                ['ll',                                 '2010ë 2ì 14ì¼'],
                ['lll',                                '2010ë 2ì 14ì¼ ì¤í 3ì 25ë¶'],
                ['llll',                               '2010ë 2ì 14ì¼ ì¼ ì¤í 3ì 25ë¶']
            ],
            b = moment(new Date(2010, 1, 14, 15, 25, 50, 125)),
            i;
        for (i = 0; i < a.length; i++) {
            assert.equal(b.format(a[i][0]), a[i][1], a[i][0] + ' ---> ' + a[i][1]);
        }
    });

    test('format ordinal', function (assert) {
        assert.equal(moment([2011, 0, 1]).format('DDDo'), '1ì¼', '1ì¼');
        assert.equal(moment([2011, 0, 2]).format('DDDo'), '2ì¼', '2ì¼');
        assert.equal(moment([2011, 0, 3]).format('DDDo'), '3ì¼', '3ì¼');
        assert.equal(moment([2011, 0, 4]).format('DDDo'), '4ì¼', '4ì¼');
        assert.equal(moment([2011, 0, 5]).format('DDDo'), '5ì¼', '5ì¼');
        assert.equal(moment([2011, 0, 6]).format('DDDo'), '6ì¼', '6ì¼');
        assert.equal(moment([2011, 0, 7]).format('DDDo'), '7ì¼', '7ì¼');
        assert.equal(moment([2011, 0, 8]).format('DDDo'), '8ì¼', '8ì¼');
        assert.equal(moment([2011, 0, 9]).format('DDDo'), '9ì¼', '9ì¼');
        assert.equal(moment([2011, 0, 10]).format('DDDo'), '10ì¼', '10ì¼');

        assert.equal(moment([2011, 0, 11]).format('DDDo'), '11ì¼', '11ì¼');
        assert.equal(moment([2011, 0, 12]).format('DDDo'), '12ì¼', '12ì¼');
        assert.equal(moment([2011, 0, 13]).format('DDDo'), '13ì¼', '13ì¼');
        assert.equal(moment([2011, 0, 14]).format('DDDo'), '14ì¼', '14ì¼');
        assert.equal(moment([2011, 0, 15]).format('DDDo'), '15ì¼', '15ì¼');
        assert.equal(moment([2011, 0, 16]).format('DDDo'), '16ì¼', '16ì¼');
        assert.equal(moment([2011, 0, 17]).format('DDDo'), '17ì¼', '17ì¼');
        assert.equal(moment([2011, 0, 18]).format('DDDo'), '18ì¼', '18ì¼');
        assert.equal(moment([2011, 0, 19]).format('DDDo'), '19ì¼', '19ì¼');
        assert.equal(moment([2011, 0, 20]).format('DDDo'), '20ì¼', '20ì¼');

        assert.equal(moment([2011, 0, 21]).format('DDDo'), '21ì¼', '21ì¼');
        assert.equal(moment([2011, 0, 22]).format('DDDo'), '22ì¼', '22ì¼');
        assert.equal(moment([2011, 0, 23]).format('DDDo'), '23ì¼', '23ì¼');
        assert.equal(moment([2011, 0, 24]).format('DDDo'), '24ì¼', '24ì¼');
        assert.equal(moment([2011, 0, 25]).format('DDDo'), '25ì¼', '25ì¼');
        assert.equal(moment([2011, 0, 26]).format('DDDo'), '26ì¼', '26ì¼');
        assert.equal(moment([2011, 0, 27]).format('DDDo'), '27ì¼', '27ì¼');
        assert.equal(moment([2011, 0, 28]).format('DDDo'), '28ì¼', '28ì¼');
        assert.equal(moment([2011, 0, 29]).format('DDDo'), '29ì¼', '29ì¼');
        assert.equal(moment([2011, 0, 30]).format('DDDo'), '30ì¼', '30ì¼');

        assert.equal(moment([2011, 0, 31]).format('DDDo'), '31ì¼', '31ì¼');
    });

    test('format month', function (assert) {
        var expected = '1ì 1ì_2ì 2ì_3ì 3ì_4ì 4ì_5ì 5ì_6ì 6ì_7ì 7ì_8ì 8ì_9ì 9ì_10ì 10ì_11ì 11ì_12ì 12ì'.split('_'), i;
        for (i = 0; i < expected.length; i++) {
            assert.equal(moment([2011, i, 1]).format('MMMM MMM'), expected[i], expected[i]);
        }
    });

    test('format week', function (assert) {
        var expected = 'ì¼ìì¼ ì¼ ì¼_ììì¼ ì ì_íìì¼ í í_ììì¼ ì ì_ëª©ìì¼ ëª© ëª©_ê¸ìì¼ ê¸ ê¸_í ìì¼ í  í '.split('_'), i;
        for (i = 0; i < expected.length; i++) {
            assert.equal(moment([2011, 0, 2 + i]).format('dddd ddd dd'), expected[i], expected[i]);
        }
    });

    test('from', function (assert) {
        var start = moment([2007, 1, 28]);
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 44}), true),  'ëª ì´', '44ì´ = ëª ì´');
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 45}), true),  'ì¼ë¶',      '45ì´ = ì¼ë¶');
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 89}), true),  'ì¼ë¶',      '89ì´ = ì¼ë¶');
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 90}), true),  '2ë¶',     '90ì´ = 2ë¶');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 44}), true),  '44ë¶',    '44ë¶ = 44ë¶');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 45}), true),  'í ìê°',       '45ë¶ = í ìê°');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 89}), true),  'í ìê°',       '89ë¶ = í ìê°');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 90}), true),  '2ìê°',       '90ë¶ = 2ìê°');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 5}), true),   '5ìê°',       '5ìê° = 5ìê°');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 21}), true),  '21ìê°',      '21ìê° = 21ìê°');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 22}), true),  'íë£¨',         '22ìê° = íë£¨');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 35}), true),  'íë£¨',         '35ìê° = íë£¨');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 36}), true),  '2ì¼',        '36ìê° = 2ì¼');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 1}), true),   'íë£¨',         'íë£¨ = íë£¨');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 5}), true),   '5ì¼',        '5ì¼ = 5ì¼');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 25}), true),  '25ì¼',       '25ì¼ = 25ì¼');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 26}), true),  'í ë¬',       '26ì¼ = í ë¬');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 30}), true),  'í ë¬',       '30ì¼ = í ë¬');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 43}), true),  'í ë¬',       '45ì¼ = í ë¬');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 46}), true),  '2ë¬',      '46ì¼ = 2ë¬');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 74}), true),  '2ë¬',      '75ì¼ = 2ë¬');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 76}), true),  '3ë¬',      '76ì¼ = 3ë¬');
        assert.equal(start.from(moment([2007, 1, 28]).add({M: 1}), true),   'í ë¬',       '1ë¬ = í ë¬');
        assert.equal(start.from(moment([2007, 1, 28]).add({M: 5}), true),   '5ë¬',      '5ë¬ = 5ë¬');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 345}), true), 'ì¼ ë',        '345ì¼ = ì¼ ë');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 548}), true), '2ë',       '548ì¼ = 2ë');
        assert.equal(start.from(moment([2007, 1, 28]).add({y: 1}), true),   'ì¼ ë',        'ì¼ ë = ì¼ ë');
        assert.equal(start.from(moment([2007, 1, 28]).add({y: 5}), true),   '5ë',       '5ë = 5ë');
    });

    test('suffix', function (assert) {
        assert.equal(moment(30000).from(0), 'ëª ì´ í',  'prefix');
        assert.equal(moment(0).from(30000), 'ëª ì´ ì ', 'suffix');
    });

    test('now from now', function (assert) {
        assert.equal(moment().fromNow(), 'ëª ì´ ì ',  'now from now should display as in the past');
    });

    test('fromNow', function (assert) {
        assert.equal(moment().add({s: 30}).fromNow(), 'ëª ì´ í', 'in a few seconds');
        assert.equal(moment().add({d: 5}).fromNow(), '5ì¼ í', 'in 5 days');
    });

    test('calendar day', function (assert) {
        var a = moment().hours(12).minutes(0).seconds(0);

        assert.equal(moment(a).calendar(),                   'ì¤ë ì¤í 12ì 0ë¶',     'today at the same time');
        assert.equal(moment(a).add({m: 25}).calendar(),      'ì¤ë ì¤í 12ì 25ë¶',    'Now plus 25 min');
        assert.equal(moment(a).add({h: 1}).calendar(),       'ì¤ë ì¤í 1ì 0ë¶',      'Now plus 1 hour');
        assert.equal(moment(a).add({d: 1}).calendar(),       'ë´ì¼ ì¤í 12ì 0ë¶',     'tomorrow at the same time');
        assert.equal(moment(a).subtract({h: 1}).calendar(),  'ì¤ë ì¤ì  11ì 0ë¶',     'Now minus 1 hour');
        assert.equal(moment(a).subtract({d: 1}).calendar(),  'ì´ì  ì¤í 12ì 0ë¶',     'yesterday at the same time');
    });

    test('calendar next week', function (assert) {
        var i, m;
        for (i = 2; i < 7; i++) {
            m = moment().add({d: i});
            assert.equal(m.calendar(),       m.format('dddd LT'),  'Today + ' + i + ' days current time');
            m.hours(0).minutes(0).seconds(0).milliseconds(0);
            assert.equal(m.calendar(),       m.format('dddd LT'),  'Today + ' + i + ' days beginning of day');
            m.hours(23).minutes(59).seconds(59).milliseconds(999);
            assert.equal(m.calendar(),       m.format('dddd LT'),  'Today + ' + i + ' days end of day');
        }
    });

    test('calendar last week', function (assert) {
        var i, m;
        for (i = 2; i < 7; i++) {
            m = moment().subtract({d: i});
            assert.equal(m.calendar(),       m.format('ì§ëì£¼ dddd LT'),  'Today - ' + i + ' days current time');
            m.hours(0).minutes(0).seconds(0).milliseconds(0);
            assert.equal(m.calendar(),       m.format('ì§ëì£¼ dddd LT'),  'Today - ' + i + ' days beginning of day');
            m.hours(23).minutes(59).seconds(59).milliseconds(999);
            assert.equal(m.calendar(),       m.format('ì§ëì£¼ dddd LT'),  'Today - ' + i + ' days end of day');
        }
    });

    test('calendar all else', function (assert) {
        var weeksAgo = moment().subtract({w: 1}),
            weeksFromNow = moment().add({w: 1});

        assert.equal(weeksAgo.calendar(),       weeksAgo.format('L'),  '1 week ago');
        assert.equal(weeksFromNow.calendar(),   weeksFromNow.format('L'),  'in 1 week');

        weeksAgo = moment().subtract({w: 2});
        weeksFromNow = moment().add({w: 2});

        assert.equal(weeksAgo.calendar(),       weeksAgo.format('L'),  '2 weeks ago');
        assert.equal(weeksFromNow.calendar(),   weeksFromNow.format('L'),  'in 2 weeks');
    });

    test('weeks year starting sunday format', function (assert) {
        assert.equal(moment([2012, 0,  1]).format('w ww wo'), '1 01 1ì¼', 'Jan  1 2012 should be week 1');
        assert.equal(moment([2012, 0,  7]).format('w ww wo'), '1 01 1ì¼', 'Jan  7 2012 should be week 1');
        assert.equal(moment([2012, 0,  8]).format('w ww wo'), '2 02 2ì¼', 'Jan  8 2012 should be week 2');
        assert.equal(moment([2012, 0, 14]).format('w ww wo'), '2 02 2ì¼', 'Jan 14 2012 should be week 2');
        assert.equal(moment([2012, 0, 15]).format('w ww wo'), '3 03 3ì¼', 'Jan 15 2012 should be week 3');
    });

}));

;(function (global, factory) {
   typeof exports === 'object' && typeof module !== 'undefined'
       && typeof require === 'function' ? factory(require('../../moment')) :
   typeof define === 'function' && define.amd ? define(['../../moment'], factory) :
   factory(global.moment)
}(this, function (moment) { 'use strict';

    function each(array, callback) {
        var i;
        for (i = 0; i < array.length; i++) {
            callback(array[i], i, array);
        }
    }

    function objectKeys(obj) {
        if (Object.keys) {
            return Object.keys(obj);
        } else {
            // IE8
            var res = [], i;
            for (i in obj) {
                if (obj.hasOwnProperty(i)) {
                    res.push(i);
                }
            }
            return res;
        }
    }

    // Pick the first defined of two or three arguments.
    function defaults(a, b, c) {
        if (a != null) {
            return a;
        }
        if (b != null) {
            return b;
        }
        return c;
    }

    function defineCommonLocaleTests(locale, options) {
        test('lenient ordinal parsing', function (assert) {
            var i, ordinalStr, testMoment;
            for (i = 1; i <= 31; ++i) {
                ordinalStr = moment([2014, 0, i]).format('YYYY MM Do');
                testMoment = moment(ordinalStr, 'YYYY MM Do');
                assert.equal(testMoment.year(), 2014,
                        'lenient ordinal parsing ' + i + ' year check');
                assert.equal(testMoment.month(), 0,
                        'lenient ordinal parsing ' + i + ' month check');
                assert.equal(testMoment.date(), i,
                        'lenient ordinal parsing ' + i + ' date check');
            }
        });

        test('lenient ordinal parsing of number', function (assert) {
            var i, testMoment;
            for (i = 1; i <= 31; ++i) {
                testMoment = moment('2014 01 ' + i, 'YYYY MM Do');
                assert.equal(testMoment.year(), 2014,
                        'lenient ordinal parsing of number ' + i + ' year check');
                assert.equal(testMoment.month(), 0,
                        'lenient ordinal parsing of number ' + i + ' month check');
                assert.equal(testMoment.date(), i,
                        'lenient ordinal parsing of number ' + i + ' date check');
            }
        });

        test('strict ordinal parsing', function (assert) {
            var i, ordinalStr, testMoment;
            for (i = 1; i <= 31; ++i) {
                ordinalStr = moment([2014, 0, i]).format('YYYY MM Do');
                testMoment = moment(ordinalStr, 'YYYY MM Do', true);
                assert.ok(testMoment.isValid(), 'strict ordinal parsing ' + i);
            }
        });

        test('meridiem invariant', function (assert) {
            var h, m, t1, t2;
            for (h = 0; h < 24; ++h) {
                for (m = 0; m < 60; m += 15) {
                    t1 = moment.utc([2000, 0, 1, h, m]);
                    t2 = moment.utc(t1.format('A h:mm'), 'A h:mm');
                    assert.equal(t2.format('HH:mm'), t1.format('HH:mm'),
                            'meridiem at ' + t1.format('HH:mm'));
                }
            }
        });

        test('date format correctness', function (assert) {
            var data, tokens;
            data = moment.localeData()._longDateFormat;
            tokens = objectKeys(data);
            each(tokens, function (srchToken) {
                // Check each format string to make sure it does not contain any
                // tokens that need to be expanded.
                each(tokens, function (baseToken) {
                    // strip escaped sequences
                    var format = data[baseToken].replace(/(\[[^\]]*\])/g, '');
                    assert.equal(false, !!~format.indexOf(srchToken),
                            'contains ' + srchToken + ' in ' + baseToken);
                });
            });
        });

        test('month parsing correctness', function (assert) {
            var i, m;

            if (locale === 'tr') {
                // I can't fix it :(
                expect(0);
                return;
            }
            function tester(format) {
                var r;
                r = moment(m.format(format), format);
                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format);
                r = moment(m.format(format).toLocaleUpperCase(), format);
                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' upper');
                r = moment(m.format(format).toLocaleLowerCase(), format);
                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' lower');

                r = moment(m.format(format), format, true);
                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' strict');
                r = moment(m.format(format).toLocaleUpperCase(), format, true);
                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' upper strict');
                r = moment(m.format(format).toLocaleLowerCase(), format, true);
                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' lower strict');
            }

            for (i = 0; i < 12; ++i) {
                m = moment([2015, i, 15, 18]);
                tester('MMM');
                tester('MMM.');
                tester('MMMM');
                tester('MMMM.');
            }
        });

        test('weekday parsing correctness', function (assert) {
            var i, m;

            if (locale === 'tr' || locale === 'az') {
                // There is a lower-case letter (Ä±), that converted to upper then
                // lower changes to i
                expect(0);
                return;
            }
            function tester(format) {
                var r, baseMsg = 'weekday ' + m.weekday() + ' fmt ' + format;
                r = moment(m.format(format), format);
                assert.equal(r.weekday(), m.weekday(), baseMsg);
                r = moment(m.format(format).toLocaleUpperCase(), format);
                assert.equal(r.weekday(), m.weekday(), baseMsg + ' upper');
                r = moment(m.format(format).toLocaleLowerCase(), format);
                assert.equal(r.weekday(), m.weekday(), baseMsg + ' lower');

                r = moment(m.format(format), format, true);
                assert.equal(r.weekday(), m.weekday(), baseMsg + ' strict');
                r = moment(m.format(format).toLocaleUpperCase(), format, true);
                assert.equal(r.weekday(), m.weekday(), baseMsg + ' upper strict');
                r = moment(m.format(format).toLocaleLowerCase(), format, true);
                assert.equal(r.weekday(), m.weekday(), baseMsg + ' lower strict');
            }

            for (i = 0; i < 7; ++i) {
                m = moment.utc([2015, i, 15, 18]);
                tester('dd');
                tester('ddd');
                tester('dddd');
            }
        });
    }

    function setupDeprecationHandler(test, moment, scope) {
        test._expectedDeprecations = null;
        test._observedDeprecations = null;
        test._oldSupress = moment.suppressDeprecationWarnings;
        moment.suppressDeprecationWarnings = true;
        test.expectedDeprecations = function () {
            test._expectedDeprecations = arguments;
            test._observedDeprecations = [];
        };
        moment.deprecationHandler = function (name, msg) {
            var deprecationId = matchedDeprecation(name, msg, test._expectedDeprecations);
            if (deprecationId === -1) {
                throw new Error('Unexpected deprecation thrown name=' +
                        name + ' msg=' + msg);
            }
            test._observedDeprecations[deprecationId] = 1;
        };
    }

    function teardownDeprecationHandler(test, moment, scope) {
        moment.suppressDeprecationWarnings = test._oldSupress;

        if (test._expectedDeprecations != null) {
            var missedDeprecations = [];
            each(test._expectedDeprecations, function (deprecationPattern, id) {
                if (test._observedDeprecations[id] !== 1) {
                    missedDeprecations.push(deprecationPattern);
                }
            });
            if (missedDeprecations.length !== 0) {
                throw new Error('Expected deprecation warnings did not happen: ' +
                        missedDeprecations.join(' '));
            }
        }
    }

    function matchedDeprecation(name, msg, deprecations) {
        if (deprecations == null) {
            return -1;
        }
        for (var i = 0; i < deprecations.length; ++i) {
            if (name != null && name === deprecations[i]) {
                return i;
            }
            if (msg != null && msg.substring(0, deprecations[i].length) === deprecations[i]) {
                return i;
            }
        }
        return -1;
    }

    /*global QUnit:false*/

    var test = QUnit.test;

    var expect = QUnit.expect;

    function module (name, lifecycle) {
        QUnit.module(name, {
            setup : function () {
                moment.locale('en');
                moment.createFromInputFallback = function (config) {
                    throw new Error('input not handled by moment: ' + config._i);
                };
                setupDeprecationHandler(test, moment, 'core');
                if (lifecycle && lifecycle.setup) {
                    lifecycle.setup();
                }
            },
            teardown : function () {
                teardownDeprecationHandler(test, moment, 'core');
                if (lifecycle && lifecycle.teardown) {
                    lifecycle.teardown();
                }
            }
        });
    }

    function localeModule (name, lifecycle) {
        QUnit.module('locale:' + name, {
            setup : function () {
                moment.locale(name);
                moment.createFromInputFallback = function (config) {
                    throw new Error('input not handled by moment: ' + config._i);
                };
                setupDeprecationHandler(test, moment, 'locale');
                if (lifecycle && lifecycle.setup) {
                    lifecycle.setup();
                }
            },
            teardown : function () {
                moment.locale('en');
                teardownDeprecationHandler(test, moment, 'locale');
                if (lifecycle && lifecycle.teardown) {
                    lifecycle.teardown();
                }
            }
        });
        defineCommonLocaleTests(name, -1, -1);
    }

    localeModule('ky');

    test('parse', function (assert) {
        var tests = 'ÑÐ½Ð²Ð°ÑÑ ÑÐ½Ð²_ÑÐµÐ²ÑÐ°Ð»Ñ ÑÐµÐ²_Ð¼Ð°ÑÑ Ð¼Ð°ÑÑ_Ð°Ð¿ÑÐµÐ»Ñ Ð°Ð¿Ñ_Ð¼Ð°Ð¹ Ð¼Ð°Ð¹_Ð¸ÑÐ½Ñ Ð¸ÑÐ½Ñ_Ð¸ÑÐ»Ñ Ð¸ÑÐ»Ñ_Ð°Ð²Ð³ÑÑÑ Ð°Ð²Ð³_ÑÐµÐ½ÑÑÐ±ÑÑ ÑÐµÐ½_Ð¾ÐºÑÑÐ±ÑÑ Ð¾ÐºÑ_Ð½Ð¾ÑÐ±ÑÑ Ð½Ð¾Ñ_Ð´ÐµÐºÐ°Ð±ÑÑ Ð´ÐµÐº'.split('_'), i;
        function equalTest(input, mmm, i) {
            assert.equal(moment(input, mmm).month(), i, input + ' should be month ' + (i + 1));
        }
        for (i = 0; i < 12; i++) {
            tests[i] = tests[i].split(' ');
            equalTest(tests[i][0], 'MMM', i);
            equalTest(tests[i][1], 'MMM', i);
            equalTest(tests[i][0], 'MMMM', i);
            equalTest(tests[i][1], 'MMMM', i);
            equalTest(tests[i][0].toLocaleLowerCase(), 'MMMM', i);
            equalTest(tests[i][1].toLocaleLowerCase(), 'MMMM', i);
            equalTest(tests[i][0].toLocaleUpperCase(), 'MMMM', i);
            equalTest(tests[i][1].toLocaleUpperCase(), 'MMMM', i);
        }
    });

    test('format', function (assert) {
        var a = [
                ['dddd, Do MMMM YYYY, HH:mm:ss',       'ÐÐµÐºÑÐµÐ¼Ð±Ð¸, 14-ÑÒ¯ ÑÐµÐ²ÑÐ°Ð»Ñ 2010, 15:25:50'],
                ['ddd, hA',                            'ÐÐµÐº, 3PM'],
                ['M Mo MM MMMM MMM',                   '2 2-ÑÐ¸ 02 ÑÐµÐ²ÑÐ°Ð»Ñ ÑÐµÐ²'],
                ['YYYY YY',                            '2010 10'],
                ['D Do DD',                            '14 14-ÑÒ¯ 14'],
                ['d do dddd ddd dd',                   '0 0-ÑÒ¯ ÐÐµÐºÑÐµÐ¼Ð±Ð¸ ÐÐµÐº ÐÐº'],
                ['DDD DDDo DDDD',                      '45 45-ÑÐ¸ 045'],
                ['w wo ww',                            '7 7-ÑÐ¸ 07'],
                ['h hh',                               '3 03'],
                ['H HH',                               '15 15'],
                ['m mm',                               '25 25'],
                ['s ss',                               '50 50'],
                ['a A',                                'pm PM'],
                ['[Ð¶ÑÐ»Ð´ÑÐ½] DDDo [ÐºÒ¯Ð½Ò¯]',               'Ð¶ÑÐ»Ð´ÑÐ½ 45-ÑÐ¸ ÐºÒ¯Ð½Ò¯'],
                ['LTS',                                '15:25:50'],
                ['L',                                  '14.02.2010'],
                ['LL',                                 '14 ÑÐµÐ²ÑÐ°Ð»Ñ 2010'],
                ['LLL',                                '14 ÑÐµÐ²ÑÐ°Ð»Ñ 2010 15:25'],
                ['LLLL',                               'ÐÐµÐºÑÐµÐ¼Ð±Ð¸, 14 ÑÐµÐ²ÑÐ°Ð»Ñ 2010 15:25'],
                ['l',                                  '14.2.2010'],
                ['ll',                                 '14 ÑÐµÐ² 2010'],
                ['lll',                                '14 ÑÐµÐ² 2010 15:25'],
                ['llll',                               'ÐÐµÐº, 14 ÑÐµÐ² 2010 15:25']
            ],
            b = moment(new Date(2010, 1, 14, 15, 25, 50, 125)),
            i;
        for (i = 0; i < a.length; i++) {
            assert.equal(b.format(a[i][0]), a[i][1], a[i][0] + ' ---> ' + a[i][1]);
        }
    });

    test('format ordinal', function (assert) {
        assert.equal(moment([2011, 0, 1]).format('DDDo'), '1-ÑÐ¸', '1st');
        assert.equal(moment([2011, 0, 2]).format('DDDo'), '2-ÑÐ¸', '2nd');
        assert.equal(moment([2011, 0, 3]).format('DDDo'), '3-ÑÒ¯', '3rd');
        assert.equal(moment([2011, 0, 4]).format('DDDo'), '4-ÑÒ¯', '4th');
        assert.equal(moment([2011, 0, 5]).format('DDDo'), '5-ÑÐ¸', '5th');
        assert.equal(moment([2011, 0, 6]).format('DDDo'), '6-ÑÑ', '6th');
        assert.equal(moment([2011, 0, 7]).format('DDDo'), '7-ÑÐ¸', '7th');
        assert.equal(moment([2011, 0, 8]).format('DDDo'), '8-ÑÐ¸', '8th');
        assert.equal(moment([2011, 0, 9]).format('DDDo'), '9-ÑÑ', '9th');
        assert.equal(moment([2011, 0, 10]).format('DDDo'), '10-ÑÑ', '10th');

        assert.equal(moment([2011, 0, 11]).format('DDDo'), '11-ÑÐ¸', '11th');
        assert.equal(moment([2011, 0, 12]).format('DDDo'), '12-ÑÐ¸', '12th');
        assert.equal(moment([2011, 0, 13]).format('DDDo'), '13-ÑÒ¯', '13th');
        assert.equal(moment([2011, 0, 14]).format('DDDo'), '14-ÑÒ¯', '14th');
        assert.equal(moment([2011, 0, 15]).format('DDDo'), '15-ÑÐ¸', '15th');
        assert.equal(moment([2011, 0, 16]).format('DDDo'), '16-ÑÑ', '16th');
        assert.equal(moment([2011, 0, 17]).format('DDDo'), '17-ÑÐ¸', '17th');
        assert.equal(moment([2011, 0, 18]).format('DDDo'), '18-ÑÐ¸', '18th');
        assert.equal(moment([2011, 0, 19]).format('DDDo'), '19-ÑÑ', '19th');
        assert.equal(moment([2011, 0, 20]).format('DDDo'), '20-ÑÑ', '20th');

        assert.equal(moment([2011, 0, 21]).format('DDDo'), '21-ÑÐ¸', '21st');
        assert.equal(moment([2011, 0, 22]).format('DDDo'), '22-ÑÐ¸', '22nd');
        assert.equal(moment([2011, 0, 23]).format('DDDo'), '23-ÑÒ¯', '23rd');
        assert.equal(moment([2011, 0, 24]).format('DDDo'), '24-ÑÒ¯', '24th');
        assert.equal(moment([2011, 0, 25]).format('DDDo'), '25-ÑÐ¸', '25th');
        assert.equal(moment([2011, 0, 26]).format('DDDo'), '26-ÑÑ', '26th');
        assert.equal(moment([2011, 0, 27]).format('DDDo'), '27-ÑÐ¸', '27th');
        assert.equal(moment([2011, 0, 28]).format('DDDo'), '28-ÑÐ¸', '28th');
        assert.equal(moment([2011, 0, 29]).format('DDDo'), '29-ÑÑ', '29th');
        assert.equal(moment([2011, 0, 30]).format('DDDo'), '30-ÑÑ', '30th');

        assert.equal(moment([2011, 0, 31]).format('DDDo'), '31-ÑÐ¸', '31st');
    });

    test('format month', function (assert) {
        var expected = 'ÑÐ½Ð²Ð°ÑÑ ÑÐ½Ð²_ÑÐµÐ²ÑÐ°Ð»Ñ ÑÐµÐ²_Ð¼Ð°ÑÑ Ð¼Ð°ÑÑ_Ð°Ð¿ÑÐµÐ»Ñ Ð°Ð¿Ñ_Ð¼Ð°Ð¹ Ð¼Ð°Ð¹_Ð¸ÑÐ½Ñ Ð¸ÑÐ½Ñ_Ð¸ÑÐ»Ñ Ð¸ÑÐ»Ñ_Ð°Ð²Ð³ÑÑÑ Ð°Ð²Ð³_ÑÐµÐ½ÑÑÐ±ÑÑ ÑÐµÐ½_Ð¾ÐºÑÑÐ±ÑÑ Ð¾ÐºÑ_Ð½Ð¾ÑÐ±ÑÑ Ð½Ð¾Ñ_Ð´ÐµÐºÐ°Ð±ÑÑ Ð´ÐµÐº'.split('_'), i;
        for (i = 0; i < expected.length; i++) {
            assert.equal(moment([2011, i, 1]).format('MMMM MMM'), expected[i], expected[i]);
        }
    });

    test('format week', function (assert) {
        var expected = 'ÐÐµÐºÑÐµÐ¼Ð±Ð¸ ÐÐµÐº ÐÐº_ÐÒ¯Ð¹ÑÓ©Ð¼Ð±Ò¯ ÐÒ¯Ð¹ ÐÐ¹_Ð¨ÐµÐ¹ÑÐµÐ¼Ð±Ð¸ Ð¨ÐµÐ¹ Ð¨Ð¹_Ð¨Ð°ÑÑÐµÐ¼Ð±Ð¸ Ð¨Ð°Ñ Ð¨Ñ_ÐÐµÐ¹ÑÐµÐ¼Ð±Ð¸ ÐÐµÐ¹ ÐÐ¹_ÐÑÐ¼Ð° ÐÑÐ¼ ÐÐ¼_ÐÑÐµÐ¼Ð±Ð¸ ÐÑÐµ ÐÑ'.split('_'), i;
        for (i = 0; i < expected.length; i++) {
            assert.equal(moment([2011, 0, 2 + i]).format('dddd ddd dd'), expected[i], expected[i]);
        }
    });

    test('from', function (assert) {
        var start = moment([2007, 1, 28]);
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 44}), true),  'Ð±Ð¸ÑÐ½ÐµÑÐµ ÑÐµÐºÑÐ½Ð´', '44 seconds = a few seconds');
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 45}), true),  'Ð±Ð¸Ñ Ð¼Ò¯Ð½Ó©Ñ',      '45 seconds = a minute');
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 89}), true),  'Ð±Ð¸Ñ Ð¼Ò¯Ð½Ó©Ñ',      '89 seconds = a minute');
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 90}), true),  '2 Ð¼Ò¯Ð½Ó©Ñ',     '90 seconds = 2 minutes');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 44}), true),  '44 Ð¼Ò¯Ð½Ó©Ñ',    '44 minutes = 44 minutes');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 45}), true),  'Ð±Ð¸Ñ ÑÐ°Ð°Ñ',       '45 minutes = an hour');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 89}), true),  'Ð±Ð¸Ñ ÑÐ°Ð°Ñ',       '89 minutes = an hour');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 90}), true),  '2 ÑÐ°Ð°Ñ',       '90 minutes = 2 hours');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 5}), true),   '5 ÑÐ°Ð°Ñ',       '5 hours = 5 hours');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 21}), true),  '21 ÑÐ°Ð°Ñ',      '21 hours = 21 hours');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 22}), true),  'Ð±Ð¸Ñ ÐºÒ¯Ð½',         '22 hours = a day');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 35}), true),  'Ð±Ð¸Ñ ÐºÒ¯Ð½',         '35 hours = a day');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 36}), true),  '2 ÐºÒ¯Ð½',        '36 hours = 2 days');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 1}), true),   'Ð±Ð¸Ñ ÐºÒ¯Ð½',         '1 day = a day');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 5}), true),   '5 ÐºÒ¯Ð½',        '5 days = 5 days');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 25}), true),  '25 ÐºÒ¯Ð½',       '25 days = 25 days');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 26}), true),  'Ð±Ð¸Ñ Ð°Ð¹',       '26 days = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 30}), true),  'Ð±Ð¸Ñ Ð°Ð¹',       '30 days = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 43}), true),  'Ð±Ð¸Ñ Ð°Ð¹',       '43 days = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 46}), true),  '2 Ð°Ð¹',      '46 days = 2 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 74}), true),  '2 Ð°Ð¹',      '75 days = 2 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 76}), true),  '3 Ð°Ð¹',      '76 days = 3 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({M: 1}), true),   'Ð±Ð¸Ñ Ð°Ð¹',       '1 month = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({M: 5}), true),   '5 Ð°Ð¹',      '5 months = 5 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 345}), true), 'Ð±Ð¸Ñ Ð¶ÑÐ»',        '345 days = a year');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 548}), true), '2 Ð¶ÑÐ»',       '548 days = 2 years');
        assert.equal(start.from(moment([2007, 1, 28]).add({y: 1}), true),   'Ð±Ð¸Ñ Ð¶ÑÐ»',        '1 year = a year');
        assert.equal(start.from(moment([2007, 1, 28]).add({y: 5}), true),   '5 Ð¶ÑÐ»',       '5 years = 5 years');
    });

    test('suffix', function (assert) {
        assert.equal(moment(30000).from(0), 'Ð±Ð¸ÑÐ½ÐµÑÐµ ÑÐµÐºÑÐ½Ð´ Ð¸ÑÐ¸Ð½Ð´Ðµ',  'prefix');
        assert.equal(moment(0).from(30000), 'Ð±Ð¸ÑÐ½ÐµÑÐµ ÑÐµÐºÑÐ½Ð´ Ð¼ÑÑÑÐ½', 'suffix');
    });

    test('now from now', function (assert) {
        assert.equal(moment().fromNow(), 'Ð±Ð¸ÑÐ½ÐµÑÐµ ÑÐµÐºÑÐ½Ð´ Ð¼ÑÑÑÐ½',  'now from now should display as in the past');
    });

    test('fromNow', function (assert) {
        assert.equal(moment().add({s: 30}).fromNow(), 'Ð±Ð¸ÑÐ½ÐµÑÐµ ÑÐµÐºÑÐ½Ð´ Ð¸ÑÐ¸Ð½Ð´Ðµ', 'in a few seconds');
        assert.equal(moment().add({d: 5}).fromNow(), '5 ÐºÒ¯Ð½ Ð¸ÑÐ¸Ð½Ð´Ðµ', 'in 5 days');
    });

    test('calendar day', function (assert) {
        var a = moment().hours(12).minutes(0).seconds(0);

        assert.equal(moment(a).calendar(),                   'ÐÒ¯Ð³Ò¯Ð½ ÑÐ°Ð°Ñ 12:00',  'today at the same time');
        assert.equal(moment(a).add({m: 25}).calendar(),      'ÐÒ¯Ð³Ò¯Ð½ ÑÐ°Ð°Ñ 12:25',  'Now plus 25 min');
        assert.equal(moment(a).add({h: 1}).calendar(),       'ÐÒ¯Ð³Ò¯Ð½ ÑÐ°Ð°Ñ 13:00',  'Now plus 1 hour');
        assert.equal(moment(a).add({d: 1}).calendar(),       'Ð­ÑÑÐµÒ£ ÑÐ°Ð°Ñ 12:00',  'tomorrow at the same time');
        assert.equal(moment(a).subtract({h: 1}).calendar(),  'ÐÒ¯Ð³Ò¯Ð½ ÑÐ°Ð°Ñ 11:00',  'Now minus 1 hour');
        assert.equal(moment(a).subtract({d: 1}).calendar(),  'ÐÐµÑÐµ ÑÐ°Ð°Ñ 12:00',   'yesterday at the same time');
    });

    test('calendar next week', function (assert) {
        var i, m;
        for (i = 2; i < 7; i++) {
            m = moment().add({d: i});
            assert.equal(m.calendar(),       m.format('dddd [ÑÐ°Ð°Ñ] LT'),  'Today + ' + i + ' days current time');
            m.hours(0).minutes(0).seconds(0).milliseconds(0);
            assert.equal(m.calendar(),       m.format('dddd [ÑÐ°Ð°Ñ] LT'),  'Today + ' + i + ' days beginning of day');
            m.hours(23).minutes(59).seconds(59).milliseconds(999);
            assert.equal(m.calendar(),       m.format('dddd [ÑÐ°Ð°Ñ] LT'),  'Today + ' + i + ' days end of day');
        }
    });

    test('calendar last week', function (assert) {
        var i, m;

        for (i = 2; i < 7; i++) {
            m = moment().subtract({d: i});
            assert.equal(m.calendar(),       m.format('[Ó¨ÑÐºÐµÐ½ Ð°Ð¿ÑÐ°Ð½ÑÐ½] dddd [ÐºÒ¯Ð½Ò¯] [ÑÐ°Ð°Ñ] LT'),  'Today - ' + i + ' days current time');
            m.hours(0).minutes(0).seconds(0).milliseconds(0);
            assert.equal(m.calendar(),       m.format('[Ó¨ÑÐºÐµÐ½ Ð°Ð¿ÑÐ°Ð½ÑÐ½] dddd [ÐºÒ¯Ð½Ò¯] [ÑÐ°Ð°Ñ] LT'),  'Today - ' + i + ' days beginning of day');
            m.hours(23).minutes(59).seconds(59).milliseconds(999);
            assert.equal(m.calendar(),       m.format('[Ó¨ÑÐºÐµÐ½ Ð°Ð¿ÑÐ°Ð½ÑÐ½] dddd [ÐºÒ¯Ð½Ò¯] [ÑÐ°Ð°Ñ] LT'),  'Today - ' + i + ' days end of day');
        }
    });

    test('calendar all else', function (assert) {
        var weeksAgo = moment().subtract({w: 1}),
            weeksFromNow = moment().add({w: 1});

        assert.equal(weeksAgo.calendar(),       weeksAgo.format('L'),  '1 week ago');
        assert.equal(weeksFromNow.calendar(),   weeksFromNow.format('L'),  'in 1 week');

        weeksAgo = moment().subtract({w: 2});
        weeksFromNow = moment().add({w: 2});

        assert.equal(weeksAgo.calendar(),       weeksAgo.format('L'),  '2 weeks ago');
        assert.equal(weeksFromNow.calendar(),   weeksFromNow.format('L'),  'in 2 weeks');
    });

    test('weeks year starting sunday formatted', function (assert) {
        assert.equal(moment([2012, 0,  1]).format('w ww wo'),   '1 01 1-ÑÐ¸', 'Jan  1 2012 should be week 1');
        assert.equal(moment([2012, 0,  2]).format('w ww wo'),   '2 02 2-ÑÐ¸', 'Jan  2 2012 should be week 2');
        assert.equal(moment([2012, 0,  8]).format('w ww wo'),   '2 02 2-ÑÐ¸', 'Jan  8 2012 should be week 2');
        assert.equal(moment([2012, 0,  9]).format('w ww wo'),   '3 03 3-ÑÒ¯', 'Jan  9 2012 should be week 3');
        assert.equal(moment([2012, 0, 15]).format('w ww wo'),   '3 03 3-ÑÒ¯', 'Jan 15 2012 should be week 3');
    });

}));

;(function (global, factory) {
   typeof exports === 'object' && typeof module !== 'undefined'
       && typeof require === 'function' ? factory(require('../../moment')) :
   typeof define === 'function' && define.amd ? define(['../../moment'], factory) :
   factory(global.moment)
}(this, function (moment) { 'use strict';

    function each(array, callback) {
        var i;
        for (i = 0; i < array.length; i++) {
            callback(array[i], i, array);
        }
    }

    function objectKeys(obj) {
        if (Object.keys) {
            return Object.keys(obj);
        } else {
            // IE8
            var res = [], i;
            for (i in obj) {
                if (obj.hasOwnProperty(i)) {
                    res.push(i);
                }
            }
            return res;
        }
    }

    // Pick the first defined of two or three arguments.
    function defaults(a, b, c) {
        if (a != null) {
            return a;
        }
        if (b != null) {
            return b;
        }
        return c;
    }

    function defineCommonLocaleTests(locale, options) {
        test('lenient ordinal parsing', function (assert) {
            var i, ordinalStr, testMoment;
            for (i = 1; i <= 31; ++i) {
                ordinalStr = moment([2014, 0, i]).format('YYYY MM Do');
                testMoment = moment(ordinalStr, 'YYYY MM Do');
                assert.equal(testMoment.year(), 2014,
                        'lenient ordinal parsing ' + i + ' year check');
                assert.equal(testMoment.month(), 0,
                        'lenient ordinal parsing ' + i + ' month check');
                assert.equal(testMoment.date(), i,
                        'lenient ordinal parsing ' + i + ' date check');
            }
        });

        test('lenient ordinal parsing of number', function (assert) {
            var i, testMoment;
            for (i = 1; i <= 31; ++i) {
                testMoment = moment('2014 01 ' + i, 'YYYY MM Do');
                assert.equal(testMoment.year(), 2014,
                        'lenient ordinal parsing of number ' + i + ' year check');
                assert.equal(testMoment.month(), 0,
                        'lenient ordinal parsing of number ' + i + ' month check');
                assert.equal(testMoment.date(), i,
                        'lenient ordinal parsing of number ' + i + ' date check');
            }
        });

        test('strict ordinal parsing', function (assert) {
            var i, ordinalStr, testMoment;
            for (i = 1; i <= 31; ++i) {
                ordinalStr = moment([2014, 0, i]).format('YYYY MM Do');
                testMoment = moment(ordinalStr, 'YYYY MM Do', true);
                assert.ok(testMoment.isValid(), 'strict ordinal parsing ' + i);
            }
        });

        test('meridiem invariant', function (assert) {
            var h, m, t1, t2;
            for (h = 0; h < 24; ++h) {
                for (m = 0; m < 60; m += 15) {
                    t1 = moment.utc([2000, 0, 1, h, m]);
                    t2 = moment.utc(t1.format('A h:mm'), 'A h:mm');
                    assert.equal(t2.format('HH:mm'), t1.format('HH:mm'),
                            'meridiem at ' + t1.format('HH:mm'));
                }
            }
        });

        test('date format correctness', function (assert) {
            var data, tokens;
            data = moment.localeData()._longDateFormat;
            tokens = objectKeys(data);
            each(tokens, function (srchToken) {
                // Check each format string to make sure it does not contain any
                // tokens that need to be expanded.
                each(tokens, function (baseToken) {
                    // strip escaped sequences
                    var format = data[baseToken].replace(/(\[[^\]]*\])/g, '');
                    assert.equal(false, !!~format.indexOf(srchToken),
                            'contains ' + srchToken + ' in ' + baseToken);
                });
            });
        });

        test('month parsing correctness', function (assert) {
            var i, m;

            if (locale === 'tr') {
                // I can't fix it :(
                expect(0);
                return;
            }
            function tester(format) {
                var r;
                r = moment(m.format(format), format);
                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format);
                r = moment(m.format(format).toLocaleUpperCase(), format);
                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' upper');
                r = moment(m.format(format).toLocaleLowerCase(), format);
                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' lower');

                r = moment(m.format(format), format, true);
                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' strict');
                r = moment(m.format(format).toLocaleUpperCase(), format, true);
                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' upper strict');
                r = moment(m.format(format).toLocaleLowerCase(), format, true);
                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' lower strict');
            }

            for (i = 0; i < 12; ++i) {
                m = moment([2015, i, 15, 18]);
                tester('MMM');
                tester('MMM.');
                tester('MMMM');
                tester('MMMM.');
            }
        });

        test('weekday parsing correctness', function (assert) {
            var i, m;

            if (locale === 'tr' || locale === 'az') {
                // There is a lower-case letter (Ä±), that converted to upper then
                // lower changes to i
                expect(0);
                return;
            }
            function tester(format) {
                var r, baseMsg = 'weekday ' + m.weekday() + ' fmt ' + format;
                r = moment(m.format(format), format);
                assert.equal(r.weekday(), m.weekday(), baseMsg);
                r = moment(m.format(format).toLocaleUpperCase(), format);
                assert.equal(r.weekday(), m.weekday(), baseMsg + ' upper');
                r = moment(m.format(format).toLocaleLowerCase(), format);
                assert.equal(r.weekday(), m.weekday(), baseMsg + ' lower');

                r = moment(m.format(format), format, true);
                assert.equal(r.weekday(), m.weekday(), baseMsg + ' strict');
                r = moment(m.format(format).toLocaleUpperCase(), format, true);
                assert.equal(r.weekday(), m.weekday(), baseMsg + ' upper strict');
                r = moment(m.format(format).toLocaleLowerCase(), format, true);
                assert.equal(r.weekday(), m.weekday(), baseMsg + ' lower strict');
            }

            for (i = 0; i < 7; ++i) {
                m = moment.utc([2015, i, 15, 18]);
                tester('dd');
                tester('ddd');
                tester('dddd');
            }
        });
    }

    function setupDeprecationHandler(test, moment, scope) {
        test._expectedDeprecations = null;
        test._observedDeprecations = null;
        test._oldSupress = moment.suppressDeprecationWarnings;
        moment.suppressDeprecationWarnings = true;
        test.expectedDeprecations = function () {
            test._expectedDeprecations = arguments;
            test._observedDeprecations = [];
        };
        moment.deprecationHandler = function (name, msg) {
            var deprecationId = matchedDeprecation(name, msg, test._expectedDeprecations);
            if (deprecationId === -1) {
                throw new Error('Unexpected deprecation thrown name=' +
                        name + ' msg=' + msg);
            }
            test._observedDeprecations[deprecationId] = 1;
        };
    }

    function teardownDeprecationHandler(test, moment, scope) {
        moment.suppressDeprecationWarnings = test._oldSupress;

        if (test._expectedDeprecations != null) {
            var missedDeprecations = [];
            each(test._expectedDeprecations, function (deprecationPattern, id) {
                if (test._observedDeprecations[id] !== 1) {
                    missedDeprecations.push(deprecationPattern);
                }
            });
            if (missedDeprecations.length !== 0) {
                throw new Error('Expected deprecation warnings did not happen: ' +
                        missedDeprecations.join(' '));
            }
        }
    }

    function matchedDeprecation(name, msg, deprecations) {
        if (deprecations == null) {
            return -1;
        }
        for (var i = 0; i < deprecations.length; ++i) {
            if (name != null && name === deprecations[i]) {
                return i;
            }
            if (msg != null && msg.substring(0, deprecations[i].length) === deprecations[i]) {
                return i;
            }
        }
        return -1;
    }

    /*global QUnit:false*/

    var test = QUnit.test;

    var expect = QUnit.expect;

    function module (name, lifecycle) {
        QUnit.module(name, {
            setup : function () {
                moment.locale('en');
                moment.createFromInputFallback = function (config) {
                    throw new Error('input not handled by moment: ' + config._i);
                };
                setupDeprecationHandler(test, moment, 'core');
                if (lifecycle && lifecycle.setup) {
                    lifecycle.setup();
                }
            },
            teardown : function () {
                teardownDeprecationHandler(test, moment, 'core');
                if (lifecycle && lifecycle.teardown) {
                    lifecycle.teardown();
                }
            }
        });
    }

    function localeModule (name, lifecycle) {
        QUnit.module('locale:' + name, {
            setup : function () {
                moment.locale(name);
                moment.createFromInputFallback = function (config) {
                    throw new Error('input not handled by moment: ' + config._i);
                };
                setupDeprecationHandler(test, moment, 'locale');
                if (lifecycle && lifecycle.setup) {
                    lifecycle.setup();
                }
            },
            teardown : function () {
                moment.locale('en');
                teardownDeprecationHandler(test, moment, 'locale');
                if (lifecycle && lifecycle.teardown) {
                    lifecycle.teardown();
                }
            }
        });
        defineCommonLocaleTests(name, -1, -1);
    }

    localeModule('lb');

    test('parse', function (assert) {
        var tests = 'Januar Jan._Februar Febr._MÃ¤erz Mrz._AbrÃ«ll Abr._Mee Mee_Juni Jun._Juli Jul._August Aug._September Sept._Oktober Okt._November Nov._Dezember Dez.'.split('_'), i;

        function equalTest(input, mmm, i) {
            assert.equal(moment(input, mmm).month(), i, input + ' should be month ' + (i + 1));
        }

        for (i = 0; i < 12; i++) {
            tests[i] = tests[i].split(' ');
            equalTest(tests[i][0], 'MMM', i);
            equalTest(tests[i][1], 'MMM', i);
            equalTest(tests[i][0], 'MMMM', i);
            equalTest(tests[i][1], 'MMMM', i);
            equalTest(tests[i][0].toLocaleLowerCase(), 'MMMM', i);
            equalTest(tests[i][1].toLocaleLowerCase(), 'MMMM', i);
            equalTest(tests[i][0].toLocaleUpperCase(), 'MMMM', i);
            equalTest(tests[i][1].toLocaleUpperCase(), 'MMMM', i);
        }
    });

    test('format', function (assert) {
        var a = [
                ['dddd, Do MMMM YYYY, HH:mm:ss', 'Sonndeg, 14. Februar 2010, 15:25:50'],
                ['ddd, HH:mm', 'So., 15:25'],
                ['M Mo MM MMMM MMM', '2 2. 02 Februar Febr.'],
                ['YYYY YY', '2010 10'],
                ['D Do DD', '14 14. 14'],
                ['d do dddd ddd dd', '0 0. Sonndeg So. So'],
                ['DDD DDDo DDDD', '45 45. 045'],
                ['w wo ww', '6 6. 06'],
                ['h hh', '3 03'],
                ['H HH', '15 15'],
                ['m mm', '25 25'],
                ['s ss', '50 50'],
                ['a A', 'pm PM'],
                ['[the] DDDo [day of the year]', 'the 45. day of the year'],
                ['LTS', '15:25:50 Auer'],
                ['L', '14.02.2010'],
                ['LL', '14. Februar 2010'],
                ['LLL', '14. Februar 2010 15:25 Auer'],
                ['LLLL', 'Sonndeg, 14. Februar 2010 15:25 Auer'],
                ['l', '14.2.2010'],
                ['ll', '14. Febr. 2010'],
                ['lll', '14. Febr. 2010 15:25 Auer'],
                ['llll', 'So., 14. Febr. 2010 15:25 Auer']
            ],
            b = moment(new Date(2010, 1, 14, 15, 25, 50, 125)),
            i;
        for (i = 0; i < a.length; i++) {
            assert.equal(b.format(a[i][0]), a[i][1], a[i][0] + ' ---> ' + a[i][1]);
        }
    });

    test('format month', function (assert) {
        var expected = 'Januar Jan._Februar Febr._MÃ¤erz Mrz._AbrÃ«ll Abr._Mee Mee_Juni Jun._Juli Jul._August Aug._September Sept._Oktober Okt._November Nov._Dezember Dez.'.split('_'), i;
        for (i = 0; i < expected.length; i++) {
            assert.equal(moment([2011, i, 1]).format('MMMM MMM'), expected[i], expected[i]);
        }
    });

    test('format week', function (assert) {
        var expected = 'Sonndeg So. So_MÃ©indeg MÃ©. MÃ©_DÃ«nschdeg DÃ«. DÃ«_MÃ«ttwoch MÃ«. MÃ«_Donneschdeg Do. Do_Freideg Fr. Fr_Samschdeg Sa. Sa'.split('_'), i;
        for (i = 0; i < expected.length; i++) {
            assert.equal(moment([2011, 0, 2 + i]).format('dddd ddd dd'), expected[i], expected[i]);
        }
    });

    test('from', function (assert) {
        var start = moment([2007, 1, 28]);
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 44}), true), 'e puer Sekonnen', '44 seconds = a few seconds');
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 45}), true), 'eng Minutt', '45 seconds = a minute');
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 89}), true), 'eng Minutt', '89 seconds = a minute');
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 90}), true), '2 Minutten', '90 seconds = 2 minutes');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 44}), true), '44 Minutten', '44 minutes = 44 minutes');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 45}), true), 'eng Stonn', '45 minutes = an hour');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 89}), true), 'eng Stonn', '89 minutes = an hour');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 90}), true), '2 Stonnen', '90 minutes = 2 hours');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 5}), true), '5 Stonnen', '5 hours = 5 hours');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 21}), true), '21 Stonnen', '21 hours = 21 hours');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 22}), true), 'een Dag', '22 hours = a day');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 35}), true), 'een Dag', '35 hours = a day');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 36}), true), '2 Deeg', '36 hours = 2 days');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 1}), true), 'een Dag', '1 day = a day');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 5}), true), '5 Deeg', '5 days = 5 days');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 25}), true), '25 Deeg', '25 days = 25 days');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 26}), true), 'ee Mount', '26 days = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 30}), true), 'ee Mount', '30 days = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 43}), true), 'ee Mount', '43 days = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 46}), true), '2 MÃ©int', '46 days = 2 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 74}), true), '2 MÃ©int', '75 days = 2 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 76}), true), '3 MÃ©int', '76 days = 3 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({M: 1}), true), 'ee Mount', '1 month = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({M: 5}), true), '5 MÃ©int', '5 months = 5 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 345}), true), 'ee Joer', '345 days = a year');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 548}), true), '2 Joer', '548 days = 2 years');
        assert.equal(start.from(moment([2007, 1, 28]).add({y: 1}), true), 'ee Joer', '1 year = a year');
        assert.equal(start.from(moment([2007, 1, 28]).add({y: 5}), true), '5 Joer', '5 years = 5 years');
    });

    test('suffix', function (assert) {
        assert.equal(moment(30000).from(0), 'an e puer Sekonnen', 'prefix');
        assert.equal(moment(0).from(30000), 'virun e puer Sekonnen', 'suffix');
    });

    test('fromNow', function (assert) {
        assert.equal(moment().add({s: 30}).fromNow(), 'an e puer Sekonnen', 'in a few seconds');
        assert.equal(moment().add({d: 1}).fromNow(), 'an engem Dag', 'in one day');
        assert.equal(moment().add({d: 2}).fromNow(), 'an 2 Deeg', 'in 2 days');
        assert.equal(moment().add({d: 3}).fromNow(), 'an 3 Deeg', 'in 3 days');
        assert.equal(moment().add({d: 4}).fromNow(), 'a 4 Deeg', 'in 4 days');
        assert.equal(moment().add({d: 5}).fromNow(), 'a 5 Deeg', 'in 5 days');
        assert.equal(moment().add({d: 6}).fromNow(), 'a 6 Deeg', 'in 6 days');
        assert.equal(moment().add({d: 7}).fromNow(), 'a 7 Deeg', 'in 7 days');
        assert.equal(moment().add({d: 8}).fromNow(), 'an 8 Deeg', 'in 8 days');
        assert.equal(moment().add({d: 9}).fromNow(), 'an 9 Deeg', 'in 9 days');
        assert.equal(moment().add({d: 10}).fromNow(), 'an 10 Deeg', 'in 10 days');
        assert.equal(moment().add({y: 100}).fromNow(), 'an 100 Joer', 'in 100 years');
        assert.equal(moment().add({y: 400}).fromNow(), 'a 400 Joer', 'in 400 years');
    });

    test('calendar day', function (assert) {
        var a = moment().hours(12).minutes(0).seconds(0);

        assert.equal(moment(a).calendar(),                   'Haut um 12:00 Auer',     'today at the same time');
        assert.equal(moment(a).add({m: 25}).calendar(),      'Haut um 12:25 Auer',     'Now plus 25 min');
        assert.equal(moment(a).add({h: 1}).calendar(),       'Haut um 13:00 Auer',     'Now plus 1 hour');
        assert.equal(moment(a).add({d: 1}).calendar(),       'Muer um 12:00 Auer',     'tomorrow at the same time');
        assert.equal(moment(a).subtract({h: 1}).calendar(),  'Haut um 11:00 Auer',     'Now minus 1 hour');
        assert.equal(moment(a).subtract({d: 1}).calendar(),  'GÃ«schter um 12:00 Auer', 'yesterday at the same time');
    });

    test('calendar next week', function (assert) {
        var i, m;

        for (i = 2; i < 7; i++) {
            m = moment().add({d: i});
            assert.equal(m.calendar(),       m.format('dddd [um] LT'),  'Today + ' + i + ' days current time');
            m.hours(0).minutes(0).seconds(0).milliseconds(0);
            assert.equal(m.calendar(),       m.format('dddd [um] LT'),  'Today + ' + i + ' days beginning of day');
            m.hours(23).minutes(59).seconds(59).milliseconds(999);
            assert.equal(m.calendar(),       m.format('dddd [um] LT'),  'Today + ' + i + ' days end of day');
        }
    });

    test('calendar last week', function (assert) {
        var i, m, weekday, datestring;
        for (i = 2; i < 7; i++) {
            m = moment().subtract({d: i});

            // Different date string for 'DÃ«nschdeg' (Tuesday) and 'Donneschdeg' (Thursday)
            weekday = parseInt(m.format('d'), 10);
            datestring = (weekday === 2 || weekday === 4 ? '[Leschten] dddd [um] LT' : '[Leschte] dddd [um] LT');

            assert.equal(m.calendar(), m.format(datestring), 'Today + ' + i + ' days current time');
            m.hours(0).minutes(0).seconds(0).milliseconds(0);
            assert.equal(m.calendar(), m.format(datestring), 'Today + ' + i + ' days beginning of day');
            m.hours(23).minutes(59).seconds(59).milliseconds(999);
            assert.equal(m.calendar(), m.format(datestring), 'Today + ' + i + ' days end of day');
        }
    });

    test('calendar all else', function (assert) {
        var weeksAgo = moment().subtract({w: 1}),
            weeksFromNow = moment().add({w: 1});

        assert.equal(weeksAgo.calendar(),       weeksAgo.format('L'),  '1 week ago');
        assert.equal(weeksFromNow.calendar(),   weeksFromNow.format('L'),  'in 1 week');

        weeksAgo = moment().subtract({w: 2});
        weeksFromNow = moment().add({w: 2});

        assert.equal(weeksAgo.calendar(),       weeksAgo.format('L'),  '2 weeks ago');
        assert.equal(weeksFromNow.calendar(),   weeksFromNow.format('L'),  'in 2 weeks');
    });

    test('weeks year starting sunday format', function (assert) {
        assert.equal(moment([2012, 0,  1]).format('w ww wo'), '52 52 52.', 'Jan  1 2012 should be week 52');
        assert.equal(moment([2012, 0,  7]).format('w ww wo'), '1 01 1.',   'Jan  7 2012 should be week 1');
        assert.equal(moment([2012, 0,  8]).format('w ww wo'), '1 01 1.',   'Jan  8 2012 should be week 1');
        assert.equal(moment([2012, 0, 14]).format('w ww wo'), '2 02 2.',   'Jan 14 2012 should be week 2');
        assert.equal(moment([2012, 0, 15]).format('w ww wo'), '2 02 2.',   'Jan 15 2012 should be week 2');
    });

}));

;(function (global, factory) {
   typeof exports === 'object' && typeof module !== 'undefined'
       && typeof require === 'function' ? factory(require('../../moment')) :
   typeof define === 'function' && define.amd ? define(['../../moment'], factory) :
   factory(global.moment)
}(this, function (moment) { 'use strict';

    function each(array, callback) {
        var i;
        for (i = 0; i < array.length; i++) {
            callback(array[i], i, array);
        }
    }

    function objectKeys(obj) {
        if (Object.keys) {
            return Object.keys(obj);
        } else {
            // IE8
            var res = [], i;
            for (i in obj) {
                if (obj.hasOwnProperty(i)) {
                    res.push(i);
                }
            }
            return res;
        }
    }

    // Pick the first defined of two or three arguments.
    function defaults(a, b, c) {
        if (a != null) {
            return a;
        }
        if (b != null) {
            return b;
        }
        return c;
    }

    function defineCommonLocaleTests(locale, options) {
        test('lenient ordinal parsing', function (assert) {
            var i, ordinalStr, testMoment;
            for (i = 1; i <= 31; ++i) {
                ordinalStr = moment([2014, 0, i]).format('YYYY MM Do');
                testMoment = moment(ordinalStr, 'YYYY MM Do');
                assert.equal(testMoment.year(), 2014,
                        'lenient ordinal parsing ' + i + ' year check');
                assert.equal(testMoment.month(), 0,
                        'lenient ordinal parsing ' + i + ' month check');
                assert.equal(testMoment.date(), i,
                        'lenient ordinal parsing ' + i + ' date check');
            }
        });

        test('lenient ordinal parsing of number', function (assert) {
            var i, testMoment;
            for (i = 1; i <= 31; ++i) {
                testMoment = moment('2014 01 ' + i, 'YYYY MM Do');
                assert.equal(testMoment.year(), 2014,
                        'lenient ordinal parsing of number ' + i + ' year check');
                assert.equal(testMoment.month(), 0,
                        'lenient ordinal parsing of number ' + i + ' month check');
                assert.equal(testMoment.date(), i,
                        'lenient ordinal parsing of number ' + i + ' date check');
            }
        });

        test('strict ordinal parsing', function (assert) {
            var i, ordinalStr, testMoment;
            for (i = 1; i <= 31; ++i) {
                ordinalStr = moment([2014, 0, i]).format('YYYY MM Do');
                testMoment = moment(ordinalStr, 'YYYY MM Do', true);
                assert.ok(testMoment.isValid(), 'strict ordinal parsing ' + i);
            }
        });

        test('meridiem invariant', function (assert) {
            var h, m, t1, t2;
            for (h = 0; h < 24; ++h) {
                for (m = 0; m < 60; m += 15) {
                    t1 = moment.utc([2000, 0, 1, h, m]);
                    t2 = moment.utc(t1.format('A h:mm'), 'A h:mm');
                    assert.equal(t2.format('HH:mm'), t1.format('HH:mm'),
                            'meridiem at ' + t1.format('HH:mm'));
                }
            }
        });

        test('date format correctness', function (assert) {
            var data, tokens;
            data = moment.localeData()._longDateFormat;
            tokens = objectKeys(data);
            each(tokens, function (srchToken) {
                // Check each format string to make sure it does not contain any
                // tokens that need to be expanded.
                each(tokens, function (baseToken) {
                    // strip escaped sequences
                    var format = data[baseToken].replace(/(\[[^\]]*\])/g, '');
                    assert.equal(false, !!~format.indexOf(srchToken),
                            'contains ' + srchToken + ' in ' + baseToken);
                });
            });
        });

        test('month parsing correctness', function (assert) {
            var i, m;

            if (locale === 'tr') {
                // I can't fix it :(
                expect(0);
                return;
            }
            function tester(format) {
                var r;
                r = moment(m.format(format), format);
                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format);
                r = moment(m.format(format).toLocaleUpperCase(), format);
                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' upper');
                r = moment(m.format(format).toLocaleLowerCase(), format);
                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' lower');

                r = moment(m.format(format), format, true);
                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' strict');
                r = moment(m.format(format).toLocaleUpperCase(), format, true);
                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' upper strict');
                r = moment(m.format(format).toLocaleLowerCase(), format, true);
                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' lower strict');
            }

            for (i = 0; i < 12; ++i) {
                m = moment([2015, i, 15, 18]);
                tester('MMM');
                tester('MMM.');
                tester('MMMM');
                tester('MMMM.');
            }
        });

        test('weekday parsing correctness', function (assert) {
            var i, m;

            if (locale === 'tr' || locale === 'az') {
                // There is a lower-case letter (Ä±), that converted to upper then
                // lower changes to i
                expect(0);
                return;
            }
            function tester(format) {
                var r, baseMsg = 'weekday ' + m.weekday() + ' fmt ' + format;
                r = moment(m.format(format), format);
                assert.equal(r.weekday(), m.weekday(), baseMsg);
                r = moment(m.format(format).toLocaleUpperCase(), format);
                assert.equal(r.weekday(), m.weekday(), baseMsg + ' upper');
                r = moment(m.format(format).toLocaleLowerCase(), format);
                assert.equal(r.weekday(), m.weekday(), baseMsg + ' lower');

                r = moment(m.format(format), format, true);
                assert.equal(r.weekday(), m.weekday(), baseMsg + ' strict');
                r = moment(m.format(format).toLocaleUpperCase(), format, true);
                assert.equal(r.weekday(), m.weekday(), baseMsg + ' upper strict');
                r = moment(m.format(format).toLocaleLowerCase(), format, true);
                assert.equal(r.weekday(), m.weekday(), baseMsg + ' lower strict');
            }

            for (i = 0; i < 7; ++i) {
                m = moment.utc([2015, i, 15, 18]);
                tester('dd');
                tester('ddd');
                tester('dddd');
            }
        });
    }

    function setupDeprecationHandler(test, moment, scope) {
        test._expectedDeprecations = null;
        test._observedDeprecations = null;
        test._oldSupress = moment.suppressDeprecationWarnings;
        moment.suppressDeprecationWarnings = true;
        test.expectedDeprecations = function () {
            test._expectedDeprecations = arguments;
            test._observedDeprecations = [];
        };
        moment.deprecationHandler = function (name, msg) {
            var deprecationId = matchedDeprecation(name, msg, test._expectedDeprecations);
            if (deprecationId === -1) {
                throw new Error('Unexpected deprecation thrown name=' +
                        name + ' msg=' + msg);
            }
            test._observedDeprecations[deprecationId] = 1;
        };
    }

    function teardownDeprecationHandler(test, moment, scope) {
        moment.suppressDeprecationWarnings = test._oldSupress;

        if (test._expectedDeprecations != null) {
            var missedDeprecations = [];
            each(test._expectedDeprecations, function (deprecationPattern, id) {
                if (test._observedDeprecations[id] !== 1) {
                    missedDeprecations.push(deprecationPattern);
                }
            });
            if (missedDeprecations.length !== 0) {
                throw new Error('Expected deprecation warnings did not happen: ' +
                        missedDeprecations.join(' '));
            }
        }
    }

    function matchedDeprecation(name, msg, deprecations) {
        if (deprecations == null) {
            return -1;
        }
        for (var i = 0; i < deprecations.length; ++i) {
            if (name != null && name === deprecations[i]) {
                return i;
            }
            if (msg != null && msg.substring(0, deprecations[i].length) === deprecations[i]) {
                return i;
            }
        }
        return -1;
    }

    /*global QUnit:false*/

    var test = QUnit.test;

    var expect = QUnit.expect;

    function module (name, lifecycle) {
        QUnit.module(name, {
            setup : function () {
                moment.locale('en');
                moment.createFromInputFallback = function (config) {
                    throw new Error('input not handled by moment: ' + config._i);
                };
                setupDeprecationHandler(test, moment, 'core');
                if (lifecycle && lifecycle.setup) {
                    lifecycle.setup();
                }
            },
            teardown : function () {
                teardownDeprecationHandler(test, moment, 'core');
                if (lifecycle && lifecycle.teardown) {
                    lifecycle.teardown();
                }
            }
        });
    }

    function localeModule (name, lifecycle) {
        QUnit.module('locale:' + name, {
            setup : function () {
                moment.locale(name);
                moment.createFromInputFallback = function (config) {
                    throw new Error('input not handled by moment: ' + config._i);
                };
                setupDeprecationHandler(test, moment, 'locale');
                if (lifecycle && lifecycle.setup) {
                    lifecycle.setup();
                }
            },
            teardown : function () {
                moment.locale('en');
                teardownDeprecationHandler(test, moment, 'locale');
                if (lifecycle && lifecycle.teardown) {
                    lifecycle.teardown();
                }
            }
        });
        defineCommonLocaleTests(name, -1, -1);
    }

    localeModule('lo');

    test('parse', function (assert) {
        var tests = 'àº¡àº±àºàºàº­àº àº¡àº±àºàºàº­àº_àºàº¸àº¡àºàº² àºàº¸àº¡àºàº²_àº¡àºµàºàº² àº¡àºµàºàº²_à»àº¡àºªàº² à»àº¡àºªàº²_àºàº¶àºàºªàº°àºàº² àºàº¶àºàºªàº°àºàº²_àº¡àº´àºàº¸àºàº² àº¡àº´àºàº¸àºàº²_àºà»àº¥àº°àºàº»àº àºà»àº¥àº°àºàº»àº_àºªàº´àºàº«àº² àºªàº´àºàº«àº²_àºàº±àºàºàº² àºàº±àºàºàº²_àºàº¸àº¥àº² àºàº¸àº¥àº²_àºàº°àºàº´àº àºàº°àºàº´àº_àºàº±àºàº§àº² àºàº±àºàº§àº²'.split('_'), i;
        function equalTest(input, mmm, i) {
            assert.equal(moment(input, mmm).month(), i, input + ' should be month ' + (i + 1));
        }
        for (i = 0; i < 12; i++) {
            tests[i] = tests[i].split(' ');
            equalTest(tests[i][0], 'MMM', i);
            equalTest(tests[i][1], 'MMM', i);
            equalTest(tests[i][0], 'MMMM', i);
            equalTest(tests[i][1], 'MMMM', i);
            equalTest(tests[i][0].toLocaleLowerCase(), 'MMMM', i);
            equalTest(tests[i][1].toLocaleLowerCase(), 'MMMM', i);
            equalTest(tests[i][0].toLocaleUpperCase(), 'MMMM', i);
            equalTest(tests[i][1].toLocaleUpperCase(), 'MMMM', i);
        }
    });

    test('format', function (assert) {
        var a = [
                ['dddd, MMMM Do YYYY, h:mm:ss a',      'àº­àº²àºàº´àº, àºàº¸àº¡àºàº² àºàºµà»14 2010, 3:25:50 àºàº­àºà»àº¥àº'],
                ['ddd, hA',                            'àºàº´àº, 3àºàº­àºà»àº¥àº'],
                ['M Mo MM MMMM MMM',                   '2 àºàºµà»2 02 àºàº¸àº¡àºàº² àºàº¸àº¡àºàº²'],
                ['YYYY YY',                            '2010 10'],
                ['D Do DD',                            '14 àºàºµà»14 14'],
                ['d do dddd ddd dd',                   '0 àºàºµà»0 àº­àº²àºàº´àº àºàº´àº àº'],
                ['DDD DDDo DDDD',                      '45 àºàºµà»45 045'],
                ['w wo ww',                            '8 àºàºµà»8 08'],
                ['h hh',                               '3 03'],
                ['H HH',                               '15 15'],
                ['m mm',                               '25 25'],
                ['s ss',                               '50 50'],
                ['a A',                                'àºàº­àºà»àº¥àº àºàº­àºà»àº¥àº'],
                ['[àº§àº±àº]DDDo [àºàº­àºàºàºµ]',                   'àº§àº±àºàºàºµà»45 àºàº­àºàºàºµ'],
                ['LTS',                                '15:25:50'],
                ['L',                                  '14/02/2010'],
                ['LL',                                 '14 àºàº¸àº¡àºàº² 2010'],
                ['LLL',                                '14 àºàº¸àº¡àºàº² 2010 15:25'],
                ['LLLL',                               'àº§àº±àºàº­àº²àºàº´àº 14 àºàº¸àº¡àºàº² 2010 15:25'],
                ['l',                                  '14/2/2010'],
                ['ll',                                 '14 àºàº¸àº¡àºàº² 2010'],
                ['lll',                                '14 àºàº¸àº¡àºàº² 2010 15:25'],
                ['llll',                               'àº§àº±àºàºàº´àº 14 àºàº¸àº¡àºàº² 2010 15:25']
            ],
            b = moment(new Date(2010, 1, 14, 15, 25, 50, 125)),
            i;
        for (i = 0; i < a.length; i++) {
            assert.equal(b.format(a[i][0]), a[i][1], a[i][0] + ' ---> ' + a[i][1]);
        }
    });

    test('format ordinal', function (assert) {
        assert.equal(moment([2011, 0, 1]).format('DDDo'), 'àºàºµà»1', 'àºàºµà»1');
        assert.equal(moment([2011, 0, 2]).format('DDDo'), 'àºàºµà»2', 'àºàºµà»2');
        assert.equal(moment([2011, 0, 3]).format('DDDo'), 'àºàºµà»3', 'àºàºµà»3');
        assert.equal(moment([2011, 0, 4]).format('DDDo'), 'àºàºµà»4', 'àºàºµà»4');
        assert.equal(moment([2011, 0, 5]).format('DDDo'), 'àºàºµà»5', 'àºàºµà»5');
        assert.equal(moment([2011, 0, 6]).format('DDDo'), 'àºàºµà»6', 'àºàºµà»6');
        assert.equal(moment([2011, 0, 7]).format('DDDo'), 'àºàºµà»7', 'àºàºµà»7');
        assert.equal(moment([2011, 0, 8]).format('DDDo'), 'àºàºµà»8', 'àºàºµà»8');
        assert.equal(moment([2011, 0, 9]).format('DDDo'), 'àºàºµà»9', 'àºàºµà»9');
        assert.equal(moment([2011, 0, 10]).format('DDDo'), 'àºàºµà»10', 'àºàºµà»10');

        assert.equal(moment([2011, 0, 11]).format('DDDo'), 'àºàºµà»11', 'àºàºµà»11');
        assert.equal(moment([2011, 0, 12]).format('DDDo'), 'àºàºµà»12', 'àºàºµà»12');
        assert.equal(moment([2011, 0, 13]).format('DDDo'), 'àºàºµà»13', 'àºàºµà»13');
        assert.equal(moment([2011, 0, 14]).format('DDDo'), 'àºàºµà»14', 'àºàºµà»14');
        assert.equal(moment([2011, 0, 15]).format('DDDo'), 'àºàºµà»15', 'àºàºµà»15');
        assert.equal(moment([2011, 0, 16]).format('DDDo'), 'àºàºµà»16', 'àºàºµà»16');
        assert.equal(moment([2011, 0, 17]).format('DDDo'), 'àºàºµà»17', 'àºàºµà»17');
        assert.equal(moment([2011, 0, 18]).format('DDDo'), 'àºàºµà»18', 'àºàºµà»18');
        assert.equal(moment([2011, 0, 19]).format('DDDo'), 'àºàºµà»19', 'àºàºµà»19');
        assert.equal(moment([2011, 0, 20]).format('DDDo'), 'àºàºµà»20', 'àºàºµà»20');

        assert.equal(moment([2011, 0, 21]).format('DDDo'), 'àºàºµà»21', 'àºàºµà»21');
        assert.equal(moment([2011, 0, 22]).format('DDDo'), 'àºàºµà»22', 'àºàºµà»22');
        assert.equal(moment([2011, 0, 23]).format('DDDo'), 'àºàºµà»23', 'àºàºµà»23');
        assert.equal(moment([2011, 0, 24]).format('DDDo'), 'àºàºµà»24', 'àºàºµà»24');
        assert.equal(moment([2011, 0, 25]).format('DDDo'), 'àºàºµà»25', 'àºàºµà»25');
        assert.equal(moment([2011, 0, 26]).format('DDDo'), 'àºàºµà»26', 'àºàºµà»26');
        assert.equal(moment([2011, 0, 27]).format('DDDo'), 'àºàºµà»27', 'àºàºµà»27');
        assert.equal(moment([2011, 0, 28]).format('DDDo'), 'àºàºµà»28', 'àºàºµà»28');
        assert.equal(moment([2011, 0, 29]).format('DDDo'), 'àºàºµà»29', 'àºàºµà»29');
        assert.equal(moment([2011, 0, 30]).format('DDDo'), 'àºàºµà»30', 'àºàºµà»30');

        assert.equal(moment([2011, 0, 31]).format('DDDo'), 'àºàºµà»31', 'àºàºµà»31');
    });

    test('format month', function (assert) {
        var expected = 'àº¡àº±àºàºàº­àº àº¡àº±àºàºàº­àº_àºàº¸àº¡àºàº² àºàº¸àº¡àºàº²_àº¡àºµàºàº² àº¡àºµàºàº²_à»àº¡àºªàº² à»àº¡àºªàº²_àºàº¶àºàºªàº°àºàº² àºàº¶àºàºªàº°àºàº²_àº¡àº´àºàº¸àºàº² àº¡àº´àºàº¸àºàº²_àºà»àº¥àº°àºàº»àº àºà»àº¥àº°àºàº»àº_àºªàº´àºàº«àº² àºªàº´àºàº«àº²_àºàº±àºàºàº² àºàº±àºàºàº²_àºàº¸àº¥àº² àºàº¸àº¥àº²_àºàº°àºàº´àº àºàº°àºàº´àº_àºàº±àºàº§àº² àºàº±àºàº§àº²'.split('_'), i;
        for (i = 0; i < expected.length; i++) {
            assert.equal(moment([2011, i, 1]).format('MMMM MMM'), expected[i], expected[i]);
        }
    });

    test('format week', function (assert) {
        var expected = 'àº­àº²àºàº´àº àºàº´àº àº_àºàº±àº àºàº±àº àº_àº­àº±àºàºàº²àº àº­àº±àºàºàº²àº àº­àº_àºàº¸àº àºàº¸àº àº_àºàº°àº«àº±àº àºàº°àº«àº±àº àºàº«_àºªàº¸àº àºªàº¸àº àºªàº_à»àºªàº»àº² à»àºªàº»àº² àºª'.split('_'), i;
        for (i = 0; i < expected.length; i++) {
            assert.equal(moment([2011, 0, 2 + i]).format('dddd ddd dd'), expected[i], expected[i]);
        }
    });

    test('from', function (assert) {
        var start = moment([2007, 1, 28]);
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 44}), true),  'àºà»à»à»àºàº»à»àº²à»àºàº§àº´àºàº²àºàºµ', '44 seconds = a few seconds');
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 45}), true),  '1 àºàº²àºàºµ',      '45 seconds = a minute');
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 89}), true),  '1 àºàº²àºàºµ',      '89 seconds = a minute');
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 90}), true),  '2 àºàº²àºàºµ',     '90 seconds = 2 minutes');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 44}), true),  '44 àºàº²àºàºµ',    '44 minutes = 44 minutes');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 45}), true),  '1 àºàº»à»àº§à»àº¡àº',       '45 minutes = an hour');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 89}), true),  '1 àºàº»à»àº§à»àº¡àº',       '89 minutes = an hour');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 90}), true),  '2 àºàº»à»àº§à»àº¡àº',       '90 minutes = 2 hours');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 5}), true),   '5 àºàº»à»àº§à»àº¡àº',       '5 hours = 5 hours');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 21}), true),  '21 àºàº»à»àº§à»àº¡àº',      '21 hours = 21 hours');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 22}), true),  '1 àº¡àº·à»',         '22 hours = a day');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 35}), true),  '1 àº¡àº·à»',         '35 hours = a day');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 36}), true),  '2 àº¡àº·à»',        '36 hours = 2 days');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 1}), true),   '1 àº¡àº·à»',         '1 day = a day');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 5}), true),   '5 àº¡àº·à»',        '5 days = 5 days');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 25}), true),  '25 àº¡àº·à»',       '25 days = 25 days');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 26}), true),  '1 à»àºàº·àº­àº',       '26 days = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 30}), true),  '1 à»àºàº·àº­àº',       '30 days = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 43}), true),  '1 à»àºàº·àº­àº',       '43 days = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 46}), true),  '2 à»àºàº·àº­àº',      '46 days = 2 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 74}), true),  '2 à»àºàº·àº­àº',      '75 days = 2 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 76}), true),  '3 à»àºàº·àº­àº',      '76 days = 3 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({M: 1}), true),   '1 à»àºàº·àº­àº',       '1 month = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({M: 5}), true),   '5 à»àºàº·àº­àº',      '5 months = 5 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 345}), true), '1 àºàºµ',        '345 days = a year');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 548}), true), '2 àºàºµ',       '548 days = 2 years');
        assert.equal(start.from(moment([2007, 1, 28]).add({y: 1}), true),   '1 àºàºµ',        '1 year = a year');
        assert.equal(start.from(moment([2007, 1, 28]).add({y: 5}), true),   '5 àºàºµ',       '5 years = 5 years');
    });

    test('suffix', function (assert) {
        assert.equal(moment(30000).from(0), 'àº­àºµàº àºà»à»à»àºàº»à»àº²à»àºàº§àº´àºàº²àºàºµ',  'prefix');
        assert.equal(moment(0).from(30000), 'àºà»à»à»àºàº»à»àº²à»àºàº§àº´àºàº²àºàºµàºà»àº²àºàº¡àº²', 'suffix');
    });

    test('now from now', function (assert) {
        assert.equal(moment().fromNow(), 'àºà»à»à»àºàº»à»àº²à»àºàº§àº´àºàº²àºàºµàºà»àº²àºàº¡àº²',  'now from now should display as in the past');
    });

    test('fromNow', function (assert) {
        assert.equal(moment().add({s: 30}).fromNow(), 'àº­àºµàº àºà»à»à»àºàº»à»àº²à»àºàº§àº´àºàº²àºàºµ', 'in a few seconds');
        assert.equal(moment().add({d: 5}).fromNow(), 'àº­àºµàº 5 àº¡àº·à»', 'in 5 days');
    });

    test('calendar day', function (assert) {
        var a = moment().hours(12).minutes(0).seconds(0);

        assert.equal(moment(a).calendar(),                   'àº¡àº·à»àºàºµà»à»àº§àº¥àº² 12:00',    'today at the same time');
        assert.equal(moment(a).add({m: 25}).calendar(),      'àº¡àº·à»àºàºµà»à»àº§àº¥àº² 12:25',    'Now plus 25 min');
        assert.equal(moment(a).add({h: 1}).calendar(),       'àº¡àº·à»àºàºµà»à»àº§àº¥àº² 13:00',    'Now plus 1 hour');
        assert.equal(moment(a).add({d: 1}).calendar(),       'àº¡àº·à»àº­àº·à»àºà»àº§àº¥àº² 12:00',   'tomorrow at the same time');
        assert.equal(moment(a).subtract({h: 1}).calendar(),  'àº¡àº·à»àºàºµà»à»àº§àº¥àº² 11:00',    'Now minus 1 hour');
        assert.equal(moment(a).subtract({d: 1}).calendar(),  'àº¡àº·à»àº§àº²àºàºàºµà»à»àº§àº¥àº² 12:00',  'yesterday at the same time');
    });

    test('calendar next week', function (assert) {
        var i, m;
        for (i = 2; i < 7; i++) {
            m = moment().add({d: i});
            assert.equal(m.calendar(),       m.format('[àº§àº±àº]dddd[à»à»àº²à»àº§àº¥àº²] LT'),  'Today + ' + i + ' days current time');
            m.hours(0).minutes(0).seconds(0).milliseconds(0);
            assert.equal(m.calendar(),       m.format('[àº§àº±àº]dddd[à»à»àº²à»àº§àº¥àº²] LT'),  'Today + ' + i + ' days beginning of day');
            m.hours(23).minutes(59).seconds(59).milliseconds(999);
            assert.equal(m.calendar(),       m.format('[àº§àº±àº]dddd[à»à»àº²à»àº§àº¥àº²] LT'),  'Today + ' + i + ' days end of day');
        }
    });

    test('calendar last week', function (assert) {
        var i, m;

        for (i = 2; i < 7; i++) {
            m = moment().subtract({d: i});
            assert.equal(m.calendar(),       m.format('[àº§àº±àº]dddd[à»àº¥à»àº§àºàºµà»à»àº§àº¥àº²] LT'),  'Today - ' + i + ' days current time');
            m.hours(0).minutes(0).seconds(0).milliseconds(0);
            assert.equal(m.calendar(),       m.format('[àº§àº±àº]dddd[à»àº¥à»àº§àºàºµà»à»àº§àº¥àº²] LT'),  'Today - ' + i + ' days beginning of day');
            m.hours(23).minutes(59).seconds(59).milliseconds(999);
            assert.equal(m.calendar(),       m.format('[àº§àº±àº]dddd[à»àº¥à»àº§àºàºµà»à»àº§àº¥àº²] LT'),  'Today - ' + i + ' days end of day');
        }
    });

    test('calendar all else', function (assert) {
        var weeksAgo = moment().subtract({w: 1}),
            weeksFromNow = moment().add({w: 1});

        assert.equal(weeksAgo.calendar(),       weeksAgo.format('L'),  '1 week ago');
        assert.equal(weeksFromNow.calendar(),   weeksFromNow.format('L'),  'in 1 week');

        weeksAgo = moment().subtract({w: 2});
        weeksFromNow = moment().add({w: 2});

        assert.equal(weeksAgo.calendar(),       weeksAgo.format('L'),  '2 weeks ago');
        assert.equal(weeksFromNow.calendar(),   weeksFromNow.format('L'),  'in 2 weeks');
    });

    test('weeks year starting sunday format', function (assert) {
        assert.equal(moment([2012, 0,  1]).format('w ww wo'), '1 01 àºàºµà»1', 'Jan  1 2012 should be week 1');
        assert.equal(moment([2012, 0,  7]).format('w ww wo'), '1 01 àºàºµà»1', 'Jan  7 2012 should be week 1');
        assert.equal(moment([2012, 0,  8]).format('w ww wo'), '2 02 àºàºµà»2', 'Jan  8 2012 should be week 2');
        assert.equal(moment([2012, 0, 14]).format('w ww wo'), '2 02 àºàºµà»2', 'Jan 14 2012 should be week 2');
        assert.equal(moment([2012, 0, 15]).format('w ww wo'), '3 03 àºàºµà»3', 'Jan 15 2012 should be week 3');
    });

}));

;(function (global, factory) {
   typeof exports === 'object' && typeof module !== 'undefined'
       && typeof require === 'function' ? factory(require('../../moment')) :
   typeof define === 'function' && define.amd ? define(['../../moment'], factory) :
   factory(global.moment)
}(this, function (moment) { 'use strict';

    function each(array, callback) {
        var i;
        for (i = 0; i < array.length; i++) {
            callback(array[i], i, array);
        }
    }

    function objectKeys(obj) {
        if (Object.keys) {
            return Object.keys(obj);
        } else {
            // IE8
            var res = [], i;
            for (i in obj) {
                if (obj.hasOwnProperty(i)) {
                    res.push(i);
                }
            }
            return res;
        }
    }

    // Pick the first defined of two or three arguments.
    function defaults(a, b, c) {
        if (a != null) {
            return a;
        }
        if (b != null) {
            return b;
        }
        return c;
    }

    function defineCommonLocaleTests(locale, options) {
        test('lenient ordinal parsing', function (assert) {
            var i, ordinalStr, testMoment;
            for (i = 1; i <= 31; ++i) {
                ordinalStr = moment([2014, 0, i]).format('YYYY MM Do');
                testMoment = moment(ordinalStr, 'YYYY MM Do');
                assert.equal(testMoment.year(), 2014,
                        'lenient ordinal parsing ' + i + ' year check');
                assert.equal(testMoment.month(), 0,
                        'lenient ordinal parsing ' + i + ' month check');
                assert.equal(testMoment.date(), i,
                        'lenient ordinal parsing ' + i + ' date check');
            }
        });

        test('lenient ordinal parsing of number', function (assert) {
            var i, testMoment;
            for (i = 1; i <= 31; ++i) {
                testMoment = moment('2014 01 ' + i, 'YYYY MM Do');
                assert.equal(testMoment.year(), 2014,
                        'lenient ordinal parsing of number ' + i + ' year check');
                assert.equal(testMoment.month(), 0,
                        'lenient ordinal parsing of number ' + i + ' month check');
                assert.equal(testMoment.date(), i,
                        'lenient ordinal parsing of number ' + i + ' date check');
            }
        });

        test('strict ordinal parsing', function (assert) {
            var i, ordinalStr, testMoment;
            for (i = 1; i <= 31; ++i) {
                ordinalStr = moment([2014, 0, i]).format('YYYY MM Do');
                testMoment = moment(ordinalStr, 'YYYY MM Do', true);
                assert.ok(testMoment.isValid(), 'strict ordinal parsing ' + i);
            }
        });

        test('meridiem invariant', function (assert) {
            var h, m, t1, t2;
            for (h = 0; h < 24; ++h) {
                for (m = 0; m < 60; m += 15) {
                    t1 = moment.utc([2000, 0, 1, h, m]);
                    t2 = moment.utc(t1.format('A h:mm'), 'A h:mm');
                    assert.equal(t2.format('HH:mm'), t1.format('HH:mm'),
                            'meridiem at ' + t1.format('HH:mm'));
                }
            }
        });

        test('date format correctness', function (assert) {
            var data, tokens;
            data = moment.localeData()._longDateFormat;
            tokens = objectKeys(data);
            each(tokens, function (srchToken) {
                // Check each format string to make sure it does not contain any
                // tokens that need to be expanded.
                each(tokens, function (baseToken) {
                    // strip escaped sequences
                    var format = data[baseToken].replace(/(\[[^\]]*\])/g, '');
                    assert.equal(false, !!~format.indexOf(srchToken),
                            'contains ' + srchToken + ' in ' + baseToken);
                });
            });
        });

        test('month parsing correctness', function (assert) {
            var i, m;

            if (locale === 'tr') {
                // I can't fix it :(
                expect(0);
                return;
            }
            function tester(format) {
                var r;
                r = moment(m.format(format), format);
                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format);
                r = moment(m.format(format).toLocaleUpperCase(), format);
                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' upper');
                r = moment(m.format(format).toLocaleLowerCase(), format);
                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' lower');

                r = moment(m.format(format), format, true);
                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' strict');
                r = moment(m.format(format).toLocaleUpperCase(), format, true);
                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' upper strict');
                r = moment(m.format(format).toLocaleLowerCase(), format, true);
                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' lower strict');
            }

            for (i = 0; i < 12; ++i) {
                m = moment([2015, i, 15, 18]);
                tester('MMM');
                tester('MMM.');
                tester('MMMM');
                tester('MMMM.');
            }
        });

        test('weekday parsing correctness', function (assert) {
            var i, m;

            if (locale === 'tr' || locale === 'az') {
                // There is a lower-case letter (Ä±), that converted to upper then
                // lower changes to i
                expect(0);
                return;
            }
            function tester(format) {
                var r, baseMsg = 'weekday ' + m.weekday() + ' fmt ' + format;
                r = moment(m.format(format), format);
                assert.equal(r.weekday(), m.weekday(), baseMsg);
                r = moment(m.format(format).toLocaleUpperCase(), format);
                assert.equal(r.weekday(), m.weekday(), baseMsg + ' upper');
                r = moment(m.format(format).toLocaleLowerCase(), format);
                assert.equal(r.weekday(), m.weekday(), baseMsg + ' lower');

                r = moment(m.format(format), format, true);
                assert.equal(r.weekday(), m.weekday(), baseMsg + ' strict');
                r = moment(m.format(format).toLocaleUpperCase(), format, true);
                assert.equal(r.weekday(), m.weekday(), baseMsg + ' upper strict');
                r = moment(m.format(format).toLocaleLowerCase(), format, true);
                assert.equal(r.weekday(), m.weekday(), baseMsg + ' lower strict');
            }

            for (i = 0; i < 7; ++i) {
                m = moment.utc([2015, i, 15, 18]);
                tester('dd');
                tester('ddd');
                tester('dddd');
            }
        });
    }

    function setupDeprecationHandler(test, moment, scope) {
        test._expectedDeprecations = null;
        test._observedDeprecations = null;
        test._oldSupress = moment.suppressDeprecationWarnings;
        moment.suppressDeprecationWarnings = true;
        test.expectedDeprecations = function () {
            test._expectedDeprecations = arguments;
            test._observedDeprecations = [];
        };
        moment.deprecationHandler = function (name, msg) {
            var deprecationId = matchedDeprecation(name, msg, test._expectedDeprecations);
            if (deprecationId === -1) {
                throw new Error('Unexpected deprecation thrown name=' +
                        name + ' msg=' + msg);
            }
            test._observedDeprecations[deprecationId] = 1;
        };
    }

    function teardownDeprecationHandler(test, moment, scope) {
        moment.suppressDeprecationWarnings = test._oldSupress;

        if (test._expectedDeprecations != null) {
            var missedDeprecations = [];
            each(test._expectedDeprecations, function (deprecationPattern, id) {
                if (test._observedDeprecations[id] !== 1) {
                    missedDeprecations.push(deprecationPattern);
                }
            });
            if (missedDeprecations.length !== 0) {
                throw new Error('Expected deprecation warnings did not happen: ' +
                        missedDeprecations.join(' '));
            }
        }
    }

    function matchedDeprecation(name, msg, deprecations) {
        if (deprecations == null) {
            return -1;
        }
        for (var i = 0; i < deprecations.length; ++i) {
            if (name != null && name === deprecations[i]) {
                return i;
            }
            if (msg != null && msg.substring(0, deprecations[i].length) === deprecations[i]) {
                return i;
            }
        }
        return -1;
    }

    /*global QUnit:false*/

    var test = QUnit.test;

    var expect = QUnit.expect;

    function module (name, lifecycle) {
        QUnit.module(name, {
            setup : function () {
                moment.locale('en');
                moment.createFromInputFallback = function (config) {
                    throw new Error('input not handled by moment: ' + config._i);
                };
                setupDeprecationHandler(test, moment, 'core');
                if (lifecycle && lifecycle.setup) {
                    lifecycle.setup();
                }
            },
            teardown : function () {
                teardownDeprecationHandler(test, moment, 'core');
                if (lifecycle && lifecycle.teardown) {
                    lifecycle.teardown();
                }
            }
        });
    }

    function localeModule (name, lifecycle) {
        QUnit.module('locale:' + name, {
            setup : function () {
                moment.locale(name);
                moment.createFromInputFallback = function (config) {
                    throw new Error('input not handled by moment: ' + config._i);
                };
                setupDeprecationHandler(test, moment, 'locale');
                if (lifecycle && lifecycle.setup) {
                    lifecycle.setup();
                }
            },
            teardown : function () {
                moment.locale('en');
                teardownDeprecationHandler(test, moment, 'locale');
                if (lifecycle && lifecycle.teardown) {
                    lifecycle.teardown();
                }
            }
        });
        defineCommonLocaleTests(name, -1, -1);
    }

    localeModule('lt');

    test('parse', function (assert) {
        var tests = 'sausis sau_vasaris vas_kovas kov_balandis bal_geguÅ¾Ä geg_birÅ¾elis bir_liepa lie_rugpjÅ«tis rgp_rugsÄjis rgs_spalis spa_lapkritis lap_gruodis grd'.split('_'), i;
        function equalTest(input, mmm, i) {
            assert.equal(moment(input, mmm).month(), i, input + ' should be month ' + (i + 1));
        }
        for (i = 0; i < 12; i++) {
            tests[i] = tests[i].split(' ');
            equalTest(tests[i][0], 'MMM', i);
            equalTest(tests[i][1], 'MMM', i);
            equalTest(tests[i][0], 'MMMM', i);
            equalTest(tests[i][1], 'MMMM', i);
            equalTest(tests[i][0].toLocaleLowerCase(), 'MMMM', i);
            equalTest(tests[i][1].toLocaleLowerCase(), 'MMMM', i);
            equalTest(tests[i][0].toLocaleUpperCase(), 'MMMM', i);
            equalTest(tests[i][1].toLocaleUpperCase(), 'MMMM', i);
        }
    });

    test('format', function (assert) {
        var a = [
                ['dddd, Do MMMM YYYY, h:mm:ss a',      'sekmadienis, 14-oji vasario 2010, 3:25:50 pm'],
                ['ddd, hA',                            'Sek, 3PM'],
                ['M Mo MM MMMM MMM',                   '2 2-oji 02 vasaris vas'],
                ['YYYY YY',                            '2010 10'],
                ['D Do DD',                            '14 14-oji 14'],
                ['d do dddd ddd dd',                   '0 0-oji sekmadienis Sek S'],
                ['DDD DDDo DDDD',                      '45 45-oji 045'],
                ['w wo ww',                            '6 6-oji 06'],
                ['h hh',                               '3 03'],
                ['H HH',                               '15 15'],
                ['m mm',                               '25 25'],
                ['s ss',                               '50 50'],
                ['a A',                                'pm PM'],
                ['DDDo [metÅ³ diena]',                  '45-oji metÅ³ diena'],
                ['LTS',                                '15:25:50'],
                ['L',                                  '2010-02-14'],
                ['LL',                                 '2010 m. vasaris 14 d.'],
                ['LLL',                                '2010 m. vasaris 14 d., 15:25 val.'],
                ['LLLL',                               '2010 m. vasaris 14 d., sekmadienis, 15:25 val.'],
                ['l',                                  '2010-02-14'],
                ['ll',                                 '2010 m. vasaris 14 d.'],
                ['lll',                                '2010 m. vasaris 14 d., 15:25 val.'],
                ['llll',                               '2010 m. vasaris 14 d., Sek, 15:25 val.']
            ],
            b = moment(new Date(2010, 1, 14, 15, 25, 50, 125)),
            i;
        for (i = 0; i < a.length; i++) {
            assert.equal(b.format(a[i][0]), a[i][1], a[i][0] + ' ---> ' + a[i][1]);
        }
    });

    test('format ordinal', function (assert) {
        assert.equal(moment([2011, 0, 1]).format('DDDo'), '1-oji', '1-oji');
        assert.equal(moment([2011, 0, 2]).format('DDDo'), '2-oji', '2-oji');
        assert.equal(moment([2011, 0, 3]).format('DDDo'), '3-oji', '3-oji');
        assert.equal(moment([2011, 0, 4]).format('DDDo'), '4-oji', '4-oji');
        assert.equal(moment([2011, 0, 5]).format('DDDo'), '5-oji', '5-oji');
        assert.equal(moment([2011, 0, 6]).format('DDDo'), '6-oji', '6-oji');
        assert.equal(moment([2011, 0, 7]).format('DDDo'), '7-oji', '7-oji');
        assert.equal(moment([2011, 0, 8]).format('DDDo'), '8-oji', '8-oji');
        assert.equal(moment([2011, 0, 9]).format('DDDo'), '9-oji', '9-oji');
        assert.equal(moment([2011, 0, 10]).format('DDDo'), '10-oji', '10-oji');

        assert.equal(moment([2011, 0, 11]).format('DDDo'), '11-oji', '11-oji');
        assert.equal(moment([2011, 0, 12]).format('DDDo'), '12-oji', '12-oji');
        assert.equal(moment([2011, 0, 13]).format('DDDo'), '13-oji', '13-oji');
        assert.equal(moment([2011, 0, 14]).format('DDDo'), '14-oji', '14-oji');
        assert.equal(moment([2011, 0, 15]).format('DDDo'), '15-oji', '15-oji');
        assert.equal(moment([2011, 0, 16]).format('DDDo'), '16-oji', '16-oji');
        assert.equal(moment([2011, 0, 17]).format('DDDo'), '17-oji', '17-oji');
        assert.equal(moment([2011, 0, 18]).format('DDDo'), '18-oji', '18-oji');
        assert.equal(moment([2011, 0, 19]).format('DDDo'), '19-oji', '19-oji');
        assert.equal(moment([2011, 0, 20]).format('DDDo'), '20-oji', '20-oji');

        assert.equal(moment([2011, 0, 21]).format('DDDo'), '21-oji', '21-oji');
        assert.equal(moment([2011, 0, 22]).format('DDDo'), '22-oji', '22-oji');
        assert.equal(moment([2011, 0, 23]).format('DDDo'), '23-oji', '23-oji');
        assert.equal(moment([2011, 0, 24]).format('DDDo'), '24-oji', '24-oji');
        assert.equal(moment([2011, 0, 25]).format('DDDo'), '25-oji', '25-oji');
        assert.equal(moment([2011, 0, 26]).format('DDDo'), '26-oji', '26-oji');
        assert.equal(moment([2011, 0, 27]).format('DDDo'), '27-oji', '27-oji');
        assert.equal(moment([2011, 0, 28]).format('DDDo'), '28-oji', '28-oji');
        assert.equal(moment([2011, 0, 29]).format('DDDo'), '29-oji', '29-oji');
        assert.equal(moment([2011, 0, 30]).format('DDDo'), '30-oji', '30-oji');

        assert.equal(moment([2011, 0, 31]).format('DDDo'), '31-oji', '31-oji');
    });

    test('format month', function (assert) {
        var expected = 'sausis sau_vasaris vas_kovas kov_balandis bal_geguÅ¾Ä geg_birÅ¾elis bir_liepa lie_rugpjÅ«tis rgp_rugsÄjis rgs_spalis spa_lapkritis lap_gruodis grd'.split('_'), i;
        for (i = 0; i < expected.length; i++) {
            assert.equal(moment([2011, i, 1]).format('MMMM MMM'), expected[i], expected[i]);
        }
    });

    test('format week', function (assert) {
        var expected = 'sekmadienis Sek S_pirmadienis Pir P_antradienis Ant A_treÄiadienis Tre T_ketvirtadienis Ket K_penktadienis Pen Pn_Å¡eÅ¡tadienis Å eÅ¡ Å '.split('_'), i;
        for (i = 0; i < expected.length; i++) {
            assert.equal(moment([2011, 0, 2 + i]).format('dddd ddd dd'), expected[i], expected[i]);
        }
    });

    test('format week on US calendar', function (assert) {
        // Tests, whether the weekday names are correct, even if the week does not start on Monday
        moment.updateLocale('lt', {week: {dow: 0, doy: 6}});
        var expected = 'sekmadienis Sek S_pirmadienis Pir P_antradienis Ant A_treÄiadienis Tre T_ketvirtadienis Ket K_penktadienis Pen Pn_Å¡eÅ¡tadienis Å eÅ¡ Å '.split('_'), i;
        for (i = 0; i < expected.length; i++) {
            assert.equal(moment([2011, 0, 2 + i]).format('dddd ddd dd'), expected[i], expected[i]);
        }
        moment.updateLocale('lt', null);
    });

    test('from', function (assert) {
        var start = moment([2007, 1, 28]);
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 44}), true),  'kelios sekundÄs', '44 seconds = seconds');
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 45}), true),  'minutÄ',          '45 seconds = a minute');
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 89}), true),  'minutÄ',          '89 seconds = a minute');
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 90}), true),  '2 minutÄs',       '90 seconds = 2 minutes');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 10}), true),  '10 minuÄiÅ³',       '10 minutes = 10 minutes');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 11}), true),  '11 minuÄiÅ³',       '11 minutes = 11 minutes');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 19}), true),  '19 minuÄiÅ³',       '19 minutes = 19 minutes');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 20}), true),  '20 minuÄiÅ³',       '20 minutes = 20 minutes');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 44}), true),  '44 minutÄs',      '44 minutes = 44 minutes');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 45}), true),  'valanda',         '45 minutes = an hour');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 89}), true),  'valanda',         '89 minutes = an hour');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 90}), true),  '2 valandos',      '90 minutes = 2 hours');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 5}), true),   '5 valandos',      '5 hours = 5 hours');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 10}), true),  '10 valandÅ³',      '10 hours = 10 hours');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 21}), true),  '21 valandos',     '21 hours = 21 hours');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 22}), true),  'diena',           '22 hours = a day');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 35}), true),  'diena',           '35 hours = a day');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 36}), true),  '2 dienos',        '36 hours = 2 days');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 1}), true),   'diena',           '1 day = a day');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 5}), true),   '5 dienos',        '5 days = 5 days');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 10}), true),  '10 dienÅ³',        '10 days = 10 days');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 25}), true),  '25 dienos',       '25 days = 25 days');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 26}), true),  'mÄnuo',           '26 days = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 30}), true),  'mÄnuo',           '30 days = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 43}), true),  'mÄnuo',           '43 days = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 46}), true),  '2 mÄnesiai',      '46 days = 2 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 74}), true),  '2 mÄnesiai',      '75 days = 2 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 76}), true),  '3 mÄnesiai',      '76 days = 3 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({M: 1}), true),   'mÄnuo',           '1 month = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({M: 5}), true),   '5 mÄnesiai',      '5 months = 5 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({M: 10}), true),  '10 mÄnesiÅ³',      '10 months = 10 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 345}), true), 'metai',           '345 days = a year');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 548}), true), '2 metai',         '548 days = 2 years');
        assert.equal(start.from(moment([2007, 1, 28]).add({y: 1}), true),   'metai',           '1 year = a year');
        assert.equal(start.from(moment([2007, 1, 28]).add({y: 5}), true),   '5 metai',         '5 years = 5 years');
    });

    test('suffix', function (assert) {
        assert.equal(moment(30000).from(0), 'po keliÅ³ sekundÅ¾iÅ³',  'prefix');
        assert.equal(moment(0).from(30000), 'prieÅ¡ kelias sekundes', 'suffix');
    });

    test('now from now', function (assert) {
        assert.equal(moment().fromNow(), 'prieÅ¡ kelias sekundes',  'now from now should display as in the past');
    });

    test('fromNow', function (assert) {
        assert.equal(moment().add({s: 30}).fromNow(), 'po keliÅ³ sekundÅ¾iÅ³', 'in seconds');
        assert.equal(moment().add({d: 5}).fromNow(), 'po 5 dienÅ³', 'in 5 days');
    });

    test('calendar day', function (assert) {
        var a = moment().hours(12).minutes(0).seconds(0);

        assert.equal(moment(a).calendar(),                   'Å iandien 12:00',  'today at the same time');
        assert.equal(moment(a).add({m: 25}).calendar(),      'Å iandien 12:25',  'Now plus 25 min');
        assert.equal(moment(a).add({h: 1}).calendar(),       'Å iandien 13:00',  'Now plus 1 hour');
        assert.equal(moment(a).add({d: 1}).calendar(),       'Rytoj 12:00',     'tomorrow at the same time');
        assert.equal(moment(a).subtract({h: 1}).calendar(),  'Å iandien 11:00',  'Now minus 1 hour');
        assert.equal(moment(a).subtract({d: 1}).calendar(),  'Vakar 12:00',     'yesterday at the same time');
    });

    test('calendar next week', function (assert) {
        var i, m;
        for (i = 2; i < 7; i++) {
            m = moment().add({d: i});
            assert.equal(m.calendar(),       m.format('dddd LT'),  'Today + ' + i + ' days current time');
            m.hours(0).minutes(0).seconds(0).milliseconds(0);
            assert.equal(m.calendar(),       m.format('dddd LT'),  'Today + ' + i + ' days beginning of day');
            m.hours(23).minutes(59).seconds(59).milliseconds(999);
            assert.equal(m.calendar(),       m.format('dddd LT'),  'Today + ' + i + ' days end of day');
        }
    });

    test('calendar last week', function (assert) {
        var i, m;
        for (i = 2; i < 7; i++) {
            m = moment().subtract({d: i});
            assert.equal(m.calendar(),       m.format('[PraÄjusÄ¯] dddd LT'),  'Today - ' + i + ' days current time');
            m.hours(0).minutes(0).seconds(0).milliseconds(0);
            assert.equal(m.calendar(),       m.format('[PraÄjusÄ¯] dddd LT'),  'Today - ' + i + ' days beginning of day');
            m.hours(23).minutes(59).seconds(59).milliseconds(999);
            assert.equal(m.calendar(),       m.format('[PraÄjusÄ¯] dddd LT'),  'Today - ' + i + ' days end of day');
        }
    });

    test('calendar all else', function (assert) {
        var weeksAgo = moment().subtract({w: 1}),
            weeksFromNow = moment().add({w: 1});

        assert.equal(weeksAgo.calendar(),       weeksAgo.format('L'),  '1 week ago');
        assert.equal(weeksFromNow.calendar(),   weeksFromNow.format('L'),  'in 1 week');

        weeksAgo = moment().subtract({w: 2});
        weeksFromNow = moment().add({w: 2});

        assert.equal(weeksAgo.calendar(),       weeksAgo.format('L'),  '2 weeks ago');
        assert.equal(weeksFromNow.calendar(),   weeksFromNow.format('L'),  'in 2 weeks');
    });

    test('weeks year starting sunday formatted', function (assert) {
        assert.equal(moment([2012, 0,  1]).format('w ww wo'), '52 52 52-oji', 'Jan  1 2012 should be week 52');
        assert.equal(moment([2012, 0,  2]).format('w ww wo'),  '1 01 1-oji', 'Jan  2 2012 should be week 1');
        assert.equal(moment([2012, 0,  8]).format('w ww wo'),  '1 01 1-oji', 'Jan  8 2012 should be week 1');
        assert.equal(moment([2012, 0,  9]).format('w ww wo'),  '2 02 2-oji', 'Jan  9 2012 should be week 2');
        assert.equal(moment([2012, 0, 15]).format('w ww wo'),  '2 02 2-oji', 'Jan 15 2012 should be week 2');
    });

}));

;(function (global, factory) {
   typeof exports === 'object' && typeof module !== 'undefined'
       && typeof require === 'function' ? factory(require('../../moment')) :
   typeof define === 'function' && define.amd ? define(['../../moment'], factory) :
   factory(global.moment)
}(this, function (moment) { 'use strict';

    function each(array, callback) {
        var i;
        for (i = 0; i < array.length; i++) {
            callback(array[i], i, array);
        }
    }

    function objectKeys(obj) {
        if (Object.keys) {
            return Object.keys(obj);
        } else {
            // IE8
            var res = [], i;
            for (i in obj) {
                if (obj.hasOwnProperty(i)) {
                    res.push(i);
                }
            }
            return res;
        }
    }

    // Pick the first defined of two or three arguments.
    function defaults(a, b, c) {
        if (a != null) {
            return a;
        }
        if (b != null) {
            return b;
        }
        return c;
    }

    function defineCommonLocaleTests(locale, options) {
        test('lenient ordinal parsing', function (assert) {
            var i, ordinalStr, testMoment;
            for (i = 1; i <= 31; ++i) {
                ordinalStr = moment([2014, 0, i]).format('YYYY MM Do');
                testMoment = moment(ordinalStr, 'YYYY MM Do');
                assert.equal(testMoment.year(), 2014,
                        'lenient ordinal parsing ' + i + ' year check');
                assert.equal(testMoment.month(), 0,
                        'lenient ordinal parsing ' + i + ' month check');
                assert.equal(testMoment.date(), i,
                        'lenient ordinal parsing ' + i + ' date check');
            }
        });

        test('lenient ordinal parsing of number', function (assert) {
            var i, testMoment;
            for (i = 1; i <= 31; ++i) {
                testMoment = moment('2014 01 ' + i, 'YYYY MM Do');
                assert.equal(testMoment.year(), 2014,
                        'lenient ordinal parsing of number ' + i + ' year check');
                assert.equal(testMoment.month(), 0,
                        'lenient ordinal parsing of number ' + i + ' month check');
                assert.equal(testMoment.date(), i,
                        'lenient ordinal parsing of number ' + i + ' date check');
            }
        });

        test('strict ordinal parsing', function (assert) {
            var i, ordinalStr, testMoment;
            for (i = 1; i <= 31; ++i) {
                ordinalStr = moment([2014, 0, i]).format('YYYY MM Do');
                testMoment = moment(ordinalStr, 'YYYY MM Do', true);
                assert.ok(testMoment.isValid(), 'strict ordinal parsing ' + i);
            }
        });

        test('meridiem invariant', function (assert) {
            var h, m, t1, t2;
            for (h = 0; h < 24; ++h) {
                for (m = 0; m < 60; m += 15) {
                    t1 = moment.utc([2000, 0, 1, h, m]);
                    t2 = moment.utc(t1.format('A h:mm'), 'A h:mm');
                    assert.equal(t2.format('HH:mm'), t1.format('HH:mm'),
                            'meridiem at ' + t1.format('HH:mm'));
                }
            }
        });

        test('date format correctness', function (assert) {
            var data, tokens;
            data = moment.localeData()._longDateFormat;
            tokens = objectKeys(data);
            each(tokens, function (srchToken) {
                // Check each format string to make sure it does not contain any
                // tokens that need to be expanded.
                each(tokens, function (baseToken) {
                    // strip escaped sequences
                    var format = data[baseToken].replace(/(\[[^\]]*\])/g, '');
                    assert.equal(false, !!~format.indexOf(srchToken),
                            'contains ' + srchToken + ' in ' + baseToken);
                });
            });
        });

        test('month parsing correctness', function (assert) {
            var i, m;

            if (locale === 'tr') {
                // I can't fix it :(
                expect(0);
                return;
            }
            function tester(format) {
                var r;
                r = moment(m.format(format), format);
                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format);
                r = moment(m.format(format).toLocaleUpperCase(), format);
                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' upper');
                r = moment(m.format(format).toLocaleLowerCase(), format);
                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' lower');

                r = moment(m.format(format), format, true);
                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' strict');
                r = moment(m.format(format).toLocaleUpperCase(), format, true);
                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' upper strict');
                r = moment(m.format(format).toLocaleLowerCase(), format, true);
                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' lower strict');
            }

            for (i = 0; i < 12; ++i) {
                m = moment([2015, i, 15, 18]);
                tester('MMM');
                tester('MMM.');
                tester('MMMM');
                tester('MMMM.');
            }
        });

        test('weekday parsing correctness', function (assert) {
            var i, m;

            if (locale === 'tr' || locale === 'az') {
                // There is a lower-case letter (Ä±), that converted to upper then
                // lower changes to i
                expect(0);
                return;
            }
            function tester(format) {
                var r, baseMsg = 'weekday ' + m.weekday() + ' fmt ' + format;
                r = moment(m.format(format), format);
                assert.equal(r.weekday(), m.weekday(), baseMsg);
                r = moment(m.format(format).toLocaleUpperCase(), format);
                assert.equal(r.weekday(), m.weekday(), baseMsg + ' upper');
                r = moment(m.format(format).toLocaleLowerCase(), format);
                assert.equal(r.weekday(), m.weekday(), baseMsg + ' lower');

                r = moment(m.format(format), format, true);
                assert.equal(r.weekday(), m.weekday(), baseMsg + ' strict');
                r = moment(m.format(format).toLocaleUpperCase(), format, true);
                assert.equal(r.weekday(), m.weekday(), baseMsg + ' upper strict');
                r = moment(m.format(format).toLocaleLowerCase(), format, true);
                assert.equal(r.weekday(), m.weekday(), baseMsg + ' lower strict');
            }

            for (i = 0; i < 7; ++i) {
                m = moment.utc([2015, i, 15, 18]);
                tester('dd');
                tester('ddd');
                tester('dddd');
            }
        });
    }

    function setupDeprecationHandler(test, moment, scope) {
        test._expectedDeprecations = null;
        test._observedDeprecations = null;
        test._oldSupress = moment.suppressDeprecationWarnings;
        moment.suppressDeprecationWarnings = true;
        test.expectedDeprecations = function () {
            test._expectedDeprecations = arguments;
            test._observedDeprecations = [];
        };
        moment.deprecationHandler = function (name, msg) {
            var deprecationId = matchedDeprecation(name, msg, test._expectedDeprecations);
            if (deprecationId === -1) {
                throw new Error('Unexpected deprecation thrown name=' +
                        name + ' msg=' + msg);
            }
            test._observedDeprecations[deprecationId] = 1;
        };
    }

    function teardownDeprecationHandler(test, moment, scope) {
        moment.suppressDeprecationWarnings = test._oldSupress;

        if (test._expectedDeprecations != null) {
            var missedDeprecations = [];
            each(test._expectedDeprecations, function (deprecationPattern, id) {
                if (test._observedDeprecations[id] !== 1) {
                    missedDeprecations.push(deprecationPattern);
                }
            });
            if (missedDeprecations.length !== 0) {
                throw new Error('Expected deprecation warnings did not happen: ' +
                        missedDeprecations.join(' '));
            }
        }
    }

    function matchedDeprecation(name, msg, deprecations) {
        if (deprecations == null) {
            return -1;
        }
        for (var i = 0; i < deprecations.length; ++i) {
            if (name != null && name === deprecations[i]) {
                return i;
            }
            if (msg != null && msg.substring(0, deprecations[i].length) === deprecations[i]) {
                return i;
            }
        }
        return -1;
    }

    /*global QUnit:false*/

    var test = QUnit.test;

    var expect = QUnit.expect;

    function module (name, lifecycle) {
        QUnit.module(name, {
            setup : function () {
                moment.locale('en');
                moment.createFromInputFallback = function (config) {
                    throw new Error('input not handled by moment: ' + config._i);
                };
                setupDeprecationHandler(test, moment, 'core');
                if (lifecycle && lifecycle.setup) {
                    lifecycle.setup();
                }
            },
            teardown : function () {
                teardownDeprecationHandler(test, moment, 'core');
                if (lifecycle && lifecycle.teardown) {
                    lifecycle.teardown();
                }
            }
        });
    }

    function localeModule (name, lifecycle) {
        QUnit.module('locale:' + name, {
            setup : function () {
                moment.locale(name);
                moment.createFromInputFallback = function (config) {
                    throw new Error('input not handled by moment: ' + config._i);
                };
                setupDeprecationHandler(test, moment, 'locale');
                if (lifecycle && lifecycle.setup) {
                    lifecycle.setup();
                }
            },
            teardown : function () {
                moment.locale('en');
                teardownDeprecationHandler(test, moment, 'locale');
                if (lifecycle && lifecycle.teardown) {
                    lifecycle.teardown();
                }
            }
        });
        defineCommonLocaleTests(name, -1, -1);
    }

    localeModule('lv');

    test('parse', function (assert) {
        var tests = 'janvÄris jan_februÄris feb_marts mar_aprÄ«lis apr_maijs mai_jÅ«nijs jÅ«n_jÅ«lijs jÅ«l_augusts aug_septembris sep_oktobris okt_novembris nov_decembris dec'.split('_'), i;
        function equalTest(input, mmm, i) {
            assert.equal(moment(input, mmm).month(), i, input + ' should be month ' + (i + 1));
        }
        for (i = 0; i < 12; i++) {
            tests[i] = tests[i].split(' ');
            equalTest(tests[i][0], 'MMM', i);
            equalTest(tests[i][1], 'MMM', i);
            equalTest(tests[i][0], 'MMMM', i);
            equalTest(tests[i][1], 'MMMM', i);
            equalTest(tests[i][0].toLocaleLowerCase(), 'MMMM', i);
            equalTest(tests[i][1].toLocaleLowerCase(), 'MMMM', i);
            equalTest(tests[i][0].toLocaleUpperCase(), 'MMMM', i);
            equalTest(tests[i][1].toLocaleUpperCase(), 'MMMM', i);
        }
    });

    test('format', function (assert) {
        var a = [
                ['dddd, Do MMMM YYYY, h:mm:ss a',      'svÄtdiena, 14. februÄris 2010, 3:25:50 pm'],
                ['ddd, hA',                            'Sv, 3PM'],
                ['M Mo MM MMMM MMM',                   '2 2. 02 februÄris feb'],
                ['YYYY YY',                            '2010 10'],
                ['D Do DD',                            '14 14. 14'],
                ['d do dddd ddd dd',                   '0 0. svÄtdiena Sv Sv'],
                ['DDD DDDo DDDD',                      '45 45. 045'],
                ['w wo ww',                            '6 6. 06'],
                ['h hh',                               '3 03'],
                ['H HH',                               '15 15'],
                ['m mm',                               '25 25'],
                ['s ss',                               '50 50'],
                ['a A',                                'pm PM'],
                ['[the] DDDo [day of the year]',       'the 45. day of the year'],
                ['LTS',                                '15:25:50'],
                ['L',                                  '14.02.2010.'],
                ['LL',                                 '2010. gada 14. februÄris'],
                ['LLL',                                '2010. gada 14. februÄris, 15:25'],
                ['LLLL',                               '2010. gada 14. februÄris, svÄtdiena, 15:25'],
                ['l',                                  '14.2.2010.'],
                ['ll',                                 '2010. gada 14. feb'],
                ['lll',                                '2010. gada 14. feb, 15:25'],
                ['llll',                               '2010. gada 14. feb, Sv, 15:25']
            ],
            b = moment(new Date(2010, 1, 14, 15, 25, 50, 125)),
            i;
        for (i = 0; i < a.length; i++) {
            assert.equal(b.format(a[i][0]), a[i][1], a[i][0] + ' ---> ' + a[i][1]);
        }
    });

    test('format ordinal', function (assert) {
        assert.equal(moment([2011, 0, 1]).format('DDDo'), '1.', '1.');
        assert.equal(moment([2011, 0, 2]).format('DDDo'), '2.', '2.');
        assert.equal(moment([2011, 0, 3]).format('DDDo'), '3.', '3.');
        assert.equal(moment([2011, 0, 4]).format('DDDo'), '4.', '4.');
        assert.equal(moment([2011, 0, 5]).format('DDDo'), '5.', '5.');
        assert.equal(moment([2011, 0, 6]).format('DDDo'), '6.', '6.');
        assert.equal(moment([2011, 0, 7]).format('DDDo'), '7.', '7.');
        assert.equal(moment([2011, 0, 8]).format('DDDo'), '8.', '8.');
        assert.equal(moment([2011, 0, 9]).format('DDDo'), '9.', '9.');
        assert.equal(moment([2011, 0, 10]).format('DDDo'), '10.', '10.');

        assert.equal(moment([2011, 0, 11]).format('DDDo'), '11.', '11.');
        assert.equal(moment([2011, 0, 12]).format('DDDo'), '12.', '12.');
        assert.equal(moment([2011, 0, 13]).format('DDDo'), '13.', '13.');
        assert.equal(moment([2011, 0, 14]).format('DDDo'), '14.', '14.');
        assert.equal(moment([2011, 0, 15]).format('DDDo'), '15.', '15.');
        assert.equal(moment([2011, 0, 16]).format('DDDo'), '16.', '16.');
        assert.equal(moment([2011, 0, 17]).format('DDDo'), '17.', '17.');
        assert.equal(moment([2011, 0, 18]).format('DDDo'), '18.', '18.');
        assert.equal(moment([2011, 0, 19]).format('DDDo'), '19.', '19.');
        assert.equal(moment([2011, 0, 20]).format('DDDo'), '20.', '20.');

        assert.equal(moment([2011, 0, 21]).format('DDDo'), '21.', '21.');
        assert.equal(moment([2011, 0, 22]).format('DDDo'), '22.', '22.');
        assert.equal(moment([2011, 0, 23]).format('DDDo'), '23.', '23.');
        assert.equal(moment([2011, 0, 24]).format('DDDo'), '24.', '24.');
        assert.equal(moment([2011, 0, 25]).format('DDDo'), '25.', '25.');
        assert.equal(moment([2011, 0, 26]).format('DDDo'), '26.', '26.');
        assert.equal(moment([2011, 0, 27]).format('DDDo'), '27.', '27.');
        assert.equal(moment([2011, 0, 28]).format('DDDo'), '28.', '28.');
        assert.equal(moment([2011, 0, 29]).format('DDDo'), '29.', '29.');
        assert.equal(moment([2011, 0, 30]).format('DDDo'), '30.', '30.');

        assert.equal(moment([2011, 0, 31]).format('DDDo'), '31.', '31.');
    });

    test('format month', function (assert) {
        var expected = 'janvÄris jan_februÄris feb_marts mar_aprÄ«lis apr_maijs mai_jÅ«nijs jÅ«n_jÅ«lijs jÅ«l_augusts aug_septembris sep_oktobris okt_novembris nov_decembris dec'.split('_'), i;
        for (i = 0; i < expected.length; i++) {
            assert.equal(moment([2011, i, 1]).format('MMMM MMM'), expected[i], expected[i]);
        }
    });

    test('format week', function (assert) {
        var expected = 'svÄtdiena Sv Sv_pirmdiena P P_otrdiena O O_treÅ¡diena T T_ceturtdiena C C_piektdiena Pk Pk_sestdiena S S'.split('_'), i;
        for (i = 0; i < expected.length; i++) {
            assert.equal(moment([2011, 0, 2 + i]).format('dddd ddd dd'), expected[i], expected[i]);
        }
    });

    // Includes testing the cases of withoutSuffix = true and false.
    test('from', function (assert) {
        var start = moment([2007, 1, 28]);
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 44}), true),   'daÅ¾as sekundes',       '44 seconds = seconds');
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 44}), false),  'pirms daÅ¾Äm sekundÄm', '44 seconds with suffix = seconds ago');
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 45}), true),   'minÅ«te',               '45 seconds = a minute');
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 45}), false),  'pirms minÅ«tes',        '45 seconds with suffix = a minute ago');
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 89}), true),   'minÅ«te',               '89 seconds = a minute');
        assert.equal(start.from(moment([2007, 1, 28]).add({s: -89}), false), 'pÄc minÅ«tes',          '89 seconds with suffix/prefix = in a minute');
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 90}), true),   '2 minÅ«tes',            '90 seconds = 2 minutes');
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 90}), false),  'pirms 2 minÅ«tÄm',      '90 seconds with suffix = 2 minutes ago');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 44}), true),   '44 minÅ«tes',           '44 minutes = 44 minutes');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 44}), false),  'pirms 44 minÅ«tÄm',     '44 minutes with suffix = 44 minutes ago');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 45}), true),   'stunda',               '45 minutes = an hour');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 45}), false),  'pirms stundas',        '45 minutes with suffix = an hour ago');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 89}), true),   'stunda',               '89 minutes = an hour');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 90}), true),   '2 stundas',            '90 minutes = 2 hours');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: -90}), false), 'pÄc 2 stundÄm',        '90 minutes with suffix = in 2 hours');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 5}), true),    '5 stundas',            '5 hours = 5 hours');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 5}), false),   'pirms 5 stundÄm',      '5 hours with suffix = 5 hours ago');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 21}), true),   '21 stunda',            '21 hours = 21 hours');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 21}), false),  'pirms 21 stundas',     '21 hours with suffix = 21 hours ago');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 22}), true),   'diena',                '22 hours = a day');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 22}), false),  'pirms dienas',         '22 hours with suffix = a day ago');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 35}), true),   'diena',                '35 hours = a day');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 36}), true),   '2 dienas',             '36 hours = 2 days');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 36}), false),  'pirms 2 dienÄm',       '36 hours with suffix = 2 days ago');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 1}), true),    'diena',                '1 day = a day');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 5}), true),    '5 dienas',             '5 days = 5 days');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 5}), false),   'pirms 5 dienÄm',       '5 days with suffix = 5 days ago');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 25}), true),   '25 dienas',            '25 days = 25 days');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 25}), false),  'pirms 25 dienÄm',      '25 days with suffix = 25 days ago');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 26}), true),   'mÄnesis',              '26 days = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 26}), false),  'pirms mÄneÅ¡a',         '26 days with suffix = a month ago');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 30}), true),   'mÄnesis',              '30 days = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 43}), true),   'mÄnesis',              '43 days = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 46}), true),   '2 mÄneÅ¡i',             '46 days = 2 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 46}), false),  'pirms 2 mÄneÅ¡iem',     '46 days with suffix = 2 months ago');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 74}), true),   '2 mÄneÅ¡i',             '75 days = 2 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 76}), true),   '3 mÄneÅ¡i',             '76 days = 3 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 76}), false),  'pirms 3 mÄneÅ¡iem',     '76 days with suffix = 3 months ago');
        assert.equal(start.from(moment([2007, 1, 28]).add({M: 1}), true),    'mÄnesis',              '1 month = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({M: 5}), true),    '5 mÄneÅ¡i',             '5 months = 5 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({M: 5}), false),   'pirms 5 mÄneÅ¡iem',     '5 months with suffix = 5 months ago');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 345}), true),  'gads',                 '345 days = a year');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 345}), false), 'pirms gada',           '345 days with suffix = a year ago');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 548}), true),  '2 gadi',               '548 days = 2 years');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 548}), false), 'pirms 2 gadiem',       '548 days with suffix = 2 years ago');
        assert.equal(start.from(moment([2007, 1, 28]).add({y: 1}), true),    'gads',                 '1 year = a year');
        assert.equal(start.from(moment([2007, 1, 28]).add({y: 5}), true),    '5 gadi',               '5 years = 5 years');
        assert.equal(start.from(moment([2007, 1, 28]).add({y: 5}), false),   'pirms 5 gadiem',       '5 years with suffix = 5 years ago');
    });

    test('suffix', function (assert) {
        assert.equal(moment(30000).from(0), 'pÄc daÅ¾Äm sekundÄm',  'prefix');
        assert.equal(moment(0).from(30000), 'pirms daÅ¾Äm sekundÄm', 'suffix');
    });

    test('now from now', function (assert) {
        assert.equal(moment().fromNow(), 'pirms daÅ¾Äm sekundÄm',  'now from now should display as in the past');
    });

    test('fromNow', function (assert) {
        assert.equal(moment().add({s: 30}).fromNow(), 'pÄc daÅ¾Äm sekundÄm', 'in seconds');
        assert.equal(moment().add({d: 5}).fromNow(), 'pÄc 5 dienÄm', 'in 5 days');
    });

    test('calendar day', function (assert) {
        var a = moment().hours(12).minutes(0).seconds(0);

        assert.equal(moment(a).calendar(),                   'Å odien pulksten 12:00',  'today at the same time');
        assert.equal(moment(a).add({m: 25}).calendar(),      'Å odien pulksten 12:25',  'Now plus 25 min');
        assert.equal(moment(a).add({h: 1}).calendar(),       'Å odien pulksten 13:00',  'Now plus 1 hour');
        assert.equal(moment(a).add({d: 1}).calendar(),       'RÄ«t pulksten 12:00',     'tomorrow at the same time');
        assert.equal(moment(a).subtract({h: 1}).calendar(),  'Å odien pulksten 11:00',  'Now minus 1 hour');
        assert.equal(moment(a).subtract({d: 1}).calendar(),  'Vakar pulksten 12:00',   'yesterday at the same time');
    });

    test('calendar next week', function (assert) {
        var i, m;
        for (i = 2; i < 7; i++) {
            m = moment().add({d: i});
            assert.equal(m.calendar(),       m.format('dddd [pulksten] LT'),  'Today + ' + i + ' days current time');
            m.hours(0).minutes(0).seconds(0).milliseconds(0);
            assert.equal(m.calendar(),       m.format('dddd [pulksten] LT'),  'Today + ' + i + ' days beginning of day');
            m.hours(23).minutes(59).seconds(59).milliseconds(999);
            assert.equal(m.calendar(),       m.format('dddd [pulksten] LT'),  'Today + ' + i + ' days end of day');
        }
    });

    test('calendar last week', function (assert) {
        var i, m;
        for (i = 2; i < 7; i++) {
            m = moment().subtract({d: i});
            assert.equal(m.calendar(),       m.format('[PagÄjuÅ¡Ä] dddd [pulksten] LT'),  'Today - ' + i + ' days current time');
            m.hours(0).minutes(0).seconds(0).milliseconds(0);
            assert.equal(m.calendar(),       m.format('[PagÄjuÅ¡Ä] dddd [pulksten] LT'),  'Today - ' + i + ' days beginning of day');
            m.hours(23).minutes(59).seconds(59).milliseconds(999);
            assert.equal(m.calendar(),       m.format('[PagÄjuÅ¡Ä] dddd [pulksten] LT'),  'Today - ' + i + ' days end of day');
        }
    });

    test('calendar all else', function (assert) {
        var weeksAgo = moment().subtract({w: 1}),
            weeksFromNow = moment().add({w: 1});

        assert.equal(weeksAgo.calendar(),       weeksAgo.format('L'),  '1 week ago');
        assert.equal(weeksFromNow.calendar(),   weeksFromNow.format('L'),  'in 1 week');

        weeksAgo = moment().subtract({w: 2});
        weeksFromNow = moment().add({w: 2});

        assert.equal(weeksAgo.calendar(),       weeksAgo.format('L'),  '2 weeks ago');
        assert.equal(weeksFromNow.calendar(),   weeksFromNow.format('L'),  'in 2 weeks');
    });

    test('weeks year starting sunday formatted', function (assert) {
        assert.equal(moment([2012, 0,  1]).format('w ww wo'), '52 52 52.', 'Jan  1 2012 should be week 52');
        assert.equal(moment([2012, 0,  2]).format('w ww wo'),  '1 01 1.', 'Jan  2 2012 should be week 1');
        assert.equal(moment([2012, 0,  8]).format('w ww wo'),  '1 01 1.', 'Jan  8 2012 should be week 1');
        assert.equal(moment([2012, 0,  9]).format('w ww wo'),  '2 02 2.', 'Jan  9 2012 should be week 2');
        assert.equal(moment([2012, 0, 15]).format('w ww wo'),  '2 02 2.', 'Jan 15 2012 should be week 2');
    });

}));

;(function (global, factory) {
   typeof exports === 'object' && typeof module !== 'undefined'
       && typeof require === 'function' ? factory(require('../../moment')) :
   typeof define === 'function' && define.amd ? define(['../../moment'], factory) :
   factory(global.moment)
}(this, function (moment) { 'use strict';

    function each(array, callback) {
        var i;
        for (i = 0; i < array.length; i++) {
            callback(array[i], i, array);
        }
    }

    function objectKeys(obj) {
        if (Object.keys) {
            return Object.keys(obj);
        } else {
            // IE8
            var res = [], i;
            for (i in obj) {
                if (obj.hasOwnProperty(i)) {
                    res.push(i);
                }
            }
            return res;
        }
    }

    // Pick the first defined of two or three arguments.
    function defaults(a, b, c) {
        if (a != null) {
            return a;
        }
        if (b != null) {
            return b;
        }
        return c;
    }

    function defineCommonLocaleTests(locale, options) {
        test('lenient ordinal parsing', function (assert) {
            var i, ordinalStr, testMoment;
            for (i = 1; i <= 31; ++i) {
                ordinalStr = moment([2014, 0, i]).format('YYYY MM Do');
                testMoment = moment(ordinalStr, 'YYYY MM Do');
                assert.equal(testMoment.year(), 2014,
                        'lenient ordinal parsing ' + i + ' year check');
                assert.equal(testMoment.month(), 0,
                        'lenient ordinal parsing ' + i + ' month check');
                assert.equal(testMoment.date(), i,
                        'lenient ordinal parsing ' + i + ' date check');
            }
        });

        test('lenient ordinal parsing of number', function (assert) {
            var i, testMoment;
            for (i = 1; i <= 31; ++i) {
                testMoment = moment('2014 01 ' + i, 'YYYY MM Do');
                assert.equal(testMoment.year(), 2014,
                        'lenient ordinal parsing of number ' + i + ' year check');
                assert.equal(testMoment.month(), 0,
                        'lenient ordinal parsing of number ' + i + ' month check');
                assert.equal(testMoment.date(), i,
                        'lenient ordinal parsing of number ' + i + ' date check');
            }
        });

        test('strict ordinal parsing', function (assert) {
            var i, ordinalStr, testMoment;
            for (i = 1; i <= 31; ++i) {
                ordinalStr = moment([2014, 0, i]).format('YYYY MM Do');
                testMoment = moment(ordinalStr, 'YYYY MM Do', true);
                assert.ok(testMoment.isValid(), 'strict ordinal parsing ' + i);
            }
        });

        test('meridiem invariant', function (assert) {
            var h, m, t1, t2;
            for (h = 0; h < 24; ++h) {
                for (m = 0; m < 60; m += 15) {
                    t1 = moment.utc([2000, 0, 1, h, m]);
                    t2 = moment.utc(t1.format('A h:mm'), 'A h:mm');
                    assert.equal(t2.format('HH:mm'), t1.format('HH:mm'),
                            'meridiem at ' + t1.format('HH:mm'));
                }
            }
        });

        test('date format correctness', function (assert) {
            var data, tokens;
            data = moment.localeData()._longDateFormat;
            tokens = objectKeys(data);
            each(tokens, function (srchToken) {
                // Check each format string to make sure it does not contain any
                // tokens that need to be expanded.
                each(tokens, function (baseToken) {
                    // strip escaped sequences
                    var format = data[baseToken].replace(/(\[[^\]]*\])/g, '');
                    assert.equal(false, !!~format.indexOf(srchToken),
                            'contains ' + srchToken + ' in ' + baseToken);
                });
            });
        });

        test('month parsing correctness', function (assert) {
            var i, m;

            if (locale === 'tr') {
                // I can't fix it :(
                expect(0);
                return;
            }
            function tester(format) {
                var r;
                r = moment(m.format(format), format);
                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format);
                r = moment(m.format(format).toLocaleUpperCase(), format);
                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' upper');
                r = moment(m.format(format).toLocaleLowerCase(), format);
                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' lower');

                r = moment(m.format(format), format, true);
                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' strict');
                r = moment(m.format(format).toLocaleUpperCase(), format, true);
                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' upper strict');
                r = moment(m.format(format).toLocaleLowerCase(), format, true);
                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' lower strict');
            }

            for (i = 0; i < 12; ++i) {
                m = moment([2015, i, 15, 18]);
                tester('MMM');
                tester('MMM.');
                tester('MMMM');
                tester('MMMM.');
            }
        });

        test('weekday parsing correctness', function (assert) {
            var i, m;

            if (locale === 'tr' || locale === 'az') {
                // There is a lower-case letter (Ä±), that converted to upper then
                // lower changes to i
                expect(0);
                return;
            }
            function tester(format) {
                var r, baseMsg = 'weekday ' + m.weekday() + ' fmt ' + format;
                r = moment(m.format(format), format);
                assert.equal(r.weekday(), m.weekday(), baseMsg);
                r = moment(m.format(format).toLocaleUpperCase(), format);
                assert.equal(r.weekday(), m.weekday(), baseMsg + ' upper');
                r = moment(m.format(format).toLocaleLowerCase(), format);
                assert.equal(r.weekday(), m.weekday(), baseMsg + ' lower');

                r = moment(m.format(format), format, true);
                assert.equal(r.weekday(), m.weekday(), baseMsg + ' strict');
                r = moment(m.format(format).toLocaleUpperCase(), format, true);
                assert.equal(r.weekday(), m.weekday(), baseMsg + ' upper strict');
                r = moment(m.format(format).toLocaleLowerCase(), format, true);
                assert.equal(r.weekday(), m.weekday(), baseMsg + ' lower strict');
            }

            for (i = 0; i < 7; ++i) {
                m = moment.utc([2015, i, 15, 18]);
                tester('dd');
                tester('ddd');
                tester('dddd');
            }
        });
    }

    function setupDeprecationHandler(test, moment, scope) {
        test._expectedDeprecations = null;
        test._observedDeprecations = null;
        test._oldSupress = moment.suppressDeprecationWarnings;
        moment.suppressDeprecationWarnings = true;
        test.expectedDeprecations = function () {
            test._expectedDeprecations = arguments;
            test._observedDeprecations = [];
        };
        moment.deprecationHandler = function (name, msg) {
            var deprecationId = matchedDeprecation(name, msg, test._expectedDeprecations);
            if (deprecationId === -1) {
                throw new Error('Unexpected deprecation thrown name=' +
                        name + ' msg=' + msg);
            }
            test._observedDeprecations[deprecationId] = 1;
        };
    }

    function teardownDeprecationHandler(test, moment, scope) {
        moment.suppressDeprecationWarnings = test._oldSupress;

        if (test._expectedDeprecations != null) {
            var missedDeprecations = [];
            each(test._expectedDeprecations, function (deprecationPattern, id) {
                if (test._observedDeprecations[id] !== 1) {
                    missedDeprecations.push(deprecationPattern);
                }
            });
            if (missedDeprecations.length !== 0) {
                throw new Error('Expected deprecation warnings did not happen: ' +
                        missedDeprecations.join(' '));
            }
        }
    }

    function matchedDeprecation(name, msg, deprecations) {
        if (deprecations == null) {
            return -1;
        }
        for (var i = 0; i < deprecations.length; ++i) {
            if (name != null && name === deprecations[i]) {
                return i;
            }
            if (msg != null && msg.substring(0, deprecations[i].length) === deprecations[i]) {
                return i;
            }
        }
        return -1;
    }

    /*global QUnit:false*/

    var test = QUnit.test;

    var expect = QUnit.expect;

    function module (name, lifecycle) {
        QUnit.module(name, {
            setup : function () {
                moment.locale('en');
                moment.createFromInputFallback = function (config) {
                    throw new Error('input not handled by moment: ' + config._i);
                };
                setupDeprecationHandler(test, moment, 'core');
                if (lifecycle && lifecycle.setup) {
                    lifecycle.setup();
                }
            },
            teardown : function () {
                teardownDeprecationHandler(test, moment, 'core');
                if (lifecycle && lifecycle.teardown) {
                    lifecycle.teardown();
                }
            }
        });
    }

    function localeModule (name, lifecycle) {
        QUnit.module('locale:' + name, {
            setup : function () {
                moment.locale(name);
                moment.createFromInputFallback = function (config) {
                    throw new Error('input not handled by moment: ' + config._i);
                };
                setupDeprecationHandler(test, moment, 'locale');
                if (lifecycle && lifecycle.setup) {
                    lifecycle.setup();
                }
            },
            teardown : function () {
                moment.locale('en');
                teardownDeprecationHandler(test, moment, 'locale');
                if (lifecycle && lifecycle.teardown) {
                    lifecycle.teardown();
                }
            }
        });
        defineCommonLocaleTests(name, -1, -1);
    }

    localeModule('me');

    test('parse', function (assert) {
        var tests = 'januar jan._februar feb._mart mar._april apr._maj maj_jun jun_jul jul_avgust avg._septembar sep._oktobar okt._novembar nov._decembar dec.'.split('_'),
            i;
        function equalTest(input, mmm, i) {
            assert.equal(moment(input, mmm).month(), i, input + ' should be month ' + (i + 1));
        }
        for (i = 0; i < 12; i++) {
            tests[i] = tests[i].split(' ');
            equalTest(tests[i][0], 'MMM', i);
            equalTest(tests[i][1], 'MMM', i);
            equalTest(tests[i][0], 'MMMM', i);
            equalTest(tests[i][1], 'MMMM', i);
            equalTest(tests[i][0].toLocaleLowerCase(), 'MMMM', i);
            equalTest(tests[i][1].toLocaleLowerCase(), 'MMMM', i);
            equalTest(tests[i][0].toLocaleUpperCase(), 'MMMM', i);
            equalTest(tests[i][1].toLocaleUpperCase(), 'MMMM', i);
        }
    });

    test('format', function (assert) {
        var a = [
                ['dddd, Do MMMM YYYY, h:mm:ss a',      'nedjelja, 14. februar 2010, 3:25:50 pm'],
                ['ddd, hA',                            'ned., 3PM'],
                ['M Mo MM MMMM MMM',                   '2 2. 02 februar feb.'],
                ['YYYY YY',                            '2010 10'],
                ['D Do DD',                            '14 14. 14'],
                ['d do dddd ddd dd',                   '0 0. nedjelja ned. ne'],
                ['DDD DDDo DDDD',                      '45 45. 045'],
                ['w wo ww',                            '7 7. 07'],
                ['h hh',                               '3 03'],
                ['H HH',                               '15 15'],
                ['m mm',                               '25 25'],
                ['s ss',                               '50 50'],
                ['a A',                                'pm PM'],
                ['[the] DDDo [day of the year]',       'the 45. day of the year'],
                ['LTS',                                '15:25:50'],
                ['L',                                  '14. 02. 2010'],
                ['LL',                                 '14. februar 2010'],
                ['LLL',                                '14. februar 2010 15:25'],
                ['LLLL',                               'nedjelja, 14. februar 2010 15:25'],
                ['l',                                  '14. 2. 2010'],
                ['ll',                                 '14. feb. 2010'],
                ['lll',                                '14. feb. 2010 15:25'],
                ['llll',                               'ned., 14. feb. 2010 15:25']
            ],
            b = moment(new Date(2010, 1, 14, 15, 25, 50, 125)),
            i;
        for (i = 0; i < a.length; i++) {
            assert.equal(b.format(a[i][0]), a[i][1], a[i][0] + ' ---> ' + a[i][1]);
        }
    });

    test('format ordinal', function (assert) {
        assert.equal(moment([2011, 0, 1]).format('DDDo'), '1.', '1.');
        assert.equal(moment([2011, 0, 2]).format('DDDo'), '2.', '2.');
        assert.equal(moment([2011, 0, 3]).format('DDDo'), '3.', '3.');
        assert.equal(moment([2011, 0, 4]).format('DDDo'), '4.', '4.');
        assert.equal(moment([2011, 0, 5]).format('DDDo'), '5.', '5.');
        assert.equal(moment([2011, 0, 6]).format('DDDo'), '6.', '6.');
        assert.equal(moment([2011, 0, 7]).format('DDDo'), '7.', '7.');
        assert.equal(moment([2011, 0, 8]).format('DDDo'), '8.', '8.');
        assert.equal(moment([2011, 0, 9]).format('DDDo'), '9.', '9.');
        assert.equal(moment([2011, 0, 10]).format('DDDo'), '10.', '10.');

        assert.equal(moment([2011, 0, 11]).format('DDDo'), '11.', '11.');
        assert.equal(moment([2011, 0, 12]).format('DDDo'), '12.', '12.');
        assert.equal(moment([2011, 0, 13]).format('DDDo'), '13.', '13.');
        assert.equal(moment([2011, 0, 14]).format('DDDo'), '14.', '14.');
        assert.equal(moment([2011, 0, 15]).format('DDDo'), '15.', '15.');
        assert.equal(moment([2011, 0, 16]).format('DDDo'), '16.', '16.');
        assert.equal(moment([2011, 0, 17]).format('DDDo'), '17.', '17.');
        assert.equal(moment([2011, 0, 18]).format('DDDo'), '18.', '18.');
        assert.equal(moment([2011, 0, 19]).format('DDDo'), '19.', '19.');
        assert.equal(moment([2011, 0, 20]).format('DDDo'), '20.', '20.');

        assert.equal(moment([2011, 0, 21]).format('DDDo'), '21.', '21.');
        assert.equal(moment([2011, 0, 22]).format('DDDo'), '22.', '22.');
        assert.equal(moment([2011, 0, 23]).format('DDDo'), '23.', '23.');
        assert.equal(moment([2011, 0, 24]).format('DDDo'), '24.', '24.');
        assert.equal(moment([2011, 0, 25]).format('DDDo'), '25.', '25.');
        assert.equal(moment([2011, 0, 26]).format('DDDo'), '26.', '26.');
        assert.equal(moment([2011, 0, 27]).format('DDDo'), '27.', '27.');
        assert.equal(moment([2011, 0, 28]).format('DDDo'), '28.', '28.');
        assert.equal(moment([2011, 0, 29]).format('DDDo'), '29.', '29.');
        assert.equal(moment([2011, 0, 30]).format('DDDo'), '30.', '30.');

        assert.equal(moment([2011, 0, 31]).format('DDDo'), '31.', '31.');
    });

    test('format month', function (assert) {
        var expected = 'januar jan._februar feb._mart mar._april apr._maj maj_jun jun_jul jul_avgust avg._septembar sep._oktobar okt._novembar nov._decembar dec.'.split('_'),
            i;
        for (i = 0; i < expected.length; i++) {
            assert.equal(moment([2011, i, 1]).format('MMMM MMM'), expected[i], expected[i]);
        }
    });

    test('format week', function (assert) {
        var expected = 'nedjelja ned. ne_ponedjeljak pon. po_utorak uto. ut_srijeda sri. sr_Äetvrtak Äet. Äe_petak pet. pe_subota sub. su'.split('_'),
            i;
        for (i = 0; i < expected.length; i++) {
            assert.equal(moment([2011, 0, 2 + i]).format('dddd ddd dd'), expected[i], expected[i]);
        }
    });

    test('from', function (assert) {
        var start = moment([2007, 1, 28]);
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 44}), true),  'nekoliko sekundi', '44 seconds = a few seconds');
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 45}), true),  'jedan minut',   '45 seconds = a minute');
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 89}), true),  'jedan minut',   '89 seconds = a minute');
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 90}), true),  '2 minuta',     '90 seconds = 2 minutes');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 44}), true),  '44 minuta',     '44 minutes = 44 minutes');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 45}), true),  'jedan sat',      '45 minutes = an hour');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 89}), true),  'jedan sat',      '89 minutes = an hour');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 90}), true),  '2 sata',        '90 minutes = 2 hours');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 5}), true),   '5 sati',         '5 hours = 5 hours');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 21}), true),  '21 sati',        '21 hours = 21 hours');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 22}), true),  'dan',       '22 hours = a day');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 35}), true),  'dan',       '35 hours = a day');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 36}), true),  '2 dana',        '36 hours = 2 days');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 1}), true),   'dan',       '1 day = a day');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 5}), true),   '5 dana',        '5 days = 5 days');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 25}), true),  '25 dana',       '25 days = 25 days');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 26}), true),  'mjesec',     '26 days = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 30}), true),  'mjesec',     '30 days = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 43}), true),  'mjesec',     '43 days = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 46}), true),  '2 mjeseca',     '46 days = 2 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 74}), true),  '2 mjeseca',     '75 days = 2 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 76}), true),  '3 mjeseca',     '76 days = 3 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({M: 1}), true),   'mjesec',     '1 month = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({M: 5}), true),   '5 mjeseci',    '5 months = 5 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 345}), true), 'godinu',     '345 days = a year');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 548}), true), '2 godine',       '548 days = 2 years');
        assert.equal(start.from(moment([2007, 1, 28]).add({y: 1}), true),   'godinu',     '1 year = a year');
        assert.equal(start.from(moment([2007, 1, 28]).add({y: 5}), true),   '5 godina',        '5 years = 5 years');
    });

    test('suffix', function (assert) {
        assert.equal(moment(30000).from(0), 'za nekoliko sekundi',  'prefix');
        assert.equal(moment(0).from(30000), 'prije nekoliko sekundi', 'prefix');
    });

    test('now from now', function (assert) {
        assert.equal(moment().fromNow(), 'prije nekoliko sekundi',  'now from now should display as in the past');
    });

    test('fromNow', function (assert) {
        assert.equal(moment().add({s: 30}).fromNow(), 'za nekoliko sekundi', 'in a few seconds');
        assert.equal(moment().add({d: 5}).fromNow(), 'za 5 dana', 'in 5 days');
    });

    test('calendar day', function (assert) {
        var a = moment().hours(12).minutes(0).seconds(0);

        assert.equal(moment(a).calendar(),                   'danas u 12:00',  'today at the same time');
        assert.equal(moment(a).add({m: 25}).calendar(),      'danas u 12:25',  'Now plus 25 min');
        assert.equal(moment(a).add({h: 1}).calendar(),       'danas u 13:00',  'Now plus 1 hour');
        assert.equal(moment(a).add({d: 1}).calendar(),       'sjutra u 12:00', 'tomorrow at the same time');
        assert.equal(moment(a).subtract({h: 1}).calendar(),  'danas u 11:00',  'Now minus 1 hour');
        assert.equal(moment(a).subtract({d: 1}).calendar(),  'juÄe u 12:00',   'yesterday at the same time');
    });

    test('calendar next week', function (assert) {
        var i, m;

        function makeFormat(d) {
            switch (d.day()) {
            case 0:
                return '[u] [nedjelju] [u] LT';
            case 3:
                return '[u] [srijedu] [u] LT';
            case 6:
                return '[u] [subotu] [u] LT';
            case 1:
            case 2:
            case 4:
            case 5:
                return '[u] dddd [u] LT';
            }
        }

        for (i = 2; i < 7; i++) {
            m = moment().add({d: i});
            assert.equal(m.calendar(),       m.format(makeFormat(m)),  'Today + ' + i + ' days current time');
            m.hours(0).minutes(0).seconds(0).milliseconds(0);
            assert.equal(m.calendar(),       m.format(makeFormat(m)),  'Today + ' + i + ' days beginning of day');
            m.hours(23).minutes(59).seconds(59).milliseconds(999);
            assert.equal(m.calendar(),       m.format(makeFormat(m)),  'Today + ' + i + ' days end of day');
        }
    });

    test('calendar last week', function (assert) {
        var i, m;

        function makeFormat(d) {
            var lastWeekDay = [
                    '[proÅ¡le] [nedjelje] [u] LT',
                    '[proÅ¡log] [ponedjeljka] [u] LT',
                    '[proÅ¡log] [utorka] [u] LT',
                    '[proÅ¡le] [srijede] [u] LT',
                    '[proÅ¡log] [Äetvrtka] [u] LT',
                    '[proÅ¡log] [petka] [u] LT',
                    '[proÅ¡le] [subote] [u] LT'
                ];

            return lastWeekDay[d.day()];
        }

        for (i = 2; i < 7; i++) {
            m = moment().subtract({d: i});
            assert.equal(m.calendar(),       m.format(makeFormat(m)),  'Today - ' + i + ' days current time');
            m.hours(0).minutes(0).seconds(0).milliseconds(0);
            assert.equal(m.calendar(),       m.format(makeFormat(m)),  'Today - ' + i + ' days beginning of day');
            m.hours(23).minutes(59).seconds(59).milliseconds(999);
            assert.equal(m.calendar(),       m.format(makeFormat(m)),  'Today - ' + i + ' days end of day');
        }
    });

    test('calendar all else', function (assert) {
        var weeksAgo = moment().subtract({w: 1}),
            weeksFromNow = moment().add({w: 1});

        assert.equal(weeksAgo.calendar(),       weeksAgo.format('L'),  '1 week ago');
        assert.equal(weeksFromNow.calendar(),   weeksFromNow.format('L'),  'in 1 week');

        weeksAgo = moment().subtract({w: 2});
        weeksFromNow = moment().add({w: 2});

        assert.equal(weeksAgo.calendar(),       weeksAgo.format('L'),  '2 weeks ago');
        assert.equal(weeksFromNow.calendar(),   weeksFromNow.format('L'),  'in 2 weeks');
    });

    // Monday is the first day of the week.
    // The week that contains Jan 1st is the first week of the year.

    test('weeks year starting sunday formatted', function (assert) {
        assert.equal(moment([2011, 11, 26]).format('w ww wo'), '1 01 1.', 'Dec 26 2011 should be week 1');
        assert.equal(moment([2012,  0,  1]).format('w ww wo'), '1 01 1.', 'Jan  1 2012 should be week 1');
        assert.equal(moment([2012,  0,  2]).format('w ww wo'), '2 02 2.', 'Jan  2 2012 should be week 2');
        assert.equal(moment([2012,  0,  8]).format('w ww wo'), '2 02 2.', 'Jan  8 2012 should be week 2');
        assert.equal(moment([2012,  0,  9]).format('w ww wo'), '3 03 3.', 'Jan  9 2012 should be week 3');
    });

}));

;(function (global, factory) {
   typeof exports === 'object' && typeof module !== 'undefined'
       && typeof require === 'function' ? factory(require('../../moment')) :
   typeof define === 'function' && define.amd ? define(['../../moment'], factory) :
   factory(global.moment)
}(this, function (moment) { 'use strict';

    function each(array, callback) {
        var i;
        for (i = 0; i < array.length; i++) {
            callback(array[i], i, array);
        }
    }

    function objectKeys(obj) {
        if (Object.keys) {
            return Object.keys(obj);
        } else {
            // IE8
            var res = [], i;
            for (i in obj) {
                if (obj.hasOwnProperty(i)) {
                    res.push(i);
                }
            }
            return res;
        }
    }

    // Pick the first defined of two or three arguments.
    function defaults(a, b, c) {
        if (a != null) {
            return a;
        }
        if (b != null) {
            return b;
        }
        return c;
    }

    function defineCommonLocaleTests(locale, options) {
        test('lenient ordinal parsing', function (assert) {
            var i, ordinalStr, testMoment;
            for (i = 1; i <= 31; ++i) {
                ordinalStr = moment([2014, 0, i]).format('YYYY MM Do');
                testMoment = moment(ordinalStr, 'YYYY MM Do');
                assert.equal(testMoment.year(), 2014,
                        'lenient ordinal parsing ' + i + ' year check');
                assert.equal(testMoment.month(), 0,
                        'lenient ordinal parsing ' + i + ' month check');
                assert.equal(testMoment.date(), i,
                        'lenient ordinal parsing ' + i + ' date check');
            }
        });

        test('lenient ordinal parsing of number', function (assert) {
            var i, testMoment;
            for (i = 1; i <= 31; ++i) {
                testMoment = moment('2014 01 ' + i, 'YYYY MM Do');
                assert.equal(testMoment.year(), 2014,
                        'lenient ordinal parsing of number ' + i + ' year check');
                assert.equal(testMoment.month(), 0,
                        'lenient ordinal parsing of number ' + i + ' month check');
                assert.equal(testMoment.date(), i,
                        'lenient ordinal parsing of number ' + i + ' date check');
            }
        });

        test('strict ordinal parsing', function (assert) {
            var i, ordinalStr, testMoment;
            for (i = 1; i <= 31; ++i) {
                ordinalStr = moment([2014, 0, i]).format('YYYY MM Do');
                testMoment = moment(ordinalStr, 'YYYY MM Do', true);
                assert.ok(testMoment.isValid(), 'strict ordinal parsing ' + i);
            }
        });

        test('meridiem invariant', function (assert) {
            var h, m, t1, t2;
            for (h = 0; h < 24; ++h) {
                for (m = 0; m < 60; m += 15) {
                    t1 = moment.utc([2000, 0, 1, h, m]);
                    t2 = moment.utc(t1.format('A h:mm'), 'A h:mm');
                    assert.equal(t2.format('HH:mm'), t1.format('HH:mm'),
                            'meridiem at ' + t1.format('HH:mm'));
                }
            }
        });

        test('date format correctness', function (assert) {
            var data, tokens;
            data = moment.localeData()._longDateFormat;
            tokens = objectKeys(data);
            each(tokens, function (srchToken) {
                // Check each format string to make sure it does not contain any
                // tokens that need to be expanded.
                each(tokens, function (baseToken) {
                    // strip escaped sequences
                    var format = data[baseToken].replace(/(\[[^\]]*\])/g, '');
                    assert.equal(false, !!~format.indexOf(srchToken),
                            'contains ' + srchToken + ' in ' + baseToken);
                });
            });
        });

        test('month parsing correctness', function (assert) {
            var i, m;

            if (locale === 'tr') {
                // I can't fix it :(
                expect(0);
                return;
            }
            function tester(format) {
                var r;
                r = moment(m.format(format), format);
                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format);
                r = moment(m.format(format).toLocaleUpperCase(), format);
                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' upper');
                r = moment(m.format(format).toLocaleLowerCase(), format);
                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' lower');

                r = moment(m.format(format), format, true);
                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' strict');
                r = moment(m.format(format).toLocaleUpperCase(), format, true);
                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' upper strict');
                r = moment(m.format(format).toLocaleLowerCase(), format, true);
                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' lower strict');
            }

            for (i = 0; i < 12; ++i) {
                m = moment([2015, i, 15, 18]);
                tester('MMM');
                tester('MMM.');
                tester('MMMM');
                tester('MMMM.');
            }
        });

        test('weekday parsing correctness', function (assert) {
            var i, m;

            if (locale === 'tr' || locale === 'az') {
                // There is a lower-case letter (Ä±), that converted to upper then
                // lower changes to i
                expect(0);
                return;
            }
            function tester(format) {
                var r, baseMsg = 'weekday ' + m.weekday() + ' fmt ' + format;
                r = moment(m.format(format), format);
                assert.equal(r.weekday(), m.weekday(), baseMsg);
                r = moment(m.format(format).toLocaleUpperCase(), format);
                assert.equal(r.weekday(), m.weekday(), baseMsg + ' upper');
                r = moment(m.format(format).toLocaleLowerCase(), format);
                assert.equal(r.weekday(), m.weekday(), baseMsg + ' lower');

                r = moment(m.format(format), format, true);
                assert.equal(r.weekday(), m.weekday(), baseMsg + ' strict');
                r = moment(m.format(format).toLocaleUpperCase(), format, true);
                assert.equal(r.weekday(), m.weekday(), baseMsg + ' upper strict');
                r = moment(m.format(format).toLocaleLowerCase(), format, true);
                assert.equal(r.weekday(), m.weekday(), baseMsg + ' lower strict');
            }

            for (i = 0; i < 7; ++i) {
                m = moment.utc([2015, i, 15, 18]);
                tester('dd');
                tester('ddd');
                tester('dddd');
            }
        });
    }

    function setupDeprecationHandler(test, moment, scope) {
        test._expectedDeprecations = null;
        test._observedDeprecations = null;
        test._oldSupress = moment.suppressDeprecationWarnings;
        moment.suppressDeprecationWarnings = true;
        test.expectedDeprecations = function () {
            test._expectedDeprecations = arguments;
            test._observedDeprecations = [];
        };
        moment.deprecationHandler = function (name, msg) {
            var deprecationId = matchedDeprecation(name, msg, test._expectedDeprecations);
            if (deprecationId === -1) {
                throw new Error('Unexpected deprecation thrown name=' +
                        name + ' msg=' + msg);
            }
            test._observedDeprecations[deprecationId] = 1;
        };
    }

    function teardownDeprecationHandler(test, moment, scope) {
        moment.suppressDeprecationWarnings = test._oldSupress;

        if (test._expectedDeprecations != null) {
            var missedDeprecations = [];
            each(test._expectedDeprecations, function (deprecationPattern, id) {
                if (test._observedDeprecations[id] !== 1) {
                    missedDeprecations.push(deprecationPattern);
                }
            });
            if (missedDeprecations.length !== 0) {
                throw new Error('Expected deprecation warnings did not happen: ' +
                        missedDeprecations.join(' '));
            }
        }
    }

    function matchedDeprecation(name, msg, deprecations) {
        if (deprecations == null) {
            return -1;
        }
        for (var i = 0; i < deprecations.length; ++i) {
            if (name != null && name === deprecations[i]) {
                return i;
            }
            if (msg != null && msg.substring(0, deprecations[i].length) === deprecations[i]) {
                return i;
            }
        }
        return -1;
    }

    /*global QUnit:false*/

    var test = QUnit.test;

    var expect = QUnit.expect;

    function module (name, lifecycle) {
        QUnit.module(name, {
            setup : function () {
                moment.locale('en');
                moment.createFromInputFallback = function (config) {
                    throw new Error('input not handled by moment: ' + config._i);
                };
                setupDeprecationHandler(test, moment, 'core');
                if (lifecycle && lifecycle.setup) {
                    lifecycle.setup();
                }
            },
            teardown : function () {
                teardownDeprecationHandler(test, moment, 'core');
                if (lifecycle && lifecycle.teardown) {
                    lifecycle.teardown();
                }
            }
        });
    }

    function localeModule (name, lifecycle) {
        QUnit.module('locale:' + name, {
            setup : function () {
                moment.locale(name);
                moment.createFromInputFallback = function (config) {
                    throw new Error('input not handled by moment: ' + config._i);
                };
                setupDeprecationHandler(test, moment, 'locale');
                if (lifecycle && lifecycle.setup) {
                    lifecycle.setup();
                }
            },
            teardown : function () {
                moment.locale('en');
                teardownDeprecationHandler(test, moment, 'locale');
                if (lifecycle && lifecycle.teardown) {
                    lifecycle.teardown();
                }
            }
        });
        defineCommonLocaleTests(name, -1, -1);
    }

    localeModule('mk');

    test('parse', function (assert) {
        var tests = 'ÑÐ°Ð½ÑÐ°ÑÐ¸ ÑÐ°Ð½_ÑÐµÐ²ÑÑÐ°ÑÐ¸ ÑÐµÐ²_Ð¼Ð°ÑÑ Ð¼Ð°Ñ_Ð°Ð¿ÑÐ¸Ð» Ð°Ð¿Ñ_Ð¼Ð°Ñ Ð¼Ð°Ñ_ÑÑÐ½Ð¸ ÑÑÐ½_ÑÑÐ»Ð¸ ÑÑÐ»_Ð°Ð²Ð³ÑÑÑ Ð°Ð²Ð³_ÑÐµÐ¿ÑÐµÐ¼Ð²ÑÐ¸ ÑÐµÐ¿_Ð¾ÐºÑÐ¾Ð¼Ð²ÑÐ¸ Ð¾ÐºÑ_Ð½Ð¾ÐµÐ¼Ð²ÑÐ¸ Ð½Ð¾Ðµ_Ð´ÐµÐºÐµÐ¼Ð²ÑÐ¸ Ð´ÐµÐº'.split('_'), i;
        function equalTest(input, mmm, i) {
            assert.equal(moment(input, mmm).month(), i, input + ' should be month ' + (i + 1));
        }
        for (i = 0; i < 12; i++) {
            tests[i] = tests[i].split(' ');
            equalTest(tests[i][0], 'MMM', i);
            equalTest(tests[i][1], 'MMM', i);
            equalTest(tests[i][0], 'MMMM', i);
            equalTest(tests[i][1], 'MMMM', i);
            equalTest(tests[i][0].toLocaleLowerCase(), 'MMMM', i);
            equalTest(tests[i][1].toLocaleLowerCase(), 'MMMM', i);
            equalTest(tests[i][0].toLocaleUpperCase(), 'MMMM', i);
            equalTest(tests[i][1].toLocaleUpperCase(), 'MMMM', i);
        }
    });

    test('format', function (assert) {
        var a = [
                ['dddd, MMMM Do YYYY, H:mm:ss',        'Ð½ÐµÐ´ÐµÐ»Ð°, ÑÐµÐ²ÑÑÐ°ÑÐ¸ 14-ÑÐ¸ 2010, 15:25:50'],
                ['ddd, hA',                            'Ð½ÐµÐ´, 3PM'],
                ['M Mo MM MMMM MMM',                   '2 2-ÑÐ¸ 02 ÑÐµÐ²ÑÑÐ°ÑÐ¸ ÑÐµÐ²'],
                ['YYYY YY',                            '2010 10'],
                ['D Do DD',                            '14 14-ÑÐ¸ 14'],
                ['d do dddd ddd dd',                   '0 0-ÐµÐ² Ð½ÐµÐ´ÐµÐ»Ð° Ð½ÐµÐ´ Ð½e'],
                ['DDD DDDo DDDD',                      '45 45-ÑÐ¸ 045'],
                ['w wo ww',                            '7 7-Ð¼Ð¸ 07'],
                ['h hh',                               '3 03'],
                ['H HH',                               '15 15'],
                ['m mm',                               '25 25'],
                ['s ss',                               '50 50'],
                ['a A',                                'pm PM'],
                ['[the] DDDo [day of the year]',       'the 45-ÑÐ¸ day of the year'],
                ['LTS',                                '15:25:50'],
                ['L',                                  '14.02.2010'],
                ['LL',                                 '14 ÑÐµÐ²ÑÑÐ°ÑÐ¸ 2010'],
                ['LLL',                                '14 ÑÐµÐ²ÑÑÐ°ÑÐ¸ 2010 15:25'],
                ['LLLL',                               'Ð½ÐµÐ´ÐµÐ»Ð°, 14 ÑÐµÐ²ÑÑÐ°ÑÐ¸ 2010 15:25'],
                ['l',                                  '14.2.2010'],
                ['ll',                                 '14 ÑÐµÐ² 2010'],
                ['lll',                                '14 ÑÐµÐ² 2010 15:25'],
                ['llll',                               'Ð½ÐµÐ´, 14 ÑÐµÐ² 2010 15:25']
            ],
            b = moment(new Date(2010, 1, 14, 15, 25, 50, 125)),
            i;
        for (i = 0; i < a.length; i++) {
            assert.equal(b.format(a[i][0]), a[i][1], a[i][0] + ' ---> ' + a[i][1]);
        }
    });

    test('format ordinal', function (assert) {
        assert.equal(moment([2011, 0, 1]).format('DDDo'), '1-Ð²Ð¸', '1-Ð²Ð¸');
        assert.equal(moment([2011, 0, 2]).format('DDDo'), '2-ÑÐ¸', '2-ÑÐ¸');
        assert.equal(moment([2011, 0, 3]).format('DDDo'), '3-ÑÐ¸', '3-ÑÐ¸');
        assert.equal(moment([2011, 0, 4]).format('DDDo'), '4-ÑÐ¸', '4-ÑÐ¸');
        assert.equal(moment([2011, 0, 5]).format('DDDo'), '5-ÑÐ¸', '5-ÑÐ¸');
        assert.equal(moment([2011, 0, 6]).format('DDDo'), '6-ÑÐ¸', '6-ÑÐ¸');
        assert.equal(moment([2011, 0, 7]).format('DDDo'), '7-Ð¼Ð¸', '7-Ð¼Ð¸');
        assert.equal(moment([2011, 0, 8]).format('DDDo'), '8-Ð¼Ð¸', '8-Ð¼Ð¸');
        assert.equal(moment([2011, 0, 9]).format('DDDo'), '9-ÑÐ¸', '9-ÑÐ¸');
        assert.equal(moment([2011, 0, 10]).format('DDDo'), '10-ÑÐ¸', '10-ÑÐ¸');

        assert.equal(moment([2011, 0, 11]).format('DDDo'), '11-ÑÐ¸', '11-ÑÐ¸');
        assert.equal(moment([2011, 0, 12]).format('DDDo'), '12-ÑÐ¸', '12-ÑÐ¸');
        assert.equal(moment([2011, 0, 13]).format('DDDo'), '13-ÑÐ¸', '13-ÑÐ¸');
        assert.equal(moment([2011, 0, 14]).format('DDDo'), '14-ÑÐ¸', '14-ÑÐ¸');
        assert.equal(moment([2011, 0, 15]).format('DDDo'), '15-ÑÐ¸', '15-ÑÐ¸');
        assert.equal(moment([2011, 0, 16]).format('DDDo'), '16-ÑÐ¸', '16-ÑÐ¸');
        assert.equal(moment([2011, 0, 17]).format('DDDo'), '17-ÑÐ¸', '17-ÑÐ¸');
        assert.equal(moment([2011, 0, 18]).format('DDDo'), '18-ÑÐ¸', '18-ÑÐ¸');
        assert.equal(moment([2011, 0, 19]).format('DDDo'), '19-ÑÐ¸', '19-ÑÐ¸');
        assert.equal(moment([2011, 0, 20]).format('DDDo'), '20-ÑÐ¸', '20-ÑÐ¸');

        assert.equal(moment([2011, 0, 21]).format('DDDo'), '21-Ð²Ð¸', '21-Ð²Ð¸');
        assert.equal(moment([2011, 0, 22]).format('DDDo'), '22-ÑÐ¸', '22-ÑÐ¸');
        assert.equal(moment([2011, 0, 23]).format('DDDo'), '23-ÑÐ¸', '23-ÑÐ¸');
        assert.equal(moment([2011, 0, 24]).format('DDDo'), '24-ÑÐ¸', '24-ÑÐ¸');
        assert.equal(moment([2011, 0, 25]).format('DDDo'), '25-ÑÐ¸', '25-ÑÐ¸');
        assert.equal(moment([2011, 0, 26]).format('DDDo'), '26-ÑÐ¸', '26-ÑÐ¸');
        assert.equal(moment([2011, 0, 27]).format('DDDo'), '27-Ð¼Ð¸', '27-Ð¼Ð¸');
        assert.equal(moment([2011, 0, 28]).format('DDDo'), '28-Ð¼Ð¸', '28-Ð¼Ð¸');
        assert.equal(moment([2011, 0, 29]).format('DDDo'), '29-ÑÐ¸', '29-ÑÐ¸');
        assert.equal(moment([2011, 0, 30]).format('DDDo'), '30-ÑÐ¸', '30-ÑÐ¸');

        assert.equal(moment([2011, 0, 31]).format('DDDo'), '31-Ð²Ð¸', '31-Ð²Ð¸');
    });

    test('format month', function (assert) {
        var expected = 'ÑÐ°Ð½ÑÐ°ÑÐ¸ ÑÐ°Ð½_ÑÐµÐ²ÑÑÐ°ÑÐ¸ ÑÐµÐ²_Ð¼Ð°ÑÑ Ð¼Ð°Ñ_Ð°Ð¿ÑÐ¸Ð» Ð°Ð¿Ñ_Ð¼Ð°Ñ Ð¼Ð°Ñ_ÑÑÐ½Ð¸ ÑÑÐ½_ÑÑÐ»Ð¸ ÑÑÐ»_Ð°Ð²Ð³ÑÑÑ Ð°Ð²Ð³_ÑÐµÐ¿ÑÐµÐ¼Ð²ÑÐ¸ ÑÐµÐ¿_Ð¾ÐºÑÐ¾Ð¼Ð²ÑÐ¸ Ð¾ÐºÑ_Ð½Ð¾ÐµÐ¼Ð²ÑÐ¸ Ð½Ð¾Ðµ_Ð´ÐµÐºÐµÐ¼Ð²ÑÐ¸ Ð´ÐµÐº'.split('_'), i;
        for (i = 0; i < expected.length; i++) {
            assert.equal(moment([2011, i, 1]).format('MMMM MMM'), expected[i], expected[i]);
        }
    });

    test('format week', function (assert) {
        var expected = 'Ð½ÐµÐ´ÐµÐ»Ð° Ð½ÐµÐ´ Ð½e_Ð¿Ð¾Ð½ÐµÐ´ÐµÐ»Ð½Ð¸Ðº Ð¿Ð¾Ð½ Ð¿o_Ð²ÑÐ¾ÑÐ½Ð¸Ðº Ð²ÑÐ¾ Ð²Ñ_ÑÑÐµÐ´Ð° ÑÑÐµ ÑÑ_ÑÐµÑÐ²ÑÑÐ¾Ðº ÑÐµÑ ÑÐµ_Ð¿ÐµÑÐ¾Ðº Ð¿ÐµÑ Ð¿Ðµ_ÑÐ°Ð±Ð¾ÑÐ° ÑÐ°Ð± Ña'.split('_'), i;
        for (i = 0; i < expected.length; i++) {
            assert.equal(moment([2011, 0, 2 + i]).format('dddd ddd dd'), expected[i], expected[i]);
        }
    });

    test('from', function (assert) {
        var start = moment([2007, 1, 28]);
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 44}), true),  'Ð½ÐµÐºÐ¾Ð»ÐºÑ ÑÐµÐºÑÐ½Ð´Ð¸', '44 seconds = a few seconds');
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 45}), true),  'Ð¼Ð¸Ð½ÑÑÐ°',          '45 seconds = a minute');
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 89}), true),  'Ð¼Ð¸Ð½ÑÑÐ°',          '89 seconds = a minute');
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 90}), true),  '2 Ð¼Ð¸Ð½ÑÑÐ¸',        '90 seconds = 2 minutes');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 44}), true),  '44 Ð¼Ð¸Ð½ÑÑÐ¸',       '44 minutes = 44 minutes');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 45}), true),  'ÑÐ°Ñ',             '45 minutes = an hour');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 89}), true),  'ÑÐ°Ñ',             '89 minutes = an hour');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 90}), true),  '2 ÑÐ°ÑÐ°',          '90 minutes = 2 hours');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 5}), true),   '5 ÑÐ°ÑÐ°',          '5 hours = 5 hours');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 21}), true),  '21 ÑÐ°ÑÐ°',         '21 hours = 21 hours');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 22}), true),  'Ð´ÐµÐ½',             '22 hours = a day');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 35}), true),  'Ð´ÐµÐ½',             '35 hours = a day');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 36}), true),  '2 Ð´ÐµÐ½Ð°',          '36 hours = 2 days');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 1}), true),   'Ð´ÐµÐ½',             '1 day = a day');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 5}), true),   '5 Ð´ÐµÐ½Ð°',          '5 days = 5 days');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 25}), true),  '25 Ð´ÐµÐ½Ð°',         '25 days = 25 days');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 26}), true),  'Ð¼ÐµÑÐµÑ',           '26 days = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 30}), true),  'Ð¼ÐµÑÐµÑ',           '30 days = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 43}), true),  'Ð¼ÐµÑÐµÑ',           '43 days = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 46}), true),  '2 Ð¼ÐµÑÐµÑÐ¸',        '46 days = 2 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 74}), true),  '2 Ð¼ÐµÑÐµÑÐ¸',        '75 days = 2 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 76}), true),  '3 Ð¼ÐµÑÐµÑÐ¸',        '76 days = 3 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({M: 1}), true),   'Ð¼ÐµÑÐµÑ',           '1 month = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({M: 5}), true),   '5 Ð¼ÐµÑÐµÑÐ¸',        '5 months = 5 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 345}), true), 'Ð³Ð¾Ð´Ð¸Ð½Ð°',          '345 days = a year');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 548}), true), '2 Ð³Ð¾Ð´Ð¸Ð½Ð¸',        '548 days = 2 years');
        assert.equal(start.from(moment([2007, 1, 28]).add({y: 1}), true),   'Ð³Ð¾Ð´Ð¸Ð½Ð°',          '1 year = a year');
        assert.equal(start.from(moment([2007, 1, 28]).add({y: 5}), true),   '5 Ð³Ð¾Ð´Ð¸Ð½Ð¸',        '5 years = 5 years');
    });

    test('suffix', function (assert) {
        assert.equal(moment(30000).from(0), 'Ð¿Ð¾ÑÐ»Ðµ Ð½ÐµÐºÐ¾Ð»ÐºÑ ÑÐµÐºÑÐ½Ð´Ð¸', 'prefix');
        assert.equal(moment(0).from(30000), 'Ð¿ÑÐµÐ´ Ð½ÐµÐºÐ¾Ð»ÐºÑ ÑÐµÐºÑÐ½Ð´Ð¸',  'suffix');
    });

    test('now from now', function (assert) {
        assert.equal(moment().fromNow(), 'Ð¿ÑÐµÐ´ Ð½ÐµÐºÐ¾Ð»ÐºÑ ÑÐµÐºÑÐ½Ð´Ð¸',  'now from now should display as in the past');
    });

    test('fromNow', function (assert) {
        assert.equal(moment().add({s: 30}).fromNow(), 'Ð¿Ð¾ÑÐ»Ðµ Ð½ÐµÐºÐ¾Ð»ÐºÑ ÑÐµÐºÑÐ½Ð´Ð¸', 'in a few seconds');
        assert.equal(moment().add({d: 5}).fromNow(),  'Ð¿Ð¾ÑÐ»Ðµ 5 Ð´ÐµÐ½Ð°', 'in 5 days');
    });

    test('calendar day', function (assert) {
        var a = moment().hours(12).minutes(0).seconds(0);

        assert.equal(moment(a).calendar(),                   'ÐÐµÐ½ÐµÑ Ð²Ð¾ 12:00',  'today at the same time');
        assert.equal(moment(a).add({m: 25}).calendar(),      'ÐÐµÐ½ÐµÑ Ð²Ð¾ 12:25',  'Now plus 25 min');
        assert.equal(moment(a).add({h: 1}).calendar(),       'ÐÐµÐ½ÐµÑ Ð²Ð¾ 13:00',  'Now plus 1 hour');
        assert.equal(moment(a).add({d: 1}).calendar(),       'Ð£ÑÑÐµ Ð²Ð¾ 12:00',   'tomorrow at the same time');
        assert.equal(moment(a).subtract({h: 1}).calendar(),  'ÐÐµÐ½ÐµÑ Ð²Ð¾ 11:00',  'Now minus 1 hour');
        assert.equal(moment(a).subtract({d: 1}).calendar(),  'ÐÑÐµÑÐ° Ð²Ð¾ 12:00',  'yesterday at the same time');
    });

    test('calendar next week', function (assert) {
        var i, m;
        for (i = 2; i < 7; i++) {
            m = moment().add({d: i});
            assert.equal(m.calendar(),       m.format('[ÐÐ¾] dddd [Ð²Ð¾] LT'),  'Today + ' + i + ' days current time');
            m.hours(0).minutes(0).seconds(0).milliseconds(0);
            assert.equal(m.calendar(),       m.format('[ÐÐ¾] dddd [Ð²Ð¾] LT'),  'Today + ' + i + ' days beginning of day');
            m.hours(23).minutes(59).seconds(59).milliseconds(999);
            assert.equal(m.calendar(),       m.format('[ÐÐ¾] dddd [Ð²Ð¾] LT'),  'Today + ' + i + ' days end of day');
        }
    });

    test('calendar last week', function (assert) {
        var i, m;

        function makeFormat(d) {
            switch (d.day()) {
            case 0:
            case 3:
            case 6:
                return '[ÐÐ·Ð¼Ð¸Ð½Ð°ÑÐ°ÑÐ°] dddd [Ð²Ð¾] LT';
            case 1:
            case 2:
            case 4:
            case 5:
                return '[ÐÐ·Ð¼Ð¸Ð½Ð°ÑÐ¸Ð¾Ñ] dddd [Ð²Ð¾] LT';
            }
        }

        for (i = 2; i < 7; i++) {
            m = moment().subtract({d: i});
            assert.equal(m.calendar(),       m.format(makeFormat(m)),  'Today - ' + i + ' days current time');
            m.hours(0).minutes(0).seconds(0).milliseconds(0);
            assert.equal(m.calendar(),       m.format(makeFormat(m)),  'Today - ' + i + ' days beginning of day');
            m.hours(23).minutes(59).seconds(59).milliseconds(999);
            assert.equal(m.calendar(),       m.format(makeFormat(m)),  'Today - ' + i + ' days end of day');
        }
    });

    test('calendar all else', function (assert) {
        var weeksAgo = moment().subtract({w: 1}),
            weeksFromNow = moment().add({w: 1});

        assert.equal(weeksAgo.calendar(),       weeksAgo.format('L'),  '1 week ago');
        assert.equal(weeksFromNow.calendar(),   weeksFromNow.format('L'),  'in 1 week');

        weeksAgo = moment().subtract({w: 2});
        weeksFromNow = moment().add({w: 2});

        assert.equal(weeksAgo.calendar(),       weeksAgo.format('L'),  '2 weeks ago');
        assert.equal(weeksFromNow.calendar(),   weeksFromNow.format('L'),  'in 2 weeks');
    });

    test('weeks year starting sunday formatted', function (assert) {
        assert.equal(moment([2011, 11, 26]).format('w ww wo'), '1 01 1-Ð²Ð¸', 'Dec 26 2011 should be week 1');
        assert.equal(moment([2012,  0,  1]).format('w ww wo'), '1 01 1-Ð²Ð¸', 'Jan  1 2012 should be week 1');
        assert.equal(moment([2012,  0,  2]).format('w ww wo'), '2 02 2-ÑÐ¸', 'Jan  2 2012 should be week 2');
        assert.equal(moment([2012,  0,  8]).format('w ww wo'), '2 02 2-ÑÐ¸', 'Jan  8 2012 should be week 2');
        assert.equal(moment([2012,  0,  9]).format('w ww wo'), '3 03 3-ÑÐ¸', 'Jan  9 2012 should be week 3');
    });

}));

;(function (global, factory) {
   typeof exports === 'object' && typeof module !== 'undefined'
       && typeof require === 'function' ? factory(require('../../moment')) :
   typeof define === 'function' && define.amd ? define(['../../moment'], factory) :
   factory(global.moment)
}(this, function (moment) { 'use strict';

    function each(array, callback) {
        var i;
        for (i = 0; i < array.length; i++) {
            callback(array[i], i, array);
        }
    }

    function objectKeys(obj) {
        if (Object.keys) {
            return Object.keys(obj);
        } else {
            // IE8
            var res = [], i;
            for (i in obj) {
                if (obj.hasOwnProperty(i)) {
                    res.push(i);
                }
            }
            return res;
        }
    }

    // Pick the first defined of two or three arguments.
    function defaults(a, b, c) {
        if (a != null) {
            return a;
        }
        if (b != null) {
            return b;
        }
        return c;
    }

    function defineCommonLocaleTests(locale, options) {
        test('lenient ordinal parsing', function (assert) {
            var i, ordinalStr, testMoment;
            for (i = 1; i <= 31; ++i) {
                ordinalStr = moment([2014, 0, i]).format('YYYY MM Do');
                testMoment = moment(ordinalStr, 'YYYY MM Do');
                assert.equal(testMoment.year(), 2014,
                        'lenient ordinal parsing ' + i + ' year check');
                assert.equal(testMoment.month(), 0,
                        'lenient ordinal parsing ' + i + ' month check');
                assert.equal(testMoment.date(), i,
                        'lenient ordinal parsing ' + i + ' date check');
            }
        });

        test('lenient ordinal parsing of number', function (assert) {
            var i, testMoment;
            for (i = 1; i <= 31; ++i) {
                testMoment = moment('2014 01 ' + i, 'YYYY MM Do');
                assert.equal(testMoment.year(), 2014,
                        'lenient ordinal parsing of number ' + i + ' year check');
                assert.equal(testMoment.month(), 0,
                        'lenient ordinal parsing of number ' + i + ' month check');
                assert.equal(testMoment.date(), i,
                        'lenient ordinal parsing of number ' + i + ' date check');
            }
        });

        test('strict ordinal parsing', function (assert) {
            var i, ordinalStr, testMoment;
            for (i = 1; i <= 31; ++i) {
                ordinalStr = moment([2014, 0, i]).format('YYYY MM Do');
                testMoment = moment(ordinalStr, 'YYYY MM Do', true);
                assert.ok(testMoment.isValid(), 'strict ordinal parsing ' + i);
            }
        });

        test('meridiem invariant', function (assert) {
            var h, m, t1, t2;
            for (h = 0; h < 24; ++h) {
                for (m = 0; m < 60; m += 15) {
                    t1 = moment.utc([2000, 0, 1, h, m]);
                    t2 = moment.utc(t1.format('A h:mm'), 'A h:mm');
                    assert.equal(t2.format('HH:mm'), t1.format('HH:mm'),
                            'meridiem at ' + t1.format('HH:mm'));
                }
            }
        });

        test('date format correctness', function (assert) {
            var data, tokens;
            data = moment.localeData()._longDateFormat;
            tokens = objectKeys(data);
            each(tokens, function (srchToken) {
                // Check each format string to make sure it does not contain any
                // tokens that need to be expanded.
                each(tokens, function (baseToken) {
                    // strip escaped sequences
                    var format = data[baseToken].replace(/(\[[^\]]*\])/g, '');
                    assert.equal(false, !!~format.indexOf(srchToken),
                            'contains ' + srchToken + ' in ' + baseToken);
                });
            });
        });

        test('month parsing correctness', function (assert) {
            var i, m;

            if (locale === 'tr') {
                // I can't fix it :(
                expect(0);
                return;
            }
            function tester(format) {
                var r;
                r = moment(m.format(format), format);
                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format);
                r = moment(m.format(format).toLocaleUpperCase(), format);
                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' upper');
                r = moment(m.format(format).toLocaleLowerCase(), format);
                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' lower');

                r = moment(m.format(format), format, true);
                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' strict');
                r = moment(m.format(format).toLocaleUpperCase(), format, true);
                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' upper strict');
                r = moment(m.format(format).toLocaleLowerCase(), format, true);
                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' lower strict');
            }

            for (i = 0; i < 12; ++i) {
                m = moment([2015, i, 15, 18]);
                tester('MMM');
                tester('MMM.');
                tester('MMMM');
                tester('MMMM.');
            }
        });

        test('weekday parsing correctness', function (assert) {
            var i, m;

            if (locale === 'tr' || locale === 'az') {
                // There is a lower-case letter (Ä±), that converted to upper then
                // lower changes to i
                expect(0);
                return;
            }
            function tester(format) {
                var r, baseMsg = 'weekday ' + m.weekday() + ' fmt ' + format;
                r = moment(m.format(format), format);
                assert.equal(r.weekday(), m.weekday(), baseMsg);
                r = moment(m.format(format).toLocaleUpperCase(), format);
                assert.equal(r.weekday(), m.weekday(), baseMsg + ' upper');
                r = moment(m.format(format).toLocaleLowerCase(), format);
                assert.equal(r.weekday(), m.weekday(), baseMsg + ' lower');

                r = moment(m.format(format), format, true);
                assert.equal(r.weekday(), m.weekday(), baseMsg + ' strict');
                r = moment(m.format(format).toLocaleUpperCase(), format, true);
                assert.equal(r.weekday(), m.weekday(), baseMsg + ' upper strict');
                r = moment(m.format(format).toLocaleLowerCase(), format, true);
                assert.equal(r.weekday(), m.weekday(), baseMsg + ' lower strict');
            }

            for (i = 0; i < 7; ++i) {
                m = moment.utc([2015, i, 15, 18]);
                tester('dd');
                tester('ddd');
                tester('dddd');
            }
        });
    }

    function setupDeprecationHandler(test, moment, scope) {
        test._expectedDeprecations = null;
        test._observedDeprecations = null;
        test._oldSupress = moment.suppressDeprecationWarnings;
        moment.suppressDeprecationWarnings = true;
        test.expectedDeprecations = function () {
            test._expectedDeprecations = arguments;
            test._observedDeprecations = [];
        };
        moment.deprecationHandler = function (name, msg) {
            var deprecationId = matchedDeprecation(name, msg, test._expectedDeprecations);
            if (deprecationId === -1) {
                throw new Error('Unexpected deprecation thrown name=' +
                        name + ' msg=' + msg);
            }
            test._observedDeprecations[deprecationId] = 1;
        };
    }

    function teardownDeprecationHandler(test, moment, scope) {
        moment.suppressDeprecationWarnings = test._oldSupress;

        if (test._expectedDeprecations != null) {
            var missedDeprecations = [];
            each(test._expectedDeprecations, function (deprecationPattern, id) {
                if (test._observedDeprecations[id] !== 1) {
                    missedDeprecations.push(deprecationPattern);
                }
            });
            if (missedDeprecations.length !== 0) {
                throw new Error('Expected deprecation warnings did not happen: ' +
                        missedDeprecations.join(' '));
            }
        }
    }

    function matchedDeprecation(name, msg, deprecations) {
        if (deprecations == null) {
            return -1;
        }
        for (var i = 0; i < deprecations.length; ++i) {
            if (name != null && name === deprecations[i]) {
                return i;
            }
            if (msg != null && msg.substring(0, deprecations[i].length) === deprecations[i]) {
                return i;
            }
        }
        return -1;
    }

    /*global QUnit:false*/

    var test = QUnit.test;

    var expect = QUnit.expect;

    function module (name, lifecycle) {
        QUnit.module(name, {
            setup : function () {
                moment.locale('en');
                moment.createFromInputFallback = function (config) {
                    throw new Error('input not handled by moment: ' + config._i);
                };
                setupDeprecationHandler(test, moment, 'core');
                if (lifecycle && lifecycle.setup) {
                    lifecycle.setup();
                }
            },
            teardown : function () {
                teardownDeprecationHandler(test, moment, 'core');
                if (lifecycle && lifecycle.teardown) {
                    lifecycle.teardown();
                }
            }
        });
    }

    function localeModule (name, lifecycle) {
        QUnit.module('locale:' + name, {
            setup : function () {
                moment.locale(name);
                moment.createFromInputFallback = function (config) {
                    throw new Error('input not handled by moment: ' + config._i);
                };
                setupDeprecationHandler(test, moment, 'locale');
                if (lifecycle && lifecycle.setup) {
                    lifecycle.setup();
                }
            },
            teardown : function () {
                moment.locale('en');
                teardownDeprecationHandler(test, moment, 'locale');
                if (lifecycle && lifecycle.teardown) {
                    lifecycle.teardown();
                }
            }
        });
        defineCommonLocaleTests(name, -1, -1);
    }

    localeModule('ml');

    test('parse', function (assert) {
        var tests = 'à´à´¨àµà´µà´°à´¿ à´à´¨àµ._à´«àµà´¬àµà´°àµà´µà´°à´¿ à´«àµà´¬àµà´°àµ._à´®à´¾àµ¼à´àµà´àµ à´®à´¾àµ¼._à´à´ªàµà´°à´¿àµ½ à´à´ªàµà´°à´¿._à´®àµà´¯àµ à´®àµà´¯àµ_à´àµàµº à´àµàµº_à´àµà´²àµ à´àµà´²àµ._à´à´à´¸àµà´±àµà´±àµ à´à´._à´¸àµà´ªàµà´±àµà´±à´à´¬àµ¼ à´¸àµà´ªàµà´±àµà´±._à´à´àµà´àµà´¬àµ¼ à´à´àµà´àµ._à´¨à´µà´à´¬àµ¼ à´¨à´µà´._à´¡à´¿à´¸à´à´¬àµ¼ à´¡à´¿à´¸à´.'.split('_'), i;
        function equalTest(input, mmm, i) {
            assert.equal(moment(input, mmm).month(), i, input + ' should be month ' + (i + 1));
        }
        for (i = 0; i < 12; i++) {
            tests[i] = tests[i].split(' ');
            equalTest(tests[i][0], 'MMM', i);
            equalTest(tests[i][1], 'MMM', i);
            equalTest(tests[i][0], 'MMMM', i);
            equalTest(tests[i][1], 'MMMM', i);
            equalTest(tests[i][0].toLocaleLowerCase(), 'MMMM', i);
            equalTest(tests[i][1].toLocaleLowerCase(), 'MMMM', i);
            equalTest(tests[i][0].toLocaleUpperCase(), 'MMMM', i);
            equalTest(tests[i][1].toLocaleUpperCase(), 'MMMM', i);
        }
    });

    test('format', function (assert) {
        var a = [
                ['dddd, Do MMMM YYYY, a h:mm:ss -à´¨àµ',  'à´à´¾à´¯à´±à´¾à´´àµà´, 14 à´«àµà´¬àµà´°àµà´µà´°à´¿ 2010, à´à´àµà´ à´à´´à´¿à´àµà´àµ 3:25:50 -à´¨àµ'],
                ['ddd, a h -à´¨àµ',                       'à´à´¾à´¯àµ¼, à´à´àµà´ à´à´´à´¿à´àµà´àµ 3 -à´¨àµ'],
                ['M Mo MM MMMM MMM',                   '2 2 02 à´«àµà´¬àµà´°àµà´µà´°à´¿ à´«àµà´¬àµà´°àµ.'],
                ['YYYY YY',                            '2010 10'],
                ['D Do DD',                            '14 14 14'],
                ['d do dddd ddd dd',                   '0 0 à´à´¾à´¯à´±à´¾à´´àµà´ à´à´¾à´¯àµ¼ à´à´¾'],
                ['DDD DDDo DDDD',                      '45 45 045'],
                ['w wo ww',                            '8 8 08'],
                ['h hh',                               '3 03'],
                ['H HH',                               '15 15'],
                ['m mm',                               '25 25'],
                ['s ss',                               '50 50'],
                ['a A',                                'à´à´àµà´ à´à´´à´¿à´àµà´àµ à´à´àµà´ à´à´´à´¿à´àµà´àµ'],
                ['LTS',                                'à´à´àµà´ à´à´´à´¿à´àµà´àµ 3:25:50 -à´¨àµ'],
                ['L',                                  '14/02/2010'],
                ['LL',                                 '14 à´«àµà´¬àµà´°àµà´µà´°à´¿ 2010'],
                ['LLL',                                '14 à´«àµà´¬àµà´°àµà´µà´°à´¿ 2010, à´à´àµà´ à´à´´à´¿à´àµà´àµ 3:25 -à´¨àµ'],
                ['LLLL',                               'à´à´¾à´¯à´±à´¾à´´àµà´, 14 à´«àµà´¬àµà´°àµà´µà´°à´¿ 2010, à´à´àµà´ à´à´´à´¿à´àµà´àµ 3:25 -à´¨àµ'],
                ['l',                                  '14/2/2010'],
                ['ll',                                 '14 à´«àµà´¬àµà´°àµ. 2010'],
                ['lll',                                '14 à´«àµà´¬àµà´°àµ. 2010, à´à´àµà´ à´à´´à´¿à´àµà´àµ 3:25 -à´¨àµ'],
                ['llll',                               'à´à´¾à´¯àµ¼, 14 à´«àµà´¬àµà´°àµ. 2010, à´à´àµà´ à´à´´à´¿à´àµà´àµ 3:25 -à´¨àµ']
            ],
            b = moment(new Date(2010, 1, 14, 15, 25, 50, 125)),
            i;
        for (i = 0; i < a.length; i++) {
            assert.equal(b.format(a[i][0]), a[i][1], a[i][0] + ' ---> ' + a[i][1]);
        }
    });

    test('format ordinal', function (assert) {
        assert.equal(moment([2011, 0, 1]).format('DDDo'), '1', '1');
        assert.equal(moment([2011, 0, 2]).format('DDDo'), '2', '2');
        assert.equal(moment([2011, 0, 3]).format('DDDo'), '3', '3');
        assert.equal(moment([2011, 0, 4]).format('DDDo'), '4', '4');
        assert.equal(moment([2011, 0, 5]).format('DDDo'), '5', '5');
        assert.equal(moment([2011, 0, 6]).format('DDDo'), '6', '6');
        assert.equal(moment([2011, 0, 7]).format('DDDo'), '7', '7');
        assert.equal(moment([2011, 0, 8]).format('DDDo'), '8', '8');
        assert.equal(moment([2011, 0, 9]).format('DDDo'), '9', '9');
        assert.equal(moment([2011, 0, 10]).format('DDDo'), '10', '10');

        assert.equal(moment([2011, 0, 11]).format('DDDo'), '11', '11');
        assert.equal(moment([2011, 0, 12]).format('DDDo'), '12', '12');
        assert.equal(moment([2011, 0, 13]).format('DDDo'), '13', '13');
        assert.equal(moment([2011, 0, 14]).format('DDDo'), '14', '14');
        assert.equal(moment([2011, 0, 15]).format('DDDo'), '15', '15');
        assert.equal(moment([2011, 0, 16]).format('DDDo'), '16', '16');
        assert.equal(moment([2011, 0, 17]).format('DDDo'), '17', '17');
        assert.equal(moment([2011, 0, 18]).format('DDDo'), '18', '18');
        assert.equal(moment([2011, 0, 19]).format('DDDo'), '19', '19');
        assert.equal(moment([2011, 0, 20]).format('DDDo'), '20', '20');

        assert.equal(moment([2011, 0, 21]).format('DDDo'), '21', '21');
        assert.equal(moment([2011, 0, 22]).format('DDDo'), '22', '22');
        assert.equal(moment([2011, 0, 23]).format('DDDo'), '23', '23');
        assert.equal(moment([2011, 0, 24]).format('DDDo'), '24', '24');
        assert.equal(moment([2011, 0, 25]).format('DDDo'), '25', '25');
        assert.equal(moment([2011, 0, 26]).format('DDDo'), '26', '26');
        assert.equal(moment([2011, 0, 27]).format('DDDo'), '27', '27');
        assert.equal(moment([2011, 0, 28]).format('DDDo'), '28', '28');
        assert.equal(moment([2011, 0, 29]).format('DDDo'), '29', '29');
        assert.equal(moment([2011, 0, 30]).format('DDDo'), '30', '30');

        assert.equal(moment([2011, 0, 31]).format('DDDo'), '31', '31');
    });

    test('format month', function (assert) {
        var expected = 'à´à´¨àµà´µà´°à´¿ à´à´¨àµ._à´«àµà´¬àµà´°àµà´µà´°à´¿ à´«àµà´¬àµà´°àµ._à´®à´¾àµ¼à´àµà´àµ à´®à´¾àµ¼._à´à´ªàµà´°à´¿àµ½ à´à´ªàµà´°à´¿._à´®àµà´¯àµ à´®àµà´¯àµ_à´àµàµº à´àµàµº_à´àµà´²àµ à´àµà´²àµ._à´à´à´¸àµà´±àµà´±àµ à´à´._à´¸àµà´ªàµà´±àµà´±à´à´¬àµ¼ à´¸àµà´ªàµà´±àµà´±._à´à´àµà´àµà´¬àµ¼ à´à´àµà´àµ._à´¨à´µà´à´¬àµ¼ à´¨à´µà´._à´¡à´¿à´¸à´à´¬àµ¼ à´¡à´¿à´¸à´.'.split('_'), i;
        for (i = 0; i < expected.length; i++) {
            assert.equal(moment([2011, i, 1]).format('MMMM MMM'), expected[i], expected[i]);
        }
    });

    test('format week', function (assert) {
        var expected = 'à´à´¾à´¯à´±à´¾à´´àµà´ à´à´¾à´¯àµ¼ à´à´¾_à´¤à´¿à´àµà´à´³à´¾à´´àµà´ à´¤à´¿à´àµà´àµ¾ à´¤à´¿_à´àµà´µàµà´µà´¾à´´àµà´ à´àµà´µàµà´µ à´àµ_à´¬àµà´§à´¨à´¾à´´àµà´ à´¬àµà´§àµ» à´¬àµ_à´µàµà´¯à´¾à´´à´¾à´´àµà´ à´µàµà´¯à´¾à´´à´ à´µàµà´¯à´¾_à´µàµà´³àµà´³à´¿à´¯à´¾à´´àµà´ à´µàµà´³àµà´³à´¿ à´µàµ_à´¶à´¨à´¿à´¯à´¾à´´àµà´ à´¶à´¨à´¿ à´¶'.split('_'), i;
        for (i = 0; i < expected.length; i++) {
            assert.equal(moment([2011, 0, 2 + i]).format('dddd ddd dd'), expected[i], expected[i]);
        }
    });

    test('from', function (assert) {
        var start = moment([2007, 1, 28]);
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 44}), true),  'à´àµ½à´ª à´¨à´¿à´®à´¿à´·à´àµà´àµ¾', '44 seconds = a few seconds');
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 45}), true),  'à´à´°àµ à´®à´¿à´¨à´¿à´±àµà´±àµ',      '45 seconds = a minute');
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 89}), true),  'à´à´°àµ à´®à´¿à´¨à´¿à´±àµà´±àµ',      '89 seconds = a minute');
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 90}), true),  '2 à´®à´¿à´¨à´¿à´±àµà´±àµ',     '90 seconds = 2 minutes');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 44}), true),  '44 à´®à´¿à´¨à´¿à´±àµà´±àµ',    '44 minutes = 44 minutes');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 45}), true),  'à´à´°àµ à´®à´£à´¿à´àµà´àµàµ¼',       '45 minutes = an hour');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 89}), true),  'à´à´°àµ à´®à´£à´¿à´àµà´àµàµ¼',       '89 minutes = an hour');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 90}), true),  '2 à´®à´£à´¿à´àµà´àµàµ¼',       '90 minutes = 2 hours');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 5}), true),   '5 à´®à´£à´¿à´àµà´àµàµ¼',       '5 hours = 5 hours');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 21}), true),  '21 à´®à´£à´¿à´àµà´àµàµ¼',      '21 hours = 21 hours');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 22}), true),  'à´à´°àµ à´¦à´¿à´µà´¸à´',         '22 hours = a day');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 35}), true),  'à´à´°àµ à´¦à´¿à´µà´¸à´',         '35 hours = a day');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 36}), true),  '2 à´¦à´¿à´µà´¸à´',        '36 hours = 2 days');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 1}), true),   'à´à´°àµ à´¦à´¿à´µà´¸à´',         '1 day = a day');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 5}), true),   '5 à´¦à´¿à´µà´¸à´',        '5 days = 5 days');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 25}), true),  '25 à´¦à´¿à´µà´¸à´',       '25 days = 25 days');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 26}), true),  'à´à´°àµ à´®à´¾à´¸à´',       '26 days = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 30}), true),  'à´à´°àµ à´®à´¾à´¸à´',       '30 days = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 43}), true),  'à´à´°àµ à´®à´¾à´¸à´',       '43 days = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 46}), true),  '2 à´®à´¾à´¸à´',      '46 days = 2 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 74}), true),  '2 à´®à´¾à´¸à´',      '75 days = 2 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 76}), true),  '3 à´®à´¾à´¸à´',      '76 days = 3 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({M: 1}), true),   'à´à´°àµ à´®à´¾à´¸à´',       '1 month = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({M: 5}), true),   '5 à´®à´¾à´¸à´',      '5 months = 5 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 345}), true), 'à´à´°àµ à´µàµ¼à´·à´',        '345 days = a year');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 548}), true), '2 à´µàµ¼à´·à´',       '548 days = 2 years');
        assert.equal(start.from(moment([2007, 1, 28]).add({y: 1}), true),   'à´à´°àµ à´µàµ¼à´·à´',        '1 year = a year');
        assert.equal(start.from(moment([2007, 1, 28]).add({y: 5}), true),   '5 à´µàµ¼à´·à´',       '5 years = 5 years');
    });

    test('suffix', function (assert) {
        assert.equal(moment(30000).from(0), 'à´àµ½à´ª à´¨à´¿à´®à´¿à´·à´àµà´àµ¾ à´à´´à´¿à´àµà´àµ',  'prefix');
        assert.equal(moment(0).from(30000), 'à´àµ½à´ª à´¨à´¿à´®à´¿à´·à´àµà´àµ¾ à´®àµàµ»à´ªàµ', 'suffix');
    });

    test('now from now', function (assert) {
        assert.equal(moment().fromNow(), 'à´àµ½à´ª à´¨à´¿à´®à´¿à´·à´àµà´àµ¾ à´®àµàµ»à´ªàµ',  'now from now should display as in the past');
    });

    test('fromNow', function (assert) {
        assert.equal(moment().add({s: 30}).fromNow(), 'à´àµ½à´ª à´¨à´¿à´®à´¿à´·à´àµà´àµ¾ à´à´´à´¿à´àµà´àµ', 'à´àµ½à´ª à´¨à´¿à´®à´¿à´·à´àµà´àµ¾ à´à´´à´¿à´àµà´àµ');
        assert.equal(moment().add({d: 5}).fromNow(), '5 à´¦à´¿à´µà´¸à´ à´à´´à´¿à´àµà´àµ', '5 à´¦à´¿à´µà´¸à´ à´à´´à´¿à´àµà´àµ');
    });

    test('calendar day', function (assert) {
        var a = moment().hours(12).minutes(0).seconds(0);

        assert.equal(moment(a).calendar(),                   'à´à´¨àµà´¨àµ à´à´àµà´ à´à´´à´¿à´àµà´àµ 12:00 -à´¨àµ',   'today at the same time');
        assert.equal(moment(a).add({m: 25}).calendar(),      'à´à´¨àµà´¨àµ à´à´àµà´ à´à´´à´¿à´àµà´àµ 12:25 -à´¨àµ',   'Now plus 25 min');
        assert.equal(moment(a).add({h: 3}).calendar(),       'à´à´¨àµà´¨àµ à´à´àµà´ à´à´´à´¿à´àµà´àµ 3:00 -à´¨àµ',    'Now plus 3 hours');
        assert.equal(moment(a).add({d: 1}).calendar(),       'à´¨à´¾à´³àµ à´à´àµà´ à´à´´à´¿à´àµà´àµ 12:00 -à´¨àµ',    'tomorrow at the same time');
        assert.equal(moment(a).subtract({h: 1}).calendar(),  'à´à´¨àµà´¨àµ à´°à´¾à´µà´¿à´²àµ 11:00 -à´¨àµ',         'Now minus 1 hour');
        assert.equal(moment(a).subtract({d: 1}).calendar(),  'à´à´¨àµà´¨à´²àµ à´à´àµà´ à´à´´à´¿à´àµà´àµ 12:00 -à´¨àµ',  'yesterday at the same time');
    });

    test('calendar next week', function (assert) {
        var i, m;
        for (i = 2; i < 7; i++) {
            m = moment().add({d: i});
            assert.equal(m.calendar(),       m.format('dddd[,] LT'),  'Today + ' + i + ' days current time');
            m.hours(0).minutes(0).seconds(0).milliseconds(0);
            assert.equal(m.calendar(),       m.format('dddd[,] LT'),  'Today + ' + i + ' days beginning of day');
            m.hours(23).minutes(59).seconds(59).milliseconds(999);
            assert.equal(m.calendar(),       m.format('dddd[,] LT'),  'Today + ' + i + ' days end of day');
        }
    });

    test('calendar last week', function (assert) {
        var i, m;

        for (i = 2; i < 7; i++) {
            m = moment().subtract({d: i});
            assert.equal(m.calendar(),       m.format('[à´à´´à´¿à´àµà´] dddd[,] LT'),  'Today - ' + i + ' days current time');
            m.hours(0).minutes(0).seconds(0).milliseconds(0);
            assert.equal(m.calendar(),       m.format('[à´à´´à´¿à´àµà´] dddd[,] LT'),  'Today - ' + i + ' days beginning of day');
            m.hours(23).minutes(59).seconds(59).milliseconds(999);
            assert.equal(m.calendar(),       m.format('[à´à´´à´¿à´àµà´] dddd[,] LT'),  'Today - ' + i + ' days end of day');
        }
    });

    test('calendar all else', function (assert) {
        var weeksAgo = moment().subtract({w: 1}),
            weeksFromNow = moment().add({w: 1});

        assert.equal(weeksAgo.calendar(),       weeksAgo.format('L'),  '1 week ago');
        assert.equal(weeksFromNow.calendar(),   weeksFromNow.format('L'),  'in 1 week');

        weeksAgo = moment().subtract({w: 2});
        weeksFromNow = moment().add({w: 2});

        assert.equal(weeksAgo.calendar(),       weeksAgo.format('L'),  '2 weeks ago');
        assert.equal(weeksFromNow.calendar(),   weeksFromNow.format('L'),  'in 2 weeks');
    });

    test('meridiem', function (assert) {
        assert.equal(moment([2011, 2, 23,  2, 30]).format('a'), 'à´°à´¾à´¤àµà´°à´¿', 'before dawn');
        assert.equal(moment([2011, 2, 23,  9, 30]).format('a'), 'à´°à´¾à´µà´¿à´²àµ', 'morning');
        assert.equal(moment([2011, 2, 23, 14, 30]).format('a'), 'à´à´àµà´ à´à´´à´¿à´àµà´àµ', 'during day');
        assert.equal(moment([2011, 2, 23, 17, 30]).format('a'), 'à´µàµà´àµà´¨àµà´¨àµà´°à´', 'evening');
        assert.equal(moment([2011, 2, 23, 19, 30]).format('a'), 'à´µàµà´àµà´¨àµà´¨àµà´°à´', 'late evening');
        assert.equal(moment([2011, 2, 23, 21, 20]).format('a'), 'à´°à´¾à´¤àµà´°à´¿', 'night');

        assert.equal(moment([2011, 2, 23,  2, 30]).format('A'), 'à´°à´¾à´¤àµà´°à´¿', 'before dawn');
        assert.equal(moment([2011, 2, 23,  9, 30]).format('A'), 'à´°à´¾à´µà´¿à´²àµ', 'morning');
        assert.equal(moment([2011, 2, 23, 14, 30]).format('A'), 'à´à´àµà´ à´à´´à´¿à´àµà´àµ', ' during day');
        assert.equal(moment([2011, 2, 23, 17, 30]).format('A'), 'à´µàµà´àµà´¨àµà´¨àµà´°à´', 'evening');
        assert.equal(moment([2011, 2, 23, 19, 30]).format('A'), 'à´µàµà´àµà´¨àµà´¨àµà´°à´', 'late evening');
        assert.equal(moment([2011, 2, 23, 21, 20]).format('A'), 'à´°à´¾à´¤àµà´°à´¿', 'night');
    });

    test('weeks year starting sunday formatted', function (assert) {
        assert.equal(moment([2012, 0,  1]).format('w ww wo'), '1 01 1', 'Jan  1 2012 should be week 1');
        assert.equal(moment([2012, 0,  7]).format('w ww wo'), '1 01 1', 'Jan  7 2012 should be week 1');
        assert.equal(moment([2012, 0,  8]).format('w ww wo'), '2 02 2', 'Jan  8 2012 should be week 2');
        assert.equal(moment([2012, 0, 14]).format('w ww wo'), '2 02 2', 'Jan 14 2012 should be week 2');
        assert.equal(moment([2012, 0, 15]).format('w ww wo'), '3 03 3', 'Jan 15 2012 should be week 3');
    });

}));

;(function (global, factory) {
   typeof exports === 'object' && typeof module !== 'undefined'
       && typeof require === 'function' ? factory(require('../../moment')) :
   typeof define === 'function' && define.amd ? define(['../../moment'], factory) :
   factory(global.moment)
}(this, function (moment) { 'use strict';

    function each(array, callback) {
        var i;
        for (i = 0; i < array.length; i++) {
            callback(array[i], i, array);
        }
    }

    function objectKeys(obj) {
        if (Object.keys) {
            return Object.keys(obj);
        } else {
            // IE8
            var res = [], i;
            for (i in obj) {
                if (obj.hasOwnProperty(i)) {
                    res.push(i);
                }
            }
            return res;
        }
    }

    // Pick the first defined of two or three arguments.
    function defaults(a, b, c) {
        if (a != null) {
            return a;
        }
        if (b != null) {
            return b;
        }
        return c;
    }

    function defineCommonLocaleTests(locale, options) {
        test('lenient ordinal parsing', function (assert) {
            var i, ordinalStr, testMoment;
            for (i = 1; i <= 31; ++i) {
                ordinalStr = moment([2014, 0, i]).format('YYYY MM Do');
                testMoment = moment(ordinalStr, 'YYYY MM Do');
                assert.equal(testMoment.year(), 2014,
                        'lenient ordinal parsing ' + i + ' year check');
                assert.equal(testMoment.month(), 0,
                        'lenient ordinal parsing ' + i + ' month check');
                assert.equal(testMoment.date(), i,
                        'lenient ordinal parsing ' + i + ' date check');
            }
        });

        test('lenient ordinal parsing of number', function (assert) {
            var i, testMoment;
            for (i = 1; i <= 31; ++i) {
                testMoment = moment('2014 01 ' + i, 'YYYY MM Do');
                assert.equal(testMoment.year(), 2014,
                        'lenient ordinal parsing of number ' + i + ' year check');
                assert.equal(testMoment.month(), 0,
                        'lenient ordinal parsing of number ' + i + ' month check');
                assert.equal(testMoment.date(), i,
                        'lenient ordinal parsing of number ' + i + ' date check');
            }
        });

        test('strict ordinal parsing', function (assert) {
            var i, ordinalStr, testMoment;
            for (i = 1; i <= 31; ++i) {
                ordinalStr = moment([2014, 0, i]).format('YYYY MM Do');
                testMoment = moment(ordinalStr, 'YYYY MM Do', true);
                assert.ok(testMoment.isValid(), 'strict ordinal parsing ' + i);
            }
        });

        test('meridiem invariant', function (assert) {
            var h, m, t1, t2;
            for (h = 0; h < 24; ++h) {
                for (m = 0; m < 60; m += 15) {
                    t1 = moment.utc([2000, 0, 1, h, m]);
                    t2 = moment.utc(t1.format('A h:mm'), 'A h:mm');
                    assert.equal(t2.format('HH:mm'), t1.format('HH:mm'),
                            'meridiem at ' + t1.format('HH:mm'));
                }
            }
        });

        test('date format correctness', function (assert) {
            var data, tokens;
            data = moment.localeData()._longDateFormat;
            tokens = objectKeys(data);
            each(tokens, function (srchToken) {
                // Check each format string to make sure it does not contain any
                // tokens that need to be expanded.
                each(tokens, function (baseToken) {
                    // strip escaped sequences
                    var format = data[baseToken].replace(/(\[[^\]]*\])/g, '');
                    assert.equal(false, !!~format.indexOf(srchToken),
                            'contains ' + srchToken + ' in ' + baseToken);
                });
            });
        });

        test('month parsing correctness', function (assert) {
            var i, m;

            if (locale === 'tr') {
                // I can't fix it :(
                expect(0);
                return;
            }
            function tester(format) {
                var r;
                r = moment(m.format(format), format);
                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format);
                r = moment(m.format(format).toLocaleUpperCase(), format);
                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' upper');
                r = moment(m.format(format).toLocaleLowerCase(), format);
                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' lower');

                r = moment(m.format(format), format, true);
                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' strict');
                r = moment(m.format(format).toLocaleUpperCase(), format, true);
                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' upper strict');
                r = moment(m.format(format).toLocaleLowerCase(), format, true);
                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' lower strict');
            }

            for (i = 0; i < 12; ++i) {
                m = moment([2015, i, 15, 18]);
                tester('MMM');
                tester('MMM.');
                tester('MMMM');
                tester('MMMM.');
            }
        });

        test('weekday parsing correctness', function (assert) {
            var i, m;

            if (locale === 'tr' || locale === 'az') {
                // There is a lower-case letter (Ä±), that converted to upper then
                // lower changes to i
                expect(0);
                return;
            }
            function tester(format) {
                var r, baseMsg = 'weekday ' + m.weekday() + ' fmt ' + format;
                r = moment(m.format(format), format);
                assert.equal(r.weekday(), m.weekday(), baseMsg);
                r = moment(m.format(format).toLocaleUpperCase(), format);
                assert.equal(r.weekday(), m.weekday(), baseMsg + ' upper');
                r = moment(m.format(format).toLocaleLowerCase(), format);
                assert.equal(r.weekday(), m.weekday(), baseMsg + ' lower');

                r = moment(m.format(format), format, true);
                assert.equal(r.weekday(), m.weekday(), baseMsg + ' strict');
                r = moment(m.format(format).toLocaleUpperCase(), format, true);
                assert.equal(r.weekday(), m.weekday(), baseMsg + ' upper strict');
                r = moment(m.format(format).toLocaleLowerCase(), format, true);
                assert.equal(r.weekday(), m.weekday(), baseMsg + ' lower strict');
            }

            for (i = 0; i < 7; ++i) {
                m = moment.utc([2015, i, 15, 18]);
                tester('dd');
                tester('ddd');
                tester('dddd');
            }
        });
    }

    function setupDeprecationHandler(test, moment, scope) {
        test._expectedDeprecations = null;
        test._observedDeprecations = null;
        test._oldSupress = moment.suppressDeprecationWarnings;
        moment.suppressDeprecationWarnings = true;
        test.expectedDeprecations = function () {
            test._expectedDeprecations = arguments;
            test._observedDeprecations = [];
        };
        moment.deprecationHandler = function (name, msg) {
            var deprecationId = matchedDeprecation(name, msg, test._expectedDeprecations);
            if (deprecationId === -1) {
                throw new Error('Unexpected deprecation thrown name=' +
                        name + ' msg=' + msg);
            }
            test._observedDeprecations[deprecationId] = 1;
        };
    }

    function teardownDeprecationHandler(test, moment, scope) {
        moment.suppressDeprecationWarnings = test._oldSupress;

        if (test._expectedDeprecations != null) {
            var missedDeprecations = [];
            each(test._expectedDeprecations, function (deprecationPattern, id) {
                if (test._observedDeprecations[id] !== 1) {
                    missedDeprecations.push(deprecationPattern);
                }
            });
            if (missedDeprecations.length !== 0) {
                throw new Error('Expected deprecation warnings did not happen: ' +
                        missedDeprecations.join(' '));
            }
        }
    }

    function matchedDeprecation(name, msg, deprecations) {
        if (deprecations == null) {
            return -1;
        }
        for (var i = 0; i < deprecations.length; ++i) {
            if (name != null && name === deprecations[i]) {
                return i;
            }
            if (msg != null && msg.substring(0, deprecations[i].length) === deprecations[i]) {
                return i;
            }
        }
        return -1;
    }

    /*global QUnit:false*/

    var test = QUnit.test;

    var expect = QUnit.expect;

    function module (name, lifecycle) {
        QUnit.module(name, {
            setup : function () {
                moment.locale('en');
                moment.createFromInputFallback = function (config) {
                    throw new Error('input not handled by moment: ' + config._i);
                };
                setupDeprecationHandler(test, moment, 'core');
                if (lifecycle && lifecycle.setup) {
                    lifecycle.setup();
                }
            },
            teardown : function () {
                teardownDeprecationHandler(test, moment, 'core');
                if (lifecycle && lifecycle.teardown) {
                    lifecycle.teardown();
                }
            }
        });
    }

    function localeModule (name, lifecycle) {
        QUnit.module('locale:' + name, {
            setup : function () {
                moment.locale(name);
                moment.createFromInputFallback = function (config) {
                    throw new Error('input not handled by moment: ' + config._i);
                };
                setupDeprecationHandler(test, moment, 'locale');
                if (lifecycle && lifecycle.setup) {
                    lifecycle.setup();
                }
            },
            teardown : function () {
                moment.locale('en');
                teardownDeprecationHandler(test, moment, 'locale');
                if (lifecycle && lifecycle.teardown) {
                    lifecycle.teardown();
                }
            }
        });
        defineCommonLocaleTests(name, -1, -1);
    }

    localeModule('mr');

    test('parse', function (assert) {
        var tests = 'à¤à¤¾à¤¨à¥à¤µà¤¾à¤°à¥ à¤à¤¾à¤¨à¥._à¤«à¥à¤¬à¥à¤°à¥à¤µà¤¾à¤°à¥ à¤«à¥à¤¬à¥à¤°à¥._à¤®à¤¾à¤°à¥à¤ à¤®à¤¾à¤°à¥à¤._à¤à¤ªà¥à¤°à¤¿à¤² à¤à¤ªà¥à¤°à¤¿._à¤®à¥ à¤®à¥._à¤à¥à¤¨ à¤à¥à¤¨._à¤à¥à¤²à¥ à¤à¥à¤²à¥._à¤à¤à¤¸à¥à¤ à¤à¤._à¤¸à¤ªà¥à¤à¥à¤à¤¬à¤° à¤¸à¤ªà¥à¤à¥à¤._à¤à¤à¥à¤à¥à¤¬à¤° à¤à¤à¥à¤à¥._à¤¨à¥à¤µà¥à¤¹à¥à¤à¤¬à¤° à¤¨à¥à¤µà¥à¤¹à¥à¤._à¤¡à¤¿à¤¸à¥à¤à¤¬à¤° à¤¡à¤¿à¤¸à¥à¤.'.split('_'), i;
        function equalTest(input, mmm, i) {
            assert.equal(moment(input, mmm).month(), i, input + ' should be month ' + (i + 1));
        }
        for (i = 0; i < 12; i++) {
            tests[i] = tests[i].split(' ');
            equalTest(tests[i][0], 'MMM', i);
            equalTest(tests[i][1], 'MMM', i);
            equalTest(tests[i][0], 'MMMM', i);
            equalTest(tests[i][1], 'MMMM', i);
            equalTest(tests[i][0].toLocaleLowerCase(), 'MMMM', i);
            equalTest(tests[i][1].toLocaleLowerCase(), 'MMMM', i);
            equalTest(tests[i][0].toLocaleUpperCase(), 'MMMM', i);
            equalTest(tests[i][1].toLocaleUpperCase(), 'MMMM', i);
        }
    });

    test('format', function (assert) {
        var a = [
                ['dddd, Do MMMM YYYY, a h:mm:ss à¤µà¤¾à¤à¤¤à¤¾', 'à¤°à¤µà¤¿à¤µà¤¾à¤°, à¥§à¥ª à¤«à¥à¤¬à¥à¤°à¥à¤µà¤¾à¤°à¥ à¥¨à¥¦à¥§à¥¦, à¤¦à¥à¤ªà¤¾à¤°à¥ à¥©:à¥¨à¥«:à¥«à¥¦ à¤µà¤¾à¤à¤¤à¤¾'],
                ['ddd, a h à¤µà¤¾à¤à¤¤à¤¾',                       'à¤°à¤µà¤¿, à¤¦à¥à¤ªà¤¾à¤°à¥ à¥© à¤µà¤¾à¤à¤¤à¤¾'],
                ['M Mo MM MMMM MMM',                   'à¥¨ à¥¨ à¥¦à¥¨ à¤«à¥à¤¬à¥à¤°à¥à¤µà¤¾à¤°à¥ à¤«à¥à¤¬à¥à¤°à¥.'],
                ['YYYY YY',                            'à¥¨à¥¦à¥§à¥¦ à¥§à¥¦'],
                ['D Do DD',                            'à¥§à¥ª à¥§à¥ª à¥§à¥ª'],
                ['d do dddd ddd dd',                   'à¥¦ à¥¦ à¤°à¤µà¤¿à¤µà¤¾à¤° à¤°à¤µà¤¿ à¤°'],
                ['DDD DDDo DDDD',                      'à¥ªà¥« à¥ªà¥« à¥¦à¥ªà¥«'],
                ['w wo ww',                            'à¥® à¥® à¥¦à¥®'],
                ['h hh',                               'à¥© à¥¦à¥©'],
                ['H HH',                               'à¥§à¥« à¥§à¥«'],
                ['m mm',                               'à¥¨à¥« à¥¨à¥«'],
                ['s ss',                               'à¥«à¥¦ à¥«à¥¦'],
                ['a A',                                'à¤¦à¥à¤ªà¤¾à¤°à¥ à¤¦à¥à¤ªà¤¾à¤°à¥'],
                ['LTS',                                'à¤¦à¥à¤ªà¤¾à¤°à¥ à¥©:à¥¨à¥«:à¥«à¥¦ à¤µà¤¾à¤à¤¤à¤¾'],
                ['L',                                  'à¥§à¥ª/à¥¦à¥¨/à¥¨à¥¦à¥§à¥¦'],
                ['LL',                                 'à¥§à¥ª à¤«à¥à¤¬à¥à¤°à¥à¤µà¤¾à¤°à¥ à¥¨à¥¦à¥§à¥¦'],
                ['LLL',                                'à¥§à¥ª à¤«à¥à¤¬à¥à¤°à¥à¤µà¤¾à¤°à¥ à¥¨à¥¦à¥§à¥¦, à¤¦à¥à¤ªà¤¾à¤°à¥ à¥©:à¥¨à¥« à¤µà¤¾à¤à¤¤à¤¾'],
                ['LLLL',                               'à¤°à¤µà¤¿à¤µà¤¾à¤°, à¥§à¥ª à¤«à¥à¤¬à¥à¤°à¥à¤µà¤¾à¤°à¥ à¥¨à¥¦à¥§à¥¦, à¤¦à¥à¤ªà¤¾à¤°à¥ à¥©:à¥¨à¥« à¤µà¤¾à¤à¤¤à¤¾'],
                ['l',                                  'à¥§à¥ª/à¥¨/à¥¨à¥¦à¥§à¥¦'],
                ['ll',                                 'à¥§à¥ª à¤«à¥à¤¬à¥à¤°à¥. à¥¨à¥¦à¥§à¥¦'],
                ['lll',                                'à¥§à¥ª à¤«à¥à¤¬à¥à¤°à¥. à¥¨à¥¦à¥§à¥¦, à¤¦à¥à¤ªà¤¾à¤°à¥ à¥©:à¥¨à¥« à¤µà¤¾à¤à¤¤à¤¾'],
                ['llll',                               'à¤°à¤µà¤¿, à¥§à¥ª à¤«à¥à¤¬à¥à¤°à¥. à¥¨à¥¦à¥§à¥¦, à¤¦à¥à¤ªà¤¾à¤°à¥ à¥©:à¥¨à¥« à¤µà¤¾à¤à¤¤à¤¾']
            ],
            b = moment(new Date(2010, 1, 14, 15, 25, 50, 125)),
            i;
        for (i = 0; i < a.length; i++) {
            assert.equal(b.format(a[i][0]), a[i][1], a[i][0] + ' ---> ' + a[i][1]);
        }
    });

    test('format ordinal', function (assert) {
        assert.equal(moment([2011, 0, 1]).format('DDDo'), 'à¥§', 'à¥§');
        assert.equal(moment([2011, 0, 2]).format('DDDo'), 'à¥¨', 'à¥¨');
        assert.equal(moment([2011, 0, 3]).format('DDDo'), 'à¥©', 'à¥©');
        assert.equal(moment([2011, 0, 4]).format('DDDo'), 'à¥ª', 'à¥ª');
        assert.equal(moment([2011, 0, 5]).format('DDDo'), 'à¥«', 'à¥«');
        assert.equal(moment([2011, 0, 6]).format('DDDo'), 'à¥¬', 'à¥¬');
        assert.equal(moment([2011, 0, 7]).format('DDDo'), 'à¥­', 'à¥­');
        assert.equal(moment([2011, 0, 8]).format('DDDo'), 'à¥®', 'à¥®');
        assert.equal(moment([2011, 0, 9]).format('DDDo'), 'à¥¯', 'à¥¯');
        assert.equal(moment([2011, 0, 10]).format('DDDo'), 'à¥§à¥¦', 'à¥§à¥¦');

        assert.equal(moment([2011, 0, 11]).format('DDDo'), 'à¥§à¥§', 'à¥§à¥§');
        assert.equal(moment([2011, 0, 12]).format('DDDo'), 'à¥§à¥¨', 'à¥§à¥¨');
        assert.equal(moment([2011, 0, 13]).format('DDDo'), 'à¥§à¥©', 'à¥§à¥©');
        assert.equal(moment([2011, 0, 14]).format('DDDo'), 'à¥§à¥ª', 'à¥§à¥ª');
        assert.equal(moment([2011, 0, 15]).format('DDDo'), 'à¥§à¥«', 'à¥§à¥«');
        assert.equal(moment([2011, 0, 16]).format('DDDo'), 'à¥§à¥¬', 'à¥§à¥¬');
        assert.equal(moment([2011, 0, 17]).format('DDDo'), 'à¥§à¥­', 'à¥§à¥­');
        assert.equal(moment([2011, 0, 18]).format('DDDo'), 'à¥§à¥®', 'à¥§à¥®');
        assert.equal(moment([2011, 0, 19]).format('DDDo'), 'à¥§à¥¯', 'à¥§à¥¯');
        assert.equal(moment([2011, 0, 20]).format('DDDo'), 'à¥¨à¥¦', 'à¥¨à¥¦');

        assert.equal(moment([2011, 0, 21]).format('DDDo'), 'à¥¨à¥§', 'à¥¨à¥§');
        assert.equal(moment([2011, 0, 22]).format('DDDo'), 'à¥¨à¥¨', 'à¥¨à¥¨');
        assert.equal(moment([2011, 0, 23]).format('DDDo'), 'à¥¨à¥©', 'à¥¨à¥©');
        assert.equal(moment([2011, 0, 24]).format('DDDo'), 'à¥¨à¥ª', 'à¥¨à¥ª');
        assert.equal(moment([2011, 0, 25]).format('DDDo'), 'à¥¨à¥«', 'à¥¨à¥«');
        assert.equal(moment([2011, 0, 26]).format('DDDo'), 'à¥¨à¥¬', 'à¥¨à¥¬');
        assert.equal(moment([2011, 0, 27]).format('DDDo'), 'à¥¨à¥­', 'à¥¨à¥­');
        assert.equal(moment([2011, 0, 28]).format('DDDo'), 'à¥¨à¥®', 'à¥¨à¥®');
        assert.equal(moment([2011, 0, 29]).format('DDDo'), 'à¥¨à¥¯', 'à¥¨à¥¯');
        assert.equal(moment([2011, 0, 30]).format('DDDo'), 'à¥©à¥¦', 'à¥©à¥¦');

        assert.equal(moment([2011, 0, 31]).format('DDDo'), 'à¥©à¥§', 'à¥©à¥§');
    });

    test('format month', function (assert) {
        var expected = 'à¤à¤¾à¤¨à¥à¤µà¤¾à¤°à¥ à¤à¤¾à¤¨à¥._à¤«à¥à¤¬à¥à¤°à¥à¤µà¤¾à¤°à¥ à¤«à¥à¤¬à¥à¤°à¥._à¤®à¤¾à¤°à¥à¤ à¤®à¤¾à¤°à¥à¤._à¤à¤ªà¥à¤°à¤¿à¤² à¤à¤ªà¥à¤°à¤¿._à¤®à¥ à¤®à¥._à¤à¥à¤¨ à¤à¥à¤¨._à¤à¥à¤²à¥ à¤à¥à¤²à¥._à¤à¤à¤¸à¥à¤ à¤à¤._à¤¸à¤ªà¥à¤à¥à¤à¤¬à¤° à¤¸à¤ªà¥à¤à¥à¤._à¤à¤à¥à¤à¥à¤¬à¤° à¤à¤à¥à¤à¥._à¤¨à¥à¤µà¥à¤¹à¥à¤à¤¬à¤° à¤¨à¥à¤µà¥à¤¹à¥à¤._à¤¡à¤¿à¤¸à¥à¤à¤¬à¤° à¤¡à¤¿à¤¸à¥à¤.'.split('_'), i;
        for (i = 0; i < expected.length; i++) {
            assert.equal(moment([2011, i, 1]).format('MMMM MMM'), expected[i], expected[i]);
        }
    });

    test('format week', function (assert) {
        var expected = 'à¤°à¤µà¤¿à¤µà¤¾à¤° à¤°à¤µà¤¿ à¤°_à¤¸à¥à¤®à¤µà¤¾à¤° à¤¸à¥à¤® à¤¸à¥_à¤®à¤à¤à¤³à¤µà¤¾à¤° à¤®à¤à¤à¤³ à¤®à¤_à¤¬à¥à¤§à¤µà¤¾à¤° à¤¬à¥à¤§ à¤¬à¥_à¤à¥à¤°à¥à¤µà¤¾à¤° à¤à¥à¤°à¥ à¤à¥_à¤¶à¥à¤à¥à¤°à¤µà¤¾à¤° à¤¶à¥à¤à¥à¤° à¤¶à¥_à¤¶à¤¨à¤¿à¤µà¤¾à¤° à¤¶à¤¨à¤¿ à¤¶'.split('_'), i;
        for (i = 0; i < expected.length; i++) {
            assert.equal(moment([2011, 0, 2 + i]).format('dddd ddd dd'), expected[i], expected[i]);
        }
    });

    test('from', function (assert) {
        var start = moment([2007, 1, 28]);
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 44}), true),  'à¤à¤¾à¤¹à¥ à¤¸à¥à¤à¤à¤¦', '44 seconds = a few seconds');
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 45}), true),  'à¤à¤ à¤®à¤¿à¤¨à¤¿à¤',      '45 seconds = a minute');
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 89}), true),  'à¤à¤ à¤®à¤¿à¤¨à¤¿à¤',      '89 seconds = a minute');
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 90}), true),  'à¥¨ à¤®à¤¿à¤¨à¤¿à¤à¥',     '90 seconds = 2 minutes');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 44}), true), 'à¥ªà¥ª à¤®à¤¿à¤¨à¤¿à¤à¥', '44 minutes = 44 minutes');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 45}), true),  'à¤à¤ à¤¤à¤¾à¤¸',       '45 minutes = an hour');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 89}), true),  'à¤à¤ à¤¤à¤¾à¤¸',       '89 minutes = an hour');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 90}), true),  'à¥¨ à¤¤à¤¾à¤¸',       '90 minutes = 2 hours');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 5}), true),   'à¥« à¤¤à¤¾à¤¸',       '5 hours = 5 hours');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 21}), true),  'à¥¨à¥§ à¤¤à¤¾à¤¸',      '21 hours = 21 hours');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 22}), true),  'à¤à¤ à¤¦à¤¿à¤µà¤¸',         '22 hours = a day');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 35}), true),  'à¤à¤ à¤¦à¤¿à¤µà¤¸',         '35 hours = a day');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 36}), true),  'à¥¨ à¤¦à¤¿à¤µà¤¸',        '36 hours = 2 days');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 1}), true),   'à¤à¤ à¤¦à¤¿à¤µà¤¸',         '1 day = a day');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 5}), true),   'à¥« à¤¦à¤¿à¤µà¤¸',        '5 days = 5 days');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 25}), true),  'à¥¨à¥« à¤¦à¤¿à¤µà¤¸',       '25 days = 25 days');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 26}), true), 'à¤à¤ à¤®à¤¹à¤¿à¤¨à¤¾', '26 days = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 30}), true), 'à¤à¤ à¤®à¤¹à¤¿à¤¨à¤¾', '30 days = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 43}), true), 'à¤à¤ à¤®à¤¹à¤¿à¤¨à¤¾', '43 days = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 46}), true), 'à¥¨ à¤®à¤¹à¤¿à¤¨à¥', '46 days = 2 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 74}), true), 'à¥¨ à¤®à¤¹à¤¿à¤¨à¥', '75 days = 2 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 76}), true), 'à¥© à¤®à¤¹à¤¿à¤¨à¥', '76 days = 3 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({M: 1}), true), 'à¤à¤ à¤®à¤¹à¤¿à¤¨à¤¾', '1 month = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({M: 5}), true), 'à¥« à¤®à¤¹à¤¿à¤¨à¥', '5 months = 5 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 345}), true), 'à¤à¤ à¤µà¤°à¥à¤·',        '345 days = a year');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 548}), true), 'à¥¨ à¤µà¤°à¥à¤·à¥',       '548 days = 2 years');
        assert.equal(start.from(moment([2007, 1, 28]).add({y: 1}), true),   'à¤à¤ à¤µà¤°à¥à¤·',        '1 year = a year');
        assert.equal(start.from(moment([2007, 1, 28]).add({y: 5}), true), 'à¥« à¤µà¤°à¥à¤·à¥', '5 years = 5 years');
    });

    test('suffix', function (assert) {
        assert.equal(moment(30000).from(0), 'à¤à¤¾à¤¹à¥ à¤¸à¥à¤à¤à¤¦à¤¾à¤à¤®à¤§à¥à¤¯à¥', 'prefix');
        assert.equal(moment(0).from(30000), 'à¤à¤¾à¤¹à¥ à¤¸à¥à¤à¤à¤¦à¤¾à¤à¤ªà¥à¤°à¥à¤µà¥', 'suffix');
    });

    test('now from now', function (assert) {
        assert.equal(moment().fromNow(), 'à¤à¤¾à¤¹à¥ à¤¸à¥à¤à¤à¤¦à¤¾à¤à¤ªà¥à¤°à¥à¤µà¥',  'now from now should display as in the past');
    });

    test('fromNow', function (assert) {
        assert.equal(moment().add({s: 30}).fromNow(), 'à¤à¤¾à¤¹à¥ à¤¸à¥à¤à¤à¤¦à¤¾à¤à¤®à¤§à¥à¤¯à¥', 'in a few seconds');
        assert.equal(moment().add({d: 5}).fromNow(), 'à¥« à¤¦à¤¿à¤µà¤¸à¤¾à¤à¤®à¤§à¥à¤¯à¥', 'in 5 days');
    });

    test('calendar day', function (assert) {
        var a = moment().hours(12).minutes(0).seconds(0);

        assert.equal(moment(a).calendar(),                   'à¤à¤ à¤¦à¥à¤ªà¤¾à¤°à¥ à¥§à¥¨:à¥¦à¥¦ à¤µà¤¾à¤à¤¤à¤¾',    'today at the same time');
        assert.equal(moment(a).add({m: 25}).calendar(),      'à¤à¤ à¤¦à¥à¤ªà¤¾à¤°à¥ à¥§à¥¨:à¥¨à¥« à¤µà¤¾à¤à¤¤à¤¾',    'Now plus 25 min');
        assert.equal(moment(a).add({h: 3}).calendar(),       'à¤à¤ à¤¦à¥à¤ªà¤¾à¤°à¥ à¥©:à¥¦à¥¦ à¤µà¤¾à¤à¤¤à¤¾',     'Now plus 3 hours');
        assert.equal(moment(a).add({d: 1}).calendar(),       'à¤à¤¦à¥à¤¯à¤¾ à¤¦à¥à¤ªà¤¾à¤°à¥ à¥§à¥¨:à¥¦à¥¦ à¤µà¤¾à¤à¤¤à¤¾', 'tomorrow at the same time');
        assert.equal(moment(a).subtract({h: 1}).calendar(),  'à¤à¤ à¤¦à¥à¤ªà¤¾à¤°à¥ à¥§à¥§:à¥¦à¥¦ à¤µà¤¾à¤à¤¤à¤¾',    'Now minus 1 hour');
        assert.equal(moment(a).subtract({d: 1}).calendar(),  'à¤à¤¾à¤² à¤¦à¥à¤ªà¤¾à¤°à¥ à¥§à¥¨:à¥¦à¥¦ à¤µà¤¾à¤à¤¤à¤¾',   'yesterday at the same time');
    });

    test('calendar next week', function (assert) {
        var i, m;
        for (i = 2; i < 7; i++) {
            m = moment().add({d: i});
            assert.equal(m.calendar(),       m.format('dddd[,] LT'),  'Today + ' + i + ' days current time');
            m.hours(0).minutes(0).seconds(0).milliseconds(0);
            assert.equal(m.calendar(),       m.format('dddd[,] LT'),  'Today + ' + i + ' days beginning of day');
            m.hours(23).minutes(59).seconds(59).milliseconds(999);
            assert.equal(m.calendar(),       m.format('dddd[,] LT'),  'Today + ' + i + ' days end of day');
        }
    });

    test('calendar last week', function (assert) {
        var i, m;

        for (i = 2; i < 7; i++) {
            m = moment().subtract({d: i});
            assert.equal(m.calendar(), m.format('[à¤®à¤¾à¤à¥à¤²] dddd[,] LT'), 'Today - ' + i + ' days current time');
            m.hours(0).minutes(0).seconds(0).milliseconds(0);
            assert.equal(m.calendar(), m.format('[à¤®à¤¾à¤à¥à¤²] dddd[,] LT'), 'Today - ' + i + ' days beginning of day');
            m.hours(23).minutes(59).seconds(59).milliseconds(999);
            assert.equal(m.calendar(), m.format('[à¤®à¤¾à¤à¥à¤²] dddd[,] LT'), 'Today - ' + i + ' days end of day');
        }
    });

    test('calendar all else', function (assert) {
        var weeksAgo = moment().subtract({w: 1}),
            weeksFromNow = moment().add({w: 1});

        assert.equal(weeksAgo.calendar(),       weeksAgo.format('L'),  '1 week ago');
        assert.equal(weeksFromNow.calendar(),   weeksFromNow.format('L'),  'in 1 week');

        weeksAgo = moment().subtract({w: 2});
        weeksFromNow = moment().add({w: 2});

        assert.equal(weeksAgo.calendar(),       weeksAgo.format('L'),  '2 weeks ago');
        assert.equal(weeksFromNow.calendar(),   weeksFromNow.format('L'),  'in 2 weeks');
    });

    test('meridiem', function (assert) {
        assert.equal(moment([2011, 2, 23,  2, 30]).format('a'), 'à¤°à¤¾à¤¤à¥à¤°à¥', 'before dawn');
        assert.equal(moment([2011, 2, 23,  9, 30]).format('a'), 'à¤¸à¤à¤¾à¤³à¥', 'morning');
        assert.equal(moment([2011, 2, 23, 14, 30]).format('a'), 'à¤¦à¥à¤ªà¤¾à¤°à¥', 'during day');
        assert.equal(moment([2011, 2, 23, 17, 30]).format('a'), 'à¤¸à¤¾à¤¯à¤à¤à¤¾à¤³à¥', 'evening');
        assert.equal(moment([2011, 2, 23, 19, 30]).format('a'), 'à¤¸à¤¾à¤¯à¤à¤à¤¾à¤³à¥', 'late evening');
        assert.equal(moment([2011, 2, 23, 21, 20]).format('a'), 'à¤°à¤¾à¤¤à¥à¤°à¥', 'night');

        assert.equal(moment([2011, 2, 23,  2, 30]).format('A'), 'à¤°à¤¾à¤¤à¥à¤°à¥', 'before dawn');
        assert.equal(moment([2011, 2, 23,  9, 30]).format('A'), 'à¤¸à¤à¤¾à¤³à¥', 'morning');
        assert.equal(moment([2011, 2, 23, 14, 30]).format('A'), 'à¤¦à¥à¤ªà¤¾à¤°à¥', ' during day');
        assert.equal(moment([2011, 2, 23, 17, 30]).format('A'), 'à¤¸à¤¾à¤¯à¤à¤à¤¾à¤³à¥', 'evening');
        assert.equal(moment([2011, 2, 23, 19, 30]).format('A'), 'à¤¸à¤¾à¤¯à¤à¤à¤¾à¤³à¥', 'late evening');
        assert.equal(moment([2011, 2, 23, 21, 20]).format('A'), 'à¤°à¤¾à¤¤à¥à¤°à¥', 'night');
    });

    test('weeks year starting sunday formatted', function (assert) {
        assert.equal(moment([2012, 0,  1]).format('w ww wo'), 'à¥§ à¥¦à¥§ à¥§', 'Jan  1 2012 should be week 1');
        assert.equal(moment([2012, 0,  7]).format('w ww wo'), 'à¥§ à¥¦à¥§ à¥§', 'Jan  7 2012 should be week 1');
        assert.equal(moment([2012, 0,  8]).format('w ww wo'), 'à¥¨ à¥¦à¥¨ à¥¨', 'Jan  8 2012 should be week 2');
        assert.equal(moment([2012, 0, 14]).format('w ww wo'), 'à¥¨ à¥¦à¥¨ à¥¨', 'Jan 14 2012 should be week 2');
        assert.equal(moment([2012, 0, 15]).format('w ww wo'), 'à¥© à¥¦à¥© à¥©', 'Jan 15 2012 should be week 3');
    });

}));

;(function (global, factory) {
   typeof exports === 'object' && typeof module !== 'undefined'
       && typeof require === 'function' ? factory(require('../../moment')) :
   typeof define === 'function' && define.amd ? define(['../../moment'], factory) :
   factory(global.moment)
}(this, function (moment) { 'use strict';

    function each(array, callback) {
        var i;
        for (i = 0; i < array.length; i++) {
            callback(array[i], i, array);
        }
    }

    function objectKeys(obj) {
        if (Object.keys) {
            return Object.keys(obj);
        } else {
            // IE8
            var res = [], i;
            for (i in obj) {
                if (obj.hasOwnProperty(i)) {
                    res.push(i);
                }
            }
            return res;
        }
    }

    // Pick the first defined of two or three arguments.
    function defaults(a, b, c) {
        if (a != null) {
            return a;
        }
        if (b != null) {
            return b;
        }
        return c;
    }

    function defineCommonLocaleTests(locale, options) {
        test('lenient ordinal parsing', function (assert) {
            var i, ordinalStr, testMoment;
            for (i = 1; i <= 31; ++i) {
                ordinalStr = moment([2014, 0, i]).format('YYYY MM Do');
                testMoment = moment(ordinalStr, 'YYYY MM Do');
                assert.equal(testMoment.year(), 2014,
                        'lenient ordinal parsing ' + i + ' year check');
                assert.equal(testMoment.month(), 0,
                        'lenient ordinal parsing ' + i + ' month check');
                assert.equal(testMoment.date(), i,
                        'lenient ordinal parsing ' + i + ' date check');
            }
        });

        test('lenient ordinal parsing of number', function (assert) {
            var i, testMoment;
            for (i = 1; i <= 31; ++i) {
                testMoment = moment('2014 01 ' + i, 'YYYY MM Do');
                assert.equal(testMoment.year(), 2014,
                        'lenient ordinal parsing of number ' + i + ' year check');
                assert.equal(testMoment.month(), 0,
                        'lenient ordinal parsing of number ' + i + ' month check');
                assert.equal(testMoment.date(), i,
                        'lenient ordinal parsing of number ' + i + ' date check');
            }
        });

        test('strict ordinal parsing', function (assert) {
            var i, ordinalStr, testMoment;
            for (i = 1; i <= 31; ++i) {
                ordinalStr = moment([2014, 0, i]).format('YYYY MM Do');
                testMoment = moment(ordinalStr, 'YYYY MM Do', true);
                assert.ok(testMoment.isValid(), 'strict ordinal parsing ' + i);
            }
        });

        test('meridiem invariant', function (assert) {
            var h, m, t1, t2;
            for (h = 0; h < 24; ++h) {
                for (m = 0; m < 60; m += 15) {
                    t1 = moment.utc([2000, 0, 1, h, m]);
                    t2 = moment.utc(t1.format('A h:mm'), 'A h:mm');
                    assert.equal(t2.format('HH:mm'), t1.format('HH:mm'),
                            'meridiem at ' + t1.format('HH:mm'));
                }
            }
        });

        test('date format correctness', function (assert) {
            var data, tokens;
            data = moment.localeData()._longDateFormat;
            tokens = objectKeys(data);
            each(tokens, function (srchToken) {
                // Check each format string to make sure it does not contain any
                // tokens that need to be expanded.
                each(tokens, function (baseToken) {
                    // strip escaped sequences
                    var format = data[baseToken].replace(/(\[[^\]]*\])/g, '');
                    assert.equal(false, !!~format.indexOf(srchToken),
                            'contains ' + srchToken + ' in ' + baseToken);
                });
            });
        });

        test('month parsing correctness', function (assert) {
            var i, m;

            if (locale === 'tr') {
                // I can't fix it :(
                expect(0);
                return;
            }
            function tester(format) {
                var r;
                r = moment(m.format(format), format);
                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format);
                r = moment(m.format(format).toLocaleUpperCase(), format);
                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' upper');
                r = moment(m.format(format).toLocaleLowerCase(), format);
                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' lower');

                r = moment(m.format(format), format, true);
                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' strict');
                r = moment(m.format(format).toLocaleUpperCase(), format, true);
                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' upper strict');
                r = moment(m.format(format).toLocaleLowerCase(), format, true);
                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' lower strict');
            }

            for (i = 0; i < 12; ++i) {
                m = moment([2015, i, 15, 18]);
                tester('MMM');
                tester('MMM.');
                tester('MMMM');
                tester('MMMM.');
            }
        });

        test('weekday parsing correctness', function (assert) {
            var i, m;

            if (locale === 'tr' || locale === 'az') {
                // There is a lower-case letter (Ä±), that converted to upper then
                // lower changes to i
                expect(0);
                return;
            }
            function tester(format) {
                var r, baseMsg = 'weekday ' + m.weekday() + ' fmt ' + format;
                r = moment(m.format(format), format);
                assert.equal(r.weekday(), m.weekday(), baseMsg);
                r = moment(m.format(format).toLocaleUpperCase(), format);
                assert.equal(r.weekday(), m.weekday(), baseMsg + ' upper');
                r = moment(m.format(format).toLocaleLowerCase(), format);
                assert.equal(r.weekday(), m.weekday(), baseMsg + ' lower');

                r = moment(m.format(format), format, true);
                assert.equal(r.weekday(), m.weekday(), baseMsg + ' strict');
                r = moment(m.format(format).toLocaleUpperCase(), format, true);
                assert.equal(r.weekday(), m.weekday(), baseMsg + ' upper strict');
                r = moment(m.format(format).toLocaleLowerCase(), format, true);
                assert.equal(r.weekday(), m.weekday(), baseMsg + ' lower strict');
            }

            for (i = 0; i < 7; ++i) {
                m = moment.utc([2015, i, 15, 18]);
                tester('dd');
                tester('ddd');
                tester('dddd');
            }
        });
    }

    function setupDeprecationHandler(test, moment, scope) {
        test._expectedDeprecations = null;
        test._observedDeprecations = null;
        test._oldSupress = moment.suppressDeprecationWarnings;
        moment.suppressDeprecationWarnings = true;
        test.expectedDeprecations = function () {
            test._expectedDeprecations = arguments;
            test._observedDeprecations = [];
        };
        moment.deprecationHandler = function (name, msg) {
            var deprecationId = matchedDeprecation(name, msg, test._expectedDeprecations);
            if (deprecationId === -1) {
                throw new Error('Unexpected deprecation thrown name=' +
                        name + ' msg=' + msg);
            }
            test._observedDeprecations[deprecationId] = 1;
        };
    }

    function teardownDeprecationHandler(test, moment, scope) {
        moment.suppressDeprecationWarnings = test._oldSupress;

        if (test._expectedDeprecations != null) {
            var missedDeprecations = [];
            each(test._expectedDeprecations, function (deprecationPattern, id) {
                if (test._observedDeprecations[id] !== 1) {
                    missedDeprecations.push(deprecationPattern);
                }
            });
            if (missedDeprecations.length !== 0) {
                throw new Error('Expected deprecation warnings did not happen: ' +
                        missedDeprecations.join(' '));
            }
        }
    }

    function matchedDeprecation(name, msg, deprecations) {
        if (deprecations == null) {
            return -1;
        }
        for (var i = 0; i < deprecations.length; ++i) {
            if (name != null && name === deprecations[i]) {
                return i;
            }
            if (msg != null && msg.substring(0, deprecations[i].length) === deprecations[i]) {
                return i;
            }
        }
        return -1;
    }

    /*global QUnit:false*/

    var test = QUnit.test;

    var expect = QUnit.expect;

    function module (name, lifecycle) {
        QUnit.module(name, {
            setup : function () {
                moment.locale('en');
                moment.createFromInputFallback = function (config) {
                    throw new Error('input not handled by moment: ' + config._i);
                };
                setupDeprecationHandler(test, moment, 'core');
                if (lifecycle && lifecycle.setup) {
                    lifecycle.setup();
                }
            },
            teardown : function () {
                teardownDeprecationHandler(test, moment, 'core');
                if (lifecycle && lifecycle.teardown) {
                    lifecycle.teardown();
                }
            }
        });
    }

    function localeModule (name, lifecycle) {
        QUnit.module('locale:' + name, {
            setup : function () {
                moment.locale(name);
                moment.createFromInputFallback = function (config) {
                    throw new Error('input not handled by moment: ' + config._i);
                };
                setupDeprecationHandler(test, moment, 'locale');
                if (lifecycle && lifecycle.setup) {
                    lifecycle.setup();
                }
            },
            teardown : function () {
                moment.locale('en');
                teardownDeprecationHandler(test, moment, 'locale');
                if (lifecycle && lifecycle.teardown) {
                    lifecycle.teardown();
                }
            }
        });
        defineCommonLocaleTests(name, -1, -1);
    }

    localeModule('ms-my');

    test('parse', function (assert) {
        var i,
            tests = 'Januari Jan_Februari Feb_Mac Mac_April Apr_Mei Mei_Jun Jun_Julai Jul_Ogos Ogs_September Sep_Oktober Okt_November Nov_Disember Dis'.split('_');

        function equalTest(input, mmm, i) {
            assert.equal(moment(input, mmm).month(), i, input + ' sepatutnya bulan ' + (i + 1));
        }

        for (i = 0; i < 12; i++) {
            tests[i] = tests[i].split(' ');
            equalTest(tests[i][0], 'MMM', i);
            equalTest(tests[i][1], 'MMM', i);
            equalTest(tests[i][0], 'MMMM', i);
            equalTest(tests[i][1], 'MMMM', i);
            equalTest(tests[i][0].toLocaleLowerCase(), 'MMMM', i);
            equalTest(tests[i][1].toLocaleLowerCase(), 'MMMM', i);
            equalTest(tests[i][0].toLocaleUpperCase(), 'MMMM', i);
            equalTest(tests[i][1].toLocaleUpperCase(), 'MMMM', i);
        }
    });

    test('format', function (assert) {
        var a = [
                ['dddd, MMMM Do YYYY, h:mm:ss a',      'Ahad, Februari 14 2010, 3:25:50 petang'],
                ['ddd, hA',                            'Ahd, 3petang'],
                ['M Mo MM MMMM MMM',                   '2 2 02 Februari Feb'],
                ['YYYY YY',                            '2010 10'],
                ['D Do DD',                            '14 14 14'],
                ['d do dddd ddd dd',                   '0 0 Ahad Ahd Ah'],
                ['DDD DDDo DDDD',                      '45 45 045'],
                ['w wo ww',                            '7 7 07'],
                ['h hh',                               '3 03'],
                ['H HH',                               '15 15'],
                ['m mm',                               '25 25'],
                ['s ss',                               '50 50'],
                ['a A',                                'petang petang'],
                ['[hari] [ke] DDDo [tahun] ini', 'hari ke 45 tahun ini'],
                ['LTS',                                '15.25.50'],
                ['L',                                  '14/02/2010'],
                ['LL',                                 '14 Februari 2010'],
                ['LLL',                                '14 Februari 2010 pukul 15.25'],
                ['LLLL',                               'Ahad, 14 Februari 2010 pukul 15.25'],
                ['l',                                  '14/2/2010'],
                ['ll',                                 '14 Feb 2010'],
                ['lll',                                '14 Feb 2010 pukul 15.25'],
                ['llll',                               'Ahd, 14 Feb 2010 pukul 15.25']
            ],
            b = moment(new Date(2010, 1, 14, 15, 25, 50, 125)),
            i;

        for (i = 0; i < a.length; i++) {
            assert.equal(b.format(a[i][0]), a[i][1], a[i][0] + ' ---> ' + a[i][1]);
        }
    });

    test('format ordinal', function (assert) {
        assert.equal(moment([2011, 0, 1]).format('DDDo'), '1', '1');
        assert.equal(moment([2011, 0, 2]).format('DDDo'), '2', '2');
        assert.equal(moment([2011, 0, 3]).format('DDDo'), '3', '3');
        assert.equal(moment([2011, 0, 4]).format('DDDo'), '4', '4');
        assert.equal(moment([2011, 0, 5]).format('DDDo'), '5', '5');
        assert.equal(moment([2011, 0, 6]).format('DDDo'), '6', '6');
        assert.equal(moment([2011, 0, 7]).format('DDDo'), '7', '7');
        assert.equal(moment([2011, 0, 8]).format('DDDo'), '8', '8');
        assert.equal(moment([2011, 0, 9]).format('DDDo'), '9', '9');
        assert.equal(moment([2011, 0, 10]).format('DDDo'), '10', '10');

        assert.equal(moment([2011, 0, 11]).format('DDDo'), '11', '11');
        assert.equal(moment([2011, 0, 12]).format('DDDo'), '12', '12');
        assert.equal(moment([2011, 0, 13]).format('DDDo'), '13', '13');
        assert.equal(moment([2011, 0, 14]).format('DDDo'), '14', '14');
        assert.equal(moment([2011, 0, 15]).format('DDDo'), '15', '15');
        assert.equal(moment([2011, 0, 16]).format('DDDo'), '16', '16');
        assert.equal(moment([2011, 0, 17]).format('DDDo'), '17', '17');
        assert.equal(moment([2011, 0, 18]).format('DDDo'), '18', '18');
        assert.equal(moment([2011, 0, 19]).format('DDDo'), '19', '19');
        assert.equal(moment([2011, 0, 20]).format('DDDo'), '20', '20');

        assert.equal(moment([2011, 0, 21]).format('DDDo'), '21', '21');
        assert.equal(moment([2011, 0, 22]).format('DDDo'), '22', '22');
        assert.equal(moment([2011, 0, 23]).format('DDDo'), '23', '23');
        assert.equal(moment([2011, 0, 24]).format('DDDo'), '24', '24');
        assert.equal(moment([2011, 0, 25]).format('DDDo'), '25', '25');
        assert.equal(moment([2011, 0, 26]).format('DDDo'), '26', '26');
        assert.equal(moment([2011, 0, 27]).format('DDDo'), '27', '27');
        assert.equal(moment([2011, 0, 28]).format('DDDo'), '28', '28');
        assert.equal(moment([2011, 0, 29]).format('DDDo'), '29', '29');
        assert.equal(moment([2011, 0, 30]).format('DDDo'), '30', '30');

        assert.equal(moment([2011, 0, 31]).format('DDDo'), '31', '31');
    });

    test('format month', function (assert) {
        var i,
            expected = 'Januari Jan_Februari Feb_Mac Mac_April Apr_Mei Mei_Jun Jun_Julai Jul_Ogos Ogs_September Sep_Oktober Okt_November Nov_Disember Dis'.split('_');

        for (i = 0; i < expected.length; i++) {
            assert.equal(moment([2011, i, 1]).format('MMMM MMM'), expected[i], expected[i]);
        }
    });

    test('format week', function (assert) {
        var i,
            expected = 'Ahad Ahd Ah_Isnin Isn Is_Selasa Sel Sl_Rabu Rab Rb_Khamis Kha Km_Jumaat Jum Jm_Sabtu Sab Sb'.split('_');

        for (i = 0; i < expected.length; i++) {
            assert.equal(moment([2011, 0, 2 + i]).format('dddd ddd dd'), expected[i], expected[i]);
        }
    });

    test('from', function (assert) {
        var start = moment([2007, 1, 28]);

        assert.equal(start.from(moment([2007, 1, 28]).add({s: 44}), true),  'beberapa saat', '44 saat = beberapa saat');
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 45}), true),  'seminit',      '45 saat = seminit');
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 89}), true),  'seminit',      '89 saat = seminit');
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 90}), true),  '2 minit',     '90 saat = 2 minit');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 44}), true),  '44 minit',    '44 minit = 44 minit');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 45}), true),  'sejam',       '45 minit = sejam');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 89}), true),  'sejam',       '89 minit = sejam');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 90}), true),  '2 jam',       '90 minit = 2 jam');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 5}), true),   '5 jam',       '5 jam = 5 jam');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 21}), true),  '21 jam',      '21 jam = 21 jam');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 22}), true),  'sehari',         '22 jam = sehari');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 35}), true),  'sehari',         '35 jam = sehari');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 36}), true),  '2 hari',        '36 jam = 2 hari');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 1}), true),   'sehari',         '1 hari = sehari');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 5}), true),   '5 hari',        '5 hari = 5 hari');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 25}), true),  '25 hari',       '25 hari = 25 hari');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 26}), true),  'sebulan',       '26 hari = sebulan');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 30}), true),  'sebulan',       '30 hari = sebulan');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 43}), true),  'sebulan',       '45 hari = sebulan');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 46}), true),  '2 bulan',      '46 hari = 2 bulan');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 74}), true),  '2 bulan',      '75 hari = 2 bulan');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 76}), true),  '3 bulan',      '76 hari = 3 bulan');
        assert.equal(start.from(moment([2007, 1, 28]).add({M: 1}), true),   'sebulan',       '1 bulan = sebulan');
        assert.equal(start.from(moment([2007, 1, 28]).add({M: 5}), true),   '5 bulan',      '5 bulan = 5 bulan');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 345}), true), 'setahun',        '345 hari = setahun');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 548}), true), '2 tahun',       '548 hari = 2 tahun');
        assert.equal(start.from(moment([2007, 1, 28]).add({y: 1}), true),   'setahun',        '1 tahun = setahun');
        assert.equal(start.from(moment([2007, 1, 28]).add({y: 5}), true),   '5 tahun',       '5 tahun = 5 tahun');
    });

    test('suffix', function (assert) {
        assert.equal(moment(30000).from(0), 'dalam beberapa saat',  'prefix');
        assert.equal(moment(0).from(30000), 'beberapa saat yang lepas', 'suffix');
    });

    test('now from now', function (assert) {
        assert.equal(moment().fromNow(), 'beberapa saat yang lepas',  'waktu sekarang dari sekarang sepatutnya menunjukkan sebagai telah lepas');
    });

    test('fromNow', function (assert) {
        assert.equal(moment().add({s: 30}).fromNow(), 'dalam beberapa saat', 'dalam beberapa saat');
        assert.equal(moment().add({d: 5}).fromNow(), 'dalam 5 hari', 'dalam 5 hari');
    });

    test('calendar day', function (assert) {
        var a = moment().hours(12).minutes(0).seconds(0);

        assert.equal(moment(a).calendar(),                   'Hari ini pukul 12.00',  'hari ini pada waktu yang sama');
        assert.equal(moment(a).add({m: 25}).calendar(),      'Hari ini pukul 12.25',  'Sekarang tambah 25 minit');
        assert.equal(moment(a).add({h: 1}).calendar(),       'Hari ini pukul 13.00',  'Sekarang tambah 1 jam');
        assert.equal(moment(a).add({d: 1}).calendar(),       'Esok pukul 12.00',      'esok pada waktu yang sama');
        assert.equal(moment(a).subtract({h: 1}).calendar(),  'Hari ini pukul 11.00',  'Sekarang tolak 1 jam');
        assert.equal(moment(a).subtract({d: 1}).calendar(),  'Kelmarin pukul 12.00',  'kelmarin pada waktu yang sama');
    });

    test('calendar next week', function (assert) {
        var i, m;
        for (i = 2; i < 7; i++) {
            m = moment().add({d: i});
            assert.equal(m.calendar(),       m.format('dddd [pukul] LT'),  'Hari ini + ' + i + ' hari waktu sekarang');
            m.hours(0).minutes(0).seconds(0).milliseconds(0);
            assert.equal(m.calendar(),       m.format('dddd [pukul] LT'),  'Hari ini + ' + i + ' hari permulaan hari');
            m.hours(23).minutes(59).seconds(59).milliseconds(999);
            assert.equal(m.calendar(),       m.format('dddd [pukul] LT'),  'Hari ini + ' + i + ' hari tamat hari');
        }
    });

    test('calendar last week', function (assert) {
        var i, m;
        for (i = 2; i < 7; i++) {
            m = moment().subtract({d: i});
            assert.equal(m.calendar(),       m.format('dddd [lepas] [pukul] LT'),  'Hari ini - ' + i + ' hari waktu sekarang');
            m.hours(0).minutes(0).seconds(0).milliseconds(0);
            assert.equal(m.calendar(),       m.format('dddd [lepas] [pukul] LT'),  'Hari ini - ' + i + ' hari permulaan hari');
            m.hours(23).minutes(59).seconds(59).milliseconds(999);
            assert.equal(m.calendar(),       m.format('dddd [lepas] [pukul] LT'),  'Hari ini - ' + i + ' hari tamat hari');
        }
    });

    test('calendar all else', function (assert) {
        var weeksAgo = moment().subtract({w: 1}),
            weeksFromNow = moment().add({w: 1});

        assert.equal(weeksAgo.calendar(),       weeksAgo.format('L'),  '1 minggu lepas');
        assert.equal(weeksFromNow.calendar(),   weeksFromNow.format('L'),  'dalam 1 minggu');

        weeksAgo = moment().subtract({w: 2});
        weeksFromNow = moment().add({w: 2});

        assert.equal(weeksAgo.calendar(),       weeksAgo.format('L'),  '2 minggu lepas');
        assert.equal(weeksFromNow.calendar(),   weeksFromNow.format('L'),  'dalam 2 minggu');
    });

    test('weeks year starting sunday format', function (assert) {
        assert.equal(moment([2012, 0,  1]).format('w ww wo'), '1 01 1', 'Jan  1 2012 sepatutnya minggu 1');
        assert.equal(moment([2012, 0,  7]).format('w ww wo'), '2 02 2', 'Jan  7 2012 sepatutnya minggu 2');
        assert.equal(moment([2012, 0,  8]).format('w ww wo'), '2 02 2', 'Jan  8 2012 sepatutnya minggu 2');
        assert.equal(moment([2012, 0, 14]).format('w ww wo'), '3 03 3', 'Jan 14 2012 sepatutnya minggu 3');
        assert.equal(moment([2012, 0, 15]).format('w ww wo'), '3 03 3', 'Jan 15 2012 sepatutnya minggu 3');
    });

}));

;(function (global, factory) {
   typeof exports === 'object' && typeof module !== 'undefined'
       && typeof require === 'function' ? factory(require('../../moment')) :
   typeof define === 'function' && define.amd ? define(['../../moment'], factory) :
   factory(global.moment)
}(this, function (moment) { 'use strict';

    function each(array, callback) {
        var i;
        for (i = 0; i < array.length; i++) {
            callback(array[i], i, array);
        }
    }

    function objectKeys(obj) {
        if (Object.keys) {
            return Object.keys(obj);
        } else {
            // IE8
            var res = [], i;
            for (i in obj) {
                if (obj.hasOwnProperty(i)) {
                    res.push(i);
                }
            }
            return res;
        }
    }

    // Pick the first defined of two or three arguments.
    function defaults(a, b, c) {
        if (a != null) {
            return a;
        }
        if (b != null) {
            return b;
        }
        return c;
    }

    function defineCommonLocaleTests(locale, options) {
        test('lenient ordinal parsing', function (assert) {
            var i, ordinalStr, testMoment;
            for (i = 1; i <= 31; ++i) {
                ordinalStr = moment([2014, 0, i]).format('YYYY MM Do');
                testMoment = moment(ordinalStr, 'YYYY MM Do');
                assert.equal(testMoment.year(), 2014,
                        'lenient ordinal parsing ' + i + ' year check');
                assert.equal(testMoment.month(), 0,
                        'lenient ordinal parsing ' + i + ' month check');
                assert.equal(testMoment.date(), i,
                        'lenient ordinal parsing ' + i + ' date check');
            }
        });

        test('lenient ordinal parsing of number', function (assert) {
            var i, testMoment;
            for (i = 1; i <= 31; ++i) {
                testMoment = moment('2014 01 ' + i, 'YYYY MM Do');
                assert.equal(testMoment.year(), 2014,
                        'lenient ordinal parsing of number ' + i + ' year check');
                assert.equal(testMoment.month(), 0,
                        'lenient ordinal parsing of number ' + i + ' month check');
                assert.equal(testMoment.date(), i,
                        'lenient ordinal parsing of number ' + i + ' date check');
            }
        });

        test('strict ordinal parsing', function (assert) {
            var i, ordinalStr, testMoment;
            for (i = 1; i <= 31; ++i) {
                ordinalStr = moment([2014, 0, i]).format('YYYY MM Do');
                testMoment = moment(ordinalStr, 'YYYY MM Do', true);
                assert.ok(testMoment.isValid(), 'strict ordinal parsing ' + i);
            }
        });

        test('meridiem invariant', function (assert) {
            var h, m, t1, t2;
            for (h = 0; h < 24; ++h) {
                for (m = 0; m < 60; m += 15) {
                    t1 = moment.utc([2000, 0, 1, h, m]);
                    t2 = moment.utc(t1.format('A h:mm'), 'A h:mm');
                    assert.equal(t2.format('HH:mm'), t1.format('HH:mm'),
                            'meridiem at ' + t1.format('HH:mm'));
                }
            }
        });

        test('date format correctness', function (assert) {
            var data, tokens;
            data = moment.localeData()._longDateFormat;
            tokens = objectKeys(data);
            each(tokens, function (srchToken) {
                // Check each format string to make sure it does not contain any
                // tokens that need to be expanded.
                each(tokens, function (baseToken) {
                    // strip escaped sequences
                    var format = data[baseToken].replace(/(\[[^\]]*\])/g, '');
                    assert.equal(false, !!~format.indexOf(srchToken),
                            'contains ' + srchToken + ' in ' + baseToken);
                });
            });
        });

        test('month parsing correctness', function (assert) {
            var i, m;

            if (locale === 'tr') {
                // I can't fix it :(
                expect(0);
                return;
            }
            function tester(format) {
                var r;
                r = moment(m.format(format), format);
                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format);
                r = moment(m.format(format).toLocaleUpperCase(), format);
                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' upper');
                r = moment(m.format(format).toLocaleLowerCase(), format);
                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' lower');

                r = moment(m.format(format), format, true);
                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' strict');
                r = moment(m.format(format).toLocaleUpperCase(), format, true);
                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' upper strict');
                r = moment(m.format(format).toLocaleLowerCase(), format, true);
                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' lower strict');
            }

            for (i = 0; i < 12; ++i) {
                m = moment([2015, i, 15, 18]);
                tester('MMM');
                tester('MMM.');
                tester('MMMM');
                tester('MMMM.');
            }
        });

        test('weekday parsing correctness', function (assert) {
            var i, m;

            if (locale === 'tr' || locale === 'az') {
                // There is a lower-case letter (Ä±), that converted to upper then
                // lower changes to i
                expect(0);
                return;
            }
            function tester(format) {
                var r, baseMsg = 'weekday ' + m.weekday() + ' fmt ' + format;
                r = moment(m.format(format), format);
                assert.equal(r.weekday(), m.weekday(), baseMsg);
                r = moment(m.format(format).toLocaleUpperCase(), format);
                assert.equal(r.weekday(), m.weekday(), baseMsg + ' upper');
                r = moment(m.format(format).toLocaleLowerCase(), format);
                assert.equal(r.weekday(), m.weekday(), baseMsg + ' lower');

                r = moment(m.format(format), format, true);
                assert.equal(r.weekday(), m.weekday(), baseMsg + ' strict');
                r = moment(m.format(format).toLocaleUpperCase(), format, true);
                assert.equal(r.weekday(), m.weekday(), baseMsg + ' upper strict');
                r = moment(m.format(format).toLocaleLowerCase(), format, true);
                assert.equal(r.weekday(), m.weekday(), baseMsg + ' lower strict');
            }

            for (i = 0; i < 7; ++i) {
                m = moment.utc([2015, i, 15, 18]);
                tester('dd');
                tester('ddd');
                tester('dddd');
            }
        });
    }

    function setupDeprecationHandler(test, moment, scope) {
        test._expectedDeprecations = null;
        test._observedDeprecations = null;
        test._oldSupress = moment.suppressDeprecationWarnings;
        moment.suppressDeprecationWarnings = true;
        test.expectedDeprecations = function () {
            test._expectedDeprecations = arguments;
            test._observedDeprecations = [];
        };
        moment.deprecationHandler = function (name, msg) {
            var deprecationId = matchedDeprecation(name, msg, test._expectedDeprecations);
            if (deprecationId === -1) {
                throw new Error('Unexpected deprecation thrown name=' +
                        name + ' msg=' + msg);
            }
            test._observedDeprecations[deprecationId] = 1;
        };
    }

    function teardownDeprecationHandler(test, moment, scope) {
        moment.suppressDeprecationWarnings = test._oldSupress;

        if (test._expectedDeprecations != null) {
            var missedDeprecations = [];
            each(test._expectedDeprecations, function (deprecationPattern, id) {
                if (test._observedDeprecations[id] !== 1) {
                    missedDeprecations.push(deprecationPattern);
                }
            });
            if (missedDeprecations.length !== 0) {
                throw new Error('Expected deprecation warnings did not happen: ' +
                        missedDeprecations.join(' '));
            }
        }
    }

    function matchedDeprecation(name, msg, deprecations) {
        if (deprecations == null) {
            return -1;
        }
        for (var i = 0; i < deprecations.length; ++i) {
            if (name != null && name === deprecations[i]) {
                return i;
            }
            if (msg != null && msg.substring(0, deprecations[i].length) === deprecations[i]) {
                return i;
            }
        }
        return -1;
    }

    /*global QUnit:false*/

    var test = QUnit.test;

    var expect = QUnit.expect;

    function module (name, lifecycle) {
        QUnit.module(name, {
            setup : function () {
                moment.locale('en');
                moment.createFromInputFallback = function (config) {
                    throw new Error('input not handled by moment: ' + config._i);
                };
                setupDeprecationHandler(test, moment, 'core');
                if (lifecycle && lifecycle.setup) {
                    lifecycle.setup();
                }
            },
            teardown : function () {
                teardownDeprecationHandler(test, moment, 'core');
                if (lifecycle && lifecycle.teardown) {
                    lifecycle.teardown();
                }
            }
        });
    }

    function localeModule (name, lifecycle) {
        QUnit.module('locale:' + name, {
            setup : function () {
                moment.locale(name);
                moment.createFromInputFallback = function (config) {
                    throw new Error('input not handled by moment: ' + config._i);
                };
                setupDeprecationHandler(test, moment, 'locale');
                if (lifecycle && lifecycle.setup) {
                    lifecycle.setup();
                }
            },
            teardown : function () {
                moment.locale('en');
                teardownDeprecationHandler(test, moment, 'locale');
                if (lifecycle && lifecycle.teardown) {
                    lifecycle.teardown();
                }
            }
        });
        defineCommonLocaleTests(name, -1, -1);
    }

    localeModule('ms');

    test('parse', function (assert) {
        var i,
            tests = 'Januari Jan_Februari Feb_Mac Mac_April Apr_Mei Mei_Jun Jun_Julai Jul_Ogos Ogs_September Sep_Oktober Okt_November Nov_Disember Dis'.split('_');

        function equalTest(input, mmm, i) {
            assert.equal(moment(input, mmm).month(), i, input + ' sepatutnya bulan ' + (i + 1));
        }

        for (i = 0; i < 12; i++) {
            tests[i] = tests[i].split(' ');
            equalTest(tests[i][0], 'MMM', i);
            equalTest(tests[i][1], 'MMM', i);
            equalTest(tests[i][0], 'MMMM', i);
            equalTest(tests[i][1], 'MMMM', i);
            equalTest(tests[i][0].toLocaleLowerCase(), 'MMMM', i);
            equalTest(tests[i][1].toLocaleLowerCase(), 'MMMM', i);
            equalTest(tests[i][0].toLocaleUpperCase(), 'MMMM', i);
            equalTest(tests[i][1].toLocaleUpperCase(), 'MMMM', i);
        }
    });

    test('format', function (assert) {
        var a = [
                ['dddd, MMMM Do YYYY, h:mm:ss a',      'Ahad, Februari 14 2010, 3:25:50 petang'],
                ['ddd, hA',                            'Ahd, 3petang'],
                ['M Mo MM MMMM MMM',                   '2 2 02 Februari Feb'],
                ['YYYY YY',                            '2010 10'],
                ['D Do DD',                            '14 14 14'],
                ['d do dddd ddd dd',                   '0 0 Ahad Ahd Ah'],
                ['DDD DDDo DDDD',                      '45 45 045'],
                ['w wo ww',                            '7 7 07'],
                ['h hh',                               '3 03'],
                ['H HH',                               '15 15'],
                ['m mm',                               '25 25'],
                ['s ss',                               '50 50'],
                ['a A',                                'petang petang'],
                ['[hari] [ke] DDDo [tahun] ini', 'hari ke 45 tahun ini'],
                ['LTS',                                '15.25.50'],
                ['L',                                  '14/02/2010'],
                ['LL',                                 '14 Februari 2010'],
                ['LLL',                                '14 Februari 2010 pukul 15.25'],
                ['LLLL',                               'Ahad, 14 Februari 2010 pukul 15.25'],
                ['l',                                  '14/2/2010'],
                ['ll',                                 '14 Feb 2010'],
                ['lll',                                '14 Feb 2010 pukul 15.25'],
                ['llll',                               'Ahd, 14 Feb 2010 pukul 15.25']
            ],
            b = moment(new Date(2010, 1, 14, 15, 25, 50, 125)),
            i;

        for (i = 0; i < a.length; i++) {
            assert.equal(b.format(a[i][0]), a[i][1], a[i][0] + ' ---> ' + a[i][1]);
        }
    });

    test('format ordinal', function (assert) {
        assert.equal(moment([2011, 0, 1]).format('DDDo'), '1', '1');
        assert.equal(moment([2011, 0, 2]).format('DDDo'), '2', '2');
        assert.equal(moment([2011, 0, 3]).format('DDDo'), '3', '3');
        assert.equal(moment([2011, 0, 4]).format('DDDo'), '4', '4');
        assert.equal(moment([2011, 0, 5]).format('DDDo'), '5', '5');
        assert.equal(moment([2011, 0, 6]).format('DDDo'), '6', '6');
        assert.equal(moment([2011, 0, 7]).format('DDDo'), '7', '7');
        assert.equal(moment([2011, 0, 8]).format('DDDo'), '8', '8');
        assert.equal(moment([2011, 0, 9]).format('DDDo'), '9', '9');
        assert.equal(moment([2011, 0, 10]).format('DDDo'), '10', '10');

        assert.equal(moment([2011, 0, 11]).format('DDDo'), '11', '11');
        assert.equal(moment([2011, 0, 12]).format('DDDo'), '12', '12');
        assert.equal(moment([2011, 0, 13]).format('DDDo'), '13', '13');
        assert.equal(moment([2011, 0, 14]).format('DDDo'), '14', '14');
        assert.equal(moment([2011, 0, 15]).format('DDDo'), '15', '15');
        assert.equal(moment([2011, 0, 16]).format('DDDo'), '16', '16');
        assert.equal(moment([2011, 0, 17]).format('DDDo'), '17', '17');
        assert.equal(moment([2011, 0, 18]).format('DDDo'), '18', '18');
        assert.equal(moment([2011, 0, 19]).format('DDDo'), '19', '19');
        assert.equal(moment([2011, 0, 20]).format('DDDo'), '20', '20');

        assert.equal(moment([2011, 0, 21]).format('DDDo'), '21', '21');
        assert.equal(moment([2011, 0, 22]).format('DDDo'), '22', '22');
        assert.equal(moment([2011, 0, 23]).format('DDDo'), '23', '23');
        assert.equal(moment([2011, 0, 24]).format('DDDo'), '24', '24');
        assert.equal(moment([2011, 0, 25]).format('DDDo'), '25', '25');
        assert.equal(moment([2011, 0, 26]).format('DDDo'), '26', '26');
        assert.equal(moment([2011, 0, 27]).format('DDDo'), '27', '27');
        assert.equal(moment([2011, 0, 28]).format('DDDo'), '28', '28');
        assert.equal(moment([2011, 0, 29]).format('DDDo'), '29', '29');
        assert.equal(moment([2011, 0, 30]).format('DDDo'), '30', '30');

        assert.equal(moment([2011, 0, 31]).format('DDDo'), '31', '31');
    });

    test('format month', function (assert) {
        var i,
            expected = 'Januari Jan_Februari Feb_Mac Mac_April Apr_Mei Mei_Jun Jun_Julai Jul_Ogos Ogs_September Sep_Oktober Okt_November Nov_Disember Dis'.split('_');

        for (i = 0; i < expected.length; i++) {
            assert.equal(moment([2011, i, 1]).format('MMMM MMM'), expected[i], expected[i]);
        }
    });

    test('format week', function (assert) {
        var i,
            expected = 'Ahad Ahd Ah_Isnin Isn Is_Selasa Sel Sl_Rabu Rab Rb_Khamis Kha Km_Jumaat Jum Jm_Sabtu Sab Sb'.split('_');

        for (i = 0; i < expected.length; i++) {
            assert.equal(moment([2011, 0, 2 + i]).format('dddd ddd dd'), expected[i], expected[i]);
        }
    });

    test('from', function (assert) {
        var start = moment([2007, 1, 28]);

        assert.equal(start.from(moment([2007, 1, 28]).add({s: 44}), true),  'beberapa saat', '44 saat = beberapa saat');
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 45}), true),  'seminit',      '45 saat = seminit');
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 89}), true),  'seminit',      '89 saat = seminit');
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 90}), true),  '2 minit',     '90 saat = 2 minit');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 44}), true),  '44 minit',    '44 minit = 44 minit');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 45}), true),  'sejam',       '45 minit = sejam');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 89}), true),  'sejam',       '89 minit = sejam');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 90}), true),  '2 jam',       '90 minit = 2 jam');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 5}), true),   '5 jam',       '5 jam = 5 jam');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 21}), true),  '21 jam',      '21 jam = 21 jam');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 22}), true),  'sehari',         '22 jam = sehari');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 35}), true),  'sehari',         '35 jam = sehari');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 36}), true),  '2 hari',        '36 jam = 2 hari');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 1}), true),   'sehari',         '1 hari = sehari');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 5}), true),   '5 hari',        '5 hari = 5 hari');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 25}), true),  '25 hari',       '25 hari = 25 hari');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 26}), true),  'sebulan',       '26 hari = sebulan');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 30}), true),  'sebulan',       '30 hari = sebulan');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 43}), true),  'sebulan',       '45 hari = sebulan');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 46}), true),  '2 bulan',      '46 hari = 2 bulan');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 74}), true),  '2 bulan',      '75 hari = 2 bulan');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 76}), true),  '3 bulan',      '76 hari = 3 bulan');
        assert.equal(start.from(moment([2007, 1, 28]).add({M: 1}), true),   'sebulan',       '1 bulan = sebulan');
        assert.equal(start.from(moment([2007, 1, 28]).add({M: 5}), true),   '5 bulan',      '5 bulan = 5 bulan');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 345}), true), 'setahun',        '345 hari = setahun');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 548}), true), '2 tahun',       '548 hari = 2 tahun');
        assert.equal(start.from(moment([2007, 1, 28]).add({y: 1}), true),   'setahun',        '1 tahun = setahun');
        assert.equal(start.from(moment([2007, 1, 28]).add({y: 5}), true),   '5 tahun',       '5 tahun = 5 tahun');
    });

    test('suffix', function (assert) {
        assert.equal(moment(30000).from(0), 'dalam beberapa saat',  'prefix');
        assert.equal(moment(0).from(30000), 'beberapa saat yang lepas', 'suffix');
    });

    test('now from now', function (assert) {
        assert.equal(moment().fromNow(), 'beberapa saat yang lepas',  'waktu sekarang dari sekarang sepatutnya menunjukkan sebagai telah lepas');
    });

    test('fromNow', function (assert) {
        assert.equal(moment().add({s: 30}).fromNow(), 'dalam beberapa saat', 'dalam beberapa saat');
        assert.equal(moment().add({d: 5}).fromNow(), 'dalam 5 hari', 'dalam 5 hari');
    });

    test('calendar day', function (assert) {
        var a = moment().hours(12).minutes(0).seconds(0);

        assert.equal(moment(a).calendar(),                   'Hari ini pukul 12.00',  'hari ini pada waktu yang sama');
        assert.equal(moment(a).add({m: 25}).calendar(),      'Hari ini pukul 12.25',  'Sekarang tambah 25 minit');
        assert.equal(moment(a).add({h: 1}).calendar(),       'Hari ini pukul 13.00',  'Sekarang tambah 1 jam');
        assert.equal(moment(a).add({d: 1}).calendar(),       'Esok pukul 12.00',      'esok pada waktu yang sama');
        assert.equal(moment(a).subtract({h: 1}).calendar(),  'Hari ini pukul 11.00',  'Sekarang tolak 1 jam');
        assert.equal(moment(a).subtract({d: 1}).calendar(),  'Kelmarin pukul 12.00',  'kelmarin pada waktu yang sama');
    });

    test('calendar next week', function (assert) {
        var i, m;
        for (i = 2; i < 7; i++) {
            m = moment().add({d: i});
            assert.equal(m.calendar(),       m.format('dddd [pukul] LT'),  'Hari ini + ' + i + ' hari waktu sekarang');
            m.hours(0).minutes(0).seconds(0).milliseconds(0);
            assert.equal(m.calendar(),       m.format('dddd [pukul] LT'),  'Hari ini + ' + i + ' hari permulaan hari');
            m.hours(23).minutes(59).seconds(59).milliseconds(999);
            assert.equal(m.calendar(),       m.format('dddd [pukul] LT'),  'Hari ini + ' + i + ' hari tamat hari');
        }
    });

    test('calendar last week', function (assert) {
        var i, m;
        for (i = 2; i < 7; i++) {
            m = moment().subtract({d: i});
            assert.equal(m.calendar(),       m.format('dddd [lepas] [pukul] LT'),  'Hari ini - ' + i + ' hari waktu sekarang');
            m.hours(0).minutes(0).seconds(0).milliseconds(0);
            assert.equal(m.calendar(),       m.format('dddd [lepas] [pukul] LT'),  'Hari ini - ' + i + ' hari permulaan hari');
            m.hours(23).minutes(59).seconds(59).milliseconds(999);
            assert.equal(m.calendar(),       m.format('dddd [lepas] [pukul] LT'),  'Hari ini - ' + i + ' hari tamat hari');
        }
    });

    test('calendar all else', function (assert) {
        var weeksAgo = moment().subtract({w: 1}),
            weeksFromNow = moment().add({w: 1});

        assert.equal(weeksAgo.calendar(),       weeksAgo.format('L'),  '1 minggu lepas');
        assert.equal(weeksFromNow.calendar(),   weeksFromNow.format('L'),  'dalam 1 minggu');

        weeksAgo = moment().subtract({w: 2});
        weeksFromNow = moment().add({w: 2});

        assert.equal(weeksAgo.calendar(),       weeksAgo.format('L'),  '2 minggu lepas');
        assert.equal(weeksFromNow.calendar(),   weeksFromNow.format('L'),  'dalam 2 minggu');
    });

    test('weeks year starting sunday format', function (assert) {
        assert.equal(moment([2012, 0,  1]).format('w ww wo'), '1 01 1', 'Jan  1 2012 sepatutnya minggu 1');
        assert.equal(moment([2012, 0,  7]).format('w ww wo'), '2 02 2', 'Jan  7 2012 sepatutnya minggu 2');
        assert.equal(moment([2012, 0,  8]).format('w ww wo'), '2 02 2', 'Jan  8 2012 sepatutnya minggu 2');
        assert.equal(moment([2012, 0, 14]).format('w ww wo'), '3 03 3', 'Jan 14 2012 sepatutnya minggu 3');
        assert.equal(moment([2012, 0, 15]).format('w ww wo'), '3 03 3', 'Jan 15 2012 sepatutnya minggu 3');
    });

}));

;(function (global, factory) {
   typeof exports === 'object' && typeof module !== 'undefined'
       && typeof require === 'function' ? factory(require('../../moment')) :
   typeof define === 'function' && define.amd ? define(['../../moment'], factory) :
   factory(global.moment)
}(this, function (moment) { 'use strict';

    function each(array, callback) {
        var i;
        for (i = 0; i < array.length; i++) {
            callback(array[i], i, array);
        }
    }

    function objectKeys(obj) {
        if (Object.keys) {
            return Object.keys(obj);
        } else {
            // IE8
            var res = [], i;
            for (i in obj) {
                if (obj.hasOwnProperty(i)) {
                    res.push(i);
                }
            }
            return res;
        }
    }

    // Pick the first defined of two or three arguments.
    function defaults(a, b, c) {
        if (a != null) {
            return a;
        }
        if (b != null) {
            return b;
        }
        return c;
    }

    function defineCommonLocaleTests(locale, options) {
        test('lenient ordinal parsing', function (assert) {
            var i, ordinalStr, testMoment;
            for (i = 1; i <= 31; ++i) {
                ordinalStr = moment([2014, 0, i]).format('YYYY MM Do');
                testMoment = moment(ordinalStr, 'YYYY MM Do');
                assert.equal(testMoment.year(), 2014,
                        'lenient ordinal parsing ' + i + ' year check');
                assert.equal(testMoment.month(), 0,
                        'lenient ordinal parsing ' + i + ' month check');
                assert.equal(testMoment.date(), i,
                        'lenient ordinal parsing ' + i + ' date check');
            }
        });

        test('lenient ordinal parsing of number', function (assert) {
            var i, testMoment;
            for (i = 1; i <= 31; ++i) {
                testMoment = moment('2014 01 ' + i, 'YYYY MM Do');
                assert.equal(testMoment.year(), 2014,
                        'lenient ordinal parsing of number ' + i + ' year check');
                assert.equal(testMoment.month(), 0,
                        'lenient ordinal parsing of number ' + i + ' month check');
                assert.equal(testMoment.date(), i,
                        'lenient ordinal parsing of number ' + i + ' date check');
            }
        });

        test('strict ordinal parsing', function (assert) {
            var i, ordinalStr, testMoment;
            for (i = 1; i <= 31; ++i) {
                ordinalStr = moment([2014, 0, i]).format('YYYY MM Do');
                testMoment = moment(ordinalStr, 'YYYY MM Do', true);
                assert.ok(testMoment.isValid(), 'strict ordinal parsing ' + i);
            }
        });

        test('meridiem invariant', function (assert) {
            var h, m, t1, t2;
            for (h = 0; h < 24; ++h) {
                for (m = 0; m < 60; m += 15) {
                    t1 = moment.utc([2000, 0, 1, h, m]);
                    t2 = moment.utc(t1.format('A h:mm'), 'A h:mm');
                    assert.equal(t2.format('HH:mm'), t1.format('HH:mm'),
                            'meridiem at ' + t1.format('HH:mm'));
                }
            }
        });

        test('date format correctness', function (assert) {
            var data, tokens;
            data = moment.localeData()._longDateFormat;
            tokens = objectKeys(data);
            each(tokens, function (srchToken) {
                // Check each format string to make sure it does not contain any
                // tokens that need to be expanded.
                each(tokens, function (baseToken) {
                    // strip escaped sequences
                    var format = data[baseToken].replace(/(\[[^\]]*\])/g, '');
                    assert.equal(false, !!~format.indexOf(srchToken),
                            'contains ' + srchToken + ' in ' + baseToken);
                });
            });
        });

        test('month parsing correctness', function (assert) {
            var i, m;

            if (locale === 'tr') {
                // I can't fix it :(
                expect(0);
                return;
            }
            function tester(format) {
                var r;
                r = moment(m.format(format), format);
                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format);
                r = moment(m.format(format).toLocaleUpperCase(), format);
                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' upper');
                r = moment(m.format(format).toLocaleLowerCase(), format);
                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' lower');

                r = moment(m.format(format), format, true);
                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' strict');
                r = moment(m.format(format).toLocaleUpperCase(), format, true);
                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' upper strict');
                r = moment(m.format(format).toLocaleLowerCase(), format, true);
                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' lower strict');
            }

            for (i = 0; i < 12; ++i) {
                m = moment([2015, i, 15, 18]);
                tester('MMM');
                tester('MMM.');
                tester('MMMM');
                tester('MMMM.');
            }
        });

        test('weekday parsing correctness', function (assert) {
            var i, m;

            if (locale === 'tr' || locale === 'az') {
                // There is a lower-case letter (Ä±), that converted to upper then
                // lower changes to i
                expect(0);
                return;
            }
            function tester(format) {
                var r, baseMsg = 'weekday ' + m.weekday() + ' fmt ' + format;
                r = moment(m.format(format), format);
                assert.equal(r.weekday(), m.weekday(), baseMsg);
                r = moment(m.format(format).toLocaleUpperCase(), format);
                assert.equal(r.weekday(), m.weekday(), baseMsg + ' upper');
                r = moment(m.format(format).toLocaleLowerCase(), format);
                assert.equal(r.weekday(), m.weekday(), baseMsg + ' lower');

                r = moment(m.format(format), format, true);
                assert.equal(r.weekday(), m.weekday(), baseMsg + ' strict');
                r = moment(m.format(format).toLocaleUpperCase(), format, true);
                assert.equal(r.weekday(), m.weekday(), baseMsg + ' upper strict');
                r = moment(m.format(format).toLocaleLowerCase(), format, true);
                assert.equal(r.weekday(), m.weekday(), baseMsg + ' lower strict');
            }

            for (i = 0; i < 7; ++i) {
                m = moment.utc([2015, i, 15, 18]);
                tester('dd');
                tester('ddd');
                tester('dddd');
            }
        });
    }

    function setupDeprecationHandler(test, moment, scope) {
        test._expectedDeprecations = null;
        test._observedDeprecations = null;
        test._oldSupress = moment.suppressDeprecationWarnings;
        moment.suppressDeprecationWarnings = true;
        test.expectedDeprecations = function () {
            test._expectedDeprecations = arguments;
            test._observedDeprecations = [];
        };
        moment.deprecationHandler = function (name, msg) {
            var deprecationId = matchedDeprecation(name, msg, test._expectedDeprecations);
            if (deprecationId === -1) {
                throw new Error('Unexpected deprecation thrown name=' +
                        name + ' msg=' + msg);
            }
            test._observedDeprecations[deprecationId] = 1;
        };
    }

    function teardownDeprecationHandler(test, moment, scope) {
        moment.suppressDeprecationWarnings = test._oldSupress;

        if (test._expectedDeprecations != null) {
            var missedDeprecations = [];
            each(test._expectedDeprecations, function (deprecationPattern, id) {
                if (test._observedDeprecations[id] !== 1) {
                    missedDeprecations.push(deprecationPattern);
                }
            });
            if (missedDeprecations.length !== 0) {
                throw new Error('Expected deprecation warnings did not happen: ' +
                        missedDeprecations.join(' '));
            }
        }
    }

    function matchedDeprecation(name, msg, deprecations) {
        if (deprecations == null) {
            return -1;
        }
        for (var i = 0; i < deprecations.length; ++i) {
            if (name != null && name === deprecations[i]) {
                return i;
            }
            if (msg != null && msg.substring(0, deprecations[i].length) === deprecations[i]) {
                return i;
            }
        }
        return -1;
    }

    /*global QUnit:false*/

    var test = QUnit.test;

    var expect = QUnit.expect;

    function module (name, lifecycle) {
        QUnit.module(name, {
            setup : function () {
                moment.locale('en');
                moment.createFromInputFallback = function (config) {
                    throw new Error('input not handled by moment: ' + config._i);
                };
                setupDeprecationHandler(test, moment, 'core');
                if (lifecycle && lifecycle.setup) {
                    lifecycle.setup();
                }
            },
            teardown : function () {
                teardownDeprecationHandler(test, moment, 'core');
                if (lifecycle && lifecycle.teardown) {
                    lifecycle.teardown();
                }
            }
        });
    }

    function localeModule (name, lifecycle) {
        QUnit.module('locale:' + name, {
            setup : function () {
                moment.locale(name);
                moment.createFromInputFallback = function (config) {
                    throw new Error('input not handled by moment: ' + config._i);
                };
                setupDeprecationHandler(test, moment, 'locale');
                if (lifecycle && lifecycle.setup) {
                    lifecycle.setup();
                }
            },
            teardown : function () {
                moment.locale('en');
                teardownDeprecationHandler(test, moment, 'locale');
                if (lifecycle && lifecycle.teardown) {
                    lifecycle.teardown();
                }
            }
        });
        defineCommonLocaleTests(name, -1, -1);
    }

    localeModule('my');

    test('parse', function (assert) {
        var tests = 'áááºááá«áá® áááº_áá±áá±á¬áºáá«áá® áá±_áááº áááº_á§áá¼á® áá¼á®_áá± áá±_áá½ááº áá½ááº_áá°áá­á¯ááº áá­á¯ááº_áá¼áá¯ááº áá¼_áááºáááºáá¬ áááº_á¡á±á¬ááºáá­á¯áá¬ á¡á±á¬ááº_áá­á¯áááºáá¬ áá­á¯_áá®áááºáá¬ áá®'.split('_'),
            i;

        function equalTest (input, mmm, i) {
            assert.equal(moment(input, mmm).month(), i, input + ' should be month ' + (i + 1));
        }
        for (i = 0; i < 12; i++) {
            tests[i] = tests[i].split(' ');
            equalTest(tests[i][0], 'MMM', i);
            equalTest(tests[i][1], 'MMM', i);
            equalTest(tests[i][0], 'MMMM', i);
            equalTest(tests[i][1], 'MMMM', i);
            equalTest(tests[i][0].toLocaleLowerCase(), 'MMMM', i);
            equalTest(tests[i][1].toLocaleLowerCase(), 'MMMM', i);
            equalTest(tests[i][0].toLocaleUpperCase(), 'MMMM', i);
            equalTest(tests[i][1].toLocaleUpperCase(), 'MMMM', i);
        }
    });

    test('format', function (assert) {
        var a = [
                ['dddd, MMMM Do YYYY, h:mm:ss a', 'ááááºá¹ááá½á±, áá±áá±á¬áºáá«áá® áá áááá, á:áá:áá pm'],
                ['ddd, hA', 'áá½á±, áPM'],
                ['M Mo MM MMMM MMM', 'á á áá áá±áá±á¬áºáá«áá® áá±'],
                ['YYYY YY', 'áááá áá'],
                ['D Do DD', 'áá áá áá'],
                ['d do dddd ddd dd', 'á á ááááºá¹ááá½á± áá½á± áá½á±'],
                ['DDD DDDo DDDD', 'áá áá ááá'],
                ['w wo ww', 'á á áá'],
                ['h hh', 'á áá'],
                ['H HH', 'áá áá'],
                ['m mm', 'áá áá'],
                ['s ss', 'áá áá'],
                ['a A', 'pm PM'],
                ['[áá¾ááºá] DDDo [áááºáá¼á±á¬ááº]', 'áá¾ááºá áá áááºáá¼á±á¬ááº'],
                ['LTS', 'áá:áá:áá'],
                ['L', 'áá/áá/áááá'],
                ['LL', 'áá áá±áá±á¬áºáá«áá® áááá'],
                ['LLL', 'áá áá±áá±á¬áºáá«áá® áááá áá:áá'],
                ['LLLL', 'ááááºá¹ááá½á± áá áá±áá±á¬áºáá«áá® áááá áá:áá'],
                ['l', 'áá/á/áááá'],
                ['ll', 'áá áá± áááá'],
                ['lll', 'áá áá± áááá áá:áá'],
                ['llll', 'áá½á± áá áá± áááá áá:áá']
            ],
            b = moment(new Date(2010, 1, 14, 15, 25, 50, 125)),
            i;
        for (i = 0; i < a.length; i++) {
            assert.equal(b.format(a[i][0]), a[i][1], a[i][0] + ' ---> ' + a[i][1]);
        }
    });

    test('format ordinal', function (assert) {
        assert.equal(moment([2011, 0, 1]).format('DDDo'), 'á', 'á');
        assert.equal(moment([2011, 0, 2]).format('DDDo'), 'á', 'á');
        assert.equal(moment([2011, 0, 3]).format('DDDo'), 'á', 'á');
        assert.equal(moment([2011, 0, 4]).format('DDDo'), 'á', 'á');
        assert.equal(moment([2011, 0, 5]).format('DDDo'), 'á', 'á');
        assert.equal(moment([2011, 0, 6]).format('DDDo'), 'á', 'á');
        assert.equal(moment([2011, 0, 7]).format('DDDo'), 'á', 'á');
        assert.equal(moment([2011, 0, 8]).format('DDDo'), 'á', 'á');
        assert.equal(moment([2011, 0, 9]).format('DDDo'), 'á', 'á');
        assert.equal(moment([2011, 0, 10]).format('DDDo'), 'áá', 'áá');

        assert.equal(moment([2011, 0, 11]).format('DDDo'), 'áá', 'áá');
        assert.equal(moment([2011, 0, 12]).format('DDDo'), 'áá', 'áá');
        assert.equal(moment([2011, 0, 13]).format('DDDo'), 'áá', 'áá');
        assert.equal(moment([2011, 0, 14]).format('DDDo'), 'áá', 'áá');
        assert.equal(moment([2011, 0, 15]).format('DDDo'), 'áá', 'áá');
        assert.equal(moment([2011, 0, 16]).format('DDDo'), 'áá', 'áá');
        assert.equal(moment([2011, 0, 17]).format('DDDo'), 'áá', 'áá');
        assert.equal(moment([2011, 0, 18]).format('DDDo'), 'áá', 'áá');
        assert.equal(moment([2011, 0, 19]).format('DDDo'), 'áá', 'áá');
        assert.equal(moment([2011, 0, 20]).format('DDDo'), 'áá', 'áá');

        assert.equal(moment([2011, 0, 21]).format('DDDo'), 'áá', 'áá');
        assert.equal(moment([2011, 0, 22]).format('DDDo'), 'áá', 'áá');
        assert.equal(moment([2011, 0, 23]).format('DDDo'), 'áá', 'áá');
        assert.equal(moment([2011, 0, 24]).format('DDDo'), 'áá', 'áá');
        assert.equal(moment([2011, 0, 25]).format('DDDo'), 'áá', 'áá');
        assert.equal(moment([2011, 0, 26]).format('DDDo'), 'áá', 'áá');
        assert.equal(moment([2011, 0, 27]).format('DDDo'), 'áá', 'áá');
        assert.equal(moment([2011, 0, 28]).format('DDDo'), 'áá', 'áá');
        assert.equal(moment([2011, 0, 29]).format('DDDo'), 'áá', 'áá');
        assert.equal(moment([2011, 0, 30]).format('DDDo'), 'áá', 'áá');

        assert.equal(moment([2011, 0, 31]).format('DDDo'), 'áá', 'áá');
    });

    test('format month', function (assert) {
        var expected = 'áááºááá«áá® áááº_áá±áá±á¬áºáá«áá® áá±_áááº áááº_á§áá¼á® áá¼á®_áá± áá±_áá½ááº áá½ááº_áá°áá­á¯ááº áá­á¯ááº_áá¼áá¯ááº áá¼_áááºáááºáá¬ áááº_á¡á±á¬ááºáá­á¯áá¬ á¡á±á¬ááº_áá­á¯áááºáá¬ áá­á¯_áá®áááºáá¬ áá®'.split('_'),
            i;
        for (i = 0; i < expected.length; i++) {
            assert.equal(moment([2011, i, 1]).format('MMMM MMM'), expected[i], expected[i]);
        }
    });

    test('format week', function (assert) {
        var expected = 'ááááºá¹ááá½á± áá½á± áá½á±_ááááºá¹áá¬ áá¬ áá¬_á¡ááºá¹áá« áá« áá«_áá¯áá¹ááá°á¸ áá°á¸ áá°á¸_áá¼á¬áááá±á¸ áá¼á¬ áá¼á¬_áá±á¬áá¼á¬ áá±á¬ áá±á¬_ááá± áá± áá±'.split('_'),
            i;

        for (i = 0; i < expected.length; i++) {
            assert.equal(moment([2011, 0, 2 + i]).format('dddd ddd dd'), expected[i], expected[i]);
        }
    });

    test('from', function (assert) {
        var start = moment([2007, 1, 28]);
        assert.equal(start.from(moment([2007, 1, 28]).add({
            s: 44
        }), true), 'ááá¹áááº.á¡áááºá¸áááº', 'áá ááá¹áááº. = ááá¹áááº.á¡áááºá¸áááº');
        assert.equal(start.from(moment([2007, 1, 28]).add({
            s: 45
        }), true), 'áááºáá­áááº', 'áá ááá¹áááº. = áááºáá­áááº');
        assert.equal(start.from(moment([2007, 1, 28]).add({
            s: 89
        }), true), 'áááºáá­áááº', 'áá ááá¹áááº. = áááºáá­áááº');
        assert.equal(start.from(moment([2007, 1, 28]).add({
            s: 90
        }), true), 'á áá­áááº', 'áá ááá¹áááº. =  á áá­áááº');
        assert.equal(start.from(moment([2007, 1, 28]).add({
            m: 44
        }), true), 'áá áá­áááº', 'áá áá­áááº = áá áá­áááº');
        assert.equal(start.from(moment([2007, 1, 28]).add({
            m: 45
        }), true), 'áááºáá¬áá®', 'áá áá­áááº = á áá¬áá®');
        assert.equal(start.from(moment([2007, 1, 28]).add({
            m: 89
        }), true), 'áááºáá¬áá®', 'áá áá­áááº = áááºáá¬áá®');
        assert.equal(start.from(moment([2007, 1, 28]).add({
            m: 90
        }), true), 'á áá¬áá®', 'áá­áááº áá= á áá¬áá®');
        assert.equal(start.from(moment([2007, 1, 28]).add({
            h: 5
        }), true), 'á áá¬áá®', 'á áá¬áá®= á áá¬áá®');
        assert.equal(start.from(moment([2007, 1, 28]).add({
            h: 21
        }), true), 'áá áá¬áá®', 'áá áá¬áá® =áá áá¬áá®');
        assert.equal(start.from(moment([2007, 1, 28]).add({
            h: 22
        }), true), 'áááºáááº', 'áá áá¬áá® =áááºáááº');
        assert.equal(start.from(moment([2007, 1, 28]).add({
            h: 35
        }), true), 'áááºáááº', 'áá áá¬áá® =áááºáááº');
        assert.equal(start.from(moment([2007, 1, 28]).add({
            h: 36
        }), true), 'á áááº', 'áá áá¬áá® = á áááº');
        assert.equal(start.from(moment([2007, 1, 28]).add({
            d: 1
        }), true), 'áááºáááº', 'á áááº= áááºáááº');
        assert.equal(start.from(moment([2007, 1, 28]).add({
            d: 5
        }), true), 'á áááº', 'á áááº = á áááº');
        assert.equal(start.from(moment([2007, 1, 28]).add({
            d: 25
        }), true), 'áá áááº', 'áá áááº= áá áááº');
        assert.equal(start.from(moment([2007, 1, 28]).add({
            d: 26
        }), true), 'áááºá', 'áá áááº = áááºá');
        assert.equal(start.from(moment([2007, 1, 28]).add({
            d: 30
        }), true), 'áááºá', 'áááº áá = áááºá');
        assert.equal(start.from(moment([2007, 1, 28]).add({
            d: 43
        }), true), 'áááºá', 'áá áááº = áááºá');
        assert.equal(start.from(moment([2007, 1, 28]).add({
            d: 46
        }), true), 'á á', 'áá áááº = á á');
        assert.equal(start.from(moment([2007, 1, 28]).add({
            d: 74
        }), true), 'á á', 'áá áááº= á á');
        assert.equal(start.from(moment([2007, 1, 28]).add({
            d: 76
        }), true), 'á á', 'áá áááº = á á');
        assert.equal(start.from(moment([2007, 1, 28]).add({
            M: 1
        }), true), 'áááºá', 'á á = áááºá');
        assert.equal(start.from(moment([2007, 1, 28]).add({
            M: 5
        }), true), 'á á', 'á á = á á');
        assert.equal(start.from(moment([2007, 1, 28]).add({
            d: 345
        }), true), 'áááºáá¾ááº', 'ááá áááº = áááºáá¾ááº');
        assert.equal(start.from(moment([2007, 1, 28]).add({
            d: 548
        }), true), 'á áá¾ááº', 'ááá áááº = á áá¾ááº');
        assert.equal(start.from(moment([2007, 1, 28]).add({
            y: 1
        }), true), 'áááºáá¾ááº', 'á áá¾ááº = áááºáá¾ááº');
        assert.equal(start.from(moment([2007, 1, 28]).add({
            y: 5
        }), true), 'á áá¾ááº', 'á áá¾ááº = á áá¾ááº');
    });

    test('suffix', function (assert) {
        assert.equal(moment(30000).from(0), 'áá¬áááºá· ááá¹áááº.á¡áááºá¸áááº áá¾á¬', 'prefix');
        assert.equal(moment(0).from(30000), 'áá½ááºáá²á·áá±á¬ ááá¹áááº.á¡áááºá¸áááº á', 'suffix');
    });

    test('now from now', function (assert) {
        assert.equal(moment().fromNow(), 'áá½ááºáá²á·áá±á¬ ááá¹áááº.á¡áááºá¸áááº á', 'ááá¯áá¾ááá¼á®á¸ á¡áá­ááºáá½ááºáá±á¬áºáá¼ááá­á¯áá±á¬áºáá¼áááº');
    });

    test('fromNow', function (assert) {
        assert.equal(moment().add({
            s: 30
        }).fromNow(), 'áá¬áááºá· ááá¹áááº.á¡áááºá¸áááº áá¾á¬', 'áá¬áááºá· ááá¹áááº.á¡áááºá¸áááº áá¾á¬');
        assert.equal(moment().add({
            d: 5
        }).fromNow(), 'áá¬áááºá· á áááº áá¾á¬', 'áá¬áááºá· á áááº áá¾á¬');
    });

    test('calendar day', function (assert) {
        var a = moment().hours(12).minutes(0).seconds(0);

        assert.equal(moment(a).calendar(),                  'ááá±. áá:áá áá¾á¬',      'ááá±. áá®á¡áá»á­ááº');
        assert.equal(moment(a).add({m: 25}).calendar(),     'ááá±. áá:áá áá¾á¬',      'ááá¯áá¾ áá áá­áááºáá±á«ááºá¸áááºá·');
        assert.equal(moment(a).add({h: 1}).calendar(),      'ááá±. áá:áá áá¾á¬',      'ááá¯áá¾ á áá¬áá®áá±á«ááºá¸áááºá·');
        assert.equal(moment(a).add({d: 1}).calendar(),      'ááááºáá¼ááº áá:áá áá¾á¬',  'ááááºáá¼ááº áá®á¡áá»á­ááº');
        assert.equal(moment(a).subtract({h: 1}).calendar(), 'ááá±. áá:áá áá¾á¬',      'ááá¯áá¾ á áá¬áá®áá¾á¯ááº');
        assert.equal(moment(a).subtract({d: 1}).calendar(), 'ááá±.á áá:áá áá¾á¬',     'ááá±.á áá®á¡áá»á­ááº');
    });

    test('calendar next week', function (assert) {
        var i, m;
        for (i = 2; i < 7; i++) {
            m = moment().add({
                d: i
            });
            assert.equal(m.calendar(), m.format('dddd LT [áá¾á¬]'), 'Today + ' + i + ' days current time');
            m.hours(0).minutes(0).seconds(0).milliseconds(0);
            assert.equal(m.calendar(), m.format('dddd LT [áá¾á¬]'), 'Today + ' + i + ' days beginning of day');
            m.hours(23).minutes(59).seconds(59).milliseconds(999);
            assert.equal(m.calendar(), m.format('dddd LT [áá¾á¬]'), 'Today + ' + i + ' days end of day');
        }
    });

    test('calendar last week', function (assert) {
        var i, m;

        for (i = 2; i < 7; i++) {
            m = moment().subtract({
                d: i
            });
            assert.equal(m.calendar(), m.format('[áá¼á®á¸áá²á·áá±á¬] dddd LT [áá¾á¬]'), 'Today - ' + i + ' days current time');
            m.hours(0).minutes(0).seconds(0).milliseconds(0);
            assert.equal(m.calendar(), m.format('[áá¼á®á¸áá²á·áá±á¬] dddd LT [áá¾á¬]'), 'Today - ' + i + ' days beginning of day');
            m.hours(23).minutes(59).seconds(59).milliseconds(999);
            assert.equal(m.calendar(), m.format('[áá¼á®á¸áá²á·áá±á¬] dddd LT [áá¾á¬]'), 'Today - ' + i + ' days end of day');
        }
    });

    test('calendar all else', function (assert) {
        var weeksAgo = moment().subtract({
                w: 1
            }),
            weeksFromNow = moment().add({
                w: 1
            });

        assert.equal(weeksAgo.calendar(), weeksAgo.format('L'), 'áá½ááºáá²á·áá±á¬ á áááºá');
        assert.equal(weeksFromNow.calendar(), weeksFromNow.format('L'), 'á áááºá¡áá½ááºá¸');

        weeksAgo = moment().subtract({
            w: 2
        });
        weeksFromNow = moment().add({
            w: 2
        });

        assert.equal(weeksAgo.calendar(), weeksAgo.format('L'), 'á áááº á¡áááºá');
        assert.equal(weeksFromNow.calendar(), weeksFromNow.format('L'), 'á áááº á¡áá½ááºá¸');
    });

    test('weeks year starting sunday formatted', function (assert) {
        assert.equal(moment([2012, 0, 1]).format('w ww wo'), 'áá áá áá', 'Jan  1 2012 should be week 52');
        assert.equal(moment([2012, 0, 2]).format('w ww wo'), 'á áá á', 'Jan  2 2012 should be week 1');
        assert.equal(moment([2012, 0, 8]).format('w ww wo'), 'á áá á', 'Jan  8 2012 should be week 1');
        assert.equal(moment([2012, 0, 9]).format('w ww wo'), 'á áá á', 'Jan  9 2012 should be week 2');
        assert.equal(moment([2012, 0, 15]).format('w ww wo'), 'á áá á', 'Jan 15 2012 should be week 2');
    });

}));

;(function (global, factory) {
   typeof exports === 'object' && typeof module !== 'undefined'
       && typeof require === 'function' ? factory(require('../../moment')) :
   typeof define === 'function' && define.amd ? define(['../../moment'], factory) :
   factory(global.moment)
}(this, function (moment) { 'use strict';

    function each(array, callback) {
        var i;
        for (i = 0; i < array.length; i++) {
            callback(array[i], i, array);
        }
    }

    function objectKeys(obj) {
        if (Object.keys) {
            return Object.keys(obj);
        } else {
            // IE8
            var res = [], i;
            for (i in obj) {
                if (obj.hasOwnProperty(i)) {
                    res.push(i);
                }
            }
            return res;
        }
    }

    // Pick the first defined of two or three arguments.
    function defaults(a, b, c) {
        if (a != null) {
            return a;
        }
        if (b != null) {
            return b;
        }
        return c;
    }

    function defineCommonLocaleTests(locale, options) {
        test('lenient ordinal parsing', function (assert) {
            var i, ordinalStr, testMoment;
            for (i = 1; i <= 31; ++i) {
                ordinalStr = moment([2014, 0, i]).format('YYYY MM Do');
                testMoment = moment(ordinalStr, 'YYYY MM Do');
                assert.equal(testMoment.year(), 2014,
                        'lenient ordinal parsing ' + i + ' year check');
                assert.equal(testMoment.month(), 0,
                        'lenient ordinal parsing ' + i + ' month check');
                assert.equal(testMoment.date(), i,
                        'lenient ordinal parsing ' + i + ' date check');
            }
        });

        test('lenient ordinal parsing of number', function (assert) {
            var i, testMoment;
            for (i = 1; i <= 31; ++i) {
                testMoment = moment('2014 01 ' + i, 'YYYY MM Do');
                assert.equal(testMoment.year(), 2014,
                        'lenient ordinal parsing of number ' + i + ' year check');
                assert.equal(testMoment.month(), 0,
                        'lenient ordinal parsing of number ' + i + ' month check');
                assert.equal(testMoment.date(), i,
                        'lenient ordinal parsing of number ' + i + ' date check');
            }
        });

        test('strict ordinal parsing', function (assert) {
            var i, ordinalStr, testMoment;
            for (i = 1; i <= 31; ++i) {
                ordinalStr = moment([2014, 0, i]).format('YYYY MM Do');
                testMoment = moment(ordinalStr, 'YYYY MM Do', true);
                assert.ok(testMoment.isValid(), 'strict ordinal parsing ' + i);
            }
        });

        test('meridiem invariant', function (assert) {
            var h, m, t1, t2;
            for (h = 0; h < 24; ++h) {
                for (m = 0; m < 60; m += 15) {
                    t1 = moment.utc([2000, 0, 1, h, m]);
                    t2 = moment.utc(t1.format('A h:mm'), 'A h:mm');
                    assert.equal(t2.format('HH:mm'), t1.format('HH:mm'),
                            'meridiem at ' + t1.format('HH:mm'));
                }
            }
        });

        test('date format correctness', function (assert) {
            var data, tokens;
            data = moment.localeData()._longDateFormat;
            tokens = objectKeys(data);
            each(tokens, function (srchToken) {
                // Check each format string to make sure it does not contain any
                // tokens that need to be expanded.
                each(tokens, function (baseToken) {
                    // strip escaped sequences
                    var format = data[baseToken].replace(/(\[[^\]]*\])/g, '');
                    assert.equal(false, !!~format.indexOf(srchToken),
                            'contains ' + srchToken + ' in ' + baseToken);
                });
            });
        });

        test('month parsing correctness', function (assert) {
            var i, m;

            if (locale === 'tr') {
                // I can't fix it :(
                expect(0);
                return;
            }
            function tester(format) {
                var r;
                r = moment(m.format(format), format);
                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format);
                r = moment(m.format(format).toLocaleUpperCase(), format);
                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' upper');
                r = moment(m.format(format).toLocaleLowerCase(), format);
                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' lower');

                r = moment(m.format(format), format, true);
                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' strict');
                r = moment(m.format(format).toLocaleUpperCase(), format, true);
                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' upper strict');
                r = moment(m.format(format).toLocaleLowerCase(), format, true);
                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' lower strict');
            }

            for (i = 0; i < 12; ++i) {
                m = moment([2015, i, 15, 18]);
                tester('MMM');
                tester('MMM.');
                tester('MMMM');
                tester('MMMM.');
            }
        });

        test('weekday parsing correctness', function (assert) {
            var i, m;

            if (locale === 'tr' || locale === 'az') {
                // There is a lower-case letter (Ä±), that converted to upper then
                // lower changes to i
                expect(0);
                return;
            }
            function tester(format) {
                var r, baseMsg = 'weekday ' + m.weekday() + ' fmt ' + format;
                r = moment(m.format(format), format);
                assert.equal(r.weekday(), m.weekday(), baseMsg);
                r = moment(m.format(format).toLocaleUpperCase(), format);
                assert.equal(r.weekday(), m.weekday(), baseMsg + ' upper');
                r = moment(m.format(format).toLocaleLowerCase(), format);
                assert.equal(r.weekday(), m.weekday(), baseMsg + ' lower');

                r = moment(m.format(format), format, true);
                assert.equal(r.weekday(), m.weekday(), baseMsg + ' strict');
                r = moment(m.format(format).toLocaleUpperCase(), format, true);
                assert.equal(r.weekday(), m.weekday(), baseMsg + ' upper strict');
                r = moment(m.format(format).toLocaleLowerCase(), format, true);
                assert.equal(r.weekday(), m.weekday(), baseMsg + ' lower strict');
            }

            for (i = 0; i < 7; ++i) {
                m = moment.utc([2015, i, 15, 18]);
                tester('dd');
                tester('ddd');
                tester('dddd');
            }
        });
    }

    function setupDeprecationHandler(test, moment, scope) {
        test._expectedDeprecations = null;
        test._observedDeprecations = null;
        test._oldSupress = moment.suppressDeprecationWarnings;
        moment.suppressDeprecationWarnings = true;
        test.expectedDeprecations = function () {
            test._expectedDeprecations = arguments;
            test._observedDeprecations = [];
        };
        moment.deprecationHandler = function (name, msg) {
            var deprecationId = matchedDeprecation(name, msg, test._expectedDeprecations);
            if (deprecationId === -1) {
                throw new Error('Unexpected deprecation thrown name=' +
                        name + ' msg=' + msg);
            }
            test._observedDeprecations[deprecationId] = 1;
        };
    }

    function teardownDeprecationHandler(test, moment, scope) {
        moment.suppressDeprecationWarnings = test._oldSupress;

        if (test._expectedDeprecations != null) {
            var missedDeprecations = [];
            each(test._expectedDeprecations, function (deprecationPattern, id) {
                if (test._observedDeprecations[id] !== 1) {
                    missedDeprecations.push(deprecationPattern);
                }
            });
            if (missedDeprecations.length !== 0) {
                throw new Error('Expected deprecation warnings did not happen: ' +
                        missedDeprecations.join(' '));
            }
        }
    }

    function matchedDeprecation(name, msg, deprecations) {
        if (deprecations == null) {
            return -1;
        }
        for (var i = 0; i < deprecations.length; ++i) {
            if (name != null && name === deprecations[i]) {
                return i;
            }
            if (msg != null && msg.substring(0, deprecations[i].length) === deprecations[i]) {
                return i;
            }
        }
        return -1;
    }

    /*global QUnit:false*/

    var test = QUnit.test;

    var expect = QUnit.expect;

    function module (name, lifecycle) {
        QUnit.module(name, {
            setup : function () {
                moment.locale('en');
                moment.createFromInputFallback = function (config) {
                    throw new Error('input not handled by moment: ' + config._i);
                };
                setupDeprecationHandler(test, moment, 'core');
                if (lifecycle && lifecycle.setup) {
                    lifecycle.setup();
                }
            },
            teardown : function () {
                teardownDeprecationHandler(test, moment, 'core');
                if (lifecycle && lifecycle.teardown) {
                    lifecycle.teardown();
                }
            }
        });
    }

    function localeModule (name, lifecycle) {
        QUnit.module('locale:' + name, {
            setup : function () {
                moment.locale(name);
                moment.createFromInputFallback = function (config) {
                    throw new Error('input not handled by moment: ' + config._i);
                };
                setupDeprecationHandler(test, moment, 'locale');
                if (lifecycle && lifecycle.setup) {
                    lifecycle.setup();
                }
            },
            teardown : function () {
                moment.locale('en');
                teardownDeprecationHandler(test, moment, 'locale');
                if (lifecycle && lifecycle.teardown) {
                    lifecycle.teardown();
                }
            }
        });
        defineCommonLocaleTests(name, -1, -1);
    }

    localeModule('nb');

    test('parse', function (assert) {
        var tests = 'januar jan._februar feb._mars mars_april april_mai mai_juni juni_juli juli_august aug._september sep._oktober okt._november nov._desember des.'.split('_'),
            i;
        function equalTest(input, mmm, i) {
            assert.equal(moment(input, mmm).month(), i, input + ' should be month ' + (i + 1));
        }
        for (i = 0; i < 12; i++) {
            tests[i] = tests[i].split(' ');
            equalTest(tests[i][0], 'MMM', i);
            equalTest(tests[i][1], 'MMM', i);
            equalTest(tests[i][0], 'MMMM', i);
            equalTest(tests[i][1], 'MMMM', i);
            equalTest(tests[i][0].toLocaleLowerCase(), 'MMMM', i);
            equalTest(tests[i][1].toLocaleLowerCase(), 'MMMM', i);
            equalTest(tests[i][0].toLocaleUpperCase(), 'MMMM', i);
            equalTest(tests[i][1].toLocaleUpperCase(), 'MMMM', i);
        }
    });

    test('format', function (assert) {
        var a = [
                ['dddd, MMMM Do YYYY, h:mm:ss a',      'sÃ¸ndag, februar 14. 2010, 3:25:50 pm'],
                ['ddd, hA',                            'sÃ¸., 3PM'],
                ['M Mo MM MMMM MMM',                   '2 2. 02 februar feb.'],
                ['YYYY YY',                            '2010 10'],
                ['D Do DD',                            '14 14. 14'],
                ['d do dddd ddd dd',                   '0 0. sÃ¸ndag sÃ¸. sÃ¸'],
                ['DDD DDDo DDDD',                      '45 45. 045'],
                ['w wo ww',                            '6 6. 06'],
                ['h hh',                               '3 03'],
                ['H HH',                               '15 15'],
                ['m mm',                               '25 25'],
                ['s ss',                               '50 50'],
                ['a A',                                'pm PM'],
                ['[den] DDDo [dagen i Ã¥ret]',          'den 45. dagen i Ã¥ret'],
                ['LTS',                                '15:25:50'],
                ['L',                                  '14.02.2010'],
                ['LL',                                 '14. februar 2010'],
                ['LLL',                                '14. februar 2010 kl. 15:25'],
                ['LLLL',                               'sÃ¸ndag 14. februar 2010 kl. 15:25'],
                ['l',                                  '14.2.2010'],
                ['ll',                                 '14. feb. 2010'],
                ['lll',                                '14. feb. 2010 kl. 15:25'],
                ['llll',                               'sÃ¸. 14. feb. 2010 kl. 15:25']
            ],
            b = moment(new Date(2010, 1, 14, 15, 25, 50, 125)),
            i;
        for (i = 0; i < a.length; i++) {
            assert.equal(b.format(a[i][0]), a[i][1], a[i][0] + ' ---> ' + a[i][1]);
        }
    });

    test('format ordinal', function (assert) {
        assert.equal(moment([2011, 0, 1]).format('DDDo'), '1.', '1.');
        assert.equal(moment([2011, 0, 2]).format('DDDo'), '2.', '2.');
        assert.equal(moment([2011, 0, 3]).format('DDDo'), '3.', '3.');
        assert.equal(moment([2011, 0, 4]).format('DDDo'), '4.', '4.');
        assert.equal(moment([2011, 0, 5]).format('DDDo'), '5.', '5.');
        assert.equal(moment([2011, 0, 6]).format('DDDo'), '6.', '6.');
        assert.equal(moment([2011, 0, 7]).format('DDDo'), '7.', '7.');
        assert.equal(moment([2011, 0, 8]).format('DDDo'), '8.', '8.');
        assert.equal(moment([2011, 0, 9]).format('DDDo'), '9.', '9.');
        assert.equal(moment([2011, 0, 10]).format('DDDo'), '10.', '10.');

        assert.equal(moment([2011, 0, 11]).format('DDDo'), '11.', '11.');
        assert.equal(moment([2011, 0, 12]).format('DDDo'), '12.', '12.');
        assert.equal(moment([2011, 0, 13]).format('DDDo'), '13.', '13.');
        assert.equal(moment([2011, 0, 14]).format('DDDo'), '14.', '14.');
        assert.equal(moment([2011, 0, 15]).format('DDDo'), '15.', '15.');
        assert.equal(moment([2011, 0, 16]).format('DDDo'), '16.', '16.');
        assert.equal(moment([2011, 0, 17]).format('DDDo'), '17.', '17.');
        assert.equal(moment([2011, 0, 18]).format('DDDo'), '18.', '18.');
        assert.equal(moment([2011, 0, 19]).format('DDDo'), '19.', '19.');
        assert.equal(moment([2011, 0, 20]).format('DDDo'), '20.', '20.');

        assert.equal(moment([2011, 0, 21]).format('DDDo'), '21.', '21.');
        assert.equal(moment([2011, 0, 22]).format('DDDo'), '22.', '22.');
        assert.equal(moment([2011, 0, 23]).format('DDDo'), '23.', '23.');
        assert.equal(moment([2011, 0, 24]).format('DDDo'), '24.', '24.');
        assert.equal(moment([2011, 0, 25]).format('DDDo'), '25.', '25.');
        assert.equal(moment([2011, 0, 26]).format('DDDo'), '26.', '26.');
        assert.equal(moment([2011, 0, 27]).format('DDDo'), '27.', '27.');
        assert.equal(moment([2011, 0, 28]).format('DDDo'), '28.', '28.');
        assert.equal(moment([2011, 0, 29]).format('DDDo'), '29.', '29.');
        assert.equal(moment([2011, 0, 30]).format('DDDo'), '30.', '30.');

        assert.equal(moment([2011, 0, 31]).format('DDDo'), '31.', '31.');
    });

    test('format month', function (assert) {
        var expected = 'januar jan._februar feb._mars mars_april april_mai mai_juni juni_juli juli_august aug._september sep._oktober okt._november nov._desember des.'.split('_'), i;
        for (i = 0; i < expected.length; i++) {
            assert.equal(moment([2011, i, 1]).format('MMMM MMM'), expected[i], expected[i]);
        }
    });

    test('format week', function (assert) {
        var expected = 'sÃ¸ndag sÃ¸. sÃ¸_mandag ma. ma_tirsdag ti. ti_onsdag on. on_torsdag to. to_fredag fr. fr_lÃ¸rdag lÃ¸. lÃ¸'.split('_'), i;
        for (i = 0; i < expected.length; i++) {
            assert.equal(moment([2011, 0, 2 + i]).format('dddd ddd dd'), expected[i], expected[i]);
        }
    });

    test('from', function (assert) {
        var start = moment([2007, 1, 28]);
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 44}), true),  'noen sekunder', '44 sekunder = a few seconds');
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 45}), true),  'ett minutt',      '45 seconds = a minute');
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 89}), true),  'ett minutt',      '89 seconds = a minute');
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 90}), true),  '2 minutter',     '90 seconds = 2 minutes');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 44}), true),  '44 minutter',    '44 minutes = 44 minutes');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 45}), true),  'en time',       '45 minutes = an hour');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 89}), true),  'en time',       '89 minutes = an hour');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 90}), true),  '2 timer',       '90 minutes = 2 hours');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 5}), true),   '5 timer',       '5 hours = 5 hours');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 21}), true),  '21 timer',      '21 hours = 21 hours');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 22}), true),  'en dag',         '22 hours = a day');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 35}), true),  'en dag',         '35 hours = a day');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 36}), true),  '2 dager',        '36 hours = 2 days');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 1}), true),   'en dag',         '1 day = a day');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 5}), true),   '5 dager',        '5 days = 5 days');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 25}), true),  '25 dager',       '25 days = 25 days');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 26}), true),  'en mÃ¥ned',       '26 days = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 30}), true),  'en mÃ¥ned',       '30 days = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 43}), true),  'en mÃ¥ned',       '43 days = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 46}), true),  '2 mÃ¥neder',      '46 days = 2 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 74}), true),  '2 mÃ¥neder',      '75 days = 2 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 76}), true),  '3 mÃ¥neder',      '76 days = 3 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({M: 1}), true),   'en mÃ¥ned',       '1 month = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({M: 5}), true),   '5 mÃ¥neder',      '5 months = 5 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 345}), true), 'ett Ã¥r',        '345 days = a year');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 548}), true), '2 Ã¥r',       '548 days = 2 years');
        assert.equal(start.from(moment([2007, 1, 28]).add({y: 1}), true),   'ett Ã¥r',        '1 year = a year');
        assert.equal(start.from(moment([2007, 1, 28]).add({y: 5}), true),   '5 Ã¥r',       '5 years = 5 years');
    });

    test('suffix', function (assert) {
        assert.equal(moment(30000).from(0), 'om noen sekunder',  'prefix');
        assert.equal(moment(0).from(30000), 'noen sekunder siden', 'suffix');
    });

    test('now from now', function (assert) {
        assert.equal(moment().fromNow(), 'noen sekunder siden',  'now from now should display as in the past');
    });

    test('fromNow', function (assert) {
        assert.equal(moment().add({s: 30}).fromNow(), 'om noen sekunder', 'in a few seconds');
        assert.equal(moment().add({d: 5}).fromNow(), 'om 5 dager', 'in 5 days');
    });

    test('calendar day', function (assert) {
        var a = moment().hours(12).minutes(0).seconds(0);

        assert.equal(moment(a).calendar(),                   'i dag kl. 12:00',     'today at the same time');
        assert.equal(moment(a).add({m: 25}).calendar(),      'i dag kl. 12:25',     'Now plus 25 min');
        assert.equal(moment(a).add({h: 1}).calendar(),       'i dag kl. 13:00',     'Now plus 1 hour');
        assert.equal(moment(a).add({d: 1}).calendar(),       'i morgen kl. 12:00',  'tomorrow at the same time');
        assert.equal(moment(a).subtract({h: 1}).calendar(),  'i dag kl. 11:00',     'Now minus 1 hour');
        assert.equal(moment(a).subtract({d: 1}).calendar(),  'i gÃ¥r kl. 12:00',     'yesterday at the same time');
    });

    test('calendar next week', function (assert) {
        var i, m;
        for (i = 2; i < 7; i++) {
            m = moment().add({d: i});
            assert.equal(m.calendar(),       m.format('dddd [kl.] LT'),  'Today + ' + i + ' days current time');
            m.hours(0).minutes(0).seconds(0).milliseconds(0);
            assert.equal(m.calendar(),       m.format('dddd [kl.] LT'),  'Today + ' + i + ' days beginning of day');
            m.hours(23).minutes(59).seconds(59).milliseconds(999);
            assert.equal(m.calendar(),       m.format('dddd [kl.] LT'),  'Today + ' + i + ' days end of day');
        }
    });

    test('calendar last week', function (assert) {
        var i, m;
        for (i = 2; i < 7; i++) {
            m = moment().subtract({d: i});
            assert.equal(m.calendar(),       m.format('[forrige] dddd [kl.] LT'),  'Today - ' + i + ' days current time');
            m.hours(0).minutes(0).seconds(0).milliseconds(0);
            assert.equal(m.calendar(),       m.format('[forrige] dddd [kl.] LT'),  'Today - ' + i + ' days beginning of day');
            m.hours(23).minutes(59).seconds(59).milliseconds(999);
            assert.equal(m.calendar(),       m.format('[forrige] dddd [kl.] LT'),  'Today - ' + i + ' days end of day');
        }
    });

    test('calendar all else', function (assert) {
        var weeksAgo = moment().subtract({w: 1}),
            weeksFromNow = moment().add({w: 1});

        assert.equal(weeksAgo.calendar(),       weeksAgo.format('L'),  '1 week ago');
        assert.equal(weeksFromNow.calendar(),   weeksFromNow.format('L'),  'in 1 week');

        weeksAgo = moment().subtract({w: 2});
        weeksFromNow = moment().add({w: 2});

        assert.equal(weeksAgo.calendar(),       weeksAgo.format('L'),  '2 weeks ago');
        assert.equal(weeksFromNow.calendar(),   weeksFromNow.format('L'),  'in 2 weeks');
    });

    test('weeks year starting sunday formatted', function (assert) {
        assert.equal(moment([2012, 0,  1]).format('w ww wo'), '52 52 52.', 'Jan  1 2012 should be week 52');
        assert.equal(moment([2012, 0,  2]).format('w ww wo'),  '1 01 1.', 'Jan  2 2012 should be week 1');
        assert.equal(moment([2012, 0,  8]).format('w ww wo'),  '1 01 1.', 'Jan  8 2012 should be week 1');
        assert.equal(moment([2012, 0,  9]).format('w ww wo'),  '2 02 2.', 'Jan  9 2012 should be week 2');
        assert.equal(moment([2012, 0, 15]).format('w ww wo'),  '2 02 2.', 'Jan 15 2012 should be week 2');
    });

}));

;(function (global, factory) {
   typeof exports === 'object' && typeof module !== 'undefined'
       && typeof require === 'function' ? factory(require('../../moment')) :
   typeof define === 'function' && define.amd ? define(['../../moment'], factory) :
   factory(global.moment)
}(this, function (moment) { 'use strict';

    function each(array, callback) {
        var i;
        for (i = 0; i < array.length; i++) {
            callback(array[i], i, array);
        }
    }

    function objectKeys(obj) {
        if (Object.keys) {
            return Object.keys(obj);
        } else {
            // IE8
            var res = [], i;
            for (i in obj) {
                if (obj.hasOwnProperty(i)) {
                    res.push(i);
                }
            }
            return res;
        }
    }

    // Pick the first defined of two or three arguments.
    function defaults(a, b, c) {
        if (a != null) {
            return a;
        }
        if (b != null) {
            return b;
        }
        return c;
    }

    function defineCommonLocaleTests(locale, options) {
        test('lenient ordinal parsing', function (assert) {
            var i, ordinalStr, testMoment;
            for (i = 1; i <= 31; ++i) {
                ordinalStr = moment([2014, 0, i]).format('YYYY MM Do');
                testMoment = moment(ordinalStr, 'YYYY MM Do');
                assert.equal(testMoment.year(), 2014,
                        'lenient ordinal parsing ' + i + ' year check');
                assert.equal(testMoment.month(), 0,
                        'lenient ordinal parsing ' + i + ' month check');
                assert.equal(testMoment.date(), i,
                        'lenient ordinal parsing ' + i + ' date check');
            }
        });

        test('lenient ordinal parsing of number', function (assert) {
            var i, testMoment;
            for (i = 1; i <= 31; ++i) {
                testMoment = moment('2014 01 ' + i, 'YYYY MM Do');
                assert.equal(testMoment.year(), 2014,
                        'lenient ordinal parsing of number ' + i + ' year check');
                assert.equal(testMoment.month(), 0,
                        'lenient ordinal parsing of number ' + i + ' month check');
                assert.equal(testMoment.date(), i,
                        'lenient ordinal parsing of number ' + i + ' date check');
            }
        });

        test('strict ordinal parsing', function (assert) {
            var i, ordinalStr, testMoment;
            for (i = 1; i <= 31; ++i) {
                ordinalStr = moment([2014, 0, i]).format('YYYY MM Do');
                testMoment = moment(ordinalStr, 'YYYY MM Do', true);
                assert.ok(testMoment.isValid(), 'strict ordinal parsing ' + i);
            }
        });

        test('meridiem invariant', function (assert) {
            var h, m, t1, t2;
            for (h = 0; h < 24; ++h) {
                for (m = 0; m < 60; m += 15) {
                    t1 = moment.utc([2000, 0, 1, h, m]);
                    t2 = moment.utc(t1.format('A h:mm'), 'A h:mm');
                    assert.equal(t2.format('HH:mm'), t1.format('HH:mm'),
                            'meridiem at ' + t1.format('HH:mm'));
                }
            }
        });

        test('date format correctness', function (assert) {
            var data, tokens;
            data = moment.localeData()._longDateFormat;
            tokens = objectKeys(data);
            each(tokens, function (srchToken) {
                // Check each format string to make sure it does not contain any
                // tokens that need to be expanded.
                each(tokens, function (baseToken) {
                    // strip escaped sequences
                    var format = data[baseToken].replace(/(\[[^\]]*\])/g, '');
                    assert.equal(false, !!~format.indexOf(srchToken),
                            'contains ' + srchToken + ' in ' + baseToken);
                });
            });
        });

        test('month parsing correctness', function (assert) {
            var i, m;

            if (locale === 'tr') {
                // I can't fix it :(
                expect(0);
                return;
            }
            function tester(format) {
                var r;
                r = moment(m.format(format), format);
                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format);
                r = moment(m.format(format).toLocaleUpperCase(), format);
                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' upper');
                r = moment(m.format(format).toLocaleLowerCase(), format);
                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' lower');

                r = moment(m.format(format), format, true);
                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' strict');
                r = moment(m.format(format).toLocaleUpperCase(), format, true);
                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' upper strict');
                r = moment(m.format(format).toLocaleLowerCase(), format, true);
                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' lower strict');
            }

            for (i = 0; i < 12; ++i) {
                m = moment([2015, i, 15, 18]);
                tester('MMM');
                tester('MMM.');
                tester('MMMM');
                tester('MMMM.');
            }
        });

        test('weekday parsing correctness', function (assert) {
            var i, m;

            if (locale === 'tr' || locale === 'az') {
                // There is a lower-case letter (Ä±), that converted to upper then
                // lower changes to i
                expect(0);
                return;
            }
            function tester(format) {
                var r, baseMsg = 'weekday ' + m.weekday() + ' fmt ' + format;
                r = moment(m.format(format), format);
                assert.equal(r.weekday(), m.weekday(), baseMsg);
                r = moment(m.format(format).toLocaleUpperCase(), format);
                assert.equal(r.weekday(), m.weekday(), baseMsg + ' upper');
                r = moment(m.format(format).toLocaleLowerCase(), format);
                assert.equal(r.weekday(), m.weekday(), baseMsg + ' lower');

                r = moment(m.format(format), format, true);
                assert.equal(r.weekday(), m.weekday(), baseMsg + ' strict');
                r = moment(m.format(format).toLocaleUpperCase(), format, true);
                assert.equal(r.weekday(), m.weekday(), baseMsg + ' upper strict');
                r = moment(m.format(format).toLocaleLowerCase(), format, true);
                assert.equal(r.weekday(), m.weekday(), baseMsg + ' lower strict');
            }

            for (i = 0; i < 7; ++i) {
                m = moment.utc([2015, i, 15, 18]);
                tester('dd');
                tester('ddd');
                tester('dddd');
            }
        });
    }

    function setupDeprecationHandler(test, moment, scope) {
        test._expectedDeprecations = null;
        test._observedDeprecations = null;
        test._oldSupress = moment.suppressDeprecationWarnings;
        moment.suppressDeprecationWarnings = true;
        test.expectedDeprecations = function () {
            test._expectedDeprecations = arguments;
            test._observedDeprecations = [];
        };
        moment.deprecationHandler = function (name, msg) {
            var deprecationId = matchedDeprecation(name, msg, test._expectedDeprecations);
            if (deprecationId === -1) {
                throw new Error('Unexpected deprecation thrown name=' +
                        name + ' msg=' + msg);
            }
            test._observedDeprecations[deprecationId] = 1;
        };
    }

    function teardownDeprecationHandler(test, moment, scope) {
        moment.suppressDeprecationWarnings = test._oldSupress;

        if (test._expectedDeprecations != null) {
            var missedDeprecations = [];
            each(test._expectedDeprecations, function (deprecationPattern, id) {
                if (test._observedDeprecations[id] !== 1) {
                    missedDeprecations.push(deprecationPattern);
                }
            });
            if (missedDeprecations.length !== 0) {
                throw new Error('Expected deprecation warnings did not happen: ' +
                        missedDeprecations.join(' '));
            }
        }
    }

    function matchedDeprecation(name, msg, deprecations) {
        if (deprecations == null) {
            return -1;
        }
        for (var i = 0; i < deprecations.length; ++i) {
            if (name != null && name === deprecations[i]) {
                return i;
            }
            if (msg != null && msg.substring(0, deprecations[i].length) === deprecations[i]) {
                return i;
            }
        }
        return -1;
    }

    /*global QUnit:false*/

    var test = QUnit.test;

    var expect = QUnit.expect;

    function module (name, lifecycle) {
        QUnit.module(name, {
            setup : function () {
                moment.locale('en');
                moment.createFromInputFallback = function (config) {
                    throw new Error('input not handled by moment: ' + config._i);
                };
                setupDeprecationHandler(test, moment, 'core');
                if (lifecycle && lifecycle.setup) {
                    lifecycle.setup();
                }
            },
            teardown : function () {
                teardownDeprecationHandler(test, moment, 'core');
                if (lifecycle && lifecycle.teardown) {
                    lifecycle.teardown();
                }
            }
        });
    }

    function localeModule (name, lifecycle) {
        QUnit.module('locale:' + name, {
            setup : function () {
                moment.locale(name);
                moment.createFromInputFallback = function (config) {
                    throw new Error('input not handled by moment: ' + config._i);
                };
                setupDeprecationHandler(test, moment, 'locale');
                if (lifecycle && lifecycle.setup) {
                    lifecycle.setup();
                }
            },
            teardown : function () {
                moment.locale('en');
                teardownDeprecationHandler(test, moment, 'locale');
                if (lifecycle && lifecycle.teardown) {
                    lifecycle.teardown();
                }
            }
        });
        defineCommonLocaleTests(name, -1, -1);
    }

    localeModule('ne');

    test('parse', function (assert) {
        var tests = 'à¤à¤¨à¤µà¤°à¥ à¤à¤¨._à¤«à¥à¤¬à¥à¤°à¥à¤µà¤°à¥ à¤«à¥à¤¬à¥à¤°à¥._à¤®à¤¾à¤°à¥à¤ à¤®à¤¾à¤°à¥à¤_à¤à¤ªà¥à¤°à¤¿à¤² à¤à¤ªà¥à¤°à¤¿._à¤®à¤ à¤®à¤_à¤à¥à¤¨ à¤à¥à¤¨_à¤à¥à¤²à¤¾à¤ à¤à¥à¤²à¤¾à¤._à¤à¤à¤·à¥à¤ à¤à¤._à¤¸à¥à¤ªà¥à¤à¥à¤®à¥à¤¬à¤° à¤¸à¥à¤ªà¥à¤._à¤à¤à¥à¤à¥à¤¬à¤° à¤à¤à¥à¤à¥._à¤¨à¥à¤­à¥à¤®à¥à¤¬à¤° à¤¨à¥à¤­à¥._à¤¡à¤¿à¤¸à¥à¤®à¥à¤¬à¤° à¤¡à¤¿à¤¸à¥.'.split('_'), i;
        function equalTest(input, mmm, i) {
            assert.equal(moment(input, mmm).month(), i, input + ' should be month ' + (i + 1));
        }
        for (i = 0; i < 12; i++) {
            tests[i] = tests[i].split(' ');
            equalTest(tests[i][0], 'MMM', i);
            equalTest(tests[i][1], 'MMM', i);
            equalTest(tests[i][0], 'MMMM', i);
            equalTest(tests[i][1], 'MMMM', i);
            equalTest(tests[i][0].toLocaleLowerCase(), 'MMMM', i);
            equalTest(tests[i][1].toLocaleLowerCase(), 'MMMM', i);
            equalTest(tests[i][0].toLocaleUpperCase(), 'MMMM', i);
            equalTest(tests[i][1].toLocaleUpperCase(), 'MMMM', i);
        }
    });

    test('format', function (assert) {
        var a = [
                ['dddd, Do MMMM YYYY, aà¤à¥ h:mm:ss à¤¬à¤à¥',      'à¤à¤à¤¤à¤¬à¤¾à¤°, à¥§à¥ª à¤«à¥à¤¬à¥à¤°à¥à¤µà¤°à¥ à¥¨à¥¦à¥§à¥¦, à¤¦à¤¿à¤à¤à¤¸à¥à¤à¥ à¥©:à¥¨à¥«:à¥«à¥¦ à¤¬à¤à¥'],
                ['ddd, aà¤à¥ h à¤¬à¤à¥',                                                'à¤à¤à¤¤., à¤¦à¤¿à¤à¤à¤¸à¥à¤à¥ à¥© à¤¬à¤à¥'],
                ['M Mo MM MMMM MMM',                   'à¥¨ à¥¨ à¥¦à¥¨ à¤«à¥à¤¬à¥à¤°à¥à¤µà¤°à¥ à¤«à¥à¤¬à¥à¤°à¥.'],
                ['YYYY YY',                            'à¥¨à¥¦à¥§à¥¦ à¥§à¥¦'],
                ['D Do DD',                            'à¥§à¥ª à¥§à¥ª à¥§à¥ª'],
                ['d do dddd ddd dd',                   'à¥¦ à¥¦ à¤à¤à¤¤à¤¬à¤¾à¤° à¤à¤à¤¤. à¤.'],
                ['DDD DDDo DDDD',                      'à¥ªà¥« à¥ªà¥« à¥¦à¥ªà¥«'],
                ['w wo ww',                            'à¥® à¥® à¥¦à¥®'],
                ['h hh',                               'à¥© à¥¦à¥©'],
                ['H HH',                               'à¥§à¥« à¥§à¥«'],
                ['m mm',                               'à¥¨à¥« à¥¨à¥«'],
                ['s ss',                               'à¥«à¥¦ à¥«à¥¦'],
                ['a A',                                'à¤¦à¤¿à¤à¤à¤¸à¥ à¤¦à¤¿à¤à¤à¤¸à¥'],
                ['LTS',                                'à¤¦à¤¿à¤à¤à¤¸à¥à¤à¥ à¥©:à¥¨à¥«:à¥«à¥¦ à¤¬à¤à¥'],
                ['L',                                  'à¥§à¥ª/à¥¦à¥¨/à¥¨à¥¦à¥§à¥¦'],
                ['LL',                                 'à¥§à¥ª à¤«à¥à¤¬à¥à¤°à¥à¤µà¤°à¥ à¥¨à¥¦à¥§à¥¦'],
                ['LLL',                                'à¥§à¥ª à¤«à¥à¤¬à¥à¤°à¥à¤µà¤°à¥ à¥¨à¥¦à¥§à¥¦, à¤¦à¤¿à¤à¤à¤¸à¥à¤à¥ à¥©:à¥¨à¥« à¤¬à¤à¥'],
                ['LLLL',                               'à¤à¤à¤¤à¤¬à¤¾à¤°, à¥§à¥ª à¤«à¥à¤¬à¥à¤°à¥à¤µà¤°à¥ à¥¨à¥¦à¥§à¥¦, à¤¦à¤¿à¤à¤à¤¸à¥à¤à¥ à¥©:à¥¨à¥« à¤¬à¤à¥'],
                ['l',                                  'à¥§à¥ª/à¥¨/à¥¨à¥¦à¥§à¥¦'],
                ['ll',                                 'à¥§à¥ª à¤«à¥à¤¬à¥à¤°à¥. à¥¨à¥¦à¥§à¥¦'],
                ['lll',                                'à¥§à¥ª à¤«à¥à¤¬à¥à¤°à¥. à¥¨à¥¦à¥§à¥¦, à¤¦à¤¿à¤à¤à¤¸à¥à¤à¥ à¥©:à¥¨à¥« à¤¬à¤à¥'],
                ['llll',                               'à¤à¤à¤¤., à¥§à¥ª à¤«à¥à¤¬à¥à¤°à¥. à¥¨à¥¦à¥§à¥¦, à¤¦à¤¿à¤à¤à¤¸à¥à¤à¥ à¥©:à¥¨à¥« à¤¬à¤à¥']
            ],
            b = moment(new Date(2010, 1, 14, 15, 25, 50, 125)),
            i;
        for (i = 0; i < a.length; i++) {
            assert.equal(b.format(a[i][0]), a[i][1], a[i][0] + ' ---> ' + a[i][1]);
        }
    });

    test('format ordinal', function (assert) {
        assert.equal(moment([2011, 0, 1]).format('DDDo'), 'à¥§', 'à¥§');
        assert.equal(moment([2011, 0, 2]).format('DDDo'), 'à¥¨', 'à¥¨');
        assert.equal(moment([2011, 0, 3]).format('DDDo'), 'à¥©', 'à¥©');
        assert.equal(moment([2011, 0, 4]).format('DDDo'), 'à¥ª', 'à¥ª');
        assert.equal(moment([2011, 0, 5]).format('DDDo'), 'à¥«', 'à¥«');
        assert.equal(moment([2011, 0, 6]).format('DDDo'), 'à¥¬', 'à¥¬');
        assert.equal(moment([2011, 0, 7]).format('DDDo'), 'à¥­', 'à¥­');
        assert.equal(moment([2011, 0, 8]).format('DDDo'), 'à¥®', 'à¥®');
        assert.equal(moment([2011, 0, 9]).format('DDDo'), 'à¥¯', 'à¥¯');
        assert.equal(moment([2011, 0, 10]).format('DDDo'), 'à¥§à¥¦', 'à¥§à¥¦');

        assert.equal(moment([2011, 0, 11]).format('DDDo'), 'à¥§à¥§', 'à¥§à¥§');
        assert.equal(moment([2011, 0, 12]).format('DDDo'), 'à¥§à¥¨', 'à¥§à¥¨');
        assert.equal(moment([2011, 0, 13]).format('DDDo'), 'à¥§à¥©', 'à¥§à¥©');
        assert.equal(moment([2011, 0, 14]).format('DDDo'), 'à¥§à¥ª', 'à¥§à¥ª');
        assert.equal(moment([2011, 0, 15]).format('DDDo'), 'à¥§à¥«', 'à¥§à¥«');
        assert.equal(moment([2011, 0, 16]).format('DDDo'), 'à¥§à¥¬', 'à¥§à¥¬');
        assert.equal(moment([2011, 0, 17]).format('DDDo'), 'à¥§à¥­', 'à¥§à¥­');
        assert.equal(moment([2011, 0, 18]).format('DDDo'), 'à¥§à¥®', 'à¥§à¥®');
        assert.equal(moment([2011, 0, 19]).format('DDDo'), 'à¥§à¥¯', 'à¥§à¥¯');
        assert.equal(moment([2011, 0, 20]).format('DDDo'), 'à¥¨à¥¦', 'à¥¨à¥¦');

        assert.equal(moment([2011, 0, 21]).format('DDDo'), 'à¥¨à¥§', 'à¥¨à¥§');
        assert.equal(moment([2011, 0, 22]).format('DDDo'), 'à¥¨à¥¨', 'à¥¨à¥¨');
        assert.equal(moment([2011, 0, 23]).format('DDDo'), 'à¥¨à¥©', 'à¥¨à¥©');
        assert.equal(moment([2011, 0, 24]).format('DDDo'), 'à¥¨à¥ª', 'à¥¨à¥ª');
        assert.equal(moment([2011, 0, 25]).format('DDDo'), 'à¥¨à¥«', 'à¥¨à¥«');
        assert.equal(moment([2011, 0, 26]).format('DDDo'), 'à¥¨à¥¬', 'à¥¨à¥¬');
        assert.equal(moment([2011, 0, 27]).format('DDDo'), 'à¥¨à¥­', 'à¥¨à¥­');
        assert.equal(moment([2011, 0, 28]).format('DDDo'), 'à¥¨à¥®', 'à¥¨à¥®');
        assert.equal(moment([2011, 0, 29]).format('DDDo'), 'à¥¨à¥¯', 'à¥¨à¥¯');
        assert.equal(moment([2011, 0, 30]).format('DDDo'), 'à¥©à¥¦', 'à¥©à¥¦');

        assert.equal(moment([2011, 0, 31]).format('DDDo'), 'à¥©à¥§', 'à¥©à¥§');
    });

    test('format month', function (assert) {
        var expected = 'à¤à¤¨à¤µà¤°à¥ à¤à¤¨._à¤«à¥à¤¬à¥à¤°à¥à¤µà¤°à¥ à¤«à¥à¤¬à¥à¤°à¥._à¤®à¤¾à¤°à¥à¤ à¤®à¤¾à¤°à¥à¤_à¤à¤ªà¥à¤°à¤¿à¤² à¤à¤ªà¥à¤°à¤¿._à¤®à¤ à¤®à¤_à¤à¥à¤¨ à¤à¥à¤¨_à¤à¥à¤²à¤¾à¤ à¤à¥à¤²à¤¾à¤._à¤à¤à¤·à¥à¤ à¤à¤._à¤¸à¥à¤ªà¥à¤à¥à¤®à¥à¤¬à¤° à¤¸à¥à¤ªà¥à¤._à¤à¤à¥à¤à¥à¤¬à¤° à¤à¤à¥à¤à¥._à¤¨à¥à¤­à¥à¤®à¥à¤¬à¤° à¤¨à¥à¤­à¥._à¤¡à¤¿à¤¸à¥à¤®à¥à¤¬à¤° à¤¡à¤¿à¤¸à¥.'.split('_'), i;
        for (i = 0; i < expected.length; i++) {
            assert.equal(moment([2011, i, 1]).format('MMMM MMM'), expected[i], expected[i]);
        }
    });

    test('format week', function (assert) {
        var expected = 'à¤à¤à¤¤à¤¬à¤¾à¤° à¤à¤à¤¤. à¤._à¤¸à¥à¤®à¤¬à¤¾à¤° à¤¸à¥à¤®. à¤¸à¥._à¤®à¤à¥à¤à¤²à¤¬à¤¾à¤° à¤®à¤à¥à¤à¤². à¤®à¤._à¤¬à¥à¤§à¤¬à¤¾à¤° à¤¬à¥à¤§. à¤¬à¥._à¤¬à¤¿à¤¹à¤¿à¤¬à¤¾à¤° à¤¬à¤¿à¤¹à¤¿. à¤¬à¤¿._à¤¶à¥à¤à¥à¤°à¤¬à¤¾à¤° à¤¶à¥à¤à¥à¤°. à¤¶à¥._à¤¶à¤¨à¤¿à¤¬à¤¾à¤° à¤¶à¤¨à¤¿. à¤¶.'.split('_'), i;
        for (i = 0; i < expected.length; i++) {
            assert.equal(moment([2011, 0, 2 + i]).format('dddd ddd dd'), expected[i], expected[i]);
        }
    });

    test('from', function (assert) {
        var start = moment([2007, 1, 28]);
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 44}), true),  'à¤à¥à¤¹à¥ à¤à¥à¤·à¤£', '44 seconds = a few seconds');
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 45}), true),  'à¤à¤ à¤®à¤¿à¤¨à¥à¤',      '45 seconds = a minute');
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 89}), true),  'à¤à¤ à¤®à¤¿à¤¨à¥à¤',      '89 seconds = a minute');
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 90}), true),  'à¥¨ à¤®à¤¿à¤¨à¥à¤',     '90 seconds = 2 minutes');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 44}), true),  'à¥ªà¥ª à¤®à¤¿à¤¨à¥à¤',    '44 minutes = 44 minutes');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 45}), true),  'à¤à¤ à¤à¤£à¥à¤à¤¾',       '45 minutes = an hour');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 89}), true),  'à¤à¤ à¤à¤£à¥à¤à¤¾',       '89 minutes = an hour');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 90}), true),  'à¥¨ à¤à¤£à¥à¤à¤¾',       '90 minutes = 2 hours');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 5}), true),   'à¥« à¤à¤£à¥à¤à¤¾',       '5 hours = 5 hours');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 21}), true),  'à¥¨à¥§ à¤à¤£à¥à¤à¤¾',      '21 hours = 21 hours');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 22}), true),  'à¤à¤ à¤¦à¤¿à¤¨',         '22 hours = a day');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 35}), true),  'à¤à¤ à¤¦à¤¿à¤¨',         '35 hours = a day');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 36}), true),  'à¥¨ à¤¦à¤¿à¤¨',        '36 hours = 2 days');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 1}), true),   'à¤à¤ à¤¦à¤¿à¤¨',         '1 day = a day');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 5}), true),   'à¥« à¤¦à¤¿à¤¨',        '5 days = 5 days');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 25}), true),  'à¥¨à¥« à¤¦à¤¿à¤¨',       '25 days = 25 days');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 26}), true),  'à¤à¤ à¤®à¤¹à¤¿à¤¨à¤¾',       '26 days = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 30}), true),  'à¤à¤ à¤®à¤¹à¤¿à¤¨à¤¾',       '30 days = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 43}), true),  'à¤à¤ à¤®à¤¹à¤¿à¤¨à¤¾',       '43 days = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 46}), true),  'à¥¨ à¤®à¤¹à¤¿à¤¨à¤¾',      '46 days = 2 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 74}), true),  'à¥¨ à¤®à¤¹à¤¿à¤¨à¤¾',      '75 days = 2 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 76}), true),  'à¥© à¤®à¤¹à¤¿à¤¨à¤¾',      '76 days = 3 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({M: 1}), true),   'à¤à¤ à¤®à¤¹à¤¿à¤¨à¤¾',       '1 month = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({M: 5}), true),   'à¥« à¤®à¤¹à¤¿à¤¨à¤¾',      '5 months = 5 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 345}), true), 'à¤à¤ à¤¬à¤°à¥à¤·',        '345 days = a year');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 548}), true), 'à¥¨ à¤¬à¤°à¥à¤·',       '548 days = 2 years');
        assert.equal(start.from(moment([2007, 1, 28]).add({y: 1}), true),   'à¤à¤ à¤¬à¤°à¥à¤·',        '1 year = a year');
        assert.equal(start.from(moment([2007, 1, 28]).add({y: 5}), true),   'à¥« à¤¬à¤°à¥à¤·',       '5 years = 5 years');
    });

    test('suffix', function (assert) {
        assert.equal(moment(30000).from(0), 'à¤à¥à¤¹à¥ à¤à¥à¤·à¤£à¤®à¤¾',  'prefix');
        assert.equal(moment(0).from(30000), 'à¤à¥à¤¹à¥ à¤à¥à¤·à¤£ à¤à¤à¤¾à¤¡à¤¿', 'suffix');
    });

    test('now from now', function (assert) {
        assert.equal(moment().fromNow(), 'à¤à¥à¤¹à¥ à¤à¥à¤·à¤£ à¤à¤à¤¾à¤¡à¤¿',  'now from now should display as in the past');
    });

    test('fromNow', function (assert) {
        assert.equal(moment().add({s: 30}).fromNow(), 'à¤à¥à¤¹à¥ à¤à¥à¤·à¤£à¤®à¤¾', 'à¤à¥à¤¹à¥ à¤à¥à¤·à¤£à¤®à¤¾');
        assert.equal(moment().add({d: 5}).fromNow(), 'à¥« à¤¦à¤¿à¤¨à¤®à¤¾', 'à¥« à¤¦à¤¿à¤¨à¤®à¤¾');
    });

    test('calendar day', function (assert) {
        var a = moment().hours(12).minutes(0).seconds(0);

        assert.equal(moment(a).calendar(),                   'à¤à¤ à¤¦à¤¿à¤à¤à¤¸à¥à¤à¥ à¥§à¥¨:à¥¦à¥¦ à¤¬à¤à¥',    'today at the same time');
        assert.equal(moment(a).add({m: 25}).calendar(),      'à¤à¤ à¤¦à¤¿à¤à¤à¤¸à¥à¤à¥ à¥§à¥¨:à¥¨à¥« à¤¬à¤à¥',    'Now plus 25 min');
        assert.equal(moment(a).add({h: 1}).calendar(),       'à¤à¤ à¤¦à¤¿à¤à¤à¤¸à¥à¤à¥ à¥§:à¥¦à¥¦ à¤¬à¤à¥',     'Now plus 1 hour');
        assert.equal(moment(a).add({d: 1}).calendar(),       'à¤­à¥à¤²à¤¿ à¤¦à¤¿à¤à¤à¤¸à¥à¤à¥ à¥§à¥¨:à¥¦à¥¦ à¤¬à¤à¥',  'tomorrow at the same time');
        assert.equal(moment(a).subtract({h: 1}).calendar(),  'à¤à¤ à¤¬à¤¿à¤¹à¤¾à¤¨à¤à¥ à¥§à¥§:à¥¦à¥¦ à¤¬à¤à¥',     'Now minus 1 hour');
        assert.equal(moment(a).subtract({d: 1}).calendar(),  'à¤¹à¤¿à¤à¥ à¤¦à¤¿à¤à¤à¤¸à¥à¤à¥ à¥§à¥¨:à¥¦à¥¦ à¤¬à¤à¥',  'yesterday at the same time');
    });

    test('calendar next week', function (assert) {
        var i, m;
        for (i = 2; i < 7; i++) {
            m = moment().add({d: i});
            assert.equal(m.calendar(),       m.format('[à¤à¤à¤à¤¦à¥] dddd[,] LT'),  'Today + ' + i + ' days current time');
            m.hours(0).minutes(0).seconds(0).milliseconds(0);
            assert.equal(m.calendar(),       m.format('[à¤à¤à¤à¤¦à¥] dddd[,] LT'),  'Today + ' + i + ' days beginning of day');
            m.hours(23).minutes(59).seconds(59).milliseconds(999);
            assert.equal(m.calendar(),       m.format('[à¤à¤à¤à¤¦à¥] dddd[,] LT'),  'Today + ' + i + ' days end of day');
        }
    });

    test('calendar last week', function (assert) {
        var i, m;
        for (i = 2; i < 7; i++) {
            m = moment().subtract({d: i});
            assert.equal(m.calendar(),       m.format('[à¤à¤à¤à¥] dddd[,] LT'),  'Today - ' + i + ' days current time');
            m.hours(0).minutes(0).seconds(0).milliseconds(0);
            assert.equal(m.calendar(),       m.format('[à¤à¤à¤à¥] dddd[,] LT'),  'Today - ' + i + ' days beginning of day');
            m.hours(23).minutes(59).seconds(59).milliseconds(999);
            assert.equal(m.calendar(),       m.format('[à¤à¤à¤à¥] dddd[,] LT'),  'Today - ' + i + ' days end of day');
        }
    });

    test('calendar all else', function (assert) {
        var weeksAgo = moment().subtract({w: 1}),
            weeksFromNow = moment().add({w: 1});

        assert.equal(weeksAgo.calendar(),       weeksAgo.format('L'),  '1 week ago');
        assert.equal(weeksFromNow.calendar(),   weeksFromNow.format('L'),  'in 1 week');

        weeksAgo = moment().subtract({w: 2});
        weeksFromNow = moment().add({w: 2});

        assert.equal(weeksAgo.calendar(),       weeksAgo.format('L'),  '2 weeks ago');
        assert.equal(weeksFromNow.calendar(),   weeksFromNow.format('L'),  'in 2 weeks');
    });

    test('meridiem', function (assert) {
        assert.equal(moment([2011, 2, 23,  2, 30]).format('a'), 'à¤°à¤¾à¤¤à¤¿', 'before dawn');
        assert.equal(moment([2011, 2, 23,  9, 30]).format('a'), 'à¤¬à¤¿à¤¹à¤¾à¤¨', 'morning');
        assert.equal(moment([2011, 2, 23, 14, 30]).format('a'), 'à¤¦à¤¿à¤à¤à¤¸à¥', 'during day');
        assert.equal(moment([2011, 2, 23, 17, 30]).format('a'), 'à¤¸à¤¾à¤à¤', 'evening');
        assert.equal(moment([2011, 2, 23, 19, 30]).format('a'), 'à¤¸à¤¾à¤à¤', 'late evening');
        assert.equal(moment([2011, 2, 23, 21, 20]).format('a'), 'à¤°à¤¾à¤¤à¤¿', 'night');

        assert.equal(moment([2011, 2, 23,  2, 30]).format('A'), 'à¤°à¤¾à¤¤à¤¿', 'before dawn');
        assert.equal(moment([2011, 2, 23,  9, 30]).format('A'), 'à¤¬à¤¿à¤¹à¤¾à¤¨', 'morning');
        assert.equal(moment([2011, 2, 23, 14, 30]).format('A'), 'à¤¦à¤¿à¤à¤à¤¸à¥', 'during day');
        assert.equal(moment([2011, 2, 23, 17, 30]).format('A'), 'à¤¸à¤¾à¤à¤', 'evening');
        assert.equal(moment([2011, 2, 23, 19, 30]).format('A'), 'à¤¸à¤¾à¤à¤', 'late evening');
        assert.equal(moment([2011, 2, 23, 21, 20]).format('A'), 'à¤°à¤¾à¤¤à¤¿', 'night');
    });

    test('weeks year starting sunday formatted', function (assert) {
        assert.equal(moment([2011, 11, 26]).format('w ww wo'), 'à¥«à¥© à¥«à¥© à¥«à¥©', 'Dec 26 2011 should be week 53');
        assert.equal(moment([2012,  0,  1]).format('w ww wo'), 'à¥§ à¥¦à¥§ à¥§', 'Jan  1 2012 should be week 1');
        assert.equal(moment([2012,  0,  2]).format('w ww wo'), 'à¥§ à¥¦à¥§ à¥§', 'Jan  2 2012 should be week 1');
        assert.equal(moment([2012,  0,  8]).format('w ww wo'), 'à¥¨ à¥¦à¥¨ à¥¨', 'Jan  8 2012 should be week 2');
        assert.equal(moment([2012,  0,  9]).format('w ww wo'), 'à¥¨ à¥¦à¥¨ à¥¨', 'Jan  9 2012 should be week 2');
    });

}));

;(function (global, factory) {
   typeof exports === 'object' && typeof module !== 'undefined'
       && typeof require === 'function' ? factory(require('../../moment')) :
   typeof define === 'function' && define.amd ? define(['../../moment'], factory) :
   factory(global.moment)
}(this, function (moment) { 'use strict';

    function each(array, callback) {
        var i;
        for (i = 0; i < array.length; i++) {
            callback(array[i], i, array);
        }
    }

    function objectKeys(obj) {
        if (Object.keys) {
            return Object.keys(obj);
        } else {
            // IE8
            var res = [], i;
            for (i in obj) {
                if (obj.hasOwnProperty(i)) {
                    res.push(i);
                }
            }
            return res;
        }
    }

    // Pick the first defined of two or three arguments.
    function defaults(a, b, c) {
        if (a != null) {
            return a;
        }
        if (b != null) {
            return b;
        }
        return c;
    }

    function defineCommonLocaleTests(locale, options) {
        test('lenient ordinal parsing', function (assert) {
            var i, ordinalStr, testMoment;
            for (i = 1; i <= 31; ++i) {
                ordinalStr = moment([2014, 0, i]).format('YYYY MM Do');
                testMoment = moment(ordinalStr, 'YYYY MM Do');
                assert.equal(testMoment.year(), 2014,
                        'lenient ordinal parsing ' + i + ' year check');
                assert.equal(testMoment.month(), 0,
                        'lenient ordinal parsing ' + i + ' month check');
                assert.equal(testMoment.date(), i,
                        'lenient ordinal parsing ' + i + ' date check');
            }
        });

        test('lenient ordinal parsing of number', function (assert) {
            var i, testMoment;
            for (i = 1; i <= 31; ++i) {
                testMoment = moment('2014 01 ' + i, 'YYYY MM Do');
                assert.equal(testMoment.year(), 2014,
                        'lenient ordinal parsing of number ' + i + ' year check');
                assert.equal(testMoment.month(), 0,
                        'lenient ordinal parsing of number ' + i + ' month check');
                assert.equal(testMoment.date(), i,
                        'lenient ordinal parsing of number ' + i + ' date check');
            }
        });

        test('strict ordinal parsing', function (assert) {
            var i, ordinalStr, testMoment;
            for (i = 1; i <= 31; ++i) {
                ordinalStr = moment([2014, 0, i]).format('YYYY MM Do');
                testMoment = moment(ordinalStr, 'YYYY MM Do', true);
                assert.ok(testMoment.isValid(), 'strict ordinal parsing ' + i);
            }
        });

        test('meridiem invariant', function (assert) {
            var h, m, t1, t2;
            for (h = 0; h < 24; ++h) {
                for (m = 0; m < 60; m += 15) {
                    t1 = moment.utc([2000, 0, 1, h, m]);
                    t2 = moment.utc(t1.format('A h:mm'), 'A h:mm');
                    assert.equal(t2.format('HH:mm'), t1.format('HH:mm'),
                            'meridiem at ' + t1.format('HH:mm'));
                }
            }
        });

        test('date format correctness', function (assert) {
            var data, tokens;
            data = moment.localeData()._longDateFormat;
            tokens = objectKeys(data);
            each(tokens, function (srchToken) {
                // Check each format string to make sure it does not contain any
                // tokens that need to be expanded.
                each(tokens, function (baseToken) {
                    // strip escaped sequences
                    var format = data[baseToken].replace(/(\[[^\]]*\])/g, '');
                    assert.equal(false, !!~format.indexOf(srchToken),
                            'contains ' + srchToken + ' in ' + baseToken);
                });
            });
        });

        test('month parsing correctness', function (assert) {
            var i, m;

            if (locale === 'tr') {
                // I can't fix it :(
                expect(0);
                return;
            }
            function tester(format) {
                var r;
                r = moment(m.format(format), format);
                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format);
                r = moment(m.format(format).toLocaleUpperCase(), format);
                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' upper');
                r = moment(m.format(format).toLocaleLowerCase(), format);
                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' lower');

                r = moment(m.format(format), format, true);
                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' strict');
                r = moment(m.format(format).toLocaleUpperCase(), format, true);
                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' upper strict');
                r = moment(m.format(format).toLocaleLowerCase(), format, true);
                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' lower strict');
            }

            for (i = 0; i < 12; ++i) {
                m = moment([2015, i, 15, 18]);
                tester('MMM');
                tester('MMM.');
                tester('MMMM');
                tester('MMMM.');
            }
        });

        test('weekday parsing correctness', function (assert) {
            var i, m;

            if (locale === 'tr' || locale === 'az') {
                // There is a lower-case letter (Ä±), that converted to upper then
                // lower changes to i
                expect(0);
                return;
            }
            function tester(format) {
                var r, baseMsg = 'weekday ' + m.weekday() + ' fmt ' + format;
                r = moment(m.format(format), format);
                assert.equal(r.weekday(), m.weekday(), baseMsg);
                r = moment(m.format(format).toLocaleUpperCase(), format);
                assert.equal(r.weekday(), m.weekday(), baseMsg + ' upper');
                r = moment(m.format(format).toLocaleLowerCase(), format);
                assert.equal(r.weekday(), m.weekday(), baseMsg + ' lower');

                r = moment(m.format(format), format, true);
                assert.equal(r.weekday(), m.weekday(), baseMsg + ' strict');
                r = moment(m.format(format).toLocaleUpperCase(), format, true);
                assert.equal(r.weekday(), m.weekday(), baseMsg + ' upper strict');
                r = moment(m.format(format).toLocaleLowerCase(), format, true);
                assert.equal(r.weekday(), m.weekday(), baseMsg + ' lower strict');
            }

            for (i = 0; i < 7; ++i) {
                m = moment.utc([2015, i, 15, 18]);
                tester('dd');
                tester('ddd');
                tester('dddd');
            }
        });
    }

    function setupDeprecationHandler(test, moment, scope) {
        test._expectedDeprecations = null;
        test._observedDeprecations = null;
        test._oldSupress = moment.suppressDeprecationWarnings;
        moment.suppressDeprecationWarnings = true;
        test.expectedDeprecations = function () {
            test._expectedDeprecations = arguments;
            test._observedDeprecations = [];
        };
        moment.deprecationHandler = function (name, msg) {
            var deprecationId = matchedDeprecation(name, msg, test._expectedDeprecations);
            if (deprecationId === -1) {
                throw new Error('Unexpected deprecation thrown name=' +
                        name + ' msg=' + msg);
            }
            test._observedDeprecations[deprecationId] = 1;
        };
    }

    function teardownDeprecationHandler(test, moment, scope) {
        moment.suppressDeprecationWarnings = test._oldSupress;

        if (test._expectedDeprecations != null) {
            var missedDeprecations = [];
            each(test._expectedDeprecations, function (deprecationPattern, id) {
                if (test._observedDeprecations[id] !== 1) {
                    missedDeprecations.push(deprecationPattern);
                }
            });
            if (missedDeprecations.length !== 0) {
                throw new Error('Expected deprecation warnings did not happen: ' +
                        missedDeprecations.join(' '));
            }
        }
    }

    function matchedDeprecation(name, msg, deprecations) {
        if (deprecations == null) {
            return -1;
        }
        for (var i = 0; i < deprecations.length; ++i) {
            if (name != null && name === deprecations[i]) {
                return i;
            }
            if (msg != null && msg.substring(0, deprecations[i].length) === deprecations[i]) {
                return i;
            }
        }
        return -1;
    }

    /*global QUnit:false*/

    var test = QUnit.test;

    var expect = QUnit.expect;

    function module (name, lifecycle) {
        QUnit.module(name, {
            setup : function () {
                moment.locale('en');
                moment.createFromInputFallback = function (config) {
                    throw new Error('input not handled by moment: ' + config._i);
                };
                setupDeprecationHandler(test, moment, 'core');
                if (lifecycle && lifecycle.setup) {
                    lifecycle.setup();
                }
            },
            teardown : function () {
                teardownDeprecationHandler(test, moment, 'core');
                if (lifecycle && lifecycle.teardown) {
                    lifecycle.teardown();
                }
            }
        });
    }

    function localeModule (name, lifecycle) {
        QUnit.module('locale:' + name, {
            setup : function () {
                moment.locale(name);
                moment.createFromInputFallback = function (config) {
                    throw new Error('input not handled by moment: ' + config._i);
                };
                setupDeprecationHandler(test, moment, 'locale');
                if (lifecycle && lifecycle.setup) {
                    lifecycle.setup();
                }
            },
            teardown : function () {
                moment.locale('en');
                teardownDeprecationHandler(test, moment, 'locale');
                if (lifecycle && lifecycle.teardown) {
                    lifecycle.teardown();
                }
            }
        });
        defineCommonLocaleTests(name, -1, -1);
    }

    localeModule('nl');

    test('parse', function (assert) {
        var tests = 'januari jan._februari feb._maart mrt._april apr._mei mei._juni jun._juli jul._augustus aug._september sep._oktober okt._november nov._december dec.'.split('_'), i;
        function equalTest(input, mmm, i) {
            assert.equal(moment(input, mmm).month(), i, input + ' should be month ' + (i + 1));
        }
        for (i = 0; i < 12; i++) {
            tests[i] = tests[i].split(' ');
            equalTest(tests[i][0], 'MMM', i);
            equalTest(tests[i][1], 'MMM', i);
            equalTest(tests[i][0], 'MMMM', i);
            equalTest(tests[i][1], 'MMMM', i);
            equalTest(tests[i][0].toLocaleLowerCase(), 'MMMM', i);
            equalTest(tests[i][1].toLocaleLowerCase(), 'MMMM', i);
            equalTest(tests[i][0].toLocaleUpperCase(), 'MMMM', i);
            equalTest(tests[i][1].toLocaleUpperCase(), 'MMMM', i);
        }
    });

    test('format', function (assert) {
        var a = [
                ['dddd, MMMM Do YYYY, HH:mm:ss',       'zondag, februari 14de 2010, 15:25:50'],
                ['ddd, HH',                            'zo., 15'],
                ['M Mo MM MMMM MMM',                   '2 2de 02 februari feb.'],
                ['YYYY YY',                            '2010 10'],
                ['D Do DD',                            '14 14de 14'],
                ['d do dddd ddd dd',                   '0 0de zondag zo. Zo'],
                ['DDD DDDo DDDD',                      '45 45ste 045'],
                ['w wo ww',                            '6 6de 06'],
                ['h hh',                               '3 03'],
                ['H HH',                               '15 15'],
                ['m mm',                               '25 25'],
                ['s ss',                               '50 50'],
                ['a A',                                'pm PM'],
                ['[the] DDDo [day of the year]',       'the 45ste day of the year'],
                ['LTS',                                '15:25:50'],
                ['L',                                  '14-02-2010'],
                ['LL',                                 '14 februari 2010'],
                ['LLL',                                '14 februari 2010 15:25'],
                ['LLLL',                               'zondag 14 februari 2010 15:25'],
                ['l',                                  '14-2-2010'],
                ['ll',                                 '14 feb. 2010'],
                ['lll',                                '14 feb. 2010 15:25'],
                ['llll',                               'zo. 14 feb. 2010 15:25']
            ],
            b = moment(new Date(2010, 1, 14, 15, 25, 50, 125)),
            i;
        for (i = 0; i < a.length; i++) {
            assert.equal(b.format(a[i][0]), a[i][1], a[i][0] + ' ---> ' + a[i][1]);
        }
    });

    test('format ordinal', function (assert) {
        assert.equal(moment([2011, 0, 1]).format('DDDo'), '1ste', '1ste');
        assert.equal(moment([2011, 0, 2]).format('DDDo'), '2de', '2de');
        assert.equal(moment([2011, 0, 3]).format('DDDo'), '3de', '3de');
        assert.equal(moment([2011, 0, 4]).format('DDDo'), '4de', '4de');
        assert.equal(moment([2011, 0, 5]).format('DDDo'), '5de', '5de');
        assert.equal(moment([2011, 0, 6]).format('DDDo'), '6de', '6de');
        assert.equal(moment([2011, 0, 7]).format('DDDo'), '7de', '7de');
        assert.equal(moment([2011, 0, 8]).format('DDDo'), '8ste', '8ste');
        assert.equal(moment([2011, 0, 9]).format('DDDo'), '9de', '9de');
        assert.equal(moment([2011, 0, 10]).format('DDDo'), '10de', '10de');

        assert.equal(moment([2011, 0, 11]).format('DDDo'), '11de', '11de');
        assert.equal(moment([2011, 0, 12]).format('DDDo'), '12de', '12de');
        assert.equal(moment([2011, 0, 13]).format('DDDo'), '13de', '13de');
        assert.equal(moment([2011, 0, 14]).format('DDDo'), '14de', '14de');
        assert.equal(moment([2011, 0, 15]).format('DDDo'), '15de', '15de');
        assert.equal(moment([2011, 0, 16]).format('DDDo'), '16de', '16de');
        assert.equal(moment([2011, 0, 17]).format('DDDo'), '17de', '17de');
        assert.equal(moment([2011, 0, 18]).format('DDDo'), '18de', '18de');
        assert.equal(moment([2011, 0, 19]).format('DDDo'), '19de', '19de');
        assert.equal(moment([2011, 0, 20]).format('DDDo'), '20ste', '20ste');

        assert.equal(moment([2011, 0, 21]).format('DDDo'), '21ste', '21ste');
        assert.equal(moment([2011, 0, 22]).format('DDDo'), '22ste', '22ste');
        assert.equal(moment([2011, 0, 23]).format('DDDo'), '23ste', '23ste');
        assert.equal(moment([2011, 0, 24]).format('DDDo'), '24ste', '24ste');
        assert.equal(moment([2011, 0, 25]).format('DDDo'), '25ste', '25ste');
        assert.equal(moment([2011, 0, 26]).format('DDDo'), '26ste', '26ste');
        assert.equal(moment([2011, 0, 27]).format('DDDo'), '27ste', '27ste');
        assert.equal(moment([2011, 0, 28]).format('DDDo'), '28ste', '28ste');
        assert.equal(moment([2011, 0, 29]).format('DDDo'), '29ste', '29ste');
        assert.equal(moment([2011, 0, 30]).format('DDDo'), '30ste', '30ste');

        assert.equal(moment([2011, 0, 31]).format('DDDo'), '31ste', '31ste');
    });

    test('format month', function (assert) {
        var expected = 'januari jan._februari feb._maart mrt._april apr._mei mei_juni jun._juli jul._augustus aug._september sep._oktober okt._november nov._december dec.'.split('_'), i;
        for (i = 0; i < expected.length; i++) {
            assert.equal(moment([2011, i, 1]).format('MMMM MMM'), expected[i], expected[i]);
        }
    });

    test('format week', function (assert) {
        var expected = 'zondag zo. Zo_maandag ma. Ma_dinsdag di. Di_woensdag wo. Wo_donderdag do. Do_vrijdag vr. Vr_zaterdag za. Za'.split('_'), i;
        for (i = 0; i < expected.length; i++) {
            assert.equal(moment([2011, 0, 2 + i]).format('dddd ddd dd'), expected[i], expected[i]);
        }
    });

    test('from', function (assert) {
        var start = moment([2007, 1, 28]);
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 44}), true),  'een paar seconden', '44 seconds = a few seconds');
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 45}), true),  'Ã©Ã©n minuut',      '45 seconds = a minute');
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 89}), true),  'Ã©Ã©n minuut',      '89 seconds = a minute');
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 90}), true),  '2 minuten',     '90 seconds = 2 minutes');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 44}), true),  '44 minuten',    '44 minutes = 44 minutes');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 45}), true),  'Ã©Ã©n uur',       '45 minutes = an hour');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 89}), true),  'Ã©Ã©n uur',       '89 minutes = an hour');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 90}), true),  '2 uur',       '90 minutes = 2 hours');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 5}), true),   '5 uur',       '5 hours = 5 hours');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 21}), true),  '21 uur',      '21 hours = 21 hours');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 22}), true),  'Ã©Ã©n dag',         '22 hours = a day');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 35}), true),  'Ã©Ã©n dag',         '35 hours = a day');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 36}), true),  '2 dagen',        '36 hours = 2 days');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 1}), true),   'Ã©Ã©n dag',         '1 day = a day');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 5}), true),   '5 dagen',        '5 days = 5 days');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 25}), true),  '25 dagen',       '25 days = 25 days');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 26}), true),  'Ã©Ã©n maand',       '26 days = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 30}), true),  'Ã©Ã©n maand',       '30 days = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 43}), true),  'Ã©Ã©n maand',       '43 days = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 46}), true),  '2 maanden',      '46 days = 2 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 74}), true),  '2 maanden',      '75 days = 2 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 76}), true),  '3 maanden',      '76 days = 3 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({M: 1}), true),   'Ã©Ã©n maand',       '1 month = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({M: 5}), true),   '5 maanden',      '5 months = 5 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 345}), true), 'Ã©Ã©n jaar',        '345 days = a year');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 548}), true), '2 jaar',       '548 days = 2 years');
        assert.equal(start.from(moment([2007, 1, 28]).add({y: 1}), true),   'Ã©Ã©n jaar',        '1 year = a year');
        assert.equal(start.from(moment([2007, 1, 28]).add({y: 5}), true),   '5 jaar',       '5 years = 5 years');
    });

    test('suffix', function (assert) {
        assert.equal(moment(30000).from(0), 'over een paar seconden',  'prefix');
        assert.equal(moment(0).from(30000), 'een paar seconden geleden', 'suffix');
    });

    test('now from now', function (assert) {
        assert.equal(moment().fromNow(), 'een paar seconden geleden',  'now from now should display as in the past');
    });

    test('fromNow', function (assert) {
        assert.equal(moment().add({s: 30}).fromNow(), 'over een paar seconden', 'in a few seconds');
        assert.equal(moment().add({d: 5}).fromNow(), 'over 5 dagen', 'in 5 days');
    });

    test('calendar day', function (assert) {
        var a = moment().hours(12).minutes(0).seconds(0);

        assert.equal(moment(a).calendar(),                   'vandaag om 12:00',   'today at the same time');
        assert.equal(moment(a).add({m: 25}).calendar(),      'vandaag om 12:25',   'Now plus 25 min');
        assert.equal(moment(a).add({h: 1}).calendar(),       'vandaag om 13:00',   'Now plus 1 hour');
        assert.equal(moment(a).add({d: 1}).calendar(),       'morgen om 12:00',    'tomorrow at the same time');
        assert.equal(moment(a).subtract({h: 1}).calendar(),  'vandaag om 11:00',   'Now minus 1 hour');
        assert.equal(moment(a).subtract({d: 1}).calendar(),  'gisteren om 12:00',  'yesterday at the same time');
    });

    test('calendar next week', function (assert) {
        var i, m;
        for (i = 2; i < 7; i++) {
            m = moment().add({d: i});
            assert.equal(m.calendar(),       m.format('dddd [om] LT'),  'Today + ' + i + ' days current time');
            m.hours(0).minutes(0).seconds(0).milliseconds(0);
            assert.equal(m.calendar(),       m.format('dddd [om] LT'),  'Today + ' + i + ' days beginning of day');
            m.hours(23).minutes(59).seconds(59).milliseconds(999);
            assert.equal(m.calendar(),       m.format('dddd [om] LT'),  'Today + ' + i + ' days end of day');
        }
    });

    test('calendar last week', function (assert) {
        var i, m;
        for (i = 2; i < 7; i++) {
            m = moment().subtract({d: i});
            assert.equal(m.calendar(),       m.format('[afgelopen] dddd [om] LT'),  'Today - ' + i + ' days current time');
            m.hours(0).minutes(0).seconds(0).milliseconds(0);
            assert.equal(m.calendar(),       m.format('[afgelopen] dddd [om] LT'),  'Today - ' + i + ' days beginning of day');
            m.hours(23).minutes(59).seconds(59).milliseconds(999);
            assert.equal(m.calendar(),       m.format('[afgelopen] dddd [om] LT'),  'Today - ' + i + ' days end of day');
        }
    });

    test('calendar all else', function (assert) {
        var weeksAgo = moment().subtract({w: 1}),
            weeksFromNow = moment().add({w: 1});

        assert.equal(weeksAgo.calendar(),       weeksAgo.format('L'),  '1 week ago');
        assert.equal(weeksFromNow.calendar(),   weeksFromNow.format('L'),  'in 1 week');

        weeksAgo = moment().subtract({w: 2});
        weeksFromNow = moment().add({w: 2});

        assert.equal(weeksAgo.calendar(),       weeksAgo.format('L'),  '2 weeks ago');
        assert.equal(weeksFromNow.calendar(),   weeksFromNow.format('L'),  'in 2 weeks');
    });

    test('month abbreviation', function (assert) {
        assert.equal(moment([2012, 5, 23]).format('D-MMM-YYYY'), '23-jun-2012', 'format month abbreviation surrounded by dashes should not include a dot');
        assert.equal(moment([2012, 5, 23]).format('D MMM YYYY'), '23 jun. 2012', 'format month abbreviation not surrounded by dashes should include a dot');
    });

    test('weeks year starting sunday formatted', function (assert) {
        assert.equal(moment([2012, 0,  1]).format('w ww wo'), '52 52 52ste', 'Jan  1 2012 should be week 52');
        assert.equal(moment([2012, 0,  2]).format('w ww wo'),   '1 01 1ste', 'Jan  2 2012 should be week 1');
        assert.equal(moment([2012, 0,  8]).format('w ww wo'),   '1 01 1ste', 'Jan  8 2012 should be week 1');
        assert.equal(moment([2012, 0,  9]).format('w ww wo'),    '2 02 2de', 'Jan  9 2012 should be week 2');
        assert.equal(moment([2012, 0, 15]).format('w ww wo'),    '2 02 2de', 'Jan 15 2012 should be week 2');
    });

}));

;(function (global, factory) {
   typeof exports === 'object' && typeof module !== 'undefined'
       && typeof require === 'function' ? factory(require('../../moment')) :
   typeof define === 'function' && define.amd ? define(['../../moment'], factory) :
   factory(global.moment)
}(this, function (moment) { 'use strict';

    function each(array, callback) {
        var i;
        for (i = 0; i < array.length; i++) {
            callback(array[i], i, array);
        }
    }

    function objectKeys(obj) {
        if (Object.keys) {
            return Object.keys(obj);
        } else {
            // IE8
            var res = [], i;
            for (i in obj) {
                if (obj.hasOwnProperty(i)) {
                    res.push(i);
                }
            }
            return res;
        }
    }

    // Pick the first defined of two or three arguments.
    function defaults(a, b, c) {
        if (a != null) {
            return a;
        }
        if (b != null) {
            return b;
        }
        return c;
    }

    function defineCommonLocaleTests(locale, options) {
        test('lenient ordinal parsing', function (assert) {
            var i, ordinalStr, testMoment;
            for (i = 1; i <= 31; ++i) {
                ordinalStr = moment([2014, 0, i]).format('YYYY MM Do');
                testMoment = moment(ordinalStr, 'YYYY MM Do');
                assert.equal(testMoment.year(), 2014,
                        'lenient ordinal parsing ' + i + ' year check');
                assert.equal(testMoment.month(), 0,
                        'lenient ordinal parsing ' + i + ' month check');
                assert.equal(testMoment.date(), i,
                        'lenient ordinal parsing ' + i + ' date check');
            }
        });

        test('lenient ordinal parsing of number', function (assert) {
            var i, testMoment;
            for (i = 1; i <= 31; ++i) {
                testMoment = moment('2014 01 ' + i, 'YYYY MM Do');
                assert.equal(testMoment.year(), 2014,
                        'lenient ordinal parsing of number ' + i + ' year check');
                assert.equal(testMoment.month(), 0,
                        'lenient ordinal parsing of number ' + i + ' month check');
                assert.equal(testMoment.date(), i,
                        'lenient ordinal parsing of number ' + i + ' date check');
            }
        });

        test('strict ordinal parsing', function (assert) {
            var i, ordinalStr, testMoment;
            for (i = 1; i <= 31; ++i) {
                ordinalStr = moment([2014, 0, i]).format('YYYY MM Do');
                testMoment = moment(ordinalStr, 'YYYY MM Do', true);
                assert.ok(testMoment.isValid(), 'strict ordinal parsing ' + i);
            }
        });

        test('meridiem invariant', function (assert) {
            var h, m, t1, t2;
            for (h = 0; h < 24; ++h) {
                for (m = 0; m < 60; m += 15) {
                    t1 = moment.utc([2000, 0, 1, h, m]);
                    t2 = moment.utc(t1.format('A h:mm'), 'A h:mm');
                    assert.equal(t2.format('HH:mm'), t1.format('HH:mm'),
                            'meridiem at ' + t1.format('HH:mm'));
                }
            }
        });

        test('date format correctness', function (assert) {
            var data, tokens;
            data = moment.localeData()._longDateFormat;
            tokens = objectKeys(data);
            each(tokens, function (srchToken) {
                // Check each format string to make sure it does not contain any
                // tokens that need to be expanded.
                each(tokens, function (baseToken) {
                    // strip escaped sequences
                    var format = data[baseToken].replace(/(\[[^\]]*\])/g, '');
                    assert.equal(false, !!~format.indexOf(srchToken),
                            'contains ' + srchToken + ' in ' + baseToken);
                });
            });
        });

        test('month parsing correctness', function (assert) {
            var i, m;

            if (locale === 'tr') {
                // I can't fix it :(
                expect(0);
                return;
            }
            function tester(format) {
                var r;
                r = moment(m.format(format), format);
                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format);
                r = moment(m.format(format).toLocaleUpperCase(), format);
                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' upper');
                r = moment(m.format(format).toLocaleLowerCase(), format);
                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' lower');

                r = moment(m.format(format), format, true);
                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' strict');
                r = moment(m.format(format).toLocaleUpperCase(), format, true);
                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' upper strict');
                r = moment(m.format(format).toLocaleLowerCase(), format, true);
                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' lower strict');
            }

            for (i = 0; i < 12; ++i) {
                m = moment([2015, i, 15, 18]);
                tester('MMM');
                tester('MMM.');
                tester('MMMM');
                tester('MMMM.');
            }
        });

        test('weekday parsing correctness', function (assert) {
            var i, m;

            if (locale === 'tr' || locale === 'az') {
                // There is a lower-case letter (Ä±), that converted to upper then
                // lower changes to i
                expect(0);
                return;
            }
            function tester(format) {
                var r, baseMsg = 'weekday ' + m.weekday() + ' fmt ' + format;
                r = moment(m.format(format), format);
                assert.equal(r.weekday(), m.weekday(), baseMsg);
                r = moment(m.format(format).toLocaleUpperCase(), format);
                assert.equal(r.weekday(), m.weekday(), baseMsg + ' upper');
                r = moment(m.format(format).toLocaleLowerCase(), format);
                assert.equal(r.weekday(), m.weekday(), baseMsg + ' lower');

                r = moment(m.format(format), format, true);
                assert.equal(r.weekday(), m.weekday(), baseMsg + ' strict');
                r = moment(m.format(format).toLocaleUpperCase(), format, true);
                assert.equal(r.weekday(), m.weekday(), baseMsg + ' upper strict');
                r = moment(m.format(format).toLocaleLowerCase(), format, true);
                assert.equal(r.weekday(), m.weekday(), baseMsg + ' lower strict');
            }

            for (i = 0; i < 7; ++i) {
                m = moment.utc([2015, i, 15, 18]);
                tester('dd');
                tester('ddd');
                tester('dddd');
            }
        });
    }

    function setupDeprecationHandler(test, moment, scope) {
        test._expectedDeprecations = null;
        test._observedDeprecations = null;
        test._oldSupress = moment.suppressDeprecationWarnings;
        moment.suppressDeprecationWarnings = true;
        test.expectedDeprecations = function () {
            test._expectedDeprecations = arguments;
            test._observedDeprecations = [];
        };
        moment.deprecationHandler = function (name, msg) {
            var deprecationId = matchedDeprecation(name, msg, test._expectedDeprecations);
            if (deprecationId === -1) {
                throw new Error('Unexpected deprecation thrown name=' +
                        name + ' msg=' + msg);
            }
            test._observedDeprecations[deprecationId] = 1;
        };
    }

    function teardownDeprecationHandler(test, moment, scope) {
        moment.suppressDeprecationWarnings = test._oldSupress;

        if (test._expectedDeprecations != null) {
            var missedDeprecations = [];
            each(test._expectedDeprecations, function (deprecationPattern, id) {
                if (test._observedDeprecations[id] !== 1) {
                    missedDeprecations.push(deprecationPattern);
                }
            });
            if (missedDeprecations.length !== 0) {
                throw new Error('Expected deprecation warnings did not happen: ' +
                        missedDeprecations.join(' '));
            }
        }
    }

    function matchedDeprecation(name, msg, deprecations) {
        if (deprecations == null) {
            return -1;
        }
        for (var i = 0; i < deprecations.length; ++i) {
            if (name != null && name === deprecations[i]) {
                return i;
            }
            if (msg != null && msg.substring(0, deprecations[i].length) === deprecations[i]) {
                return i;
            }
        }
        return -1;
    }

    /*global QUnit:false*/

    var test = QUnit.test;

    var expect = QUnit.expect;

    function module (name, lifecycle) {
        QUnit.module(name, {
            setup : function () {
                moment.locale('en');
                moment.createFromInputFallback = function (config) {
                    throw new Error('input not handled by moment: ' + config._i);
                };
                setupDeprecationHandler(test, moment, 'core');
                if (lifecycle && lifecycle.setup) {
                    lifecycle.setup();
                }
            },
            teardown : function () {
                teardownDeprecationHandler(test, moment, 'core');
                if (lifecycle && lifecycle.teardown) {
                    lifecycle.teardown();
                }
            }
        });
    }

    function localeModule (name, lifecycle) {
        QUnit.module('locale:' + name, {
            setup : function () {
                moment.locale(name);
                moment.createFromInputFallback = function (config) {
                    throw new Error('input not handled by moment: ' + config._i);
                };
                setupDeprecationHandler(test, moment, 'locale');
                if (lifecycle && lifecycle.setup) {
                    lifecycle.setup();
                }
            },
            teardown : function () {
                moment.locale('en');
                teardownDeprecationHandler(test, moment, 'locale');
                if (lifecycle && lifecycle.teardown) {
                    lifecycle.teardown();
                }
            }
        });
        defineCommonLocaleTests(name, -1, -1);
    }

    localeModule('nn');

    test('parse', function (assert) {
        var tests = 'januar jan_februar feb_mars mar_april apr_mai mai_juni jun_juli jul_august aug_september sep_oktober okt_november nov_desember des'.split('_'), i;
        function equalTest(input, mmm, i) {
            assert.equal(moment(input, mmm).month(), i, input + ' should be month ' + (i + 1));
        }
        for (i = 0; i < 12; i++) {
            tests[i] = tests[i].split(' ');
            equalTest(tests[i][0], 'MMM', i);
            equalTest(tests[i][1], 'MMM', i);
            equalTest(tests[i][0], 'MMMM', i);
            equalTest(tests[i][1], 'MMMM', i);
            equalTest(tests[i][0].toLocaleLowerCase(), 'MMMM', i);
            equalTest(tests[i][1].toLocaleLowerCase(), 'MMMM', i);
            equalTest(tests[i][0].toLocaleUpperCase(), 'MMMM', i);
            equalTest(tests[i][1].toLocaleUpperCase(), 'MMMM', i);
        }
    });

    test('format', function (assert) {
        var a = [
                ['dddd, MMMM Do YYYY, h:mm:ss a',      'sundag, februar 14. 2010, 3:25:50 pm'],
                ['ddd, hA',                            'sun, 3PM'],
                ['M Mo MM MMMM MMM',                   '2 2. 02 februar feb'],
                ['YYYY YY',                            '2010 10'],
                ['D Do DD',                            '14 14. 14'],
                ['d do dddd ddd dd',                   '0 0. sundag sun su'],
                ['DDD DDDo DDDD',                      '45 45. 045'],
                ['w wo ww',                            '6 6. 06'],
                ['h hh',                               '3 03'],
                ['H HH',                               '15 15'],
                ['m mm',                               '25 25'],
                ['s ss',                               '50 50'],
                ['a A',                                'pm PM'],
                ['[the] DDDo [day of the year]',       'the 45. day of the year'],
                ['LTS',                                '15:25:50'],
                ['L',                                  '14.02.2010'],
                ['LL',                                 '14. februar 2010'],
                ['LLL',                                '14. februar 2010 kl. 15:25'],
                ['LLLL',                               'sundag 14. februar 2010 kl. 15:25'],
                ['l',                                  '14.2.2010'],
                ['ll',                                 '14. feb 2010'],
                ['lll',                                '14. feb 2010 kl. 15:25'],
                ['llll',                               'sun 14. feb 2010 kl. 15:25']
            ],
            b = moment(new Date(2010, 1, 14, 15, 25, 50, 125)),
            i;
        for (i = 0; i < a.length; i++) {
            assert.equal(b.format(a[i][0]), a[i][1], a[i][0] + ' ---> ' + a[i][1]);
        }
    });

    test('format ordinal', function (assert) {
        assert.equal(moment([2011, 0, 1]).format('DDDo'), '1.', '1.');
        assert.equal(moment([2011, 0, 2]).format('DDDo'), '2.', '2.');
        assert.equal(moment([2011, 0, 3]).format('DDDo'), '3.', '3.');
        assert.equal(moment([2011, 0, 4]).format('DDDo'), '4.', '4.');
        assert.equal(moment([2011, 0, 5]).format('DDDo'), '5.', '5.');
        assert.equal(moment([2011, 0, 6]).format('DDDo'), '6.', '6.');
        assert.equal(moment([2011, 0, 7]).format('DDDo'), '7.', '7.');
        assert.equal(moment([2011, 0, 8]).format('DDDo'), '8.', '8.');
        assert.equal(moment([2011, 0, 9]).format('DDDo'), '9.', '9.');
        assert.equal(moment([2011, 0, 10]).format('DDDo'), '10.', '10.');

        assert.equal(moment([2011, 0, 11]).format('DDDo'), '11.', '11.');
        assert.equal(moment([2011, 0, 12]).format('DDDo'), '12.', '12.');
        assert.equal(moment([2011, 0, 13]).format('DDDo'), '13.', '13.');
        assert.equal(moment([2011, 0, 14]).format('DDDo'), '14.', '14.');
        assert.equal(moment([2011, 0, 15]).format('DDDo'), '15.', '15.');
        assert.equal(moment([2011, 0, 16]).format('DDDo'), '16.', '16.');
        assert.equal(moment([2011, 0, 17]).format('DDDo'), '17.', '17.');
        assert.equal(moment([2011, 0, 18]).format('DDDo'), '18.', '18.');
        assert.equal(moment([2011, 0, 19]).format('DDDo'), '19.', '19.');
        assert.equal(moment([2011, 0, 20]).format('DDDo'), '20.', '20.');

        assert.equal(moment([2011, 0, 21]).format('DDDo'), '21.', '21.');
        assert.equal(moment([2011, 0, 22]).format('DDDo'), '22.', '22.');
        assert.equal(moment([2011, 0, 23]).format('DDDo'), '23.', '23.');
        assert.equal(moment([2011, 0, 24]).format('DDDo'), '24.', '24.');
        assert.equal(moment([2011, 0, 25]).format('DDDo'), '25.', '25.');
        assert.equal(moment([2011, 0, 26]).format('DDDo'), '26.', '26.');
        assert.equal(moment([2011, 0, 27]).format('DDDo'), '27.', '27.');
        assert.equal(moment([2011, 0, 28]).format('DDDo'), '28.', '28.');
        assert.equal(moment([2011, 0, 29]).format('DDDo'), '29.', '29.');
        assert.equal(moment([2011, 0, 30]).format('DDDo'), '30.', '30.');

        assert.equal(moment([2011, 0, 31]).format('DDDo'), '31.', '31.');
    });

    test('format month', function (assert) {
        var expected = 'januar jan_februar feb_mars mar_april apr_mai mai_juni jun_juli jul_august aug_september sep_oktober okt_november nov_desember des'.split('_'), i;
        for (i = 0; i < expected.length; i++) {
            assert.equal(moment([2011, i, 1]).format('MMMM MMM'), expected[i], expected[i]);
        }
    });

    test('format week', function (assert) {
        var expected = 'sundag sun su_mÃ¥ndag mÃ¥n mÃ¥_tysdag tys ty_onsdag ons on_torsdag tor to_fredag fre fr_laurdag lau lÃ¸'.split('_'), i;
        for (i = 0; i < expected.length; i++) {
            assert.equal(moment([2011, 0, 2 + i]).format('dddd ddd dd'), expected[i], expected[i]);
        }
    });

    test('from', function (assert) {
        var start = moment([2007, 1, 28]);
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 44}), true),  'nokre sekund', '44 sekunder = a few seconds');
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 45}), true),  'eit minutt',   '45 seconds = a minute');
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 89}), true),  'eit minutt',   '89 seconds = a minute');
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 90}), true),  '2 minutt',     '90 seconds = 2 minutes');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 44}), true),  '44 minutt',    '44 minutes = 44 minutes');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 45}), true),  'ein time',     '45 minutes = an hour');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 89}), true),  'ein time',     '89 minutes = an hour');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 90}), true),  '2 timar',      '90 minutes = 2 hours');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 5}), true),   '5 timar',      '5 hours = 5 hours');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 21}), true),  '21 timar',     '21 hours = 21 hours');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 22}), true),  'ein dag',      '22 hours = a day');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 35}), true),  'ein dag',      '35 hours = a day');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 36}), true),  '2 dagar',      '36 hours = 2 days');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 1}), true),   'ein dag',      '1 day = a day');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 5}), true),   '5 dagar',      '5 days = 5 days');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 25}), true),  '25 dagar',     '25 days = 25 days');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 26}), true),  'ein mÃ¥nad',    '26 days = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 30}), true),  'ein mÃ¥nad',    '30 days = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 43}), true),  'ein mÃ¥nad',    '43 days = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 46}), true),  '2 mÃ¥nader',    '46 days = 2 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 74}), true),  '2 mÃ¥nader',    '75 days = 2 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 76}), true),  '3 mÃ¥nader',    '76 days = 3 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({M: 1}), true),   'ein mÃ¥nad',    '1 month = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({M: 5}), true),   '5 mÃ¥nader',    '5 months = 5 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 345}), true), 'eit Ã¥r',       '345 days = a year');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 548}), true), '2 Ã¥r',         '548 days = 2 years');
        assert.equal(start.from(moment([2007, 1, 28]).add({y: 1}), true),   'eit Ã¥r',       '1 year = a year');
        assert.equal(start.from(moment([2007, 1, 28]).add({y: 5}), true),   '5 Ã¥r',         '5 years = 5 years');
    });

    test('suffix', function (assert) {
        assert.equal(moment(30000).from(0), 'om nokre sekund',  'prefix');
        assert.equal(moment(0).from(30000), 'nokre sekund sidan', 'suffix');
    });

    test('now from now', function (assert) {
        assert.equal(moment().fromNow(), 'nokre sekund sidan',  'now from now should display as in the past');
    });

    test('fromNow', function (assert) {
        assert.equal(moment().add({s: 30}).fromNow(), 'om nokre sekund', 'in a few seconds');
        assert.equal(moment().add({d: 5}).fromNow(), 'om 5 dagar', 'in 5 days');
    });

    test('calendar day', function (assert) {
        var a = moment().hours(12).minutes(0).seconds(0);

        assert.equal(moment(a).calendar(),                   'I dag klokka 12:00',     'today at the same time');
        assert.equal(moment(a).add({m: 25}).calendar(),      'I dag klokka 12:25',     'Now plus 25 min');
        assert.equal(moment(a).add({h: 1}).calendar(),       'I dag klokka 13:00',     'Now plus 1 hour');
        assert.equal(moment(a).add({d: 1}).calendar(),       'I morgon klokka 12:00',  'tomorrow at the same time');
        assert.equal(moment(a).subtract({h: 1}).calendar(),  'I dag klokka 11:00',     'Now minus 1 hour');
        assert.equal(moment(a).subtract({d: 1}).calendar(),  'I gÃ¥r klokka 12:00',     'yesterday at the same time');
    });

    test('calendar next week', function (assert) {
        var i, m;
        for (i = 2; i < 7; i++) {
            m = moment().add({d: i});
            assert.equal(m.calendar(),       m.format('dddd [klokka] LT'),  'Today + ' + i + ' days current time');
            m.hours(0).minutes(0).seconds(0).milliseconds(0);
            assert.equal(m.calendar(),       m.format('dddd [klokka] LT'),  'Today + ' + i + ' days beginning of day');
            m.hours(23).minutes(59).seconds(59).milliseconds(999);
            assert.equal(m.calendar(),       m.format('dddd [klokka] LT'),  'Today + ' + i + ' days end of day');
        }
    });

    test('calendar last week', function (assert) {
        var i, m;
        for (i = 2; i < 7; i++) {
            m = moment().subtract({d: i});
            assert.equal(m.calendar(),       m.format('[FÃ¸regÃ¥ande] dddd [klokka] LT'),  'Today - ' + i + ' days current time');
            m.hours(0).minutes(0).seconds(0).milliseconds(0);
            assert.equal(m.calendar(),       m.format('[FÃ¸regÃ¥ande] dddd [klokka] LT'),  'Today - ' + i + ' days beginning of day');
            m.hours(23).minutes(59).seconds(59).milliseconds(999);
            assert.equal(m.calendar(),       m.format('[FÃ¸regÃ¥ande] dddd [klokka] LT'),  'Today - ' + i + ' days end of day');
        }
    });

    test('calendar all else', function (assert) {
        var weeksAgo = moment().subtract({w: 1}),
            weeksFromNow = moment().add({w: 1});

        assert.equal(weeksAgo.calendar(),       weeksAgo.format('L'),  '1 week ago');
        assert.equal(weeksFromNow.calendar(),   weeksFromNow.format('L'),  'in 1 week');

        weeksAgo = moment().subtract({w: 2});
        weeksFromNow = moment().add({w: 2});

        assert.equal(weeksAgo.calendar(),       weeksAgo.format('L'),  '2 weeks ago');
        assert.equal(weeksFromNow.calendar(),   weeksFromNow.format('L'),  'in 2 weeks');
    });

    test('weeks year starting sunday formatted', function (assert) {
        assert.equal(moment([2012, 0,  1]).format('w ww wo'), '52 52 52.', 'Jan  1 2012 should be week 52');
        assert.equal(moment([2012, 0,  2]).format('w ww wo'),   '1 01 1.', 'Jan  2 2012 should be week 1');
        assert.equal(moment([2012, 0,  8]).format('w ww wo'),   '1 01 1.', 'Jan  8 2012 should be week 1');
        assert.equal(moment([2012, 0,  9]).format('w ww wo'),   '2 02 2.', 'Jan  9 2012 should be week 2');
        assert.equal(moment([2012, 0, 15]).format('w ww wo'),   '2 02 2.', 'Jan 15 2012 should be week 2');
    });

}));

;(function (global, factory) {
   typeof exports === 'object' && typeof module !== 'undefined'
       && typeof require === 'function' ? factory(require('../../moment')) :
   typeof define === 'function' && define.amd ? define(['../../moment'], factory) :
   factory(global.moment)
}(this, function (moment) { 'use strict';

    function each(array, callback) {
        var i;
        for (i = 0; i < array.length; i++) {
            callback(array[i], i, array);
        }
    }

    function objectKeys(obj) {
        if (Object.keys) {
            return Object.keys(obj);
        } else {
            // IE8
            var res = [], i;
            for (i in obj) {
                if (obj.hasOwnProperty(i)) {
                    res.push(i);
                }
            }
            return res;
        }
    }

    // Pick the first defined of two or three arguments.
    function defaults(a, b, c) {
        if (a != null) {
            return a;
        }
        if (b != null) {
            return b;
        }
        return c;
    }

    function defineCommonLocaleTests(locale, options) {
        test('lenient ordinal parsing', function (assert) {
            var i, ordinalStr, testMoment;
            for (i = 1; i <= 31; ++i) {
                ordinalStr = moment([2014, 0, i]).format('YYYY MM Do');
                testMoment = moment(ordinalStr, 'YYYY MM Do');
                assert.equal(testMoment.year(), 2014,
                        'lenient ordinal parsing ' + i + ' year check');
                assert.equal(testMoment.month(), 0,
                        'lenient ordinal parsing ' + i + ' month check');
                assert.equal(testMoment.date(), i,
                        'lenient ordinal parsing ' + i + ' date check');
            }
        });

        test('lenient ordinal parsing of number', function (assert) {
            var i, testMoment;
            for (i = 1; i <= 31; ++i) {
                testMoment = moment('2014 01 ' + i, 'YYYY MM Do');
                assert.equal(testMoment.year(), 2014,
                        'lenient ordinal parsing of number ' + i + ' year check');
                assert.equal(testMoment.month(), 0,
                        'lenient ordinal parsing of number ' + i + ' month check');
                assert.equal(testMoment.date(), i,
                        'lenient ordinal parsing of number ' + i + ' date check');
            }
        });

        test('strict ordinal parsing', function (assert) {
            var i, ordinalStr, testMoment;
            for (i = 1; i <= 31; ++i) {
                ordinalStr = moment([2014, 0, i]).format('YYYY MM Do');
                testMoment = moment(ordinalStr, 'YYYY MM Do', true);
                assert.ok(testMoment.isValid(), 'strict ordinal parsing ' + i);
            }
        });

        test('meridiem invariant', function (assert) {
            var h, m, t1, t2;
            for (h = 0; h < 24; ++h) {
                for (m = 0; m < 60; m += 15) {
                    t1 = moment.utc([2000, 0, 1, h, m]);
                    t2 = moment.utc(t1.format('A h:mm'), 'A h:mm');
                    assert.equal(t2.format('HH:mm'), t1.format('HH:mm'),
                            'meridiem at ' + t1.format('HH:mm'));
                }
            }
        });

        test('date format correctness', function (assert) {
            var data, tokens;
            data = moment.localeData()._longDateFormat;
            tokens = objectKeys(data);
            each(tokens, function (srchToken) {
                // Check each format string to make sure it does not contain any
                // tokens that need to be expanded.
                each(tokens, function (baseToken) {
                    // strip escaped sequences
                    var format = data[baseToken].replace(/(\[[^\]]*\])/g, '');
                    assert.equal(false, !!~format.indexOf(srchToken),
                            'contains ' + srchToken + ' in ' + baseToken);
                });
            });
        });

        test('month parsing correctness', function (assert) {
            var i, m;

            if (locale === 'tr') {
                // I can't fix it :(
                expect(0);
                return;
            }
            function tester(format) {
                var r;
                r = moment(m.format(format), format);
                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format);
                r = moment(m.format(format).toLocaleUpperCase(), format);
                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' upper');
                r = moment(m.format(format).toLocaleLowerCase(), format);
                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' lower');

                r = moment(m.format(format), format, true);
                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' strict');
                r = moment(m.format(format).toLocaleUpperCase(), format, true);
                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' upper strict');
                r = moment(m.format(format).toLocaleLowerCase(), format, true);
                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' lower strict');
            }

            for (i = 0; i < 12; ++i) {
                m = moment([2015, i, 15, 18]);
                tester('MMM');
                tester('MMM.');
                tester('MMMM');
                tester('MMMM.');
            }
        });

        test('weekday parsing correctness', function (assert) {
            var i, m;

            if (locale === 'tr' || locale === 'az') {
                // There is a lower-case letter (Ä±), that converted to upper then
                // lower changes to i
                expect(0);
                return;
            }
            function tester(format) {
                var r, baseMsg = 'weekday ' + m.weekday() + ' fmt ' + format;
                r = moment(m.format(format), format);
                assert.equal(r.weekday(), m.weekday(), baseMsg);
                r = moment(m.format(format).toLocaleUpperCase(), format);
                assert.equal(r.weekday(), m.weekday(), baseMsg + ' upper');
                r = moment(m.format(format).toLocaleLowerCase(), format);
                assert.equal(r.weekday(), m.weekday(), baseMsg + ' lower');

                r = moment(m.format(format), format, true);
                assert.equal(r.weekday(), m.weekday(), baseMsg + ' strict');
                r = moment(m.format(format).toLocaleUpperCase(), format, true);
                assert.equal(r.weekday(), m.weekday(), baseMsg + ' upper strict');
                r = moment(m.format(format).toLocaleLowerCase(), format, true);
                assert.equal(r.weekday(), m.weekday(), baseMsg + ' lower strict');
            }

            for (i = 0; i < 7; ++i) {
                m = moment.utc([2015, i, 15, 18]);
                tester('dd');
                tester('ddd');
                tester('dddd');
            }
        });
    }

    function setupDeprecationHandler(test, moment, scope) {
        test._expectedDeprecations = null;
        test._observedDeprecations = null;
        test._oldSupress = moment.suppressDeprecationWarnings;
        moment.suppressDeprecationWarnings = true;
        test.expectedDeprecations = function () {
            test._expectedDeprecations = arguments;
            test._observedDeprecations = [];
        };
        moment.deprecationHandler = function (name, msg) {
            var deprecationId = matchedDeprecation(name, msg, test._expectedDeprecations);
            if (deprecationId === -1) {
                throw new Error('Unexpected deprecation thrown name=' +
                        name + ' msg=' + msg);
            }
            test._observedDeprecations[deprecationId] = 1;
        };
    }

    function teardownDeprecationHandler(test, moment, scope) {
        moment.suppressDeprecationWarnings = test._oldSupress;

        if (test._expectedDeprecations != null) {
            var missedDeprecations = [];
            each(test._expectedDeprecations, function (deprecationPattern, id) {
                if (test._observedDeprecations[id] !== 1) {
                    missedDeprecations.push(deprecationPattern);
                }
            });
            if (missedDeprecations.length !== 0) {
                throw new Error('Expected deprecation warnings did not happen: ' +
                        missedDeprecations.join(' '));
            }
        }
    }

    function matchedDeprecation(name, msg, deprecations) {
        if (deprecations == null) {
            return -1;
        }
        for (var i = 0; i < deprecations.length; ++i) {
            if (name != null && name === deprecations[i]) {
                return i;
            }
            if (msg != null && msg.substring(0, deprecations[i].length) === deprecations[i]) {
                return i;
            }
        }
        return -1;
    }

    /*global QUnit:false*/

    var test = QUnit.test;

    var expect = QUnit.expect;

    function module (name, lifecycle) {
        QUnit.module(name, {
            setup : function () {
                moment.locale('en');
                moment.createFromInputFallback = function (config) {
                    throw new Error('input not handled by moment: ' + config._i);
                };
                setupDeprecationHandler(test, moment, 'core');
                if (lifecycle && lifecycle.setup) {
                    lifecycle.setup();
                }
            },
            teardown : function () {
                teardownDeprecationHandler(test, moment, 'core');
                if (lifecycle && lifecycle.teardown) {
                    lifecycle.teardown();
                }
            }
        });
    }

    function localeModule (name, lifecycle) {
        QUnit.module('locale:' + name, {
            setup : function () {
                moment.locale(name);
                moment.createFromInputFallback = function (config) {
                    throw new Error('input not handled by moment: ' + config._i);
                };
                setupDeprecationHandler(test, moment, 'locale');
                if (lifecycle && lifecycle.setup) {
                    lifecycle.setup();
                }
            },
            teardown : function () {
                moment.locale('en');
                teardownDeprecationHandler(test, moment, 'locale');
                if (lifecycle && lifecycle.teardown) {
                    lifecycle.teardown();
                }
            }
        });
        defineCommonLocaleTests(name, -1, -1);
    }

    localeModule('pa-in');

    test('parse', function (assert) {
        var tests = 'à¨à¨¨à¨µà¨°à© à¨à¨¨à¨µà¨°à©_à¨«à¨¼à¨°à¨µà¨°à© à¨«à¨¼à¨°à¨µà¨°à©_à¨®à¨¾à¨°à¨ à¨®à¨¾à¨°à¨_à¨à¨ªà©à¨°à©à¨² à¨à¨ªà©à¨°à©à¨²_à¨®à¨ à¨®à¨_à¨à©à¨¨ à¨à©à¨¨_à¨à©à¨²à¨¾à¨ à¨à©à¨²à¨¾à¨_à¨à¨à¨¸à¨¤ à¨à¨à¨¸à¨¤_à¨¸à¨¤à©°à¨¬à¨° à¨¸à¨¤à©°à¨¬à¨°_à¨à¨à¨¤à©à¨¬à¨° à¨à¨à¨¤à©à¨¬à¨°_à¨¨à¨µà©°à¨¬à¨° à¨¨à¨µà©°à¨¬à¨°_à¨¦à¨¸à©°à¨¬à¨° à¨¦à¨¸à©°à¨¬à¨°'.split('_'), i;
        function equalTest(input, mmm, i) {
            assert.equal(moment(input, mmm).month(), i, input + ' should be month ' + (i + 1));
        }
        for (i = 0; i < 12; i++) {
            tests[i] = tests[i].split(' ');
            equalTest(tests[i][0], 'MMM', i);
            equalTest(tests[i][1], 'MMM', i);
            equalTest(tests[i][0], 'MMMM', i);
            equalTest(tests[i][1], 'MMMM', i);
            equalTest(tests[i][0].toLocaleLowerCase(), 'MMMM', i);
            equalTest(tests[i][1].toLocaleLowerCase(), 'MMMM', i);
            equalTest(tests[i][0].toLocaleUpperCase(), 'MMMM', i);
            equalTest(tests[i][1].toLocaleUpperCase(), 'MMMM', i);
        }
    });

    test('format', function (assert) {
        var a = [
                ['dddd, Do MMMM YYYY, a h:mm:ss à¨µà¨à©',  'à¨à¨¤à¨µà¨¾à¨°, à©§à©ª à¨«à¨¼à¨°à¨µà¨°à© à©¨à©¦à©§à©¦, à¨¦à©à¨ªà¨¹à¨¿à¨° à©©:à©¨à©«:à©«à©¦ à¨µà¨à©'],
                ['ddd, a h à¨µà¨à©',                       'à¨à¨¤, à¨¦à©à¨ªà¨¹à¨¿à¨° à©© à¨µà¨à©'],
                ['M Mo MM MMMM MMM',                   'à©¨ à©¨ à©¦à©¨ à¨«à¨¼à¨°à¨µà¨°à© à¨«à¨¼à¨°à¨µà¨°à©'],
                ['YYYY YY',                            'à©¨à©¦à©§à©¦ à©§à©¦'],
                ['D Do DD',                            'à©§à©ª à©§à©ª à©§à©ª'],
                ['d do dddd ddd dd',                   'à©¦ à©¦ à¨à¨¤à¨µà¨¾à¨° à¨à¨¤ à¨à¨¤'],
                ['DDD DDDo DDDD',                      'à©ªà©« à©ªà©« à©¦à©ªà©«'],
                ['w wo ww',                            'à©® à©® à©¦à©®'],
                ['h hh',                               'à©© à©¦à©©'],
                ['H HH',                               'à©§à©« à©§à©«'],
                ['m mm',                               'à©¨à©« à©¨à©«'],
                ['s ss',                               'à©«à©¦ à©«à©¦'],
                ['a A',                                'à¨¦à©à¨ªà¨¹à¨¿à¨° à¨¦à©à¨ªà¨¹à¨¿à¨°'],
                ['LTS',                                'à¨¦à©à¨ªà¨¹à¨¿à¨° à©©:à©¨à©«:à©«à©¦ à¨µà¨à©'],
                ['L',                                  'à©§à©ª/à©¦à©¨/à©¨à©¦à©§à©¦'],
                ['LL',                                 'à©§à©ª à¨«à¨¼à¨°à¨µà¨°à© à©¨à©¦à©§à©¦'],
                ['LLL',                                'à©§à©ª à¨«à¨¼à¨°à¨µà¨°à© à©¨à©¦à©§à©¦, à¨¦à©à¨ªà¨¹à¨¿à¨° à©©:à©¨à©« à¨µà¨à©'],
                ['LLLL',                               'à¨à¨¤à¨µà¨¾à¨°, à©§à©ª à¨«à¨¼à¨°à¨µà¨°à© à©¨à©¦à©§à©¦, à¨¦à©à¨ªà¨¹à¨¿à¨° à©©:à©¨à©« à¨µà¨à©'],
                ['l',                                  'à©§à©ª/à©¨/à©¨à©¦à©§à©¦'],
                ['ll',                                 'à©§à©ª à¨«à¨¼à¨°à¨µà¨°à© à©¨à©¦à©§à©¦'],
                ['lll',                                'à©§à©ª à¨«à¨¼à¨°à¨µà¨°à© à©¨à©¦à©§à©¦, à¨¦à©à¨ªà¨¹à¨¿à¨° à©©:à©¨à©« à¨µà¨à©'],
                ['llll',                               'à¨à¨¤, à©§à©ª à¨«à¨¼à¨°à¨µà¨°à© à©¨à©¦à©§à©¦, à¨¦à©à¨ªà¨¹à¨¿à¨° à©©:à©¨à©« à¨µà¨à©']
            ],
            b = moment(new Date(2010, 1, 14, 15, 25, 50, 125)),
            i;
        for (i = 0; i < a.length; i++) {
            assert.equal(b.format(a[i][0]), a[i][1], a[i][0] + ' ---> ' + a[i][1]);
        }
    });

    test('format ordinal', function (assert) {
        assert.equal(moment([2011, 0, 1]).format('DDDo'), 'à©§', 'à©§');
        assert.equal(moment([2011, 0, 2]).format('DDDo'), 'à©¨', 'à©¨');
        assert.equal(moment([2011, 0, 3]).format('DDDo'), 'à©©', 'à©©');
        assert.equal(moment([2011, 0, 4]).format('DDDo'), 'à©ª', 'à©ª');
        assert.equal(moment([2011, 0, 5]).format('DDDo'), 'à©«', 'à©«');
        assert.equal(moment([2011, 0, 6]).format('DDDo'), 'à©¬', 'à©¬');
        assert.equal(moment([2011, 0, 7]).format('DDDo'), 'à©­', 'à©­');
        assert.equal(moment([2011, 0, 8]).format('DDDo'), 'à©®', 'à©®');
        assert.equal(moment([2011, 0, 9]).format('DDDo'), 'à©¯', 'à©¯');
        assert.equal(moment([2011, 0, 10]).format('DDDo'), 'à©§à©¦', 'à©§à©¦');

        assert.equal(moment([2011, 0, 11]).format('DDDo'), 'à©§à©§', 'à©§à©§');
        assert.equal(moment([2011, 0, 12]).format('DDDo'), 'à©§à©¨', 'à©§à©¨');
        assert.equal(moment([2011, 0, 13]).format('DDDo'), 'à©§à©©', 'à©§à©©');
        assert.equal(moment([2011, 0, 14]).format('DDDo'), 'à©§à©ª', 'à©§à©ª');
        assert.equal(moment([2011, 0, 15]).format('DDDo'), 'à©§à©«', 'à©§à©«');
        assert.equal(moment([2011, 0, 16]).format('DDDo'), 'à©§à©¬', 'à©§à©¬');
        assert.equal(moment([2011, 0, 17]).format('DDDo'), 'à©§à©­', 'à©§à©­');
        assert.equal(moment([2011, 0, 18]).format('DDDo'), 'à©§à©®', 'à©§à©®');
        assert.equal(moment([2011, 0, 19]).format('DDDo'), 'à©§à©¯', 'à©§à©¯');
        assert.equal(moment([2011, 0, 20]).format('DDDo'), 'à©¨à©¦', 'à©¨à©¦');

        assert.equal(moment([2011, 0, 21]).format('DDDo'), 'à©¨à©§', 'à©¨à©§');
        assert.equal(moment([2011, 0, 22]).format('DDDo'), 'à©¨à©¨', 'à©¨à©¨');
        assert.equal(moment([2011, 0, 23]).format('DDDo'), 'à©¨à©©', 'à©¨à©©');
        assert.equal(moment([2011, 0, 24]).format('DDDo'), 'à©¨à©ª', 'à©¨à©ª');
        assert.equal(moment([2011, 0, 25]).format('DDDo'), 'à©¨à©«', 'à©¨à©«');
        assert.equal(moment([2011, 0, 26]).format('DDDo'), 'à©¨à©¬', 'à©¨à©¬');
        assert.equal(moment([2011, 0, 27]).format('DDDo'), 'à©¨à©­', 'à©¨à©­');
        assert.equal(moment([2011, 0, 28]).format('DDDo'), 'à©¨à©®', 'à©¨à©®');
        assert.equal(moment([2011, 0, 29]).format('DDDo'), 'à©¨à©¯', 'à©¨à©¯');
        assert.equal(moment([2011, 0, 30]).format('DDDo'), 'à©©à©¦', 'à©©à©¦');

        assert.equal(moment([2011, 0, 31]).format('DDDo'), 'à©©à©§', 'à©©à©§');
    });

    test('format month', function (assert) {
        var expected = 'à¨à¨¨à¨µà¨°à© à¨à¨¨à¨µà¨°à©_à¨«à¨¼à¨°à¨µà¨°à© à¨«à¨¼à¨°à¨µà¨°à©_à¨®à¨¾à¨°à¨ à¨®à¨¾à¨°à¨_à¨à¨ªà©à¨°à©à¨² à¨à¨ªà©à¨°à©à¨²_à¨®à¨ à¨®à¨_à¨à©à¨¨ à¨à©à¨¨_à¨à©à¨²à¨¾à¨ à¨à©à¨²à¨¾à¨_à¨à¨à¨¸à¨¤ à¨à¨à¨¸à¨¤_à¨¸à¨¤à©°à¨¬à¨° à¨¸à¨¤à©°à¨¬à¨°_à¨à¨à¨¤à©à¨¬à¨° à¨à¨à¨¤à©à¨¬à¨°_à¨¨à¨µà©°à¨¬à¨° à¨¨à¨µà©°à¨¬à¨°_à¨¦à¨¸à©°à¨¬à¨° à¨¦à¨¸à©°à¨¬à¨°'.split('_'), i;
        for (i = 0; i < expected.length; i++) {
            assert.equal(moment([2011, i, 1]).format('MMMM MMM'), expected[i], expected[i]);
        }
    });

    test('format week', function (assert) {
        var expected = 'à¨à¨¤à¨µà¨¾à¨° à¨à¨¤ à¨à¨¤_à¨¸à©à¨®à¨µà¨¾à¨° à¨¸à©à¨® à¨¸à©à¨®_à¨®à©°à¨à¨²à¨µà¨¾à¨° à¨®à©°à¨à¨² à¨®à©°à¨à¨²_à¨¬à©à¨§à¨µà¨¾à¨° à¨¬à©à¨§ à¨¬à©à¨§_à¨µà©à¨°à¨µà¨¾à¨° à¨µà©à¨° à¨µà©à¨°_à¨¸à¨¼à©à©±à¨à¨°à¨µà¨¾à¨° à¨¸à¨¼à©à¨à¨° à¨¸à¨¼à©à¨à¨°_à¨¸à¨¼à¨¨à©à¨à¨°à¨µà¨¾à¨° à¨¸à¨¼à¨¨à© à¨¸à¨¼à¨¨à©'.split('_'), i;
        for (i = 0; i < expected.length; i++) {
            assert.equal(moment([2011, 0, 2 + i]).format('dddd ddd dd'), expected[i], expected[i]);
        }
    });

    test('from', function (assert) {
        var start = moment([2007, 1, 28]);
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 44}), true),  'à¨à©à¨ à¨¸à¨à¨¿à©°à¨', '44 seconds = a few seconds');
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 45}), true),  'à¨à¨ à¨®à¨¿à©°à¨',      '45 seconds = a minute');
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 89}), true),  'à¨à¨ à¨®à¨¿à©°à¨',      '89 seconds = a minute');
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 90}), true),  'à©¨ à¨®à¨¿à©°à¨',     '90 seconds = 2 minutes');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 44}), true),  'à©ªà©ª à¨®à¨¿à©°à¨',    '44 minutes = 44 minutes');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 45}), true),  'à¨à©±à¨ à¨à©°à¨à¨¾',       '45 minutes = an hour');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 89}), true),  'à¨à©±à¨ à¨à©°à¨à¨¾',       '89 minutes = an hour');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 90}), true),  'à©¨ à¨à©°à¨à©',       '90 minutes = 2 hours');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 5}), true),   'à©« à¨à©°à¨à©',       '5 hours = 5 hours');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 21}), true),  'à©¨à©§ à¨à©°à¨à©',      '21 hours = 21 hours');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 22}), true),  'à¨à©±à¨ à¨¦à¨¿à¨¨',         '22 hours = a day');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 35}), true),  'à¨à©±à¨ à¨¦à¨¿à¨¨',         '35 hours = a day');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 36}), true),  'à©¨ à¨¦à¨¿à¨¨',        '36 hours = 2 days');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 1}), true),   'à¨à©±à¨ à¨¦à¨¿à¨¨',         '1 day = a day');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 5}), true),   'à©« à¨¦à¨¿à¨¨',        '5 days = 5 days');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 25}), true),  'à©¨à©« à¨¦à¨¿à¨¨',       '25 days = 25 days');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 26}), true),  'à¨à©±à¨ à¨®à¨¹à©à¨¨à¨¾',       '26 days = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 30}), true),  'à¨à©±à¨ à¨®à¨¹à©à¨¨à¨¾',       '30 days = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 43}), true),  'à¨à©±à¨ à¨®à¨¹à©à¨¨à¨¾',       '43 days = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 46}), true),  'à©¨ à¨®à¨¹à©à¨¨à©',      '46 days = 2 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 74}), true),  'à©¨ à¨®à¨¹à©à¨¨à©',      '75 days = 2 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 76}), true),  'à©© à¨®à¨¹à©à¨¨à©',      '76 days = 3 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({M: 1}), true),   'à¨à©±à¨ à¨®à¨¹à©à¨¨à¨¾',       '1 month = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({M: 5}), true),   'à©« à¨®à¨¹à©à¨¨à©',      '5 months = 5 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 345}), true), 'à¨à©±à¨ à¨¸à¨¾à¨²',        '345 days = a year');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 548}), true), 'à©¨ à¨¸à¨¾à¨²',       '548 days = 2 years');
        assert.equal(start.from(moment([2007, 1, 28]).add({y: 1}), true),   'à¨à©±à¨ à¨¸à¨¾à¨²',        '1 year = a year');
        assert.equal(start.from(moment([2007, 1, 28]).add({y: 5}), true),   'à©« à¨¸à¨¾à¨²',       '5 years = 5 years');
    });

    test('suffix', function (assert) {
        assert.equal(moment(30000).from(0), 'à¨à©à¨ à¨¸à¨à¨¿à©°à¨ à¨µà¨¿à©±à¨',  'prefix');
        assert.equal(moment(0).from(30000), 'à¨à©à¨ à¨¸à¨à¨¿à©°à¨ à¨ªà¨¿à¨à¨²à©', 'suffix');
    });

    test('now from now', function (assert) {
        assert.equal(moment().fromNow(), 'à¨à©à¨ à¨¸à¨à¨¿à©°à¨ à¨ªà¨¿à¨à¨²à©',  'now from now should display as in the past');
    });

    test('fromNow', function (assert) {
        assert.equal(moment().add({s: 30}).fromNow(), 'à¨à©à¨ à¨¸à¨à¨¿à©°à¨ à¨µà¨¿à©±à¨', 'à¨à©à¨ à¨¸à¨à¨¿à©°à¨ à¨µà¨¿à©±à¨');
        assert.equal(moment().add({d: 5}).fromNow(), 'à©« à¨¦à¨¿à¨¨ à¨µà¨¿à©±à¨', 'à©« à¨¦à¨¿à¨¨ à¨µà¨¿à©±à¨');
    });

    test('calendar day', function (assert) {
        var a = moment().hours(12).minutes(0).seconds(0);

        assert.equal(moment(a).calendar(),                   'à¨à¨ à¨¦à©à¨ªà¨¹à¨¿à¨° à©§à©¨:à©¦à©¦ à¨µà¨à©',  'today at the same time');
        assert.equal(moment(a).add({m: 25}).calendar(),      'à¨à¨ à¨¦à©à¨ªà¨¹à¨¿à¨° à©§à©¨:à©¨à©« à¨µà¨à©',  'Now plus 25 min');
        assert.equal(moment(a).add({h: 3}).calendar(),       'à¨à¨ à¨¦à©à¨ªà¨¹à¨¿à¨° à©©:à©¦à©¦ à¨µà¨à©',   'Now plus 3 hours');
        assert.equal(moment(a).add({d: 1}).calendar(),       'à¨à¨² à¨¦à©à¨ªà¨¹à¨¿à¨° à©§à©¨:à©¦à©¦ à¨µà¨à©',  'tomorrow at the same time');
        assert.equal(moment(a).subtract({h: 1}).calendar(),  'à¨à¨ à¨¦à©à¨ªà¨¹à¨¿à¨° à©§à©§:à©¦à©¦ à¨µà¨à©',  'Now minus 1 hour');
        assert.equal(moment(a).subtract({d: 1}).calendar(),  'à¨à¨² à¨¦à©à¨ªà¨¹à¨¿à¨° à©§à©¨:à©¦à©¦ à¨µà¨à©',  'yesterday at the same time');
    });

    test('calendar next week', function (assert) {
        var i, m;
        for (i = 2; i < 7; i++) {
            m = moment().add({d: i});
            assert.equal(m.calendar(),       m.format('dddd[,] LT'),  'Today + ' + i + ' days current time');
            m.hours(0).minutes(0).seconds(0).milliseconds(0);
            assert.equal(m.calendar(),       m.format('dddd[,] LT'),  'Today + ' + i + ' days beginning of day');
            m.hours(23).minutes(59).seconds(59).milliseconds(999);
            assert.equal(m.calendar(),       m.format('dddd[,] LT'),  'Today + ' + i + ' days end of day');
        }
    });

    test('calendar last week', function (assert) {
        var i, m;

        for (i = 2; i < 7; i++) {
            m = moment().subtract({d: i});
            assert.equal(m.calendar(),       m.format('[à¨ªà¨¿à¨à¨²à©] dddd[,] LT'),  'Today - ' + i + ' days current time');
            m.hours(0).minutes(0).seconds(0).milliseconds(0);
            assert.equal(m.calendar(),       m.format('[à¨ªà¨¿à¨à¨²à©] dddd[,] LT'),  'Today - ' + i + ' days beginning of day');
            m.hours(23).minutes(59).seconds(59).milliseconds(999);
            assert.equal(m.calendar(),       m.format('[à¨ªà¨¿à¨à¨²à©] dddd[,] LT'),  'Today - ' + i + ' days end of day');
        }
    });

    test('calendar all else', function (assert) {
        var weeksAgo = moment().subtract({w: 1}),
            weeksFromNow = moment().add({w: 1});

        assert.equal(weeksAgo.calendar(),       weeksAgo.format('L'),  '1 week ago');
        assert.equal(weeksFromNow.calendar(),   weeksFromNow.format('L'),  'in 1 week');

        weeksAgo = moment().subtract({w: 2});
        weeksFromNow = moment().add({w: 2});

        assert.equal(weeksAgo.calendar(),       weeksAgo.format('L'),  '2 weeks ago');
        assert.equal(weeksFromNow.calendar(),   weeksFromNow.format('L'),  'in 2 weeks');
    });

    test('meridiem invariant', function (assert) {
        assert.equal(moment([2011, 2, 23,  2, 30]).format('a'), 'à¨°à¨¾à¨¤', 'before dawn');
        assert.equal(moment([2011, 2, 23,  9, 30]).format('a'), 'à¨¸à¨µà©à¨°', 'morning');
        assert.equal(moment([2011, 2, 23, 14, 30]).format('a'), 'à¨¦à©à¨ªà¨¹à¨¿à¨°', 'during day');
        assert.equal(moment([2011, 2, 23, 17, 30]).format('a'), 'à¨¸à¨¼à¨¾à¨®', 'evening');
        assert.equal(moment([2011, 2, 23, 19, 30]).format('a'), 'à¨¸à¨¼à¨¾à¨®', 'late evening');
        assert.equal(moment([2011, 2, 23, 21, 20]).format('a'), 'à¨°à¨¾à¨¤', 'night');

        assert.equal(moment([2011, 2, 23,  2, 30]).format('A'), 'à¨°à¨¾à¨¤', 'before dawn');
        assert.equal(moment([2011, 2, 23,  9, 30]).format('A'), 'à¨¸à¨µà©à¨°', 'morning');
        assert.equal(moment([2011, 2, 23, 14, 30]).format('A'), 'à¨¦à©à¨ªà¨¹à¨¿à¨°', ' during day');
        assert.equal(moment([2011, 2, 23, 17, 30]).format('A'), 'à¨¸à¨¼à¨¾à¨®', 'evening');
        assert.equal(moment([2011, 2, 23, 19, 30]).format('A'), 'à¨¸à¨¼à¨¾à¨®', 'late evening');
        assert.equal(moment([2011, 2, 23, 21, 20]).format('A'), 'à¨°à¨¾à¨¤', 'night');
    });

    test('weeks year starting sunday', function (assert) {
        assert.equal(moment([2012, 0,  1]).week(), 1, 'Jan  1 2012 should be week 1');
        assert.equal(moment([2012, 0,  7]).week(), 1, 'Jan  7 2012 should be week 1');
        assert.equal(moment([2012, 0,  8]).week(), 2, 'Jan  8 2012 should be week 2');
        assert.equal(moment([2012, 0, 14]).week(), 2, 'Jan 14 2012 should be week 2');
        assert.equal(moment([2012, 0, 15]).week(), 3, 'Jan 15 2012 should be week 3');
    });

    test('weeks year starting monday', function (assert) {
        assert.equal(moment([2006, 11, 31]).week(), 1, 'Dec 31 2006 should be week 1');
        assert.equal(moment([2007,  0,  1]).week(), 1, 'Jan  1 2007 should be week 1');
        assert.equal(moment([2007,  0,  6]).week(), 1, 'Jan  6 2007 should be week 1');
        assert.equal(moment([2007,  0,  7]).week(), 2, 'Jan  7 2007 should be week 2');
        assert.equal(moment([2007,  0, 13]).week(), 2, 'Jan 13 2007 should be week 2');
        assert.equal(moment([2007,  0, 14]).week(), 3, 'Jan 14 2007 should be week 3');
    });

    test('weeks year starting tuesday', function (assert) {
        assert.equal(moment([2007, 11, 29]).week(), 52, 'Dec 29 2007 should be week 52');
        assert.equal(moment([2008,  0,  1]).week(), 1, 'Jan  1 2008 should be week 1');
        assert.equal(moment([2008,  0,  5]).week(), 1, 'Jan  5 2008 should be week 1');
        assert.equal(moment([2008,  0,  6]).week(), 2, 'Jan  6 2008 should be week 2');
        assert.equal(moment([2008,  0, 12]).week(), 2, 'Jan 12 2008 should be week 2');
        assert.equal(moment([2008,  0, 13]).week(), 3, 'Jan 13 2008 should be week 3');
    });

    test('weeks year starting wednesday', function (assert) {
        assert.equal(moment([2002, 11, 29]).week(), 1, 'Dec 29 2002 should be week 1');
        assert.equal(moment([2003,  0,  1]).week(), 1, 'Jan  1 2003 should be week 1');
        assert.equal(moment([2003,  0,  4]).week(), 1, 'Jan  4 2003 should be week 1');
        assert.equal(moment([2003,  0,  5]).week(), 2, 'Jan  5 2003 should be week 2');
        assert.equal(moment([2003,  0, 11]).week(), 2, 'Jan 11 2003 should be week 2');
        assert.equal(moment([2003,  0, 12]).week(), 3, 'Jan 12 2003 should be week 3');
    });

    test('weeks year starting thursday', function (assert) {
        assert.equal(moment([2008, 11, 28]).week(), 1, 'Dec 28 2008 should be week 1');
        assert.equal(moment([2009,  0,  1]).week(), 1, 'Jan  1 2009 should be week 1');
        assert.equal(moment([2009,  0,  3]).week(), 1, 'Jan  3 2009 should be week 1');
        assert.equal(moment([2009,  0,  4]).week(), 2, 'Jan  4 2009 should be week 2');
        assert.equal(moment([2009,  0, 10]).week(), 2, 'Jan 10 2009 should be week 2');
        assert.equal(moment([2009,  0, 11]).week(), 3, 'Jan 11 2009 should be week 3');
    });

    test('weeks year starting friday', function (assert) {
        assert.equal(moment([2009, 11, 27]).week(), 1, 'Dec 27 2009 should be week 1');
        assert.equal(moment([2010,  0,  1]).week(), 1, 'Jan  1 2010 should be week 1');
        assert.equal(moment([2010,  0,  2]).week(), 1, 'Jan  2 2010 should be week 1');
        assert.equal(moment([2010,  0,  3]).week(), 2, 'Jan  3 2010 should be week 2');
        assert.equal(moment([2010,  0,  9]).week(), 2, 'Jan  9 2010 should be week 2');
        assert.equal(moment([2010,  0, 10]).week(), 3, 'Jan 10 2010 should be week 3');
    });

    test('weeks year starting saturday', function (assert) {
        assert.equal(moment([2010, 11, 26]).week(), 1, 'Dec 26 2010 should be week 1');
        assert.equal(moment([2011,  0,  1]).week(), 1, 'Jan  1 2011 should be week 1');
        assert.equal(moment([2011,  0,  2]).week(), 2, 'Jan  2 2011 should be week 2');
        assert.equal(moment([2011,  0,  8]).week(), 2, 'Jan  8 2011 should be week 2');
        assert.equal(moment([2011,  0,  9]).week(), 3, 'Jan  9 2011 should be week 3');
    });

    test('weeks year starting sunday formatted', function (assert) {
        assert.equal(moment([2012, 0,  1]).format('w ww wo'), 'à©§ à©¦à©§ à©§', 'Jan  1 2012 should be week 1');
        assert.equal(moment([2012, 0,  7]).format('w ww wo'), 'à©§ à©¦à©§ à©§', 'Jan  7 2012 should be week 1');
        assert.equal(moment([2012, 0,  8]).format('w ww wo'), 'à©¨ à©¦à©¨ à©¨', 'Jan  8 2012 should be week 2');
        assert.equal(moment([2012, 0, 14]).format('w ww wo'), 'à©¨ à©¦à©¨ à©¨', 'Jan 14 2012 should be week 2');
        assert.equal(moment([2012, 0, 15]).format('w ww wo'), 'à©© à©¦à©© à©©', 'Jan 15 2012 should be week 3');
    });

    test('lenient ordinal parsing', function (assert) {
        var i, ordinalStr, testMoment;
        for (i = 1; i <= 31; ++i) {
            ordinalStr = moment([2014, 0, i]).format('YYYY MM Do');
            testMoment = moment(ordinalStr, 'YYYY MM Do');
            assert.equal(testMoment.year(), 2014,
                    'lenient ordinal parsing ' + i + ' year check');
            assert.equal(testMoment.month(), 0,
                    'lenient ordinal parsing ' + i + ' month check');
            assert.equal(testMoment.date(), i,
                    'lenient ordinal parsing ' + i + ' date check');
        }
    });

    test('lenient ordinal parsing of number', function (assert) {
        var i, testMoment;
        for (i = 1; i <= 31; ++i) {
            testMoment = moment('2014 01 ' + i, 'YYYY MM Do');
            assert.equal(testMoment.year(), 2014,
                    'lenient ordinal parsing of number ' + i + ' year check');
            assert.equal(testMoment.month(), 0,
                    'lenient ordinal parsing of number ' + i + ' month check');
            assert.equal(testMoment.date(), i,
                    'lenient ordinal parsing of number ' + i + ' date check');
        }
    });

    test('strict ordinal parsing', function (assert) {
        var i, ordinalStr, testMoment;
        for (i = 1; i <= 31; ++i) {
            ordinalStr = moment([2014, 0, i]).format('YYYY MM Do');
            testMoment = moment(ordinalStr, 'YYYY MM Do', true);
            assert.ok(testMoment.isValid(), 'strict ordinal parsing ' + i);
        }
    });

}));

;(function (global, factory) {
   typeof exports === 'object' && typeof module !== 'undefined'
       && typeof require === 'function' ? factory(require('../../moment')) :
   typeof define === 'function' && define.amd ? define(['../../moment'], factory) :
   factory(global.moment)
}(this, function (moment) { 'use strict';

    function each(array, callback) {
        var i;
        for (i = 0; i < array.length; i++) {
            callback(array[i], i, array);
        }
    }

    function objectKeys(obj) {
        if (Object.keys) {
            return Object.keys(obj);
        } else {
            // IE8
            var res = [], i;
            for (i in obj) {
                if (obj.hasOwnProperty(i)) {
                    res.push(i);
                }
            }
            return res;
        }
    }

    // Pick the first defined of two or three arguments.
    function defaults(a, b, c) {
        if (a != null) {
            return a;
        }
        if (b != null) {
            return b;
        }
        return c;
    }

    function defineCommonLocaleTests(locale, options) {
        test('lenient ordinal parsing', function (assert) {
            var i, ordinalStr, testMoment;
            for (i = 1; i <= 31; ++i) {
                ordinalStr = moment([2014, 0, i]).format('YYYY MM Do');
                testMoment = moment(ordinalStr, 'YYYY MM Do');
                assert.equal(testMoment.year(), 2014,
                        'lenient ordinal parsing ' + i + ' year check');
                assert.equal(testMoment.month(), 0,
                        'lenient ordinal parsing ' + i + ' month check');
                assert.equal(testMoment.date(), i,
                        'lenient ordinal parsing ' + i + ' date check');
            }
        });

        test('lenient ordinal parsing of number', function (assert) {
            var i, testMoment;
            for (i = 1; i <= 31; ++i) {
                testMoment = moment('2014 01 ' + i, 'YYYY MM Do');
                assert.equal(testMoment.year(), 2014,
                        'lenient ordinal parsing of number ' + i + ' year check');
                assert.equal(testMoment.month(), 0,
                        'lenient ordinal parsing of number ' + i + ' month check');
                assert.equal(testMoment.date(), i,
                        'lenient ordinal parsing of number ' + i + ' date check');
            }
        });

        test('strict ordinal parsing', function (assert) {
            var i, ordinalStr, testMoment;
            for (i = 1; i <= 31; ++i) {
                ordinalStr = moment([2014, 0, i]).format('YYYY MM Do');
                testMoment = moment(ordinalStr, 'YYYY MM Do', true);
                assert.ok(testMoment.isValid(), 'strict ordinal parsing ' + i);
            }
        });

        test('meridiem invariant', function (assert) {
            var h, m, t1, t2;
            for (h = 0; h < 24; ++h) {
                for (m = 0; m < 60; m += 15) {
                    t1 = moment.utc([2000, 0, 1, h, m]);
                    t2 = moment.utc(t1.format('A h:mm'), 'A h:mm');
                    assert.equal(t2.format('HH:mm'), t1.format('HH:mm'),
                            'meridiem at ' + t1.format('HH:mm'));
                }
            }
        });

        test('date format correctness', function (assert) {
            var data, tokens;
            data = moment.localeData()._longDateFormat;
            tokens = objectKeys(data);
            each(tokens, function (srchToken) {
                // Check each format string to make sure it does not contain any
                // tokens that need to be expanded.
                each(tokens, function (baseToken) {
                    // strip escaped sequences
                    var format = data[baseToken].replace(/(\[[^\]]*\])/g, '');
                    assert.equal(false, !!~format.indexOf(srchToken),
                            'contains ' + srchToken + ' in ' + baseToken);
                });
            });
        });

        test('month parsing correctness', function (assert) {
            var i, m;

            if (locale === 'tr') {
                // I can't fix it :(
                expect(0);
                return;
            }
            function tester(format) {
                var r;
                r = moment(m.format(format), format);
                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format);
                r = moment(m.format(format).toLocaleUpperCase(), format);
                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' upper');
                r = moment(m.format(format).toLocaleLowerCase(), format);
                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' lower');

                r = moment(m.format(format), format, true);
                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' strict');
                r = moment(m.format(format).toLocaleUpperCase(), format, true);
                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' upper strict');
                r = moment(m.format(format).toLocaleLowerCase(), format, true);
                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' lower strict');
            }

            for (i = 0; i < 12; ++i) {
                m = moment([2015, i, 15, 18]);
                tester('MMM');
                tester('MMM.');
                tester('MMMM');
                tester('MMMM.');
            }
        });

        test('weekday parsing correctness', function (assert) {
            var i, m;

            if (locale === 'tr' || locale === 'az') {
                // There is a lower-case letter (Ä±), that converted to upper then
                // lower changes to i
                expect(0);
                return;
            }
            function tester(format) {
                var r, baseMsg = 'weekday ' + m.weekday() + ' fmt ' + format;
                r = moment(m.format(format), format);
                assert.equal(r.weekday(), m.weekday(), baseMsg);
                r = moment(m.format(format).toLocaleUpperCase(), format);
                assert.equal(r.weekday(), m.weekday(), baseMsg + ' upper');
                r = moment(m.format(format).toLocaleLowerCase(), format);
                assert.equal(r.weekday(), m.weekday(), baseMsg + ' lower');

                r = moment(m.format(format), format, true);
                assert.equal(r.weekday(), m.weekday(), baseMsg + ' strict');
                r = moment(m.format(format).toLocaleUpperCase(), format, true);
                assert.equal(r.weekday(), m.weekday(), baseMsg + ' upper strict');
                r = moment(m.format(format).toLocaleLowerCase(), format, true);
                assert.equal(r.weekday(), m.weekday(), baseMsg + ' lower strict');
            }

            for (i = 0; i < 7; ++i) {
                m = moment.utc([2015, i, 15, 18]);
                tester('dd');
                tester('ddd');
                tester('dddd');
            }
        });
    }

    function setupDeprecationHandler(test, moment, scope) {
        test._expectedDeprecations = null;
        test._observedDeprecations = null;
        test._oldSupress = moment.suppressDeprecationWarnings;
        moment.suppressDeprecationWarnings = true;
        test.expectedDeprecations = function () {
            test._expectedDeprecations = arguments;
            test._observedDeprecations = [];
        };
        moment.deprecationHandler = function (name, msg) {
            var deprecationId = matchedDeprecation(name, msg, test._expectedDeprecations);
            if (deprecationId === -1) {
                throw new Error('Unexpected deprecation thrown name=' +
                        name + ' msg=' + msg);
            }
            test._observedDeprecations[deprecationId] = 1;
        };
    }

    function teardownDeprecationHandler(test, moment, scope) {
        moment.suppressDeprecationWarnings = test._oldSupress;

        if (test._expectedDeprecations != null) {
            var missedDeprecations = [];
            each(test._expectedDeprecations, function (deprecationPattern, id) {
                if (test._observedDeprecations[id] !== 1) {
                    missedDeprecations.push(deprecationPattern);
                }
            });
            if (missedDeprecations.length !== 0) {
                throw new Error('Expected deprecation warnings did not happen: ' +
                        missedDeprecations.join(' '));
            }
        }
    }

    function matchedDeprecation(name, msg, deprecations) {
        if (deprecations == null) {
            return -1;
        }
        for (var i = 0; i < deprecations.length; ++i) {
            if (name != null && name === deprecations[i]) {
                return i;
            }
            if (msg != null && msg.substring(0, deprecations[i].length) === deprecations[i]) {
                return i;
            }
        }
        return -1;
    }

    /*global QUnit:false*/

    var test = QUnit.test;

    var expect = QUnit.expect;

    function module (name, lifecycle) {
        QUnit.module(name, {
            setup : function () {
                moment.locale('en');
                moment.createFromInputFallback = function (config) {
                    throw new Error('input not handled by moment: ' + config._i);
                };
                setupDeprecationHandler(test, moment, 'core');
                if (lifecycle && lifecycle.setup) {
                    lifecycle.setup();
                }
            },
            teardown : function () {
                teardownDeprecationHandler(test, moment, 'core');
                if (lifecycle && lifecycle.teardown) {
                    lifecycle.teardown();
                }
            }
        });
    }

    function localeModule (name, lifecycle) {
        QUnit.module('locale:' + name, {
            setup : function () {
                moment.locale(name);
                moment.createFromInputFallback = function (config) {
                    throw new Error('input not handled by moment: ' + config._i);
                };
                setupDeprecationHandler(test, moment, 'locale');
                if (lifecycle && lifecycle.setup) {
                    lifecycle.setup();
                }
            },
            teardown : function () {
                moment.locale('en');
                teardownDeprecationHandler(test, moment, 'locale');
                if (lifecycle && lifecycle.teardown) {
                    lifecycle.teardown();
                }
            }
        });
        defineCommonLocaleTests(name, -1, -1);
    }

    localeModule('pl');

    test('parse', function (assert) {
        var tests = 'styczeÅ stycznia sty_luty lutego lut_marzec marca mar_kwiecieÅ kwietnia kwi_maj maja maj_czerwiec czerwca cze_lipiec lipca lip_sierpieÅ sierpnia sie_wrzesieÅ wrzeÅnia wrz_paÅºdziernik paÅºdziernika paÅº_listopad listopada lis_grudzieÅ grudnia gru'.split('_'), i;
        function equalTest(input, mmm, i) {
            assert.equal(moment(input, mmm).month(), i, input + ' should be month ' + (i + 1));
        }
        for (i = 0; i < 12; i++) {
            tests[i] = tests[i].split(' ');
            equalTest(tests[i][0], 'MMM', i);
            equalTest(tests[i][1], 'MMM', i);
            equalTest(tests[i][2], 'MMM', i);
            equalTest(tests[i][0], 'MMMM', i);
            equalTest(tests[i][1], 'MMMM', i);
            equalTest(tests[i][2], 'MMMM', i);
            equalTest(tests[i][0].toLocaleLowerCase(), 'MMMM', i);
            equalTest(tests[i][1].toLocaleLowerCase(), 'MMMM', i);
            equalTest(tests[i][2].toLocaleLowerCase(), 'MMMM', i);
            equalTest(tests[i][0].toLocaleUpperCase(), 'MMMM', i);
            equalTest(tests[i][1].toLocaleUpperCase(), 'MMMM', i);
            equalTest(tests[i][2].toLocaleUpperCase(), 'MMMM', i);
        }
    });

    test('parse strict', function (assert) {
        var tests = 'styczeÅ stycznia sty_luty lutego lut_marzec marca mar_kwiecieÅ kwietnia kwi_maj maja maj_czerwiec czerwca cze_lipiec lipca lip_sierpieÅ sierpnia sie_wrzesieÅ wrzeÅnia wrz_paÅºdziernik paÅºdziernika paÅº_listopad listopada lis_grudzieÅ grudnia gru'.split('_'), i;
        function equalTest(input, mmm, i) {
            assert.equal(moment(input, mmm, true).month(), i, input + ' should be month ' + (i + 1));
        }
        for (i = 0; i < 12; i++) {
            tests[i] = tests[i].split(' ');
            equalTest(tests[i][0], 'MMMM', i);
            equalTest(tests[i][1], 'MMMM', i);
            equalTest(tests[i][2], 'MMM', i);
            equalTest(tests[i][0].toLocaleLowerCase(), 'MMMM', i);
            equalTest(tests[i][1].toLocaleLowerCase(), 'MMMM', i);
            equalTest(tests[i][2].toLocaleLowerCase(), 'MMM', i);
            equalTest(tests[i][0].toLocaleUpperCase(), 'MMMM', i);
            equalTest(tests[i][1].toLocaleUpperCase(), 'MMMM', i);
            equalTest(tests[i][2].toLocaleUpperCase(), 'MMM', i);
        }
    });

    test('format', function (assert) {
        var a = [
                ['dddd, MMMM Do YYYY, h:mm:ss a',      'niedziela, luty 14. 2010, 3:25:50 pm'],
                ['ddd, hA',                            'nie, 3PM'],
                ['M Mo MM MMMM MMM',                   '2 2. 02 luty lut'],
                ['YYYY YY',                            '2010 10'],
                ['D Do DD',                            '14 14. 14'],
                ['d do dddd ddd dd',                   '0 0. niedziela nie Nd'],
                ['DDD DDDo DDDD',                      '45 45. 045'],
                ['w wo ww',                            '6 6. 06'],
                ['h hh',                               '3 03'],
                ['H HH',                               '15 15'],
                ['m mm',                               '25 25'],
                ['s ss',                               '50 50'],
                ['a A',                                'pm PM'],
                ['[the] DDDo [day of the year]',       'the 45. day of the year'],
                ['LTS',                                '15:25:50'],
                ['L',                                  '14.02.2010'],
                ['LL',                                 '14 lutego 2010'],
                ['LLL',                                '14 lutego 2010 15:25'],
                ['LLLL',                               'niedziela, 14 lutego 2010 15:25'],
                ['l',                                  '14.2.2010'],
                ['ll',                                 '14 lut 2010'],
                ['lll',                                '14 lut 2010 15:25'],
                ['llll',                               'nie, 14 lut 2010 15:25']
            ],
            b = moment(new Date(2010, 1, 14, 15, 25, 50, 125)),
            i;
        for (i = 0; i < a.length; i++) {
            assert.equal(b.format(a[i][0]), a[i][1], a[i][0] + ' ---> ' + a[i][1]);
        }
    });

    test('format ordinal', function (assert) {
        assert.equal(moment([2011, 0, 1]).format('DDDo'), '1.', '1.');
        assert.equal(moment([2011, 0, 2]).format('DDDo'), '2.', '2.');
        assert.equal(moment([2011, 0, 3]).format('DDDo'), '3.', '3.');
        assert.equal(moment([2011, 0, 4]).format('DDDo'), '4.', '4.');
        assert.equal(moment([2011, 0, 5]).format('DDDo'), '5.', '5.');
        assert.equal(moment([2011, 0, 6]).format('DDDo'), '6.', '6.');
        assert.equal(moment([2011, 0, 7]).format('DDDo'), '7.', '7.');
        assert.equal(moment([2011, 0, 8]).format('DDDo'), '8.', '8.');
        assert.equal(moment([2011, 0, 9]).format('DDDo'), '9.', '9.');
        assert.equal(moment([2011, 0, 10]).format('DDDo'), '10.', '10.');

        assert.equal(moment([2011, 0, 11]).format('DDDo'), '11.', '11.');
        assert.equal(moment([2011, 0, 12]).format('DDDo'), '12.', '12.');
        assert.equal(moment([2011, 0, 13]).format('DDDo'), '13.', '13.');
        assert.equal(moment([2011, 0, 14]).format('DDDo'), '14.', '14.');
        assert.equal(moment([2011, 0, 15]).format('DDDo'), '15.', '15.');
        assert.equal(moment([2011, 0, 16]).format('DDDo'), '16.', '16.');
        assert.equal(moment([2011, 0, 17]).format('DDDo'), '17.', '17.');
        assert.equal(moment([2011, 0, 18]).format('DDDo'), '18.', '18.');
        assert.equal(moment([2011, 0, 19]).format('DDDo'), '19.', '19.');
        assert.equal(moment([2011, 0, 20]).format('DDDo'), '20.', '20.');

        assert.equal(moment([2011, 0, 21]).format('DDDo'), '21.', '21.');
        assert.equal(moment([2011, 0, 22]).format('DDDo'), '22.', '22.');
        assert.equal(moment([2011, 0, 23]).format('DDDo'), '23.', '23.');
        assert.equal(moment([2011, 0, 24]).format('DDDo'), '24.', '24.');
        assert.equal(moment([2011, 0, 25]).format('DDDo'), '25.', '25.');
        assert.equal(moment([2011, 0, 26]).format('DDDo'), '26.', '26.');
        assert.equal(moment([2011, 0, 27]).format('DDDo'), '27.', '27.');
        assert.equal(moment([2011, 0, 28]).format('DDDo'), '28.', '28.');
        assert.equal(moment([2011, 0, 29]).format('DDDo'), '29.', '29.');
        assert.equal(moment([2011, 0, 30]).format('DDDo'), '30.', '30.');

        assert.equal(moment([2011, 0, 31]).format('DDDo'), '31.', '31.');
    });

    test('format month', function (assert) {
        var expected = 'styczeÅ sty_luty lut_marzec mar_kwiecieÅ kwi_maj maj_czerwiec cze_lipiec lip_sierpieÅ sie_wrzesieÅ wrz_paÅºdziernik paÅº_listopad lis_grudzieÅ gru'.split('_'), i;
        for (i = 0; i < expected.length; i++) {
            assert.equal(moment([2011, i, 1]).format('MMMM MMM'), expected[i], expected[i]);
        }
    });

    test('format week', function (assert) {
        var expected = 'niedziela nie Nd_poniedziaÅek pon Pn_wtorek wt Wt_Åroda År År_czwartek czw Cz_piÄtek pt Pt_sobota sb So'.split('_'), i;
        for (i = 0; i < expected.length; i++) {
            assert.equal(moment([2011, 0, 2 + i]).format('dddd ddd dd'), expected[i], expected[i]);
        }
    });

    test('from', function (assert) {
        var start = moment([2007, 1, 28]);
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 44}), true),  'kilka sekund',  '44 seconds = a few seconds');
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 45}), true),  'minuta',        '45 seconds = a minute');
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 89}), true),  'minuta',        '89 seconds = a minute');
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 90}), true),  '2 minuty',      '90 seconds = 2 minutes');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 44}), true),  '44 minuty',     '44 minutes = 44 minutes');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 45}), true),  'godzina',       '45 minutes = an hour');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 89}), true),  'godzina',       '89 minutes = an hour');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 90}), true),  '2 godziny',     '90 minutes = 2 hours');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 5}), true),   '5 godzin',      '5 hours = 5 hours');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 21}), true),  '21 godzin',     '21 hours = 21 hours');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 22}), true),  '1 dzieÅ',       '22 hours = a day');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 35}), true),  '1 dzieÅ',       '35 hours = a day');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 36}), true),  '2 dni',         '36 hours = 2 days');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 1}), true),   '1 dzieÅ',       '1 day = a day');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 5}), true),   '5 dni',         '5 days = 5 days');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 25}), true),  '25 dni',        '25 days = 25 days');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 26}), true),  'miesiÄc',       '26 days = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 30}), true),  'miesiÄc',       '30 days = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 43}), true),  'miesiÄc',       '43 days = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 46}), true),  '2 miesiÄce',    '46 days = 2 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 74}), true),  '2 miesiÄce',    '75 days = 2 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 76}), true),  '3 miesiÄce',    '76 days = 3 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({M: 1}), true),   'miesiÄc',       '1 month = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({M: 5}), true),   '5 miesiÄcy',    '5 months = 5 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 345}), true), 'rok',           '345 days = a year');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 548}), true), '2 lata',        '548 days = 2 years');
        assert.equal(start.from(moment([2007, 1, 28]).add({y: 1}), true),   'rok',           '1 year = a year');
        assert.equal(start.from(moment([2007, 1, 28]).add({y: 5}), true),   '5 lat',         '5 years = 5 years');
        assert.equal(start.from(moment([2007, 1, 28]).add({y: 112}), true), '112 lat',       '112 years = 112 years');
        assert.equal(start.from(moment([2007, 1, 28]).add({y: 122}), true), '122 lata',      '122 years = 122 years');
        assert.equal(start.from(moment([2007, 1, 28]).add({y: 213}), true), '213 lat',       '213 years = 213 years');
        assert.equal(start.from(moment([2007, 1, 28]).add({y: 223}), true), '223 lata',      '223 years = 223 years');
    });

    test('suffix', function (assert) {
        assert.equal(moment(30000).from(0), 'za kilka sekund',  'prefix');
        assert.equal(moment(0).from(30000), 'kilka sekund temu', 'suffix');
    });

    test('now from now', function (assert) {
        assert.equal(moment().fromNow(), 'kilka sekund temu',  'now from now should display as in the past');
    });

    test('fromNow', function (assert) {
        assert.equal(moment().add({s: 30}).fromNow(), 'za kilka sekund', 'in a few seconds');
        assert.equal(moment().add({h: 1}).fromNow(), 'za godzinÄ', 'in an hour');
        assert.equal(moment().add({d: 5}).fromNow(), 'za 5 dni', 'in 5 days');
    });

    test('calendar day', function (assert) {
        var a = moment().hours(12).minutes(0).seconds(0);

        assert.equal(moment(a).calendar(),                   'DziÅ o 12:00',    'today at the same time');
        assert.equal(moment(a).add({m: 25}).calendar(),      'DziÅ o 12:25',    'Now plus 25 min');
        assert.equal(moment(a).add({h: 1}).calendar(),       'DziÅ o 13:00',    'Now plus 1 hour');
        assert.equal(moment(a).add({d: 1}).calendar(),       'Jutro o 12:00',   'tomorrow at the same time');
        assert.equal(moment(a).subtract({h: 1}).calendar(),  'DziÅ o 11:00',    'Now minus 1 hour');
        assert.equal(moment(a).subtract({d: 1}).calendar(),  'Wczoraj o 12:00', 'yesterday at the same time');
    });

    test('calendar next week', function (assert) {
        var i, m;
        for (i = 2; i < 7; i++) {
            m = moment().add({d: i});
            assert.equal(m.calendar(),       m.format('[W] dddd [o] LT'),  'Today + ' + i + ' days current time');
            m.hours(0).minutes(0).seconds(0).milliseconds(0);
            assert.equal(m.calendar(),       m.format('[W] dddd [o] LT'),  'Today + ' + i + ' days beginning of day');
            m.hours(23).minutes(59).seconds(59).milliseconds(999);
            assert.equal(m.calendar(),       m.format('[W] dddd [o] LT'),  'Today + ' + i + ' days end of day');
        }
    });

    test('calendar last week', function (assert) {
        var i, m;

        function makeFormat(d) {
            switch (d.day()) {
            case 0:
                return '[W zeszÅÄ niedzielÄ o] LT';
            case 3:
                return '[W zeszÅÄ ÅrodÄ o] LT';
            case 6:
                return '[W zeszÅÄ sobotÄ o] LT';
            default:
                return '[W zeszÅy] dddd [o] LT';
            }
        }

        for (i = 2; i < 7; i++) {
            m = moment().subtract({d: i});
            assert.equal(m.calendar(), m.format(makeFormat(m)), 'Today - ' + i + ' days current time');

            m.hours(0).minutes(0).seconds(0).milliseconds(0);
            assert.equal(m.calendar(), m.format(makeFormat(m)), 'Today - ' + i + ' days beginning of day');

            m.hours(23).minutes(59).seconds(59).milliseconds(999);
            assert.equal(m.calendar(), m.format(makeFormat(m)), 'Today - ' + i + ' days end of day');
        }
    });

    test('calendar all else', function (assert) {
        var weeksAgo = moment().subtract({w: 1}),
            weeksFromNow = moment().add({w: 1});

        assert.equal(weeksAgo.calendar(),       weeksAgo.format('L'),  '1 week ago');
        assert.equal(weeksFromNow.calendar(),   weeksFromNow.format('L'),  'in 1 week');

        weeksAgo = moment().subtract({w: 2});
        weeksFromNow = moment().add({w: 2});

        assert.equal(weeksAgo.calendar(),       weeksAgo.format('L'),  '2 weeks ago');
        assert.equal(weeksFromNow.calendar(),   weeksFromNow.format('L'),  'in 2 weeks');
    });

    test('weeks year starting sunday formatted', function (assert) {
        assert.equal(moment([2012, 0,  1]).format('w ww wo'), '52 52 52.', 'Jan  1 2012 should be week 52');
        assert.equal(moment([2012, 0,  2]).format('w ww wo'),   '1 01 1.', 'Jan  2 2012 should be week 1');
        assert.equal(moment([2012, 0,  8]).format('w ww wo'),   '1 01 1.', 'Jan  8 2012 should be week 1');
        assert.equal(moment([2012, 0,  9]).format('w ww wo'),   '2 02 2.', 'Jan  9 2012 should be week 2');
        assert.equal(moment([2012, 0, 15]).format('w ww wo'),   '2 02 2.', 'Jan 15 2012 should be week 2');
    });

}));

;(function (global, factory) {
   typeof exports === 'object' && typeof module !== 'undefined'
       && typeof require === 'function' ? factory(require('../../moment')) :
   typeof define === 'function' && define.amd ? define(['../../moment'], factory) :
   factory(global.moment)
}(this, function (moment) { 'use strict';

    function each(array, callback) {
        var i;
        for (i = 0; i < array.length; i++) {
            callback(array[i], i, array);
        }
    }

    function objectKeys(obj) {
        if (Object.keys) {
            return Object.keys(obj);
        } else {
            // IE8
            var res = [], i;
            for (i in obj) {
                if (obj.hasOwnProperty(i)) {
                    res.push(i);
                }
            }
            return res;
        }
    }

    // Pick the first defined of two or three arguments.
    function defaults(a, b, c) {
        if (a != null) {
            return a;
        }
        if (b != null) {
            return b;
        }
        return c;
    }

    function defineCommonLocaleTests(locale, options) {
        test('lenient ordinal parsing', function (assert) {
            var i, ordinalStr, testMoment;
            for (i = 1; i <= 31; ++i) {
                ordinalStr = moment([2014, 0, i]).format('YYYY MM Do');
                testMoment = moment(ordinalStr, 'YYYY MM Do');
                assert.equal(testMoment.year(), 2014,
                        'lenient ordinal parsing ' + i + ' year check');
                assert.equal(testMoment.month(), 0,
                        'lenient ordinal parsing ' + i + ' month check');
                assert.equal(testMoment.date(), i,
                        'lenient ordinal parsing ' + i + ' date check');
            }
        });

        test('lenient ordinal parsing of number', function (assert) {
            var i, testMoment;
            for (i = 1; i <= 31; ++i) {
                testMoment = moment('2014 01 ' + i, 'YYYY MM Do');
                assert.equal(testMoment.year(), 2014,
                        'lenient ordinal parsing of number ' + i + ' year check');
                assert.equal(testMoment.month(), 0,
                        'lenient ordinal parsing of number ' + i + ' month check');
                assert.equal(testMoment.date(), i,
                        'lenient ordinal parsing of number ' + i + ' date check');
            }
        });

        test('strict ordinal parsing', function (assert) {
            var i, ordinalStr, testMoment;
            for (i = 1; i <= 31; ++i) {
                ordinalStr = moment([2014, 0, i]).format('YYYY MM Do');
                testMoment = moment(ordinalStr, 'YYYY MM Do', true);
                assert.ok(testMoment.isValid(), 'strict ordinal parsing ' + i);
            }
        });

        test('meridiem invariant', function (assert) {
            var h, m, t1, t2;
            for (h = 0; h < 24; ++h) {
                for (m = 0; m < 60; m += 15) {
                    t1 = moment.utc([2000, 0, 1, h, m]);
                    t2 = moment.utc(t1.format('A h:mm'), 'A h:mm');
                    assert.equal(t2.format('HH:mm'), t1.format('HH:mm'),
                            'meridiem at ' + t1.format('HH:mm'));
                }
            }
        });

        test('date format correctness', function (assert) {
            var data, tokens;
            data = moment.localeData()._longDateFormat;
            tokens = objectKeys(data);
            each(tokens, function (srchToken) {
                // Check each format string to make sure it does not contain any
                // tokens that need to be expanded.
                each(tokens, function (baseToken) {
                    // strip escaped sequences
                    var format = data[baseToken].replace(/(\[[^\]]*\])/g, '');
                    assert.equal(false, !!~format.indexOf(srchToken),
                            'contains ' + srchToken + ' in ' + baseToken);
                });
            });
        });

        test('month parsing correctness', function (assert) {
            var i, m;

            if (locale === 'tr') {
                // I can't fix it :(
                expect(0);
                return;
            }
            function tester(format) {
                var r;
                r = moment(m.format(format), format);
                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format);
                r = moment(m.format(format).toLocaleUpperCase(), format);
                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' upper');
                r = moment(m.format(format).toLocaleLowerCase(), format);
                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' lower');

                r = moment(m.format(format), format, true);
                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' strict');
                r = moment(m.format(format).toLocaleUpperCase(), format, true);
                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' upper strict');
                r = moment(m.format(format).toLocaleLowerCase(), format, true);
                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' lower strict');
            }

            for (i = 0; i < 12; ++i) {
                m = moment([2015, i, 15, 18]);
                tester('MMM');
                tester('MMM.');
                tester('MMMM');
                tester('MMMM.');
            }
        });

        test('weekday parsing correctness', function (assert) {
            var i, m;

            if (locale === 'tr' || locale === 'az') {
                // There is a lower-case letter (Ä±), that converted to upper then
                // lower changes to i
                expect(0);
                return;
            }
            function tester(format) {
                var r, baseMsg = 'weekday ' + m.weekday() + ' fmt ' + format;
                r = moment(m.format(format), format);
                assert.equal(r.weekday(), m.weekday(), baseMsg);
                r = moment(m.format(format).toLocaleUpperCase(), format);
                assert.equal(r.weekday(), m.weekday(), baseMsg + ' upper');
                r = moment(m.format(format).toLocaleLowerCase(), format);
                assert.equal(r.weekday(), m.weekday(), baseMsg + ' lower');

                r = moment(m.format(format), format, true);
                assert.equal(r.weekday(), m.weekday(), baseMsg + ' strict');
                r = moment(m.format(format).toLocaleUpperCase(), format, true);
                assert.equal(r.weekday(), m.weekday(), baseMsg + ' upper strict');
                r = moment(m.format(format).toLocaleLowerCase(), format, true);
                assert.equal(r.weekday(), m.weekday(), baseMsg + ' lower strict');
            }

            for (i = 0; i < 7; ++i) {
                m = moment.utc([2015, i, 15, 18]);
                tester('dd');
                tester('ddd');
                tester('dddd');
            }
        });
    }

    function setupDeprecationHandler(test, moment, scope) {
        test._expectedDeprecations = null;
        test._observedDeprecations = null;
        test._oldSupress = moment.suppressDeprecationWarnings;
        moment.suppressDeprecationWarnings = true;
        test.expectedDeprecations = function () {
            test._expectedDeprecations = arguments;
            test._observedDeprecations = [];
        };
        moment.deprecationHandler = function (name, msg) {
            var deprecationId = matchedDeprecation(name, msg, test._expectedDeprecations);
            if (deprecationId === -1) {
                throw new Error('Unexpected deprecation thrown name=' +
                        name + ' msg=' + msg);
            }
            test._observedDeprecations[deprecationId] = 1;
        };
    }

    function teardownDeprecationHandler(test, moment, scope) {
        moment.suppressDeprecationWarnings = test._oldSupress;

        if (test._expectedDeprecations != null) {
            var missedDeprecations = [];
            each(test._expectedDeprecations, function (deprecationPattern, id) {
                if (test._observedDeprecations[id] !== 1) {
                    missedDeprecations.push(deprecationPattern);
                }
            });
            if (missedDeprecations.length !== 0) {
                throw new Error('Expected deprecation warnings did not happen: ' +
                        missedDeprecations.join(' '));
            }
        }
    }

    function matchedDeprecation(name, msg, deprecations) {
        if (deprecations == null) {
            return -1;
        }
        for (var i = 0; i < deprecations.length; ++i) {
            if (name != null && name === deprecations[i]) {
                return i;
            }
            if (msg != null && msg.substring(0, deprecations[i].length) === deprecations[i]) {
                return i;
            }
        }
        return -1;
    }

    /*global QUnit:false*/

    var test = QUnit.test;

    var expect = QUnit.expect;

    function module (name, lifecycle) {
        QUnit.module(name, {
            setup : function () {
                moment.locale('en');
                moment.createFromInputFallback = function (config) {
                    throw new Error('input not handled by moment: ' + config._i);
                };
                setupDeprecationHandler(test, moment, 'core');
                if (lifecycle && lifecycle.setup) {
                    lifecycle.setup();
                }
            },
            teardown : function () {
                teardownDeprecationHandler(test, moment, 'core');
                if (lifecycle && lifecycle.teardown) {
                    lifecycle.teardown();
                }
            }
        });
    }

    function localeModule (name, lifecycle) {
        QUnit.module('locale:' + name, {
            setup : function () {
                moment.locale(name);
                moment.createFromInputFallback = function (config) {
                    throw new Error('input not handled by moment: ' + config._i);
                };
                setupDeprecationHandler(test, moment, 'locale');
                if (lifecycle && lifecycle.setup) {
                    lifecycle.setup();
                }
            },
            teardown : function () {
                moment.locale('en');
                teardownDeprecationHandler(test, moment, 'locale');
                if (lifecycle && lifecycle.teardown) {
                    lifecycle.teardown();
                }
            }
        });
        defineCommonLocaleTests(name, -1, -1);
    }

    localeModule('pt-br');

    test('parse', function (assert) {
        var tests = 'janeiro jan_fevereiro fev_marÃ§o mar_abril abr_maio mai_junho jun_julho jul_agosto ago_setembro set_outubro out_novembro nov_dezembro dez'.split('_'), i;

        function equalTest(input, mmm, i) {
            assert.equal(moment(input, mmm).month(), i, input + ' should be month ' + (i + 1));
        }

        for (i = 0; i < 12; i++) {
            tests[i] = tests[i].split(' ');
            equalTest(tests[i][0], 'MMM', i);
            equalTest(tests[i][1], 'MMM', i);
            equalTest(tests[i][0], 'MMMM', i);
            equalTest(tests[i][1], 'MMMM', i);
            equalTest(tests[i][0].toLocaleLowerCase(), 'MMMM', i);
            equalTest(tests[i][1].toLocaleLowerCase(), 'MMMM', i);
            equalTest(tests[i][0].toLocaleUpperCase(), 'MMMM', i);
            equalTest(tests[i][1].toLocaleUpperCase(), 'MMMM', i);
        }
    });

    test('format', function (assert) {
        var a = [
                ['dddd, MMMM Do YYYY, h:mm:ss a',      'Domingo, Fevereiro 14Âº 2010, 3:25:50 pm'],
                ['ddd, hA',                            'Dom, 3PM'],
                ['M Mo MM MMMM MMM',                   '2 2Âº 02 Fevereiro Fev'],
                ['YYYY YY',                            '2010 10'],
                ['D Do DD',                            '14 14Âº 14'],
                ['d do dddd ddd',                      '0 0Âº Domingo Dom'],
                ['DDD DDDo DDDD',                      '45 45Âº 045'],
                ['w wo ww',                            '8 8Âº 08'],
                ['h hh',                               '3 03'],
                ['H HH',                               '15 15'],
                ['m mm',                               '25 25'],
                ['s ss',                               '50 50'],
                ['a A',                                'pm PM'],
                ['[the] DDDo [day of the year]',       'the 45Âº day of the year'],
                ['LTS',                                '15:25:50'],
                ['L',                                  '14/02/2010'],
                ['LL',                                 '14 de Fevereiro de 2010'],
                ['LLL',                                '14 de Fevereiro de 2010 Ã s 15:25'],
                ['LLLL',                               'Domingo, 14 de Fevereiro de 2010 Ã s 15:25'],
                ['l',                                  '14/2/2010'],
                ['ll',                                 '14 de Fev de 2010'],
                ['lll',                                '14 de Fev de 2010 Ã s 15:25'],
                ['llll',                               'Dom, 14 de Fev de 2010 Ã s 15:25']
            ],
            b = moment(new Date(2010, 1, 14, 15, 25, 50, 125)),
            i;
        for (i = 0; i < a.length; i++) {
            assert.equal(b.format(a[i][0]), a[i][1], a[i][0] + ' ---> ' + a[i][1]);
        }
    });

    test('format ordinal', function (assert) {
        assert.equal(moment([2011, 0, 1]).format('DDDo'), '1Âº', '1Âº');
        assert.equal(moment([2011, 0, 2]).format('DDDo'), '2Âº', '2Âº');
        assert.equal(moment([2011, 0, 3]).format('DDDo'), '3Âº', '3Âº');
        assert.equal(moment([2011, 0, 4]).format('DDDo'), '4Âº', '4Âº');
        assert.equal(moment([2011, 0, 5]).format('DDDo'), '5Âº', '5Âº');
        assert.equal(moment([2011, 0, 6]).format('DDDo'), '6Âº', '6Âº');
        assert.equal(moment([2011, 0, 7]).format('DDDo'), '7Âº', '7Âº');
        assert.equal(moment([2011, 0, 8]).format('DDDo'), '8Âº', '8Âº');
        assert.equal(moment([2011, 0, 9]).format('DDDo'), '9Âº', '9Âº');
        assert.equal(moment([2011, 0, 10]).format('DDDo'), '10Âº', '10Âº');

        assert.equal(moment([2011, 0, 11]).format('DDDo'), '11Âº', '11Âº');
        assert.equal(moment([2011, 0, 12]).format('DDDo'), '12Âº', '12Âº');
        assert.equal(moment([2011, 0, 13]).format('DDDo'), '13Âº', '13Âº');
        assert.equal(moment([2011, 0, 14]).format('DDDo'), '14Âº', '14Âº');
        assert.equal(moment([2011, 0, 15]).format('DDDo'), '15Âº', '15Âº');
        assert.equal(moment([2011, 0, 16]).format('DDDo'), '16Âº', '16Âº');
        assert.equal(moment([2011, 0, 17]).format('DDDo'), '17Âº', '17Âº');
        assert.equal(moment([2011, 0, 18]).format('DDDo'), '18Âº', '18Âº');
        assert.equal(moment([2011, 0, 19]).format('DDDo'), '19Âº', '19Âº');
        assert.equal(moment([2011, 0, 20]).format('DDDo'), '20Âº', '20Âº');

        assert.equal(moment([2011, 0, 21]).format('DDDo'), '21Âº', '21Âº');
        assert.equal(moment([2011, 0, 22]).format('DDDo'), '22Âº', '22Âº');
        assert.equal(moment([2011, 0, 23]).format('DDDo'), '23Âº', '23Âº');
        assert.equal(moment([2011, 0, 24]).format('DDDo'), '24Âº', '24Âº');
        assert.equal(moment([2011, 0, 25]).format('DDDo'), '25Âº', '25Âº');
        assert.equal(moment([2011, 0, 26]).format('DDDo'), '26Âº', '26Âº');
        assert.equal(moment([2011, 0, 27]).format('DDDo'), '27Âº', '27Âº');
        assert.equal(moment([2011, 0, 28]).format('DDDo'), '28Âº', '28Âº');
        assert.equal(moment([2011, 0, 29]).format('DDDo'), '29Âº', '29Âº');
        assert.equal(moment([2011, 0, 30]).format('DDDo'), '30Âº', '30Âº');

        assert.equal(moment([2011, 0, 31]).format('DDDo'), '31Âº', '31Âº');
    });

    test('format month', function (assert) {
        var expected = 'Janeiro Jan_Fevereiro Fev_MarÃ§o Mar_Abril Abr_Maio Mai_Junho Jun_Julho Jul_Agosto Ago_Setembro Set_Outubro Out_Novembro Nov_Dezembro Dez'.split('_'), i;
        for (i = 0; i < expected.length; i++) {
            assert.equal(moment([2011, i, 1]).format('MMMM MMM'), expected[i], expected[i]);
        }
    });

    test('format week', function (assert) {
        var expected = 'Domingo Dom_Segunda-feira Seg_TerÃ§a-feira Ter_Quarta-feira Qua_Quinta-feira Qui_Sexta-feira Sex_SÃ¡bado SÃ¡b'.split('_'), i;
        for (i = 0; i < expected.length; i++) {
            assert.equal(moment([2011, 0, 2 + i]).format('dddd ddd'), expected[i], expected[i]);
        }
    });

    test('from', function (assert) {
        var start = moment([2007, 1, 28]);
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 44}), true),  'poucos segundos', '44 seconds = seconds');
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 45}), true),  'um minuto',   '45 seconds = a minute');
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 89}), true),  'um minuto',   '89 seconds = a minute');
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 90}), true),  '2 minutos',  '90 seconds = 2 minutes');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 44}), true),  '44 minutos', '44 minutes = 44 minutes');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 45}), true),  'uma hora',    '45 minutes = an hour');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 89}), true),  'uma hora',    '89 minutes = an hour');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 90}), true),  '2 horas',    '90 minutes = 2 hours');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 5}), true),   '5 horas',    '5 hours = 5 hours');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 21}), true),  '21 horas',   '21 hours = 21 hours');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 22}), true),  'um dia',      '22 hours = a day');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 35}), true),  'um dia',      '35 hours = a day');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 36}), true),  '2 dias',     '36 hours = 2 days');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 1}), true),   'um dia',      '1 day = a day');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 5}), true),   '5 dias',     '5 days = 5 days');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 25}), true),  '25 dias',    '25 days = 25 days');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 26}), true),  'um mÃªs',    '26 days = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 30}), true),  'um mÃªs',    '30 days = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 43}), true),  'um mÃªs',    '43 days = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 46}), true),  '2 meses',   '46 days = 2 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 74}), true),  '2 meses',   '75 days = 2 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 76}), true),  '3 meses',   '76 days = 3 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({M: 1}), true),   'um mÃªs',    '1 month = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({M: 5}), true),   '5 meses',   '5 months = 5 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 345}), true), 'um ano',     '345 days = a year');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 548}), true), '2 anos',    '548 days = 2 years');
        assert.equal(start.from(moment([2007, 1, 28]).add({y: 1}), true),   'um ano',     '1 year = a year');
        assert.equal(start.from(moment([2007, 1, 28]).add({y: 5}), true),   '5 anos',    '5 years = 5 years');
    });

    test('suffix', function (assert) {
        assert.equal(moment(30000).from(0), 'em poucos segundos', 'prefix');
        assert.equal(moment(0).from(30000), 'poucos segundos atrÃ¡s', 'suffix');
    });

    test('fromNow', function (assert) {
        assert.equal(moment().add({s: 30}).fromNow(), 'em poucos segundos', 'in seconds');
        assert.equal(moment().add({d: 5}).fromNow(), 'em 5 dias', 'in 5 days');
    });

    test('calendar day', function (assert) {
        var a = moment().hours(12).minutes(0).seconds(0);

        assert.equal(moment(a).calendar(),                   'Hoje Ã s 12:00',    'today at the same time');
        assert.equal(moment(a).add({m: 25}).calendar(),      'Hoje Ã s 12:25',    'Now plus 25 min');
        assert.equal(moment(a).add({h: 1}).calendar(),       'Hoje Ã s 13:00',    'Now plus 1 hour');
        assert.equal(moment(a).add({d: 1}).calendar(),       'AmanhÃ£ Ã s 12:00',  'tomorrow at the same time');
        assert.equal(moment(a).subtract({h: 1}).calendar(),  'Hoje Ã s 11:00',    'Now minus 1 hour');
        assert.equal(moment(a).subtract({d: 1}).calendar(),  'Ontem Ã s 12:00',   'yesterday at the same time');
    });

    test('calendar next week', function (assert) {
        var i, m;
        for (i = 2; i < 7; i++) {
            m = moment().add({d: i});
            assert.equal(m.calendar(),       m.format('dddd [Ã s] LT'),  'Today + ' + i + ' days current time');
            m.hours(0).minutes(0).seconds(0).milliseconds(0);
            assert.equal(m.calendar(),       m.format('dddd [Ã s] LT'),  'Today + ' + i + ' days beginning of day');
            m.hours(23).minutes(59).seconds(59).milliseconds(999);
            assert.equal(m.calendar(),       m.format('dddd [Ã s] LT'),  'Today + ' + i + ' days end of day');
        }
    });

    test('calendar last week', function (assert) {
        var i, m;
        for (i = 2; i < 7; i++) {
            m = moment().subtract({d: i});
            assert.equal(m.calendar(),       m.format((m.day() === 0 || m.day() === 6) ? '[Ãltimo] dddd [Ã s] LT' : '[Ãltima] dddd [Ã s] LT'),  'Today - ' + i + ' days current time');
            m.hours(0).minutes(0).seconds(0).milliseconds(0);
            assert.equal(m.calendar(),       m.format((m.day() === 0 || m.day() === 6) ? '[Ãltimo] dddd [Ã s] LT' : '[Ãltima] dddd [Ã s] LT'),  'Today - ' + i + ' days beginning of day');
            m.hours(23).minutes(59).seconds(59).milliseconds(999);
            assert.equal(m.calendar(),       m.format((m.day() === 0 || m.day() === 6) ? '[Ãltimo] dddd [Ã s] LT' : '[Ãltima] dddd [Ã s] LT'),  'Today - ' + i + ' days end of day');
        }
    });

    test('calendar all else', function (assert) {
        var weeksAgo = moment().subtract({w: 1}),
            weeksFromNow = moment().add({w: 1});

        assert.equal(weeksAgo.calendar(),       weeksAgo.format('L'),  '1 week ago');
        assert.equal(weeksFromNow.calendar(),   weeksFromNow.format('L'),  'in 1 week');

        weeksAgo = moment().subtract({w: 2});
        weeksFromNow = moment().add({w: 2});

        assert.equal(weeksAgo.calendar(),       weeksAgo.format('L'),  '2 weeks ago');
        assert.equal(weeksFromNow.calendar(),   weeksFromNow.format('L'),  'in 2 weeks');
    });

    test('weeks year starting sunday format', function (assert) {
        assert.equal(moment([2012, 0,  1]).format('w ww wo'), '1 01 1Âº', 'Jan  1 2012 should be week 1');
        assert.equal(moment([2012, 0,  7]).format('w ww wo'), '1 01 1Âº', 'Jan  7 2012 should be week 1');
        assert.equal(moment([2012, 0,  8]).format('w ww wo'), '2 02 2Âº', 'Jan  8 2012 should be week 2');
        assert.equal(moment([2012, 0, 14]).format('w ww wo'), '2 02 2Âº', 'Jan 14 2012 should be week 2');
        assert.equal(moment([2012, 0, 15]).format('w ww wo'), '3 03 3Âº', 'Jan 15 2012 should be week 3');
    });

}));

;(function (global, factory) {
   typeof exports === 'object' && typeof module !== 'undefined'
       && typeof require === 'function' ? factory(require('../../moment')) :
   typeof define === 'function' && define.amd ? define(['../../moment'], factory) :
   factory(global.moment)
}(this, function (moment) { 'use strict';

    function each(array, callback) {
        var i;
        for (i = 0; i < array.length; i++) {
            callback(array[i], i, array);
        }
    }

    function objectKeys(obj) {
        if (Object.keys) {
            return Object.keys(obj);
        } else {
            // IE8
            var res = [], i;
            for (i in obj) {
                if (obj.hasOwnProperty(i)) {
                    res.push(i);
                }
            }
            return res;
        }
    }

    // Pick the first defined of two or three arguments.
    function defaults(a, b, c) {
        if (a != null) {
            return a;
        }
        if (b != null) {
            return b;
        }
        return c;
    }

    function defineCommonLocaleTests(locale, options) {
        test('lenient ordinal parsing', function (assert) {
            var i, ordinalStr, testMoment;
            for (i = 1; i <= 31; ++i) {
                ordinalStr = moment([2014, 0, i]).format('YYYY MM Do');
                testMoment = moment(ordinalStr, 'YYYY MM Do');
                assert.equal(testMoment.year(), 2014,
                        'lenient ordinal parsing ' + i + ' year check');
                assert.equal(testMoment.month(), 0,
                        'lenient ordinal parsing ' + i + ' month check');
                assert.equal(testMoment.date(), i,
                        'lenient ordinal parsing ' + i + ' date check');
            }
        });

        test('lenient ordinal parsing of number', function (assert) {
            var i, testMoment;
            for (i = 1; i <= 31; ++i) {
                testMoment = moment('2014 01 ' + i, 'YYYY MM Do');
                assert.equal(testMoment.year(), 2014,
                        'lenient ordinal parsing of number ' + i + ' year check');
                assert.equal(testMoment.month(), 0,
                        'lenient ordinal parsing of number ' + i + ' month check');
                assert.equal(testMoment.date(), i,
                        'lenient ordinal parsing of number ' + i + ' date check');
            }
        });

        test('strict ordinal parsing', function (assert) {
            var i, ordinalStr, testMoment;
            for (i = 1; i <= 31; ++i) {
                ordinalStr = moment([2014, 0, i]).format('YYYY MM Do');
                testMoment = moment(ordinalStr, 'YYYY MM Do', true);
                assert.ok(testMoment.isValid(), 'strict ordinal parsing ' + i);
            }
        });

        test('meridiem invariant', function (assert) {
            var h, m, t1, t2;
            for (h = 0; h < 24; ++h) {
                for (m = 0; m < 60; m += 15) {
                    t1 = moment.utc([2000, 0, 1, h, m]);
                    t2 = moment.utc(t1.format('A h:mm'), 'A h:mm');
                    assert.equal(t2.format('HH:mm'), t1.format('HH:mm'),
                            'meridiem at ' + t1.format('HH:mm'));
                }
            }
        });

        test('date format correctness', function (assert) {
            var data, tokens;
            data = moment.localeData()._longDateFormat;
            tokens = objectKeys(data);
            each(tokens, function (srchToken) {
                // Check each format string to make sure it does not contain any
                // tokens that need to be expanded.
                each(tokens, function (baseToken) {
                    // strip escaped sequences
                    var format = data[baseToken].replace(/(\[[^\]]*\])/g, '');
                    assert.equal(false, !!~format.indexOf(srchToken),
                            'contains ' + srchToken + ' in ' + baseToken);
                });
            });
        });

        test('month parsing correctness', function (assert) {
            var i, m;

            if (locale === 'tr') {
                // I can't fix it :(
                expect(0);
                return;
            }
            function tester(format) {
                var r;
                r = moment(m.format(format), format);
                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format);
                r = moment(m.format(format).toLocaleUpperCase(), format);
                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' upper');
                r = moment(m.format(format).toLocaleLowerCase(), format);
                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' lower');

                r = moment(m.format(format), format, true);
                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' strict');
                r = moment(m.format(format).toLocaleUpperCase(), format, true);
                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' upper strict');
                r = moment(m.format(format).toLocaleLowerCase(), format, true);
                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' lower strict');
            }

            for (i = 0; i < 12; ++i) {
                m = moment([2015, i, 15, 18]);
                tester('MMM');
                tester('MMM.');
                tester('MMMM');
                tester('MMMM.');
            }
        });

        test('weekday parsing correctness', function (assert) {
            var i, m;

            if (locale === 'tr' || locale === 'az') {
                // There is a lower-case letter (Ä±), that converted to upper then
                // lower changes to i
                expect(0);
                return;
            }
            function tester(format) {
                var r, baseMsg = 'weekday ' + m.weekday() + ' fmt ' + format;
                r = moment(m.format(format), format);
                assert.equal(r.weekday(), m.weekday(), baseMsg);
                r = moment(m.format(format).toLocaleUpperCase(), format);
                assert.equal(r.weekday(), m.weekday(), baseMsg + ' upper');
                r = moment(m.format(format).toLocaleLowerCase(), format);
                assert.equal(r.weekday(), m.weekday(), baseMsg + ' lower');

                r = moment(m.format(format), format, true);
                assert.equal(r.weekday(), m.weekday(), baseMsg + ' strict');
                r = moment(m.format(format).toLocaleUpperCase(), format, true);
                assert.equal(r.weekday(), m.weekday(), baseMsg + ' upper strict');
                r = moment(m.format(format).toLocaleLowerCase(), format, true);
                assert.equal(r.weekday(), m.weekday(), baseMsg + ' lower strict');
            }

            for (i = 0; i < 7; ++i) {
                m = moment.utc([2015, i, 15, 18]);
                tester('dd');
                tester('ddd');
                tester('dddd');
            }
        });
    }

    function setupDeprecationHandler(test, moment, scope) {
        test._expectedDeprecations = null;
        test._observedDeprecations = null;
        test._oldSupress = moment.suppressDeprecationWarnings;
        moment.suppressDeprecationWarnings = true;
        test.expectedDeprecations = function () {
            test._expectedDeprecations = arguments;
            test._observedDeprecations = [];
        };
        moment.deprecationHandler = function (name, msg) {
            var deprecationId = matchedDeprecation(name, msg, test._expectedDeprecations);
            if (deprecationId === -1) {
                throw new Error('Unexpected deprecation thrown name=' +
                        name + ' msg=' + msg);
            }
            test._observedDeprecations[deprecationId] = 1;
        };
    }

    function teardownDeprecationHandler(test, moment, scope) {
        moment.suppressDeprecationWarnings = test._oldSupress;

        if (test._expectedDeprecations != null) {
            var missedDeprecations = [];
            each(test._expectedDeprecations, function (deprecationPattern, id) {
                if (test._observedDeprecations[id] !== 1) {
                    missedDeprecations.push(deprecationPattern);
                }
            });
            if (missedDeprecations.length !== 0) {
                throw new Error('Expected deprecation warnings did not happen: ' +
                        missedDeprecations.join(' '));
            }
        }
    }

    function matchedDeprecation(name, msg, deprecations) {
        if (deprecations == null) {
            return -1;
        }
        for (var i = 0; i < deprecations.length; ++i) {
            if (name != null && name === deprecations[i]) {
                return i;
            }
            if (msg != null && msg.substring(0, deprecations[i].length) === deprecations[i]) {
                return i;
            }
        }
        return -1;
    }

    /*global QUnit:false*/

    var test = QUnit.test;

    var expect = QUnit.expect;

    function module (name, lifecycle) {
        QUnit.module(name, {
            setup : function () {
                moment.locale('en');
                moment.createFromInputFallback = function (config) {
                    throw new Error('input not handled by moment: ' + config._i);
                };
                setupDeprecationHandler(test, moment, 'core');
                if (lifecycle && lifecycle.setup) {
                    lifecycle.setup();
                }
            },
            teardown : function () {
                teardownDeprecationHandler(test, moment, 'core');
                if (lifecycle && lifecycle.teardown) {
                    lifecycle.teardown();
                }
            }
        });
    }

    function localeModule (name, lifecycle) {
        QUnit.module('locale:' + name, {
            setup : function () {
                moment.locale(name);
                moment.createFromInputFallback = function (config) {
                    throw new Error('input not handled by moment: ' + config._i);
                };
                setupDeprecationHandler(test, moment, 'locale');
                if (lifecycle && lifecycle.setup) {
                    lifecycle.setup();
                }
            },
            teardown : function () {
                moment.locale('en');
                teardownDeprecationHandler(test, moment, 'locale');
                if (lifecycle && lifecycle.teardown) {
                    lifecycle.teardown();
                }
            }
        });
        defineCommonLocaleTests(name, -1, -1);
    }

    localeModule('pt');

    test('parse', function (assert) {
        var tests = 'Janeiro Jan_Fevereiro Fev_MarÃ§o Mar_Abril Abr_Maio Mai_Junho Jun_Julho Jul_Agosto Ago_Setembro Set_Outubro Out_Novembro Nov_Dezembro Dez'.split('_'), i;
        function equalTest(input, mmm, i) {
            assert.equal(moment(input, mmm).month(), i, input + ' should be month ' + (i + 1));
        }
        for (i = 0; i < 12; i++) {
            tests[i] = tests[i].split(' ');
            equalTest(tests[i][0], 'MMM', i);
            equalTest(tests[i][1], 'MMM', i);
            equalTest(tests[i][0], 'MMMM', i);
            equalTest(tests[i][1], 'MMMM', i);
            equalTest(tests[i][0].toLocaleLowerCase(), 'MMMM', i);
            equalTest(tests[i][1].toLocaleLowerCase(), 'MMMM', i);
            equalTest(tests[i][0].toLocaleUpperCase(), 'MMMM', i);
            equalTest(tests[i][1].toLocaleUpperCase(), 'MMMM', i);
        }
    });

    test('format', function (assert) {
        var a = [
                ['dddd, MMMM Do YYYY, h:mm:ss a',      'Domingo, Fevereiro 14Âº 2010, 3:25:50 pm'],
                ['ddd, hA',                            'Dom, 3PM'],
                ['M Mo MM MMMM MMM',                   '2 2Âº 02 Fevereiro Fev'],
                ['YYYY YY',                            '2010 10'],
                ['D Do DD',                            '14 14Âº 14'],
                ['d do dddd ddd',                      '0 0Âº Domingo Dom'],
                ['DDD DDDo DDDD',                      '45 45Âº 045'],
                ['w wo ww',                            '6 6Âº 06'],
                ['h hh',                               '3 03'],
                ['H HH',                               '15 15'],
                ['m mm',                               '25 25'],
                ['s ss',                               '50 50'],
                ['a A',                                'pm PM'],
                ['[the] DDDo [day of the year]',       'the 45Âº day of the year'],
                ['LTS',                                '15:25:50'],
                ['L',                                  '14/02/2010'],
                ['LL',                                 '14 de Fevereiro de 2010'],
                ['LLL',                                '14 de Fevereiro de 2010 15:25'],
                ['LLLL',                               'Domingo, 14 de Fevereiro de 2010 15:25'],
                ['l',                                  '14/2/2010'],
                ['ll',                                 '14 de Fev de 2010'],
                ['lll',                                '14 de Fev de 2010 15:25'],
                ['llll',                               'Dom, 14 de Fev de 2010 15:25']
            ],
            b = moment(new Date(2010, 1, 14, 15, 25, 50, 125)),
            i;
        for (i = 0; i < a.length; i++) {
            assert.equal(b.format(a[i][0]), a[i][1], a[i][0] + ' ---> ' + a[i][1]);
        }
    });

    test('format ordinal', function (assert) {
        assert.equal(moment([2011, 0, 1]).format('DDDo'), '1Âº', '1Âº');
        assert.equal(moment([2011, 0, 2]).format('DDDo'), '2Âº', '2Âº');
        assert.equal(moment([2011, 0, 3]).format('DDDo'), '3Âº', '3Âº');
        assert.equal(moment([2011, 0, 4]).format('DDDo'), '4Âº', '4Âº');
        assert.equal(moment([2011, 0, 5]).format('DDDo'), '5Âº', '5Âº');
        assert.equal(moment([2011, 0, 6]).format('DDDo'), '6Âº', '6Âº');
        assert.equal(moment([2011, 0, 7]).format('DDDo'), '7Âº', '7Âº');
        assert.equal(moment([2011, 0, 8]).format('DDDo'), '8Âº', '8Âº');
        assert.equal(moment([2011, 0, 9]).format('DDDo'), '9Âº', '9Âº');
        assert.equal(moment([2011, 0, 10]).format('DDDo'), '10Âº', '10Âº');

        assert.equal(moment([2011, 0, 11]).format('DDDo'), '11Âº', '11Âº');
        assert.equal(moment([2011, 0, 12]).format('DDDo'), '12Âº', '12Âº');
        assert.equal(moment([2011, 0, 13]).format('DDDo'), '13Âº', '13Âº');
        assert.equal(moment([2011, 0, 14]).format('DDDo'), '14Âº', '14Âº');
        assert.equal(moment([2011, 0, 15]).format('DDDo'), '15Âº', '15Âº');
        assert.equal(moment([2011, 0, 16]).format('DDDo'), '16Âº', '16Âº');
        assert.equal(moment([2011, 0, 17]).format('DDDo'), '17Âº', '17Âº');
        assert.equal(moment([2011, 0, 18]).format('DDDo'), '18Âº', '18Âº');
        assert.equal(moment([2011, 0, 19]).format('DDDo'), '19Âº', '19Âº');
        assert.equal(moment([2011, 0, 20]).format('DDDo'), '20Âº', '20Âº');

        assert.equal(moment([2011, 0, 21]).format('DDDo'), '21Âº', '21Âº');
        assert.equal(moment([2011, 0, 22]).format('DDDo'), '22Âº', '22Âº');
        assert.equal(moment([2011, 0, 23]).format('DDDo'), '23Âº', '23Âº');
        assert.equal(moment([2011, 0, 24]).format('DDDo'), '24Âº', '24Âº');
        assert.equal(moment([2011, 0, 25]).format('DDDo'), '25Âº', '25Âº');
        assert.equal(moment([2011, 0, 26]).format('DDDo'), '26Âº', '26Âº');
        assert.equal(moment([2011, 0, 27]).format('DDDo'), '27Âº', '27Âº');
        assert.equal(moment([2011, 0, 28]).format('DDDo'), '28Âº', '28Âº');
        assert.equal(moment([2011, 0, 29]).format('DDDo'), '29Âº', '29Âº');
        assert.equal(moment([2011, 0, 30]).format('DDDo'), '30Âº', '30Âº');

        assert.equal(moment([2011, 0, 31]).format('DDDo'), '31Âº', '31Âº');
    });

    test('format month', function (assert) {
        var expected = 'Janeiro Jan_Fevereiro Fev_MarÃ§o Mar_Abril Abr_Maio Mai_Junho Jun_Julho Jul_Agosto Ago_Setembro Set_Outubro Out_Novembro Nov_Dezembro Dez'.split('_'), i;
        for (i = 0; i < expected.length; i++) {
            assert.equal(moment([2011, i, 1]).format('MMMM MMM'), expected[i], expected[i]);
        }
    });

    test('format week', function (assert) {
        var expected = 'Domingo Dom Dom_Segunda-Feira Seg 2Âª_TerÃ§a-Feira Ter 3Âª_Quarta-Feira Qua 4Âª_Quinta-Feira Qui 5Âª_Sexta-Feira Sex 6Âª_SÃ¡bado SÃ¡b SÃ¡b'.split('_'), i;
        for (i = 0; i < expected.length; i++) {
            assert.equal(moment([2011, 0, 2 + i]).format('dddd ddd dd'), expected[i], expected[i]);
        }
    });

    test('from', function (assert) {
        var start = moment([2007, 1, 28]);
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 44}), true),  'segundos',    '44 seconds = seconds');
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 45}), true),  'um minuto',   '45 seconds = a minute');
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 89}), true),  'um minuto',   '89 seconds = a minute');
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 90}), true),  '2 minutos',  '90 seconds = 2 minutes');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 44}), true),  '44 minutos', '44 minutes = 44 minutes');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 45}), true),  'uma hora',    '45 minutes = an hour');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 89}), true),  'uma hora',    '89 minutes = an hour');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 90}), true),  '2 horas',    '90 minutes = 2 hours');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 5}), true),   '5 horas',    '5 hours = 5 hours');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 21}), true),  '21 horas',   '21 hours = 21 hours');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 22}), true),  'um dia',      '22 hours = a day');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 35}), true),  'um dia',      '35 hours = a day');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 36}), true),  '2 dias',     '36 hours = 2 days');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 1}), true),   'um dia',      '1 day = a day');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 5}), true),   '5 dias',     '5 days = 5 days');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 25}), true),  '25 dias',    '25 days = 25 days');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 26}), true),  'um mÃªs',    '26 days = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 30}), true),  'um mÃªs',    '30 days = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 43}), true),  'um mÃªs',    '43 days = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 46}), true),  '2 meses',   '46 days = 2 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 74}), true),  '2 meses',   '75 days = 2 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 76}), true),  '3 meses',   '76 days = 3 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({M: 1}), true),   'um mÃªs',    '1 month = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({M: 5}), true),   '5 meses',   '5 months = 5 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 345}), true), 'um ano',     '345 days = a year');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 548}), true), '2 anos',    '548 days = 2 years');
        assert.equal(start.from(moment([2007, 1, 28]).add({y: 1}), true),   'um ano',     '1 year = a year');
        assert.equal(start.from(moment([2007, 1, 28]).add({y: 5}), true),   '5 anos',    '5 years = 5 years');
    });

    test('suffix', function (assert) {
        assert.equal(moment(30000).from(0), 'em segundos', 'prefix');
        assert.equal(moment(0).from(30000), 'hÃ¡ segundos', 'suffix');
    });

    test('fromNow', function (assert) {
        assert.equal(moment().add({s: 30}).fromNow(), 'em segundos', 'in seconds');
        assert.equal(moment().add({d: 5}).fromNow(), 'em 5 dias', 'in 5 days');
    });

    test('calendar day', function (assert) {
        var a = moment().hours(12).minutes(0).seconds(0);

        assert.equal(moment(a).calendar(),                   'Hoje Ã s 12:00',    'today at the same time');
        assert.equal(moment(a).add({m: 25}).calendar(),      'Hoje Ã s 12:25',    'Now plus 25 min');
        assert.equal(moment(a).add({h: 1}).calendar(),       'Hoje Ã s 13:00',    'Now plus 1 hour');
        assert.equal(moment(a).add({d: 1}).calendar(),       'AmanhÃ£ Ã s 12:00',  'tomorrow at the same time');
        assert.equal(moment(a).subtract({h: 1}).calendar(),  'Hoje Ã s 11:00',    'Now minus 1 hour');
        assert.equal(moment(a).subtract({d: 1}).calendar(),  'Ontem Ã s 12:00',   'yesterday at the same time');
    });

    test('calendar next week', function (assert) {
        var i, m;
        for (i = 2; i < 7; i++) {
            m = moment().add({d: i});
            assert.equal(m.calendar(),       m.format('dddd [Ã s] LT'),  'Today + ' + i + ' days current time');
            m.hours(0).minutes(0).seconds(0).milliseconds(0);
            assert.equal(m.calendar(),       m.format('dddd [Ã s] LT'),  'Today + ' + i + ' days beginning of day');
            m.hours(23).minutes(59).seconds(59).milliseconds(999);
            assert.equal(m.calendar(),       m.format('dddd [Ã s] LT'),  'Today + ' + i + ' days end of day');
        }
    });

    test('calendar last week', function (assert) {
        var i, m;
        for (i = 2; i < 7; i++) {
            m = moment().subtract({d: i});
            assert.equal(m.calendar(),       m.format((m.day() === 0 || m.day() === 6) ? '[Ãltimo] dddd [Ã s] LT' : '[Ãltima] dddd [Ã s] LT'),  'Today - ' + i + ' days current time');
            m.hours(0).minutes(0).seconds(0).milliseconds(0);
            assert.equal(m.calendar(),       m.format((m.day() === 0 || m.day() === 6) ? '[Ãltimo] dddd [Ã s] LT' : '[Ãltima] dddd [Ã s] LT'),  'Today - ' + i + ' days beginning of day');
            m.hours(23).minutes(59).seconds(59).milliseconds(999);
            assert.equal(m.calendar(),       m.format((m.day() === 0 || m.day() === 6) ? '[Ãltimo] dddd [Ã s] LT' : '[Ãltima] dddd [Ã s] LT'),  'Today - ' + i + ' days end of day');
        }
    });

    test('calendar all else', function (assert) {
        var weeksAgo = moment().subtract({w: 1}),
            weeksFromNow = moment().add({w: 1});

        assert.equal(weeksAgo.calendar(),       weeksAgo.format('L'),  '1 week ago');
        assert.equal(weeksFromNow.calendar(),   weeksFromNow.format('L'),  'in 1 week');

        weeksAgo = moment().subtract({w: 2});
        weeksFromNow = moment().add({w: 2});

        assert.equal(weeksAgo.calendar(),       weeksAgo.format('L'),  '2 weeks ago');
        assert.equal(weeksFromNow.calendar(),   weeksFromNow.format('L'),  'in 2 weeks');
    });

    test('weeks year starting sunday formatted', function (assert) {
        assert.equal(moment([2012, 0,  1]).format('w ww wo'), '52 52 52Âº', 'Jan  1 2012 should be week 52');
        assert.equal(moment([2012, 0,  2]).format('w ww wo'),  '1 01 1Âº', 'Jan  2 2012 should be week 1');
        assert.equal(moment([2012, 0,  8]).format('w ww wo'),  '1 01 1Âº', 'Jan  8 2012 should be week 1');
        assert.equal(moment([2012, 0,  9]).format('w ww wo'),  '2 02 2Âº', 'Jan  9 2012 should be week 2');
        assert.equal(moment([2012, 0, 15]).format('w ww wo'),  '2 02 2Âº', 'Jan 15 2012 should be week 2');
    });

}));

;(function (global, factory) {
   typeof exports === 'object' && typeof module !== 'undefined'
       && typeof require === 'function' ? factory(require('../../moment')) :
   typeof define === 'function' && define.amd ? define(['../../moment'], factory) :
   factory(global.moment)
}(this, function (moment) { 'use strict';

    function each(array, callback) {
        var i;
        for (i = 0; i < array.length; i++) {
            callback(array[i], i, array);
        }
    }

    function objectKeys(obj) {
        if (Object.keys) {
            return Object.keys(obj);
        } else {
            // IE8
            var res = [], i;
            for (i in obj) {
                if (obj.hasOwnProperty(i)) {
                    res.push(i);
                }
            }
            return res;
        }
    }

    // Pick the first defined of two or three arguments.
    function defaults(a, b, c) {
        if (a != null) {
            return a;
        }
        if (b != null) {
            return b;
        }
        return c;
    }

    function defineCommonLocaleTests(locale, options) {
        test('lenient ordinal parsing', function (assert) {
            var i, ordinalStr, testMoment;
            for (i = 1; i <= 31; ++i) {
                ordinalStr = moment([2014, 0, i]).format('YYYY MM Do');
                testMoment = moment(ordinalStr, 'YYYY MM Do');
                assert.equal(testMoment.year(), 2014,
                        'lenient ordinal parsing ' + i + ' year check');
                assert.equal(testMoment.month(), 0,
                        'lenient ordinal parsing ' + i + ' month check');
                assert.equal(testMoment.date(), i,
                        'lenient ordinal parsing ' + i + ' date check');
            }
        });

        test('lenient ordinal parsing of number', function (assert) {
            var i, testMoment;
            for (i = 1; i <= 31; ++i) {
                testMoment = moment('2014 01 ' + i, 'YYYY MM Do');
                assert.equal(testMoment.year(), 2014,
                        'lenient ordinal parsing of number ' + i + ' year check');
                assert.equal(testMoment.month(), 0,
                        'lenient ordinal parsing of number ' + i + ' month check');
                assert.equal(testMoment.date(), i,
                        'lenient ordinal parsing of number ' + i + ' date check');
            }
        });

        test('strict ordinal parsing', function (assert) {
            var i, ordinalStr, testMoment;
            for (i = 1; i <= 31; ++i) {
                ordinalStr = moment([2014, 0, i]).format('YYYY MM Do');
                testMoment = moment(ordinalStr, 'YYYY MM Do', true);
                assert.ok(testMoment.isValid(), 'strict ordinal parsing ' + i);
            }
        });

        test('meridiem invariant', function (assert) {
            var h, m, t1, t2;
            for (h = 0; h < 24; ++h) {
                for (m = 0; m < 60; m += 15) {
                    t1 = moment.utc([2000, 0, 1, h, m]);
                    t2 = moment.utc(t1.format('A h:mm'), 'A h:mm');
                    assert.equal(t2.format('HH:mm'), t1.format('HH:mm'),
                            'meridiem at ' + t1.format('HH:mm'));
                }
            }
        });

        test('date format correctness', function (assert) {
            var data, tokens;
            data = moment.localeData()._longDateFormat;
            tokens = objectKeys(data);
            each(tokens, function (srchToken) {
                // Check each format string to make sure it does not contain any
                // tokens that need to be expanded.
                each(tokens, function (baseToken) {
                    // strip escaped sequences
                    var format = data[baseToken].replace(/(\[[^\]]*\])/g, '');
                    assert.equal(false, !!~format.indexOf(srchToken),
                            'contains ' + srchToken + ' in ' + baseToken);
                });
            });
        });

        test('month parsing correctness', function (assert) {
            var i, m;

            if (locale === 'tr') {
                // I can't fix it :(
                expect(0);
                return;
            }
            function tester(format) {
                var r;
                r = moment(m.format(format), format);
                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format);
                r = moment(m.format(format).toLocaleUpperCase(), format);
                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' upper');
                r = moment(m.format(format).toLocaleLowerCase(), format);
                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' lower');

                r = moment(m.format(format), format, true);
                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' strict');
                r = moment(m.format(format).toLocaleUpperCase(), format, true);
                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' upper strict');
                r = moment(m.format(format).toLocaleLowerCase(), format, true);
                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' lower strict');
            }

            for (i = 0; i < 12; ++i) {
                m = moment([2015, i, 15, 18]);
                tester('MMM');
                tester('MMM.');
                tester('MMMM');
                tester('MMMM.');
            }
        });

        test('weekday parsing correctness', function (assert) {
            var i, m;

            if (locale === 'tr' || locale === 'az') {
                // There is a lower-case letter (Ä±), that converted to upper then
                // lower changes to i
                expect(0);
                return;
            }
            function tester(format) {
                var r, baseMsg = 'weekday ' + m.weekday() + ' fmt ' + format;
                r = moment(m.format(format), format);
                assert.equal(r.weekday(), m.weekday(), baseMsg);
                r = moment(m.format(format).toLocaleUpperCase(), format);
                assert.equal(r.weekday(), m.weekday(), baseMsg + ' upper');
                r = moment(m.format(format).toLocaleLowerCase(), format);
                assert.equal(r.weekday(), m.weekday(), baseMsg + ' lower');

                r = moment(m.format(format), format, true);
                assert.equal(r.weekday(), m.weekday(), baseMsg + ' strict');
                r = moment(m.format(format).toLocaleUpperCase(), format, true);
                assert.equal(r.weekday(), m.weekday(), baseMsg + ' upper strict');
                r = moment(m.format(format).toLocaleLowerCase(), format, true);
                assert.equal(r.weekday(), m.weekday(), baseMsg + ' lower strict');
            }

            for (i = 0; i < 7; ++i) {
                m = moment.utc([2015, i, 15, 18]);
                tester('dd');
                tester('ddd');
                tester('dddd');
            }
        });
    }

    function setupDeprecationHandler(test, moment, scope) {
        test._expectedDeprecations = null;
        test._observedDeprecations = null;
        test._oldSupress = moment.suppressDeprecationWarnings;
        moment.suppressDeprecationWarnings = true;
        test.expectedDeprecations = function () {
            test._expectedDeprecations = arguments;
            test._observedDeprecations = [];
        };
        moment.deprecationHandler = function (name, msg) {
            var deprecationId = matchedDeprecation(name, msg, test._expectedDeprecations);
            if (deprecationId === -1) {
                throw new Error('Unexpected deprecation thrown name=' +
                        name + ' msg=' + msg);
            }
            test._observedDeprecations[deprecationId] = 1;
        };
    }

    function teardownDeprecationHandler(test, moment, scope) {
        moment.suppressDeprecationWarnings = test._oldSupress;

        if (test._expectedDeprecations != null) {
            var missedDeprecations = [];
            each(test._expectedDeprecations, function (deprecationPattern, id) {
                if (test._observedDeprecations[id] !== 1) {
                    missedDeprecations.push(deprecationPattern);
                }
            });
            if (missedDeprecations.length !== 0) {
                throw new Error('Expected deprecation warnings did not happen: ' +
                        missedDeprecations.join(' '));
            }
        }
    }

    function matchedDeprecation(name, msg, deprecations) {
        if (deprecations == null) {
            return -1;
        }
        for (var i = 0; i < deprecations.length; ++i) {
            if (name != null && name === deprecations[i]) {
                return i;
            }
            if (msg != null && msg.substring(0, deprecations[i].length) === deprecations[i]) {
                return i;
            }
        }
        return -1;
    }

    /*global QUnit:false*/

    var test = QUnit.test;

    var expect = QUnit.expect;

    function module (name, lifecycle) {
        QUnit.module(name, {
            setup : function () {
                moment.locale('en');
                moment.createFromInputFallback = function (config) {
                    throw new Error('input not handled by moment: ' + config._i);
                };
                setupDeprecationHandler(test, moment, 'core');
                if (lifecycle && lifecycle.setup) {
                    lifecycle.setup();
                }
            },
            teardown : function () {
                teardownDeprecationHandler(test, moment, 'core');
                if (lifecycle && lifecycle.teardown) {
                    lifecycle.teardown();
                }
            }
        });
    }

    function localeModule (name, lifecycle) {
        QUnit.module('locale:' + name, {
            setup : function () {
                moment.locale(name);
                moment.createFromInputFallback = function (config) {
                    throw new Error('input not handled by moment: ' + config._i);
                };
                setupDeprecationHandler(test, moment, 'locale');
                if (lifecycle && lifecycle.setup) {
                    lifecycle.setup();
                }
            },
            teardown : function () {
                moment.locale('en');
                teardownDeprecationHandler(test, moment, 'locale');
                if (lifecycle && lifecycle.teardown) {
                    lifecycle.teardown();
                }
            }
        });
        defineCommonLocaleTests(name, -1, -1);
    }

    localeModule('ro');

    test('parse', function (assert) {
        var tests = 'ianuarie ian._februarie febr._martie mart._aprilie apr._mai mai_iunie iun._iulie iul._august aug._septembrie sept._octombrie oct._noiembrie nov._decembrie dec.'.split('_'), i;
        function equalTest(input, mmm, i) {
            assert.equal(moment(input, mmm).month(), i, input + ' should be month ' + (i + 1));
        }
        for (i = 0; i < 12; i++) {
            tests[i] = tests[i].split(' ');
            equalTest(tests[i][0], 'MMM', i);
            equalTest(tests[i][1], 'MMM', i);
            equalTest(tests[i][0], 'MMMM', i);
            equalTest(tests[i][1], 'MMMM', i);
            equalTest(tests[i][0].toLocaleLowerCase(), 'MMMM', i);
            equalTest(tests[i][1].toLocaleLowerCase(), 'MMMM', i);
            equalTest(tests[i][0].toLocaleUpperCase(), 'MMMM', i);
            equalTest(tests[i][1].toLocaleUpperCase(), 'MMMM', i);
        }
    });

    test('format', function (assert) {
        var a = [
                ['dddd, MMMM Do YYYY, h:mm:ss A',  'duminicÄ, februarie 14 2010, 3:25:50 PM'],
                ['ddd, hA',                        'Dum, 3PM'],
                ['M Mo MM MMMM MMM',               '2 2 02 februarie febr.'],
                ['YYYY YY',                        '2010 10'],
                ['D Do DD',                        '14 14 14'],
                ['d do dddd ddd dd',               '0 0 duminicÄ Dum Du'],
                ['DDD DDDo DDDD',                  '45 45 045'],
                ['w wo ww',                        '7 7 07'],
                ['h hh',                           '3 03'],
                ['H HH',                           '15 15'],
                ['m mm',                           '25 25'],
                ['s ss',                           '50 50'],
                ['a A',                            'pm PM'],
                ['[a] DDDo[a zi a anului]',        'a 45a zi a anului'],
                ['LTS',                            '15:25:50'],
                ['L',                              '14.02.2010'],
                ['LL',                             '14 februarie 2010'],
                ['LLL',                            '14 februarie 2010 15:25'],
                ['LLLL',                           'duminicÄ, 14 februarie 2010 15:25'],
                ['l',                              '14.2.2010'],
                ['ll',                             '14 febr. 2010'],
                ['lll',                            '14 febr. 2010 15:25'],
                ['llll',                           'Dum, 14 febr. 2010 15:25']
            ],
            b = moment(new Date(2010, 1, 14, 15, 25, 50, 125)),
            i;
        for (i = 0; i < a.length; i++) {
            assert.equal(b.format(a[i][0]), a[i][1], a[i][0] + ' ---> ' + a[i][1]);
        }
    });

    test('format ordinal', function (assert) {
        assert.equal(moment([2011, 0, 1]).format('DDDo'), '1', '1');
        assert.equal(moment([2011, 0, 2]).format('DDDo'), '2', '2');
        assert.equal(moment([2011, 0, 3]).format('DDDo'), '3', '3');
        assert.equal(moment([2011, 0, 4]).format('DDDo'), '4', '4');
        assert.equal(moment([2011, 0, 5]).format('DDDo'), '5', '5');
        assert.equal(moment([2011, 0, 6]).format('DDDo'), '6', '6');
        assert.equal(moment([2011, 0, 7]).format('DDDo'), '7', '7');
        assert.equal(moment([2011, 0, 8]).format('DDDo'), '8', '8');
        assert.equal(moment([2011, 0, 9]).format('DDDo'), '9', '9');
        assert.equal(moment([2011, 0, 10]).format('DDDo'), '10', '10');

        assert.equal(moment([2011, 0, 11]).format('DDDo'), '11', '11');
        assert.equal(moment([2011, 0, 12]).format('DDDo'), '12', '12');
        assert.equal(moment([2011, 0, 13]).format('DDDo'), '13', '13');
        assert.equal(moment([2011, 0, 14]).format('DDDo'), '14', '14');
        assert.equal(moment([2011, 0, 15]).format('DDDo'), '15', '15');
        assert.equal(moment([2011, 0, 16]).format('DDDo'), '16', '16');
        assert.equal(moment([2011, 0, 17]).format('DDDo'), '17', '17');
        assert.equal(moment([2011, 0, 18]).format('DDDo'), '18', '18');
        assert.equal(moment([2011, 0, 19]).format('DDDo'), '19', '19');
        assert.equal(moment([2011, 0, 20]).format('DDDo'), '20', '20');

        assert.equal(moment([2011, 0, 21]).format('DDDo'), '21', '21');
        assert.equal(moment([2011, 0, 22]).format('DDDo'), '22', '22');
        assert.equal(moment([2011, 0, 23]).format('DDDo'), '23', '23');
        assert.equal(moment([2011, 0, 24]).format('DDDo'), '24', '24');
        assert.equal(moment([2011, 0, 25]).format('DDDo'), '25', '25');
        assert.equal(moment([2011, 0, 26]).format('DDDo'), '26', '26');
        assert.equal(moment([2011, 0, 27]).format('DDDo'), '27', '27');
        assert.equal(moment([2011, 0, 28]).format('DDDo'), '28', '28');
        assert.equal(moment([2011, 0, 29]).format('DDDo'), '29', '29');
        assert.equal(moment([2011, 0, 30]).format('DDDo'), '30', '30');

        assert.equal(moment([2011, 0, 31]).format('DDDo'), '31', '31');
    });

    test('format month', function (assert) {
        var expected = 'ianuarie ian._februarie febr._martie mart._aprilie apr._mai mai_iunie iun._iulie iul._august aug._septembrie sept._octombrie oct._noiembrie nov._decembrie dec.'.split('_'), i;
        for (i = 0; i < expected.length; i++) {
            assert.equal(moment([2011, i, 1]).format('MMMM MMM'), expected[i], expected[i]);
        }
    });

    test('format week', function (assert) {
        var expected = 'duminicÄ Dum Du_luni Lun Lu_marÈi Mar Ma_miercuri Mie Mi_joi Joi Jo_vineri Vin Vi_sÃ¢mbÄtÄ SÃ¢m SÃ¢'.split('_'), i;
        for (i = 0; i < expected.length; i++) {
            assert.equal(moment([2011, 0, 2 + i]).format('dddd ddd dd'), expected[i], expected[i]);
        }
    });

    test('from', function (assert) {
        var start = moment([2007, 1, 28]);
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 44}), true),  'cÃ¢teva secunde', '44 seconds = a few seconds');
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 45}), true),  'un minut',       '45 seconds = a minute');
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 89}), true),  'un minut',       '89 seconds = a minute');
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 90}), true),  '2 minute',       '90 seconds = 2 minutes');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 44}), true),  '44 de minute',   '44 minutes = 44 minutes');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 45}), true),  'o orÄ',          '45 minutes = an hour');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 89}), true),  'o orÄ',          '89 minutes = an hour');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 90}), true),  '2 ore',          '90 minutes = 2 hours');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 5}), true),   '5 ore',          '5 hours = 5 hours');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 21}), true),  '21 de ore',      '21 hours = 21 hours');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 22}), true),  'o zi',           '22 hours = a day');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 35}), true),  'o zi',           '35 hours = a day');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 36}), true),  '2 zile',         '36 hours = 2 days');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 1}), true),   'o zi',           '1 day = a day');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 5}), true),   '5 zile',         '5 days = 5 days');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 25}), true),  '25 de zile',     '25 days = 25 days');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 26}), true),  'o lunÄ',         '26 days = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 30}), true),  'o lunÄ',         '30 days = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 43}), true),  'o lunÄ',         '43 days = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 46}), true),  '2 luni',         '46 days = 2 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 74}), true),  '2 luni',         '75 days = 2 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 76}), true),  '3 luni',         '76 days = 3 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({M: 1}), true),   'o lunÄ',         '1 month = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({M: 5}), true),   '5 luni',         '5 months = 5 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 345}), true), 'un an',          '345 days = a year');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 548}), true), '2 ani',          '548 days = 2 years');
        assert.equal(start.from(moment([2007, 1, 28]).add({y: 1}), true),   'un an',          '1 year = a year');
        assert.equal(start.from(moment([2007, 1, 28]).add({y: 5}), true),   '5 ani',          '5 years = 5 years');
        assert.equal(start.from(moment([2007, 1, 28]).add({y: 19}), true),   '19 ani',        '19 years = 19 years');
        assert.equal(start.from(moment([2007, 1, 28]).add({y: 20}), true),   '20 de ani',     '20 years = 20 years');
        assert.equal(start.from(moment([2007, 1, 28]).add({y: 100}), true),   '100 de ani',   '100 years = 100 years');
        assert.equal(start.from(moment([2007, 1, 28]).add({y: 101}), true),   '101 ani',      '101 years = 101 years');
        assert.equal(start.from(moment([2007, 1, 28]).add({y: 119}), true),   '119 ani',      '119 years = 119 years');
        assert.equal(start.from(moment([2007, 1, 28]).add({y: 120}), true),   '120 de ani',   '120 years = 120 years');
        assert.equal(start.from(moment([2007, 1, 28]).add({y: 219}), true),   '219 ani',      '219 years = 219 years');
        assert.equal(start.from(moment([2007, 1, 28]).add({y: 220}), true),   '220 de ani',   '220 years = 220 years');
    });

    test('suffix', function (assert) {
        assert.equal(moment(30000).from(0), 'peste cÃ¢teva secunde',   'prefix');
        assert.equal(moment(0).from(30000), 'cÃ¢teva secunde Ã®n urmÄ', 'suffix');
    });

    test('now from now', function (assert) {
        assert.equal(moment().fromNow(), 'cÃ¢teva secunde Ã®n urmÄ',  'now from now should display as in the past');
    });

    test('fromNow', function (assert) {
        assert.equal(moment().add({s: 30}).fromNow(), 'peste cÃ¢teva secunde', 'in a few seconds');
        assert.equal(moment().add({d: 5}).fromNow(), 'peste 5 zile', 'in 5 days');
    });

    test('calendar day', function (assert) {
        var a = moment().hours(12).minutes(0).seconds(0);

        assert.equal(moment(a).calendar(),                   'azi la 12:00',     'today at the same time');
        assert.equal(moment(a).add({m: 25}).calendar(),      'azi la 12:25',     'Now plus 25 min');
        assert.equal(moment(a).add({h: 1}).calendar(),       'azi la 13:00',     'Now plus 1 hour');
        assert.equal(moment(a).add({d: 1}).calendar(),       'mÃ¢ine la 12:00',   'tomorrow at the same time');
        assert.equal(moment(a).subtract({h: 1}).calendar(),  'azi la 11:00',     'Now minus 1 hour');
        assert.equal(moment(a).subtract({d: 1}).calendar(),  'ieri la 12:00',    'yesterday at the same time');
    });

    test('calendar next week', function (assert) {
        var i, m;
        for (i = 2; i < 7; i++) {
            m = moment().add({d: i});
            assert.equal(m.calendar(),       m.format('dddd [la] LT'),  'Today + ' + i + ' days current time');
            m.hours(0).minutes(0).seconds(0).milliseconds(0);
            assert.equal(m.calendar(),       m.format('dddd [la] LT'),  'Today + ' + i + ' days beginning of day');
            m.hours(23).minutes(59).seconds(59).milliseconds(999);
            assert.equal(m.calendar(),       m.format('dddd [la] LT'),  'Today + ' + i + ' days end of day');
        }
    });

    test('calendar last week', function (assert) {
        var i, m;
        for (i = 2; i < 7; i++) {
            m = moment().subtract({d: i});
            assert.equal(m.calendar(),       m.format('[fosta] dddd [la] LT'),  'Today - ' + i + ' days current time');
            m.hours(0).minutes(0).seconds(0).milliseconds(0);
            assert.equal(m.calendar(),       m.format('[fosta] dddd [la] LT'),  'Today - ' + i + ' days beginning of day');
            m.hours(23).minutes(59).seconds(59).milliseconds(999);
            assert.equal(m.calendar(),       m.format('[fosta] dddd [la] LT'),  'Today - ' + i + ' days end of day');
        }
    });

    test('calendar all else', function (assert) {
        var weeksAgo = moment().subtract({w: 1}),
            weeksFromNow = moment().add({w: 1});

        assert.equal(weeksAgo.calendar(),       weeksAgo.format('L'),  '1 week ago');
        assert.equal(weeksFromNow.calendar(),   weeksFromNow.format('L'),  'in 1 week');

        weeksAgo = moment().subtract({w: 2});
        weeksFromNow = moment().add({w: 2});

        assert.equal(weeksAgo.calendar(),       weeksAgo.format('L'),  '2 weeks ago');
        assert.equal(weeksFromNow.calendar(),   weeksFromNow.format('L'),  'in 2 weeks');
    });

    test('weeks year starting sunday formatted', function (assert) {
        assert.equal(moment([2011, 11, 26]).format('w ww wo'), '1 01 1', 'Dec 26 2011 should be week 1');
        assert.equal(moment([2012,  0,  1]).format('w ww wo'), '1 01 1', 'Jan  1 2012 should be week 1');
        assert.equal(moment([2012,  0,  2]).format('w ww wo'), '2 02 2', 'Jan  2 2012 should be week 2');
        assert.equal(moment([2012,  0,  8]).format('w ww wo'), '2 02 2', 'Jan  8 2012 should be week 2');
        assert.equal(moment([2012,  0,  9]).format('w ww wo'), '3 03 3', 'Jan  9 2012 should be week 3');
    });

}));

;(function (global, factory) {
   typeof exports === 'object' && typeof module !== 'undefined'
       && typeof require === 'function' ? factory(require('../../moment')) :
   typeof define === 'function' && define.amd ? define(['../../moment'], factory) :
   factory(global.moment)
}(this, function (moment) { 'use strict';

    function each(array, callback) {
        var i;
        for (i = 0; i < array.length; i++) {
            callback(array[i], i, array);
        }
    }

    function objectKeys(obj) {
        if (Object.keys) {
            return Object.keys(obj);
        } else {
            // IE8
            var res = [], i;
            for (i in obj) {
                if (obj.hasOwnProperty(i)) {
                    res.push(i);
                }
            }
            return res;
        }
    }

    // Pick the first defined of two or three arguments.
    function defaults(a, b, c) {
        if (a != null) {
            return a;
        }
        if (b != null) {
            return b;
        }
        return c;
    }

    function defineCommonLocaleTests(locale, options) {
        test('lenient ordinal parsing', function (assert) {
            var i, ordinalStr, testMoment;
            for (i = 1; i <= 31; ++i) {
                ordinalStr = moment([2014, 0, i]).format('YYYY MM Do');
                testMoment = moment(ordinalStr, 'YYYY MM Do');
                assert.equal(testMoment.year(), 2014,
                        'lenient ordinal parsing ' + i + ' year check');
                assert.equal(testMoment.month(), 0,
                        'lenient ordinal parsing ' + i + ' month check');
                assert.equal(testMoment.date(), i,
                        'lenient ordinal parsing ' + i + ' date check');
            }
        });

        test('lenient ordinal parsing of number', function (assert) {
            var i, testMoment;
            for (i = 1; i <= 31; ++i) {
                testMoment = moment('2014 01 ' + i, 'YYYY MM Do');
                assert.equal(testMoment.year(), 2014,
                        'lenient ordinal parsing of number ' + i + ' year check');
                assert.equal(testMoment.month(), 0,
                        'lenient ordinal parsing of number ' + i + ' month check');
                assert.equal(testMoment.date(), i,
                        'lenient ordinal parsing of number ' + i + ' date check');
            }
        });

        test('strict ordinal parsing', function (assert) {
            var i, ordinalStr, testMoment;
            for (i = 1; i <= 31; ++i) {
                ordinalStr = moment([2014, 0, i]).format('YYYY MM Do');
                testMoment = moment(ordinalStr, 'YYYY MM Do', true);
                assert.ok(testMoment.isValid(), 'strict ordinal parsing ' + i);
            }
        });

        test('meridiem invariant', function (assert) {
            var h, m, t1, t2;
            for (h = 0; h < 24; ++h) {
                for (m = 0; m < 60; m += 15) {
                    t1 = moment.utc([2000, 0, 1, h, m]);
                    t2 = moment.utc(t1.format('A h:mm'), 'A h:mm');
                    assert.equal(t2.format('HH:mm'), t1.format('HH:mm'),
                            'meridiem at ' + t1.format('HH:mm'));
                }
            }
        });

        test('date format correctness', function (assert) {
            var data, tokens;
            data = moment.localeData()._longDateFormat;
            tokens = objectKeys(data);
            each(tokens, function (srchToken) {
                // Check each format string to make sure it does not contain any
                // tokens that need to be expanded.
                each(tokens, function (baseToken) {
                    // strip escaped sequences
                    var format = data[baseToken].replace(/(\[[^\]]*\])/g, '');
                    assert.equal(false, !!~format.indexOf(srchToken),
                            'contains ' + srchToken + ' in ' + baseToken);
                });
            });
        });

        test('month parsing correctness', function (assert) {
            var i, m;

            if (locale === 'tr') {
                // I can't fix it :(
                expect(0);
                return;
            }
            function tester(format) {
                var r;
                r = moment(m.format(format), format);
                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format);
                r = moment(m.format(format).toLocaleUpperCase(), format);
                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' upper');
                r = moment(m.format(format).toLocaleLowerCase(), format);
                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' lower');

                r = moment(m.format(format), format, true);
                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' strict');
                r = moment(m.format(format).toLocaleUpperCase(), format, true);
                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' upper strict');
                r = moment(m.format(format).toLocaleLowerCase(), format, true);
                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' lower strict');
            }

            for (i = 0; i < 12; ++i) {
                m = moment([2015, i, 15, 18]);
                tester('MMM');
                tester('MMM.');
                tester('MMMM');
                tester('MMMM.');
            }
        });

        test('weekday parsing correctness', function (assert) {
            var i, m;

            if (locale === 'tr' || locale === 'az') {
                // There is a lower-case letter (Ä±), that converted to upper then
                // lower changes to i
                expect(0);
                return;
            }
            function tester(format) {
                var r, baseMsg = 'weekday ' + m.weekday() + ' fmt ' + format;
                r = moment(m.format(format), format);
                assert.equal(r.weekday(), m.weekday(), baseMsg);
                r = moment(m.format(format).toLocaleUpperCase(), format);
                assert.equal(r.weekday(), m.weekday(), baseMsg + ' upper');
                r = moment(m.format(format).toLocaleLowerCase(), format);
                assert.equal(r.weekday(), m.weekday(), baseMsg + ' lower');

                r = moment(m.format(format), format, true);
                assert.equal(r.weekday(), m.weekday(), baseMsg + ' strict');
                r = moment(m.format(format).toLocaleUpperCase(), format, true);
                assert.equal(r.weekday(), m.weekday(), baseMsg + ' upper strict');
                r = moment(m.format(format).toLocaleLowerCase(), format, true);
                assert.equal(r.weekday(), m.weekday(), baseMsg + ' lower strict');
            }

            for (i = 0; i < 7; ++i) {
                m = moment.utc([2015, i, 15, 18]);
                tester('dd');
                tester('ddd');
                tester('dddd');
            }
        });
    }

    function setupDeprecationHandler(test, moment, scope) {
        test._expectedDeprecations = null;
        test._observedDeprecations = null;
        test._oldSupress = moment.suppressDeprecationWarnings;
        moment.suppressDeprecationWarnings = true;
        test.expectedDeprecations = function () {
            test._expectedDeprecations = arguments;
            test._observedDeprecations = [];
        };
        moment.deprecationHandler = function (name, msg) {
            var deprecationId = matchedDeprecation(name, msg, test._expectedDeprecations);
            if (deprecationId === -1) {
                throw new Error('Unexpected deprecation thrown name=' +
                        name + ' msg=' + msg);
            }
            test._observedDeprecations[deprecationId] = 1;
        };
    }

    function teardownDeprecationHandler(test, moment, scope) {
        moment.suppressDeprecationWarnings = test._oldSupress;

        if (test._expectedDeprecations != null) {
            var missedDeprecations = [];
            each(test._expectedDeprecations, function (deprecationPattern, id) {
                if (test._observedDeprecations[id] !== 1) {
                    missedDeprecations.push(deprecationPattern);
                }
            });
            if (missedDeprecations.length !== 0) {
                throw new Error('Expected deprecation warnings did not happen: ' +
                        missedDeprecations.join(' '));
            }
        }
    }

    function matchedDeprecation(name, msg, deprecations) {
        if (deprecations == null) {
            return -1;
        }
        for (var i = 0; i < deprecations.length; ++i) {
            if (name != null && name === deprecations[i]) {
                return i;
            }
            if (msg != null && msg.substring(0, deprecations[i].length) === deprecations[i]) {
                return i;
            }
        }
        return -1;
    }

    /*global QUnit:false*/

    var test = QUnit.test;

    var expect = QUnit.expect;

    function module (name, lifecycle) {
        QUnit.module(name, {
            setup : function () {
                moment.locale('en');
                moment.createFromInputFallback = function (config) {
                    throw new Error('input not handled by moment: ' + config._i);
                };
                setupDeprecationHandler(test, moment, 'core');
                if (lifecycle && lifecycle.setup) {
                    lifecycle.setup();
                }
            },
            teardown : function () {
                teardownDeprecationHandler(test, moment, 'core');
                if (lifecycle && lifecycle.teardown) {
                    lifecycle.teardown();
                }
            }
        });
    }

    function localeModule (name, lifecycle) {
        QUnit.module('locale:' + name, {
            setup : function () {
                moment.locale(name);
                moment.createFromInputFallback = function (config) {
                    throw new Error('input not handled by moment: ' + config._i);
                };
                setupDeprecationHandler(test, moment, 'locale');
                if (lifecycle && lifecycle.setup) {
                    lifecycle.setup();
                }
            },
            teardown : function () {
                moment.locale('en');
                teardownDeprecationHandler(test, moment, 'locale');
                if (lifecycle && lifecycle.teardown) {
                    lifecycle.teardown();
                }
            }
        });
        defineCommonLocaleTests(name, -1, -1);
    }

    localeModule('ru');

    test('parse', function (assert) {
        var tests = 'ÑÐ½Ð²Ð°ÑÑ ÑÐ½Ð²._ÑÐµÐ²ÑÐ°Ð»Ñ ÑÐµÐ²Ñ._Ð¼Ð°ÑÑ Ð¼Ð°ÑÑ_Ð°Ð¿ÑÐµÐ»Ñ Ð°Ð¿Ñ._Ð¼Ð°Ð¹ Ð¼Ð°Ð¹_Ð¸ÑÐ½Ñ Ð¸ÑÐ½Ñ_Ð¸ÑÐ»Ñ Ð¸ÑÐ»Ñ_Ð°Ð²Ð³ÑÑÑ Ð°Ð²Ð³._ÑÐµÐ½ÑÑÐ±ÑÑ ÑÐµÐ½Ñ._Ð¾ÐºÑÑÐ±ÑÑ Ð¾ÐºÑ._Ð½Ð¾ÑÐ±ÑÑ Ð½Ð¾ÑÐ±._Ð´ÐµÐºÐ°Ð±ÑÑ Ð´ÐµÐº.'.split('_'), i;
        function equalTest(input, mmm, i) {
            assert.equal(moment(input, mmm).month(), i, input + ' should be month ' + (i + 1));
        }
        function equalTestStrict(input, mmm, monthIndex) {
            assert.equal(moment(input, mmm, true).month(), monthIndex, input + ' ' + mmm + ' should be strict month ' + (monthIndex + 1));
        }
        for (i = 0; i < 12; i++) {
            tests[i] = tests[i].split(' ');
            equalTest(tests[i][0], 'MMM', i);
            equalTest(tests[i][1], 'MMM', i);
            equalTest(tests[i][0], 'MMMM', i);
            equalTest(tests[i][1], 'MMMM', i);
            equalTest(tests[i][0].toLocaleLowerCase(), 'MMMM', i);
            equalTest(tests[i][1].toLocaleLowerCase(), 'MMMM', i);
            equalTest(tests[i][0].toLocaleUpperCase(), 'MMMM', i);
            equalTest(tests[i][1].toLocaleUpperCase(), 'MMMM', i);

            equalTestStrict(tests[i][1], 'MMM', i);
            equalTestStrict(tests[i][0], 'MMMM', i);
            equalTestStrict(tests[i][1].toLocaleLowerCase(), 'MMM', i);
            equalTestStrict(tests[i][1].toLocaleUpperCase(), 'MMM', i);
            equalTestStrict(tests[i][0].toLocaleLowerCase(), 'MMMM', i);
            equalTestStrict(tests[i][0].toLocaleUpperCase(), 'MMMM', i);
        }
    });

    test('parse exceptional case', function (assert) {
        assert.equal(moment('11 ÐÐ°Ñ 1989', ['DD MMMM YYYY']).format('DD-MM-YYYY'), '11-05-1989');
    });

    test('format', function (assert) {
        var a = [
                ['dddd, Do MMMM YYYY, HH:mm:ss',       'Ð²Ð¾ÑÐºÑÐµÑÐµÐ½ÑÐµ, 14-Ð³Ð¾ ÑÐµÐ²ÑÐ°Ð»Ñ 2010, 15:25:50'],
                ['ddd, h A',                           'Ð²Ñ, 3 Ð´Ð½Ñ'],
                ['M Mo MM MMMM MMM',                   '2 2-Ð¹ 02 ÑÐµÐ²ÑÐ°Ð»Ñ ÑÐµÐ²Ñ.'],
                ['YYYY YY',                            '2010 10'],
                ['D Do DD',                            '14 14-Ð³Ð¾ 14'],
                ['d do dddd ddd dd',                   '0 0-Ð¹ Ð²Ð¾ÑÐºÑÐµÑÐµÐ½ÑÐµ Ð²Ñ Ð²Ñ'],
                ['DDD DDDo DDDD',                      '45 45-Ð¹ 045'],
                ['w wo ww',                            '7 7-Ñ 07'],
                ['h hh',                               '3 03'],
                ['H HH',                               '15 15'],
                ['m mm',                               '25 25'],
                ['s ss',                               '50 50'],
                ['a A',                                'Ð´Ð½Ñ Ð´Ð½Ñ'],
                ['DDDo [Ð´ÐµÐ½Ñ Ð³Ð¾Ð´Ð°]',                   '45-Ð¹ Ð´ÐµÐ½Ñ Ð³Ð¾Ð´Ð°'],
                ['LTS',                                '15:25:50'],
                ['L',                                  '14.02.2010'],
                ['LL',                                 '14 ÑÐµÐ²ÑÐ°Ð»Ñ 2010 Ð³.'],
                ['LLL',                                '14 ÑÐµÐ²ÑÐ°Ð»Ñ 2010 Ð³., 15:25'],
                ['LLLL',                               'Ð²Ð¾ÑÐºÑÐµÑÐµÐ½ÑÐµ, 14 ÑÐµÐ²ÑÐ°Ð»Ñ 2010 Ð³., 15:25'],
                ['l',                                  '14.2.2010'],
                ['ll',                                 '14 ÑÐµÐ²Ñ. 2010 Ð³.'],
                ['lll',                                '14 ÑÐµÐ²Ñ. 2010 Ð³., 15:25'],
                ['llll',                               'Ð²Ñ, 14 ÑÐµÐ²Ñ. 2010 Ð³., 15:25']
            ],
            b = moment(new Date(2010, 1, 14, 15, 25, 50, 125)),
            i;
        for (i = 0; i < a.length; i++) {
            assert.equal(b.format(a[i][0]), a[i][1], a[i][0] + ' ---> ' + a[i][1]);
        }
    });

    test('format meridiem', function (assert) {
        assert.equal(moment([2012, 11, 28, 0, 0]).format('A'), 'Ð½Ð¾ÑÐ¸', 'night');
        assert.equal(moment([2012, 11, 28, 3, 59]).format('A'), 'Ð½Ð¾ÑÐ¸', 'night');
        assert.equal(moment([2012, 11, 28, 4, 0]).format('A'), 'ÑÑÑÐ°', 'morning');
        assert.equal(moment([2012, 11, 28, 11, 59]).format('A'), 'ÑÑÑÐ°', 'morning');
        assert.equal(moment([2012, 11, 28, 12, 0]).format('A'), 'Ð´Ð½Ñ', 'afternoon');
        assert.equal(moment([2012, 11, 28, 16, 59]).format('A'), 'Ð´Ð½Ñ', 'afternoon');
        assert.equal(moment([2012, 11, 28, 17, 0]).format('A'), 'Ð²ÐµÑÐµÑÐ°', 'evening');
        assert.equal(moment([2012, 11, 28, 23, 59]).format('A'), 'Ð²ÐµÑÐµÑÐ°', 'evening');
    });

    test('format ordinal', function (assert) {
        assert.equal(moment([2011, 0, 1]).format('DDDo'), '1-Ð¹', '1-Ð¹');
        assert.equal(moment([2011, 0, 2]).format('DDDo'), '2-Ð¹', '2-Ð¹');
        assert.equal(moment([2011, 0, 3]).format('DDDo'), '3-Ð¹', '3-Ð¹');
        assert.equal(moment([2011, 0, 4]).format('DDDo'), '4-Ð¹', '4-Ð¹');
        assert.equal(moment([2011, 0, 5]).format('DDDo'), '5-Ð¹', '5-Ð¹');
        assert.equal(moment([2011, 0, 6]).format('DDDo'), '6-Ð¹', '6-Ð¹');
        assert.equal(moment([2011, 0, 7]).format('DDDo'), '7-Ð¹', '7-Ð¹');
        assert.equal(moment([2011, 0, 8]).format('DDDo'), '8-Ð¹', '8-Ð¹');
        assert.equal(moment([2011, 0, 9]).format('DDDo'), '9-Ð¹', '9-Ð¹');
        assert.equal(moment([2011, 0, 10]).format('DDDo'), '10-Ð¹', '10-Ð¹');

        assert.equal(moment([2011, 0, 11]).format('DDDo'), '11-Ð¹', '11-Ð¹');
        assert.equal(moment([2011, 0, 12]).format('DDDo'), '12-Ð¹', '12-Ð¹');
        assert.equal(moment([2011, 0, 13]).format('DDDo'), '13-Ð¹', '13-Ð¹');
        assert.equal(moment([2011, 0, 14]).format('DDDo'), '14-Ð¹', '14-Ð¹');
        assert.equal(moment([2011, 0, 15]).format('DDDo'), '15-Ð¹', '15-Ð¹');
        assert.equal(moment([2011, 0, 16]).format('DDDo'), '16-Ð¹', '16-Ð¹');
        assert.equal(moment([2011, 0, 17]).format('DDDo'), '17-Ð¹', '17-Ð¹');
        assert.equal(moment([2011, 0, 18]).format('DDDo'), '18-Ð¹', '18-Ð¹');
        assert.equal(moment([2011, 0, 19]).format('DDDo'), '19-Ð¹', '19-Ð¹');
        assert.equal(moment([2011, 0, 20]).format('DDDo'), '20-Ð¹', '20-Ð¹');

        assert.equal(moment([2011, 0, 21]).format('DDDo'), '21-Ð¹', '21-Ð¹');
        assert.equal(moment([2011, 0, 22]).format('DDDo'), '22-Ð¹', '22-Ð¹');
        assert.equal(moment([2011, 0, 23]).format('DDDo'), '23-Ð¹', '23-Ð¹');
        assert.equal(moment([2011, 0, 24]).format('DDDo'), '24-Ð¹', '24-Ð¹');
        assert.equal(moment([2011, 0, 25]).format('DDDo'), '25-Ð¹', '25-Ð¹');
        assert.equal(moment([2011, 0, 26]).format('DDDo'), '26-Ð¹', '26-Ð¹');
        assert.equal(moment([2011, 0, 27]).format('DDDo'), '27-Ð¹', '27-Ð¹');
        assert.equal(moment([2011, 0, 28]).format('DDDo'), '28-Ð¹', '28-Ð¹');
        assert.equal(moment([2011, 0, 29]).format('DDDo'), '29-Ð¹', '29-Ð¹');
        assert.equal(moment([2011, 0, 30]).format('DDDo'), '30-Ð¹', '30-Ð¹');

        assert.equal(moment([2011, 0, 31]).format('DDDo'), '31-Ð¹', '31-Ð¹');
    });

    test('format month', function (assert) {
        var expected = 'ÑÐ½Ð²Ð°ÑÑ ÑÐ½Ð²._ÑÐµÐ²ÑÐ°Ð»Ñ ÑÐµÐ²Ñ._Ð¼Ð°ÑÑ Ð¼Ð°ÑÑ_Ð°Ð¿ÑÐµÐ»Ñ Ð°Ð¿Ñ._Ð¼Ð°Ð¹ Ð¼Ð°Ð¹_Ð¸ÑÐ½Ñ Ð¸ÑÐ½Ñ_Ð¸ÑÐ»Ñ Ð¸ÑÐ»Ñ_Ð°Ð²Ð³ÑÑÑ Ð°Ð²Ð³._ÑÐµÐ½ÑÑÐ±ÑÑ ÑÐµÐ½Ñ._Ð¾ÐºÑÑÐ±ÑÑ Ð¾ÐºÑ._Ð½Ð¾ÑÐ±ÑÑ Ð½Ð¾ÑÐ±._Ð´ÐµÐºÐ°Ð±ÑÑ Ð´ÐµÐº.'.split('_'), i;
        for (i = 0; i < expected.length; i++) {
            assert.equal(moment([2011, i, 1]).format('MMMM MMM'), expected[i], expected[i]);
        }
    });

    test('format month case', function (assert) {
        var months = {
            'nominative': 'ÑÐ½Ð²Ð°ÑÑ_ÑÐµÐ²ÑÐ°Ð»Ñ_Ð¼Ð°ÑÑ_Ð°Ð¿ÑÐµÐ»Ñ_Ð¼Ð°Ð¹_Ð¸ÑÐ½Ñ_Ð¸ÑÐ»Ñ_Ð°Ð²Ð³ÑÑÑ_ÑÐµÐ½ÑÑÐ±ÑÑ_Ð¾ÐºÑÑÐ±ÑÑ_Ð½Ð¾ÑÐ±ÑÑ_Ð´ÐµÐºÐ°Ð±ÑÑ'.split('_'),
            'accusative': 'ÑÐ½Ð²Ð°ÑÑ_ÑÐµÐ²ÑÐ°Ð»Ñ_Ð¼Ð°ÑÑÐ°_Ð°Ð¿ÑÐµÐ»Ñ_Ð¼Ð°Ñ_Ð¸ÑÐ½Ñ_Ð¸ÑÐ»Ñ_Ð°Ð²Ð³ÑÑÑÐ°_ÑÐµÐ½ÑÑÐ±ÑÑ_Ð¾ÐºÑÑÐ±ÑÑ_Ð½Ð¾ÑÐ±ÑÑ_Ð´ÐµÐºÐ°Ð±ÑÑ'.split('_')
        }, i;
        for (i = 0; i < 12; i++) {
            assert.equal(moment([2011, i, 1]).format('D MMMM'), '1 ' + months.accusative[i], '1 ' + months.accusative[i]);
            assert.equal(moment([2011, i, 1]).format('MMMM'), months.nominative[i], '1 ' + months.nominative[i]);
        }
    });

    test('format month short case', function (assert) {
        var monthsShort = {
            'nominative': 'ÑÐ½Ð²._ÑÐµÐ²Ñ._Ð¼Ð°ÑÑ_Ð°Ð¿Ñ._Ð¼Ð°Ð¹_Ð¸ÑÐ½Ñ_Ð¸ÑÐ»Ñ_Ð°Ð²Ð³._ÑÐµÐ½Ñ._Ð¾ÐºÑ._Ð½Ð¾ÑÐ±._Ð´ÐµÐº.'.split('_'),
            'accusative': 'ÑÐ½Ð²._ÑÐµÐ²Ñ._Ð¼Ð°Ñ._Ð°Ð¿Ñ._Ð¼Ð°Ñ_Ð¸ÑÐ½Ñ_Ð¸ÑÐ»Ñ_Ð°Ð²Ð³._ÑÐµÐ½Ñ._Ð¾ÐºÑ._Ð½Ð¾ÑÐ±._Ð´ÐµÐº.'.split('_')
        }, i;
        for (i = 0; i < 12; i++) {
            assert.equal(moment([2011, i, 1]).format('D MMM'), '1 ' + monthsShort.accusative[i], '1 ' + monthsShort.accusative[i]);
            assert.equal(moment([2011, i, 1]).format('MMM'), monthsShort.nominative[i], '1 ' + monthsShort.nominative[i]);
        }
    });

    test('format month case with escaped symbols', function (assert) {
        var months = {
            'nominative': 'ÑÐ½Ð²Ð°ÑÑ_ÑÐµÐ²ÑÐ°Ð»Ñ_Ð¼Ð°ÑÑ_Ð°Ð¿ÑÐµÐ»Ñ_Ð¼Ð°Ð¹_Ð¸ÑÐ½Ñ_Ð¸ÑÐ»Ñ_Ð°Ð²Ð³ÑÑÑ_ÑÐµÐ½ÑÑÐ±ÑÑ_Ð¾ÐºÑÑÐ±ÑÑ_Ð½Ð¾ÑÐ±ÑÑ_Ð´ÐµÐºÐ°Ð±ÑÑ'.split('_'),
            'accusative': 'ÑÐ½Ð²Ð°ÑÑ_ÑÐµÐ²ÑÐ°Ð»Ñ_Ð¼Ð°ÑÑÐ°_Ð°Ð¿ÑÐµÐ»Ñ_Ð¼Ð°Ñ_Ð¸ÑÐ½Ñ_Ð¸ÑÐ»Ñ_Ð°Ð²Ð³ÑÑÑÐ°_ÑÐµÐ½ÑÑÐ±ÑÑ_Ð¾ÐºÑÑÐ±ÑÑ_Ð½Ð¾ÑÐ±ÑÑ_Ð´ÐµÐºÐ°Ð±ÑÑ'.split('_')
        }, i;
        for (i = 0; i < 12; i++) {
            assert.equal(moment([2013, i, 1]).format('D[] MMMM'), '1 ' + months.accusative[i], '1 ' + months.accusative[i]);
            assert.equal(moment([2013, i, 1]).format('[<i>]D[</i>] [<b>]MMMM[</b>]'), '<i>1</i> <b>' + months.accusative[i] + '</b>', '1 <b>' + months.accusative[i] + '</b>');
            assert.equal(moment([2013, i, 1]).format('D[-Ð¹ Ð´ÐµÐ½Ñ] MMMM'), '1-Ð¹ Ð´ÐµÐ½Ñ ' + months.accusative[i], '1-Ð¹ Ð´ÐµÐ½Ñ ' + months.accusative[i]);
            assert.equal(moment([2013, i, 1]).format('D, MMMM'), '1, ' + months.nominative[i], '1, ' + months.nominative[i]);
        }
    });

    test('format month short case with escaped symbols', function (assert) {
        var monthsShort = {
            'nominative': 'ÑÐ½Ð²._ÑÐµÐ²Ñ._Ð¼Ð°ÑÑ_Ð°Ð¿Ñ._Ð¼Ð°Ð¹_Ð¸ÑÐ½Ñ_Ð¸ÑÐ»Ñ_Ð°Ð²Ð³._ÑÐµÐ½Ñ._Ð¾ÐºÑ._Ð½Ð¾ÑÐ±._Ð´ÐµÐº.'.split('_'),
            'accusative': 'ÑÐ½Ð²._ÑÐµÐ²Ñ._Ð¼Ð°Ñ._Ð°Ð¿Ñ._Ð¼Ð°Ñ_Ð¸ÑÐ½Ñ_Ð¸ÑÐ»Ñ_Ð°Ð²Ð³._ÑÐµÐ½Ñ._Ð¾ÐºÑ._Ð½Ð¾ÑÐ±._Ð´ÐµÐº.'.split('_')
        }, i;
        for (i = 0; i < 12; i++) {
            assert.equal(moment([2013, i, 1]).format('D[] MMM'), '1 ' + monthsShort.accusative[i], '1 ' + monthsShort.accusative[i]);
            assert.equal(moment([2013, i, 1]).format('[<i>]D[</i>] [<b>]MMM[</b>]'), '<i>1</i> <b>' + monthsShort.accusative[i] + '</b>', '1 <b>' + monthsShort.accusative[i] + '</b>');
            assert.equal(moment([2013, i, 1]).format('D[-Ð¹ Ð´ÐµÐ½Ñ] MMM'), '1-Ð¹ Ð´ÐµÐ½Ñ ' + monthsShort.accusative[i], '1-Ð¹ Ð´ÐµÐ½Ñ ' + monthsShort.accusative[i]);
            assert.equal(moment([2013, i, 1]).format('D, MMM'), '1, ' + monthsShort.nominative[i], '1, ' + monthsShort.nominative[i]);
        }
    });

    test('format week', function (assert) {
        var expected = 'Ð²Ð¾ÑÐºÑÐµÑÐµÐ½ÑÐµ Ð²Ñ Ð²Ñ_Ð¿Ð¾Ð½ÐµÐ´ÐµÐ»ÑÐ½Ð¸Ðº Ð¿Ð½ Ð¿Ð½_Ð²ÑÐ¾ÑÐ½Ð¸Ðº Ð²Ñ Ð²Ñ_ÑÑÐµÐ´Ð° ÑÑ ÑÑ_ÑÐµÑÐ²ÐµÑÐ³ ÑÑ ÑÑ_Ð¿ÑÑÐ½Ð¸ÑÐ° Ð¿Ñ Ð¿Ñ_ÑÑÐ±Ð±Ð¾ÑÐ° ÑÐ± ÑÐ±'.split('_'), i;
        for (i = 0; i < expected.length; i++) {
            assert.equal(moment([2011, 0, 2 + i]).format('dddd ddd dd'), expected[i], expected[i]);
        }
    });

    test('from', function (assert) {
        var start = moment([2007, 1, 28]);
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 44}), true),  'Ð½ÐµÑÐºÐ¾Ð»ÑÐºÐ¾ ÑÐµÐºÑÐ½Ð´',    '44 seconds = seconds');
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 45}), true),  'Ð¼Ð¸Ð½ÑÑÐ°',   '45 seconds = a minute');
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 89}), true),  'Ð¼Ð¸Ð½ÑÑÐ°',   '89 seconds = a minute');
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 90}), true),  '2 Ð¼Ð¸Ð½ÑÑÑ',  '90 seconds = 2 minutes');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 31}), true),  '31 Ð¼Ð¸Ð½ÑÑÐ°',  '31 minutes = 31 minutes');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 44}), true),  '44 Ð¼Ð¸Ð½ÑÑÑ', '44 minutes = 44 minutes');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 45}), true),  'ÑÐ°Ñ',    '45 minutes = an hour');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 89}), true),  'ÑÐ°Ñ',    '89 minutes = an hour');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 90}), true),  '2 ÑÐ°ÑÐ°',    '90 minutes = 2 hours');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 5}), true),   '5 ÑÐ°ÑÐ¾Ð²',    '5 hours = 5 hours');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 21}), true),  '21 ÑÐ°Ñ',   '21 hours = 21 hours');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 22}), true),  'Ð´ÐµÐ½Ñ',      '22 hours = a day');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 35}), true),  'Ð´ÐµÐ½Ñ',      '35 hours = a day');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 36}), true),  '2 Ð´Ð½Ñ',     '36 hours = 2 days');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 1}), true),   'Ð´ÐµÐ½Ñ',      '1 day = a day');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 5}), true),   '5 Ð´Ð½ÐµÐ¹',     '5 days = 5 days');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 11}), true),  '11 Ð´Ð½ÐµÐ¹',     '11 days = 11 days');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 21}), true),  '21 Ð´ÐµÐ½Ñ',     '21 days = 21 days');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 25}), true),  '25 Ð´Ð½ÐµÐ¹',    '25 days = 25 days');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 26}), true),  'Ð¼ÐµÑÑÑ',    '26 days = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 30}), true),  'Ð¼ÐµÑÑÑ',    '30 days = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 43}), true),  'Ð¼ÐµÑÑÑ',    '43 days = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 46}), true),  '2 Ð¼ÐµÑÑÑÐ°',   '46 days = 2 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 74}), true),  '2 Ð¼ÐµÑÑÑÐ°',   '75 days = 2 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 76}), true),  '3 Ð¼ÐµÑÑÑÐ°',   '76 days = 3 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({M: 1}), true),   'Ð¼ÐµÑÑÑ',    '1 month = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({M: 5}), true),   '5 Ð¼ÐµÑÑÑÐµÐ²',   '5 months = 5 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 345}), true), 'Ð³Ð¾Ð´',     '345 days = a year');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 548}), true), '2 Ð³Ð¾Ð´Ð°',    '548 days = 2 years');
        assert.equal(start.from(moment([2007, 1, 28]).add({y: 1}), true),   'Ð³Ð¾Ð´',     '1 year = a year');
        assert.equal(start.from(moment([2007, 1, 28]).add({y: 5}), true),   '5 Ð»ÐµÑ',    '5 years = 5 years');
    });

    test('suffix', function (assert) {
        assert.equal(moment(30000).from(0), 'ÑÐµÑÐµÐ· Ð½ÐµÑÐºÐ¾Ð»ÑÐºÐ¾ ÑÐµÐºÑÐ½Ð´', 'prefix');
        assert.equal(moment(0).from(30000), 'Ð½ÐµÑÐºÐ¾Ð»ÑÐºÐ¾ ÑÐµÐºÑÐ½Ð´ Ð½Ð°Ð·Ð°Ð´', 'suffix');
    });

    test('fromNow', function (assert) {
        assert.equal(moment().add({s: 30}).fromNow(), 'ÑÐµÑÐµÐ· Ð½ÐµÑÐºÐ¾Ð»ÑÐºÐ¾ ÑÐµÐºÑÐ½Ð´', 'in seconds');
        assert.equal(moment().add({d: 5}).fromNow(), 'ÑÐµÑÐµÐ· 5 Ð´Ð½ÐµÐ¹', 'in 5 days');
        assert.equal(moment().add({m: 31}).fromNow(), 'ÑÐµÑÐµÐ· 31 Ð¼Ð¸Ð½ÑÑÑ', 'in 31 minutes = in 31 minutes');
        assert.equal(moment().subtract({m: 31}).fromNow(), '31 Ð¼Ð¸Ð½ÑÑÑ Ð½Ð°Ð·Ð°Ð´', '31 minutes ago = 31 minutes ago');
    });

    test('calendar day', function (assert) {
        var a = moment().hours(12).minutes(0).seconds(0);

        assert.equal(moment(a).calendar(),                   'Ð¡ÐµÐ³Ð¾Ð´Ð½Ñ Ð² 12:00',     'today at the same time');
        assert.equal(moment(a).add({m: 25}).calendar(),      'Ð¡ÐµÐ³Ð¾Ð´Ð½Ñ Ð² 12:25',     'Now plus 25 min');
        assert.equal(moment(a).add({h: 1}).calendar(),       'Ð¡ÐµÐ³Ð¾Ð´Ð½Ñ Ð² 13:00',     'Now plus 1 hour');
        assert.equal(moment(a).add({d: 1}).calendar(),       'ÐÐ°Ð²ÑÑÐ° Ð² 12:00',      'tomorrow at the same time');
        assert.equal(moment(a).subtract({h: 1}).calendar(),  'Ð¡ÐµÐ³Ð¾Ð´Ð½Ñ Ð² 11:00',     'Now minus 1 hour');
        assert.equal(moment(a).subtract({d: 1}).calendar(),  'ÐÑÐµÑÐ° Ð² 12:00',       'yesterday at the same time');
    });

    test('calendar next week', function (assert) {
        var i, m, now;

        function makeFormatNext(d) {
            switch (d.day()) {
            case 0:
                return '[Ð ÑÐ»ÐµÐ´ÑÑÑÐµÐµ] dddd [Ð²] LT';
            case 1:
            case 2:
            case 4:
                return '[Ð ÑÐ»ÐµÐ´ÑÑÑÐ¸Ð¹] dddd [Ð²] LT';
            case 3:
            case 5:
            case 6:
                return '[Ð ÑÐ»ÐµÐ´ÑÑÑÑÑ] dddd [Ð²] LT';
            }
        }

        function makeFormatThis(d) {
            if (d.day() === 2) {
                return '[ÐÐ¾] dddd [Ð²] LT';
            }
            else {
                return '[Ð] dddd [Ð²] LT';
            }
        }

        now = moment().startOf('week');
        for (i = 2; i < 7; i++) {
            m = moment(now).add({d: i});
            assert.equal(m.calendar(now),       m.format(makeFormatThis(m)),  'Today + ' + i + ' days current time');
            m.hours(0).minutes(0).seconds(0).milliseconds(0);
            assert.equal(m.calendar(now),       m.format(makeFormatThis(m)),  'Today + ' + i + ' days beginning of day');
            m.hours(23).minutes(59).seconds(59).milliseconds(999);
            assert.equal(m.calendar(now),       m.format(makeFormatThis(m)),  'Today + ' + i + ' days end of day');
        }

        now = moment().endOf('week');
        for (i = 2; i < 7; i++) {
            m = moment(now).add({d: i});
            assert.equal(m.calendar(now),       m.format(makeFormatNext(m)),  'Today + ' + i + ' days current time');
            m.hours(0).minutes(0).seconds(0).milliseconds(0);
            assert.equal(m.calendar(now),       m.format(makeFormatNext(m)),  'Today + ' + i + ' days beginning of day');
            m.hours(23).minutes(59).seconds(59).milliseconds(999);
            assert.equal(m.calendar(now),       m.format(makeFormatNext(m)),  'Today + ' + i + ' days end of day');
        }
    });

    test('calendar last week', function (assert) {
        var i, m, now;

        function makeFormatLast(d) {
            switch (d.day()) {
            case 0:
                return '[Ð Ð¿ÑÐ¾ÑÐ»Ð¾Ðµ] dddd [Ð²] LT';
            case 1:
            case 2:
            case 4:
                return '[Ð Ð¿ÑÐ¾ÑÐ»ÑÐ¹] dddd [Ð²] LT';
            case 3:
            case 5:
            case 6:
                return '[Ð Ð¿ÑÐ¾ÑÐ»ÑÑ] dddd [Ð²] LT';
            }
        }

        function makeFormatThis(d) {
            if (d.day() === 2) {
                return '[ÐÐ¾] dddd [Ð²] LT';
            }
            else {
                return '[Ð] dddd [Ð²] LT';
            }
        }

        now = moment().startOf('week');
        for (i = 2; i < 7; i++) {
            m = moment(now).subtract({d: i});
            assert.equal(m.calendar(now),       m.format(makeFormatLast(m)),  'Today - ' + i + ' days current time');
            m.hours(0).minutes(0).seconds(0).milliseconds(0);
            assert.equal(m.calendar(now),       m.format(makeFormatLast(m)),  'Today - ' + i + ' days beginning of day');
            m.hours(23).minutes(59).seconds(59).milliseconds(999);
            assert.equal(m.calendar(now),       m.format(makeFormatLast(m)),  'Today - ' + i + ' days end of day');
        }

        now = moment().endOf('week');
        for (i = 2; i < 7; i++) {
            m = moment(now).subtract({d: i});
            assert.equal(m.calendar(now),       m.format(makeFormatThis(m)),  'Today - ' + i + ' days current time');
            m.hours(0).minutes(0).seconds(0).milliseconds(0);
            assert.equal(m.calendar(now),       m.format(makeFormatThis(m)),  'Today - ' + i + ' days beginning of day');
            m.hours(23).minutes(59).seconds(59).milliseconds(999);
            assert.equal(m.calendar(now),       m.format(makeFormatThis(m)),  'Today - ' + i + ' days end of day');
        }
    });

    test('calendar all else', function (assert) {
        var weeksAgo = moment().subtract({w: 1}),
            weeksFromNow = moment().add({w: 1});

        assert.equal(weeksAgo.calendar(),       weeksAgo.format('L'),  '1 week ago');
        assert.equal(weeksFromNow.calendar(),   weeksFromNow.format('L'),  'in 1 week');

        weeksAgo = moment().subtract({w: 2});
        weeksFromNow = moment().add({w: 2});

        assert.equal(weeksAgo.calendar(),       weeksAgo.format('L'),  '2 weeks ago');
        assert.equal(weeksFromNow.calendar(),   weeksFromNow.format('L'),  'in 2 weeks');
    });

    test('weeks year starting sunday formatted', function (assert) {
        assert.equal(moment([2011, 11, 26]).format('w ww wo'), '1 01 1-Ñ', 'Dec 26 2011 should be week 1');
        assert.equal(moment([2012,  0,  1]).format('w ww wo'), '1 01 1-Ñ', 'Jan  1 2012 should be week 1');
        assert.equal(moment([2012,  0,  2]).format('w ww wo'), '2 02 2-Ñ', 'Jan  2 2012 should be week 2');
        assert.equal(moment([2012,  0,  8]).format('w ww wo'), '2 02 2-Ñ', 'Jan  8 2012 should be week 2');
        assert.equal(moment([2012,  0,  9]).format('w ww wo'), '3 03 3-Ñ', 'Jan  9 2012 should be week 3');
    });

}));

;(function (global, factory) {
   typeof exports === 'object' && typeof module !== 'undefined'
       && typeof require === 'function' ? factory(require('../../moment')) :
   typeof define === 'function' && define.amd ? define(['../../moment'], factory) :
   factory(global.moment)
}(this, function (moment) { 'use strict';

    function each(array, callback) {
        var i;
        for (i = 0; i < array.length; i++) {
            callback(array[i], i, array);
        }
    }

    function objectKeys(obj) {
        if (Object.keys) {
            return Object.keys(obj);
        } else {
            // IE8
            var res = [], i;
            for (i in obj) {
                if (obj.hasOwnProperty(i)) {
                    res.push(i);
                }
            }
            return res;
        }
    }

    // Pick the first defined of two or three arguments.
    function defaults(a, b, c) {
        if (a != null) {
            return a;
        }
        if (b != null) {
            return b;
        }
        return c;
    }

    function defineCommonLocaleTests(locale, options) {
        test('lenient ordinal parsing', function (assert) {
            var i, ordinalStr, testMoment;
            for (i = 1; i <= 31; ++i) {
                ordinalStr = moment([2014, 0, i]).format('YYYY MM Do');
                testMoment = moment(ordinalStr, 'YYYY MM Do');
                assert.equal(testMoment.year(), 2014,
                        'lenient ordinal parsing ' + i + ' year check');
                assert.equal(testMoment.month(), 0,
                        'lenient ordinal parsing ' + i + ' month check');
                assert.equal(testMoment.date(), i,
                        'lenient ordinal parsing ' + i + ' date check');
            }
        });

        test('lenient ordinal parsing of number', function (assert) {
            var i, testMoment;
            for (i = 1; i <= 31; ++i) {
                testMoment = moment('2014 01 ' + i, 'YYYY MM Do');
                assert.equal(testMoment.year(), 2014,
                        'lenient ordinal parsing of number ' + i + ' year check');
                assert.equal(testMoment.month(), 0,
                        'lenient ordinal parsing of number ' + i + ' month check');
                assert.equal(testMoment.date(), i,
                        'lenient ordinal parsing of number ' + i + ' date check');
            }
        });

        test('strict ordinal parsing', function (assert) {
            var i, ordinalStr, testMoment;
            for (i = 1; i <= 31; ++i) {
                ordinalStr = moment([2014, 0, i]).format('YYYY MM Do');
                testMoment = moment(ordinalStr, 'YYYY MM Do', true);
                assert.ok(testMoment.isValid(), 'strict ordinal parsing ' + i);
            }
        });

        test('meridiem invariant', function (assert) {
            var h, m, t1, t2;
            for (h = 0; h < 24; ++h) {
                for (m = 0; m < 60; m += 15) {
                    t1 = moment.utc([2000, 0, 1, h, m]);
                    t2 = moment.utc(t1.format('A h:mm'), 'A h:mm');
                    assert.equal(t2.format('HH:mm'), t1.format('HH:mm'),
                            'meridiem at ' + t1.format('HH:mm'));
                }
            }
        });

        test('date format correctness', function (assert) {
            var data, tokens;
            data = moment.localeData()._longDateFormat;
            tokens = objectKeys(data);
            each(tokens, function (srchToken) {
                // Check each format string to make sure it does not contain any
                // tokens that need to be expanded.
                each(tokens, function (baseToken) {
                    // strip escaped sequences
                    var format = data[baseToken].replace(/(\[[^\]]*\])/g, '');
                    assert.equal(false, !!~format.indexOf(srchToken),
                            'contains ' + srchToken + ' in ' + baseToken);
                });
            });
        });

        test('month parsing correctness', function (assert) {
            var i, m;

            if (locale === 'tr') {
                // I can't fix it :(
                expect(0);
                return;
            }
            function tester(format) {
                var r;
                r = moment(m.format(format), format);
                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format);
                r = moment(m.format(format).toLocaleUpperCase(), format);
                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' upper');
                r = moment(m.format(format).toLocaleLowerCase(), format);
                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' lower');

                r = moment(m.format(format), format, true);
                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' strict');
                r = moment(m.format(format).toLocaleUpperCase(), format, true);
                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' upper strict');
                r = moment(m.format(format).toLocaleLowerCase(), format, true);
                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' lower strict');
            }

            for (i = 0; i < 12; ++i) {
                m = moment([2015, i, 15, 18]);
                tester('MMM');
                tester('MMM.');
                tester('MMMM');
                tester('MMMM.');
            }
        });

        test('weekday parsing correctness', function (assert) {
            var i, m;

            if (locale === 'tr' || locale === 'az') {
                // There is a lower-case letter (Ä±), that converted to upper then
                // lower changes to i
                expect(0);
                return;
            }
            function tester(format) {
                var r, baseMsg = 'weekday ' + m.weekday() + ' fmt ' + format;
                r = moment(m.format(format), format);
                assert.equal(r.weekday(), m.weekday(), baseMsg);
                r = moment(m.format(format).toLocaleUpperCase(), format);
                assert.equal(r.weekday(), m.weekday(), baseMsg + ' upper');
                r = moment(m.format(format).toLocaleLowerCase(), format);
                assert.equal(r.weekday(), m.weekday(), baseMsg + ' lower');

                r = moment(m.format(format), format, true);
                assert.equal(r.weekday(), m.weekday(), baseMsg + ' strict');
                r = moment(m.format(format).toLocaleUpperCase(), format, true);
                assert.equal(r.weekday(), m.weekday(), baseMsg + ' upper strict');
                r = moment(m.format(format).toLocaleLowerCase(), format, true);
                assert.equal(r.weekday(), m.weekday(), baseMsg + ' lower strict');
            }

            for (i = 0; i < 7; ++i) {
                m = moment.utc([2015, i, 15, 18]);
                tester('dd');
                tester('ddd');
                tester('dddd');
            }
        });
    }

    function setupDeprecationHandler(test, moment, scope) {
        test._expectedDeprecations = null;
        test._observedDeprecations = null;
        test._oldSupress = moment.suppressDeprecationWarnings;
        moment.suppressDeprecationWarnings = true;
        test.expectedDeprecations = function () {
            test._expectedDeprecations = arguments;
            test._observedDeprecations = [];
        };
        moment.deprecationHandler = function (name, msg) {
            var deprecationId = matchedDeprecation(name, msg, test._expectedDeprecations);
            if (deprecationId === -1) {
                throw new Error('Unexpected deprecation thrown name=' +
                        name + ' msg=' + msg);
            }
            test._observedDeprecations[deprecationId] = 1;
        };
    }

    function teardownDeprecationHandler(test, moment, scope) {
        moment.suppressDeprecationWarnings = test._oldSupress;

        if (test._expectedDeprecations != null) {
            var missedDeprecations = [];
            each(test._expectedDeprecations, function (deprecationPattern, id) {
                if (test._observedDeprecations[id] !== 1) {
                    missedDeprecations.push(deprecationPattern);
                }
            });
            if (missedDeprecations.length !== 0) {
                throw new Error('Expected deprecation warnings did not happen: ' +
                        missedDeprecations.join(' '));
            }
        }
    }

    function matchedDeprecation(name, msg, deprecations) {
        if (deprecations == null) {
            return -1;
        }
        for (var i = 0; i < deprecations.length; ++i) {
            if (name != null && name === deprecations[i]) {
                return i;
            }
            if (msg != null && msg.substring(0, deprecations[i].length) === deprecations[i]) {
                return i;
            }
        }
        return -1;
    }

    /*global QUnit:false*/

    var test = QUnit.test;

    var expect = QUnit.expect;

    function module (name, lifecycle) {
        QUnit.module(name, {
            setup : function () {
                moment.locale('en');
                moment.createFromInputFallback = function (config) {
                    throw new Error('input not handled by moment: ' + config._i);
                };
                setupDeprecationHandler(test, moment, 'core');
                if (lifecycle && lifecycle.setup) {
                    lifecycle.setup();
                }
            },
            teardown : function () {
                teardownDeprecationHandler(test, moment, 'core');
                if (lifecycle && lifecycle.teardown) {
                    lifecycle.teardown();
                }
            }
        });
    }

    function localeModule (name, lifecycle) {
        QUnit.module('locale:' + name, {
            setup : function () {
                moment.locale(name);
                moment.createFromInputFallback = function (config) {
                    throw new Error('input not handled by moment: ' + config._i);
                };
                setupDeprecationHandler(test, moment, 'locale');
                if (lifecycle && lifecycle.setup) {
                    lifecycle.setup();
                }
            },
            teardown : function () {
                moment.locale('en');
                teardownDeprecationHandler(test, moment, 'locale');
                if (lifecycle && lifecycle.teardown) {
                    lifecycle.teardown();
                }
            }
        });
        defineCommonLocaleTests(name, -1, -1);
    }

    localeModule('se');

    test('parse', function (assert) {
        var i,
            tests = 'oÄÄajagemÃ¡nnu oÄÄj_guovvamÃ¡nnu guov_njukÄamÃ¡nnu njuk_cuoÅomÃ¡nnu cuo_miessemÃ¡nnu mies_geassemÃ¡nnu geas_suoidnemÃ¡nnu suoi_borgemÃ¡nnu borg_ÄakÄamÃ¡nnu ÄakÄ_golggotmÃ¡nnu golg_skÃ¡bmamÃ¡nnu skÃ¡b_juovlamÃ¡nnu juov'.split('_');

        function equalTest(input, mmm, i) {
            assert.equal(moment(input, mmm).month(), i, input + ' should be month ' + (i + 1));
        }

        for (i = 0; i < 12; i++) {
            tests[i] = tests[i].split(' ');
            equalTest(tests[i][0], 'MMM', i);
            equalTest(tests[i][1], 'MMM', i);
            equalTest(tests[i][0], 'MMMM', i);
            equalTest(tests[i][1], 'MMMM', i);
            equalTest(tests[i][0].toLocaleLowerCase(), 'MMMM', i);
            equalTest(tests[i][1].toLocaleLowerCase(), 'MMMM', i);
            equalTest(tests[i][0].toLocaleUpperCase(), 'MMMM', i);
            equalTest(tests[i][1].toLocaleUpperCase(), 'MMMM', i);
        }
    });

    test('format', function (assert) {
        var a = [
                ['dddd, MMMM Do YYYY, h:mm:ss a',      'sotnabeaivi, guovvamÃ¡nnu 14. 2010, 3:25:50 pm'],
                ['ddd, hA',                            'sotn, 3PM'],
                ['M Mo MM MMMM MMM',                   '2 2. 02 guovvamÃ¡nnu guov'],
                ['YYYY YY',                            '2010 10'],
                ['D Do DD',                            '14 14. 14'],
                ['d do dddd ddd dd',                   '0 0. sotnabeaivi sotn s'],
                ['DDD DDDo DDDD',                      '45 45. 045'],
                ['w wo ww',                            '6 6. 06'],
                ['h hh',                               '3 03'],
                ['H HH',                               '15 15'],
                ['m mm',                               '25 25'],
                ['s ss',                               '50 50'],
                ['a A',                                'pm PM'],
                ['[jagi] DDDo [beaivi]',               'jagi 45. beaivi'],
                ['LTS',                                '15:25:50'],
                ['L',                                  '14.02.2010'],
                ['LL',                                 'guovvamÃ¡nnu 14. b. 2010'],
                ['LLL',                                'guovvamÃ¡nnu 14. b. 2010 ti. 15:25'],
                ['LLLL',                               'sotnabeaivi, guovvamÃ¡nnu 14. b. 2010 ti. 15:25'],
                ['l',                                  '14.2.2010'],
                ['ll',                                 'guov 14. b. 2010'],
                ['lll',                                'guov 14. b. 2010 ti. 15:25'],
                ['llll',                               'sotn, guov 14. b. 2010 ti. 15:25']
            ],
            b = moment(new Date(2010, 1, 14, 15, 25, 50, 125)),
            i;

        for (i = 0; i < a.length; i++) {
            assert.equal(b.format(a[i][0]), a[i][1], a[i][0] + ' ---> ' + a[i][1]);
        }
    });

    test('format ordinal', function (assert) {
        assert.equal(moment([2011, 0, 1]).format('DDDo'), '1.', '1.');
        assert.equal(moment([2011, 0, 2]).format('DDDo'), '2.', '2.');
        assert.equal(moment([2011, 0, 3]).format('DDDo'), '3.', '3.');
        assert.equal(moment([2011, 0, 4]).format('DDDo'), '4.', '4.');
        assert.equal(moment([2011, 0, 5]).format('DDDo'), '5.', '5.');
        assert.equal(moment([2011, 0, 6]).format('DDDo'), '6.', '6.');
        assert.equal(moment([2011, 0, 7]).format('DDDo'), '7.', '7.');
        assert.equal(moment([2011, 0, 8]).format('DDDo'), '8.', '8.');
        assert.equal(moment([2011, 0, 9]).format('DDDo'), '9.', '9.');
        assert.equal(moment([2011, 0, 10]).format('DDDo'), '10.', '10.');

        assert.equal(moment([2011, 0, 11]).format('DDDo'), '11.', '11.');
        assert.equal(moment([2011, 0, 12]).format('DDDo'), '12.', '12.');
        assert.equal(moment([2011, 0, 13]).format('DDDo'), '13.', '13.');
        assert.equal(moment([2011, 0, 14]).format('DDDo'), '14.', '14.');
        assert.equal(moment([2011, 0, 15]).format('DDDo'), '15.', '15.');
        assert.equal(moment([2011, 0, 16]).format('DDDo'), '16.', '16.');
        assert.equal(moment([2011, 0, 17]).format('DDDo'), '17.', '17.');
        assert.equal(moment([2011, 0, 18]).format('DDDo'), '18.', '18.');
        assert.equal(moment([2011, 0, 19]).format('DDDo'), '19.', '19.');
        assert.equal(moment([2011, 0, 20]).format('DDDo'), '20.', '20.');

        assert.equal(moment([2011, 0, 21]).format('DDDo'), '21.', '21.');
        assert.equal(moment([2011, 0, 22]).format('DDDo'), '22.', '22.');
        assert.equal(moment([2011, 0, 23]).format('DDDo'), '23.', '23.');
        assert.equal(moment([2011, 0, 24]).format('DDDo'), '24.', '24.');
        assert.equal(moment([2011, 0, 25]).format('DDDo'), '25.', '25.');
        assert.equal(moment([2011, 0, 26]).format('DDDo'), '26.', '26.');
        assert.equal(moment([2011, 0, 27]).format('DDDo'), '27.', '27.');
        assert.equal(moment([2011, 0, 28]).format('DDDo'), '28.', '28.');
        assert.equal(moment([2011, 0, 29]).format('DDDo'), '29.', '29.');
        assert.equal(moment([2011, 0, 30]).format('DDDo'), '30.', '30.');

        assert.equal(moment([2011, 0, 31]).format('DDDo'), '31.', '31.');
    });

    test('format month', function (assert) {
        var i,
            expected = 'oÄÄajagemÃ¡nnu oÄÄj_guovvamÃ¡nnu guov_njukÄamÃ¡nnu njuk_cuoÅomÃ¡nnu cuo_miessemÃ¡nnu mies_geassemÃ¡nnu geas_suoidnemÃ¡nnu suoi_borgemÃ¡nnu borg_ÄakÄamÃ¡nnu ÄakÄ_golggotmÃ¡nnu golg_skÃ¡bmamÃ¡nnu skÃ¡b_juovlamÃ¡nnu juov'.split('_');

        for (i = 0; i < expected.length; i++) {
            assert.equal(moment([2011, i, 1]).format('MMMM MMM'), expected[i], expected[i]);
        }
    });

    test('format week', function (assert) {
        var i,
            expected = 'sotnabeaivi sotn s_vuossÃ¡rga vuos v_maÅÅebÃ¡rga maÅ m_gaskavahkku gask g_duorastat duor d_bearjadat bear b_lÃ¡vvardat lÃ¡v L'.split('_');

        for (i = 0; i < expected.length; i++) {
            assert.equal(moment([2011, 0, 2 + i]).format('dddd ddd dd'), expected[i], expected[i]);
        }
    });

    test('from', function (assert) {
        var start = moment([2007, 1, 28]);

        assert.equal(start.from(moment([2007, 1, 28]).add({s: 44}), true),  'moadde sekunddat', '44 seconds = a few seconds');
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 45}), true),  'okta minuhta',  '45 seconds = a minute');
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 89}), true),  'okta minuhta',  '89 seconds = a minute');
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 90}), true),  '2 minuhtat',    '90 seconds = 2 minutes');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 44}), true),  '44 minuhtat',   '44 minutes = 44 minutes');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 45}), true),  'okta diimmu',   '45 minutes = an hour');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 89}), true),  'okta diimmu',   '89 minutes = an hour');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 90}), true),  '2 diimmut',     '90 minutes = 2 hours');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 5}), true),   '5 diimmut',     '5 hours = 5 hours');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 21}), true),  '21 diimmut',    '21 hours = 21 hours');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 22}), true),  'okta beaivi',   '22 hours = a day');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 35}), true),  'okta beaivi',   '35 hours = a day');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 36}), true),  '2 beaivvit',    '36 hours = 2 days');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 1}), true),   'okta beaivi',   '1 day = a day');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 5}), true),   '5 beaivvit',    '5 days = 5 days');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 25}), true),  '25 beaivvit',   '25 days = 25 days');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 26}), true),  'okta mÃ¡nnu',    '26 days = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 30}), true),  'okta mÃ¡nnu',    '30 days = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 43}), true),  'okta mÃ¡nnu',    '43 days = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 46}), true),  '2 mÃ¡nut',       '46 days = 2 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 74}), true),  '2 mÃ¡nut',       '75 days = 2 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 76}), true),  '3 mÃ¡nut',       '76 days = 3 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({M: 1}), true),   'okta mÃ¡nnu',    '1 month = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({M: 5}), true),   '5 mÃ¡nut',       '5 months = 5 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 345}), true), 'okta jahki',    '345 days = a year');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 548}), true), '2 jagit',       '548 days = 2 years');
        assert.equal(start.from(moment([2007, 1, 28]).add({y: 1}), true),   'okta jahki',    '1 year = a year');
        assert.equal(start.from(moment([2007, 1, 28]).add({y: 5}), true),   '5 jagit',       '5 years = 5 years');
    });

    test('suffix', function (assert) {
        assert.equal(moment(30000).from(0), 'moadde sekunddat geaÅ¾es',  'prefix');
        assert.equal(moment(0).from(30000), 'maÅit moadde sekunddat', 'suffix');
    });

    test('now from now', function (assert) {
        assert.equal(moment().fromNow(), 'maÅit moadde sekunddat',  'now from now should display as in the past');
    });

    test('fromNow', function (assert) {
        assert.equal(moment().add({s: 30}).fromNow(), 'moadde sekunddat geaÅ¾es', 'in a few seconds');
        assert.equal(moment().add({d: 5}).fromNow(), '5 beaivvit geaÅ¾es', 'in 5 days');
    });

    test('calendar day', function (assert) {
        var a = moment().hours(12).minutes(0).seconds(0);

        assert.equal(moment(a).calendar(),                   'otne ti 12:00',     'Today at the same time');
        assert.equal(moment(a).add({m: 25}).calendar(),      'otne ti 12:25',     'Now plus 25 min');
        assert.equal(moment(a).add({h: 1}).calendar(),       'otne ti 13:00',     'Now plus 1 hour');
        assert.equal(moment(a).add({d: 1}).calendar(),       'ihttin ti 12:00',   'Tomorrow at the same time');
        assert.equal(moment(a).subtract({h: 1}).calendar(),  'otne ti 11:00',     'Now minus 1 hour');
        assert.equal(moment(a).subtract({d: 1}).calendar(),  'ikte ti 12:00',     'yesterday at the same time');
    });

    test('calendar next week', function (assert) {
        var i, m;

        for (i = 2; i < 7; i++) {
            m = moment().add({d: i});
            assert.equal(m.calendar(),       m.format('dddd [ti] LT'),  'Today + ' + i + ' days current time');
            m.hours(0).minutes(0).seconds(0).milliseconds(0);
            assert.equal(m.calendar(),       m.format('dddd [ti] LT'),  'Today + ' + i + ' days beginning of day');
            m.hours(23).minutes(59).seconds(59).milliseconds(999);
            assert.equal(m.calendar(),       m.format('dddd [ti] LT'),  'Today + ' + i + ' days end of day');
        }
    });

    test('calendar last week', function (assert) {
        var i, m;

        for (i = 2; i < 7; i++) {
            m = moment().subtract({d: i});
            assert.equal(m.calendar(),       m.format('[ovddit] dddd [ti] LT'),  'Today - ' + i + ' days current time');
            m.hours(0).minutes(0).seconds(0).milliseconds(0);
            assert.equal(m.calendar(),       m.format('[ovddit] dddd [ti] LT'),  'Today - ' + i + ' days beginning of day');
            m.hours(23).minutes(59).seconds(59).milliseconds(999);
            assert.equal(m.calendar(),       m.format('[ovddit] dddd [ti] LT'),  'Today - ' + i + ' days end of day');
        }
    });

    test('calendar all else', function (assert) {
        var weeksAgo = moment().subtract({w: 1}),
            weeksFromNow = moment().add({w: 1});

        assert.equal(weeksAgo.calendar(),       weeksAgo.format('L'),  '1 week ago');
        assert.equal(weeksFromNow.calendar(),   weeksFromNow.format('L'),  'in 1 week');

        weeksAgo = moment().subtract({w: 2});
        weeksFromNow = moment().add({w: 2});

        assert.equal(weeksAgo.calendar(),       weeksAgo.format('L'),  '2 weeks ago');
        assert.equal(weeksFromNow.calendar(),   weeksFromNow.format('L'),  'in 2 weeks');
    });

    test('weeks year starting sunday formatted', function (assert) {
        assert.equal(moment([2012, 0,  1]).format('w ww wo'), '52 52 52.', 'Jan  1 2012 should be week 52');
        assert.equal(moment([2012, 0,  2]).format('w ww wo'),  '1 01 1.', 'Jan  2 2012 should be week 1');
        assert.equal(moment([2012, 0,  8]).format('w ww wo'),  '1 01 1.', 'Jan  8 2012 should be week 1');
        assert.equal(moment([2012, 0,  9]).format('w ww wo'),  '2 02 2.', 'Jan  9 2012 should be week 2');
        assert.equal(moment([2012, 0, 15]).format('w ww wo'),  '2 02 2.', 'Jan 15 2012 should be week 2');
    });

}));

;(function (global, factory) {
   typeof exports === 'object' && typeof module !== 'undefined'
       && typeof require === 'function' ? factory(require('../../moment')) :
   typeof define === 'function' && define.amd ? define(['../../moment'], factory) :
   factory(global.moment)
}(this, function (moment) { 'use strict';

    function each(array, callback) {
        var i;
        for (i = 0; i < array.length; i++) {
            callback(array[i], i, array);
        }
    }

    function objectKeys(obj) {
        if (Object.keys) {
            return Object.keys(obj);
        } else {
            // IE8
            var res = [], i;
            for (i in obj) {
                if (obj.hasOwnProperty(i)) {
                    res.push(i);
                }
            }
            return res;
        }
    }

    // Pick the first defined of two or three arguments.
    function defaults(a, b, c) {
        if (a != null) {
            return a;
        }
        if (b != null) {
            return b;
        }
        return c;
    }

    function defineCommonLocaleTests(locale, options) {
        test('lenient ordinal parsing', function (assert) {
            var i, ordinalStr, testMoment;
            for (i = 1; i <= 31; ++i) {
                ordinalStr = moment([2014, 0, i]).format('YYYY MM Do');
                testMoment = moment(ordinalStr, 'YYYY MM Do');
                assert.equal(testMoment.year(), 2014,
                        'lenient ordinal parsing ' + i + ' year check');
                assert.equal(testMoment.month(), 0,
                        'lenient ordinal parsing ' + i + ' month check');
                assert.equal(testMoment.date(), i,
                        'lenient ordinal parsing ' + i + ' date check');
            }
        });

        test('lenient ordinal parsing of number', function (assert) {
            var i, testMoment;
            for (i = 1; i <= 31; ++i) {
                testMoment = moment('2014 01 ' + i, 'YYYY MM Do');
                assert.equal(testMoment.year(), 2014,
                        'lenient ordinal parsing of number ' + i + ' year check');
                assert.equal(testMoment.month(), 0,
                        'lenient ordinal parsing of number ' + i + ' month check');
                assert.equal(testMoment.date(), i,
                        'lenient ordinal parsing of number ' + i + ' date check');
            }
        });

        test('strict ordinal parsing', function (assert) {
            var i, ordinalStr, testMoment;
            for (i = 1; i <= 31; ++i) {
                ordinalStr = moment([2014, 0, i]).format('YYYY MM Do');
                testMoment = moment(ordinalStr, 'YYYY MM Do', true);
                assert.ok(testMoment.isValid(), 'strict ordinal parsing ' + i);
            }
        });

        test('meridiem invariant', function (assert) {
            var h, m, t1, t2;
            for (h = 0; h < 24; ++h) {
                for (m = 0; m < 60; m += 15) {
                    t1 = moment.utc([2000, 0, 1, h, m]);
                    t2 = moment.utc(t1.format('A h:mm'), 'A h:mm');
                    assert.equal(t2.format('HH:mm'), t1.format('HH:mm'),
                            'meridiem at ' + t1.format('HH:mm'));
                }
            }
        });

        test('date format correctness', function (assert) {
            var data, tokens;
            data = moment.localeData()._longDateFormat;
            tokens = objectKeys(data);
            each(tokens, function (srchToken) {
                // Check each format string to make sure it does not contain any
                // tokens that need to be expanded.
                each(tokens, function (baseToken) {
                    // strip escaped sequences
                    var format = data[baseToken].replace(/(\[[^\]]*\])/g, '');
                    assert.equal(false, !!~format.indexOf(srchToken),
                            'contains ' + srchToken + ' in ' + baseToken);
                });
            });
        });

        test('month parsing correctness', function (assert) {
            var i, m;

            if (locale === 'tr') {
                // I can't fix it :(
                expect(0);
                return;
            }
            function tester(format) {
                var r;
                r = moment(m.format(format), format);
                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format);
                r = moment(m.format(format).toLocaleUpperCase(), format);
                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' upper');
                r = moment(m.format(format).toLocaleLowerCase(), format);
                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' lower');

                r = moment(m.format(format), format, true);
                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' strict');
                r = moment(m.format(format).toLocaleUpperCase(), format, true);
                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' upper strict');
                r = moment(m.format(format).toLocaleLowerCase(), format, true);
                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' lower strict');
            }

            for (i = 0; i < 12; ++i) {
                m = moment([2015, i, 15, 18]);
                tester('MMM');
                tester('MMM.');
                tester('MMMM');
                tester('MMMM.');
            }
        });

        test('weekday parsing correctness', function (assert) {
            var i, m;

            if (locale === 'tr' || locale === 'az') {
                // There is a lower-case letter (Ä±), that converted to upper then
                // lower changes to i
                expect(0);
                return;
            }
            function tester(format) {
                var r, baseMsg = 'weekday ' + m.weekday() + ' fmt ' + format;
                r = moment(m.format(format), format);
                assert.equal(r.weekday(), m.weekday(), baseMsg);
                r = moment(m.format(format).toLocaleUpperCase(), format);
                assert.equal(r.weekday(), m.weekday(), baseMsg + ' upper');
                r = moment(m.format(format).toLocaleLowerCase(), format);
                assert.equal(r.weekday(), m.weekday(), baseMsg + ' lower');

                r = moment(m.format(format), format, true);
                assert.equal(r.weekday(), m.weekday(), baseMsg + ' strict');
                r = moment(m.format(format).toLocaleUpperCase(), format, true);
                assert.equal(r.weekday(), m.weekday(), baseMsg + ' upper strict');
                r = moment(m.format(format).toLocaleLowerCase(), format, true);
                assert.equal(r.weekday(), m.weekday(), baseMsg + ' lower strict');
            }

            for (i = 0; i < 7; ++i) {
                m = moment.utc([2015, i, 15, 18]);
                tester('dd');
                tester('ddd');
                tester('dddd');
            }
        });
    }

    function setupDeprecationHandler(test, moment, scope) {
        test._expectedDeprecations = null;
        test._observedDeprecations = null;
        test._oldSupress = moment.suppressDeprecationWarnings;
        moment.suppressDeprecationWarnings = true;
        test.expectedDeprecations = function () {
            test._expectedDeprecations = arguments;
            test._observedDeprecations = [];
        };
        moment.deprecationHandler = function (name, msg) {
            var deprecationId = matchedDeprecation(name, msg, test._expectedDeprecations);
            if (deprecationId === -1) {
                throw new Error('Unexpected deprecation thrown name=' +
                        name + ' msg=' + msg);
            }
            test._observedDeprecations[deprecationId] = 1;
        };
    }

    function teardownDeprecationHandler(test, moment, scope) {
        moment.suppressDeprecationWarnings = test._oldSupress;

        if (test._expectedDeprecations != null) {
            var missedDeprecations = [];
            each(test._expectedDeprecations, function (deprecationPattern, id) {
                if (test._observedDeprecations[id] !== 1) {
                    missedDeprecations.push(deprecationPattern);
                }
            });
            if (missedDeprecations.length !== 0) {
                throw new Error('Expected deprecation warnings did not happen: ' +
                        missedDeprecations.join(' '));
            }
        }
    }

    function matchedDeprecation(name, msg, deprecations) {
        if (deprecations == null) {
            return -1;
        }
        for (var i = 0; i < deprecations.length; ++i) {
            if (name != null && name === deprecations[i]) {
                return i;
            }
            if (msg != null && msg.substring(0, deprecations[i].length) === deprecations[i]) {
                return i;
            }
        }
        return -1;
    }

    /*global QUnit:false*/

    var test = QUnit.test;

    var expect = QUnit.expect;

    function module (name, lifecycle) {
        QUnit.module(name, {
            setup : function () {
                moment.locale('en');
                moment.createFromInputFallback = function (config) {
                    throw new Error('input not handled by moment: ' + config._i);
                };
                setupDeprecationHandler(test, moment, 'core');
                if (lifecycle && lifecycle.setup) {
                    lifecycle.setup();
                }
            },
            teardown : function () {
                teardownDeprecationHandler(test, moment, 'core');
                if (lifecycle && lifecycle.teardown) {
                    lifecycle.teardown();
                }
            }
        });
    }

    function localeModule (name, lifecycle) {
        QUnit.module('locale:' + name, {
            setup : function () {
                moment.locale(name);
                moment.createFromInputFallback = function (config) {
                    throw new Error('input not handled by moment: ' + config._i);
                };
                setupDeprecationHandler(test, moment, 'locale');
                if (lifecycle && lifecycle.setup) {
                    lifecycle.setup();
                }
            },
            teardown : function () {
                moment.locale('en');
                teardownDeprecationHandler(test, moment, 'locale');
                if (lifecycle && lifecycle.teardown) {
                    lifecycle.teardown();
                }
            }
        });
        defineCommonLocaleTests(name, -1, -1);
    }

    localeModule('si');

    /*jshint -W100*/
    test('parse', function (assert) {
        var tests = 'à¶¢à¶±à·à·à¶»à· à¶¢à¶±_à¶´à·à¶¶à¶»à·à·à¶»à· à¶´à·à¶¶_à¶¸à·à¶»à·à¶­à· à¶¸à·à¶»à·_à¶à¶´à·âà¶»à·à¶½à· à¶à¶´à·_à¶¸à·à¶ºà· à¶¸à·à¶ºà·_à¶¢à·à¶±à· à¶¢à·à¶±à·_à¶¢à·à¶½à· à¶¢à·à¶½à·_à¶à¶à·à·à·à¶­à· à¶à¶à·_à·à·à¶´à·à¶­à·à¶¸à·à¶¶à¶»à· à·à·à¶´à·_à¶à¶à·à¶­à·à¶¶à¶»à· à¶à¶à·_à¶±à·à·à·à¶¸à·à¶¶à¶»à· à¶±à·à·à·_à¶¯à·à·à·à¶¸à·à¶¶à¶»à· à¶¯à·à·à·'.split('_'), i;
        function equalTest(input, mmm, i) {
            assert.equal(moment(input, mmm).month(), i, input + ' should be month ' + (i + 1));
        }
        for (i = 0; i < 12; i++) {
            tests[i] = tests[i].split(' ');
            equalTest(tests[i][0], 'MMM', i);
            equalTest(tests[i][1], 'MMM', i);
            equalTest(tests[i][0], 'MMMM', i);
            equalTest(tests[i][1], 'MMMM', i);
            equalTest(tests[i][0].toLocaleLowerCase(), 'MMMM', i);
            equalTest(tests[i][1].toLocaleLowerCase(), 'MMMM', i);
            equalTest(tests[i][0].toLocaleUpperCase(), 'MMMM', i);
            equalTest(tests[i][1].toLocaleUpperCase(), 'MMMM', i);
        }
    });

    test('format', function (assert) {
        var a = [
                ['YYYY MMMM Do dddd, a h:mm:ss',       '2010 à¶´à·à¶¶à¶»à·à·à¶»à· 14 à·à·à¶±à· à¶à¶»à·à¶¯à·, à¶´.à·. 3:25:50'],
                ['YYYY MMMM Do dddd, a h:mm:ss',       '2010 à¶´à·à¶¶à¶»à·à·à¶»à· 14 à·à·à¶±à· à¶à¶»à·à¶¯à·, à¶´.à·. 3:25:50'],
                ['ddd, A h',                            'à¶à¶»à·, à¶´à·à· à·à¶»à· 3'],
                ['M Mo MM MMMM MMM',                   '2 2 à·à·à¶±à· 02 à¶´à·à¶¶à¶»à·à·à¶»à· à¶´à·à¶¶'],
                ['YYYY YY',                            '2010 10'],
                ['D Do DD',                            '14 14 à·à·à¶±à· 14'],
                ['d do dddd ddd dd',                   '0 0 à·à·à¶±à· à¶à¶»à·à¶¯à· à¶à¶»à· à¶'],
                ['DDD DDDo DDDD',                      '45 45 à·à·à¶±à· 045'],
                ['h hh',                               '3 03'],
                ['H HH',                               '15 15'],
                ['m mm',                               '25 25'],
                ['s ss',                               '50 50'],
                ['a A',                                'à¶´.à·. à¶´à·à· à·à¶»à·'],
                ['[à·à·à¶»à·] DDDo [à¶¯à·à¶±à¶º]',                      'à·à·à¶»à· 45 à·à·à¶±à· à¶¯à·à¶±à¶º'],
                ['LTS',                                'à¶´.à·. 3:25:50'],
                ['LT',                                 'à¶´.à·. 3:25'],
                ['L',                                  '2010/02/14'],
                ['LL',                                 '2010 à¶´à·à¶¶à¶»à·à·à¶»à· 14'],
                ['LLL',                                '2010 à¶´à·à¶¶à¶»à·à·à¶»à· 14, à¶´.à·. 3:25'],
                ['LLLL',                               '2010 à¶´à·à¶¶à¶»à·à·à¶»à· 14 à·à·à¶±à· à¶à¶»à·à¶¯à·, à¶´.à·. 3:25:50'],
                ['l',                                  '2010/2/14'],
                ['ll',                                 '2010 à¶´à·à¶¶ 14'],
                ['lll',                                '2010 à¶´à·à¶¶ 14, à¶´.à·. 3:25'],
                ['llll',                               '2010 à¶´à·à¶¶ 14 à·à·à¶±à· à¶à¶»à·, à¶´.à·. 3:25:50']
            ],
            b = moment(new Date(2010, 1, 14, 15, 25, 50, 125)),
            i;
        for (i = 0; i < a.length; i++) {
            assert.equal(b.format(a[i][0]), a[i][1], a[i][0] + ' ---> ' + a[i][1]);
        }
    });

    test('format ordinal', function (assert) {
        assert.equal(moment([2011, 0, 1]).format('DDDo'), '1 à·à·à¶±à·', '1 à·à·à¶±à·');
        assert.equal(moment([2011, 0, 2]).format('DDDo'), '2 à·à·à¶±à·', '2 à·à·à¶±à·');
        assert.equal(moment([2011, 0, 3]).format('DDDo'), '3 à·à·à¶±à·', '3 à·à·à¶±à·');
        assert.equal(moment([2011, 0, 4]).format('DDDo'), '4 à·à·à¶±à·', '4 à·à·à¶±à·');
        assert.equal(moment([2011, 0, 5]).format('DDDo'), '5 à·à·à¶±à·', '5 à·à·à¶±à·');
        assert.equal(moment([2011, 0, 6]).format('DDDo'), '6 à·à·à¶±à·', '6 à·à·à¶±à·');
        assert.equal(moment([2011, 0, 7]).format('DDDo'), '7 à·à·à¶±à·', '7 à·à·à¶±à·');
        assert.equal(moment([2011, 0, 8]).format('DDDo'), '8 à·à·à¶±à·', '8 à·à·à¶±à·');
        assert.equal(moment([2011, 0, 9]).format('DDDo'), '9 à·à·à¶±à·', '9 à·à·à¶±à·');
        assert.equal(moment([2011, 0, 10]).format('DDDo'), '10 à·à·à¶±à·', '10 à·à·à¶±à·');

        assert.equal(moment([2011, 0, 11]).format('DDDo'), '11 à·à·à¶±à·', '11 à·à·à¶±à·');
        assert.equal(moment([2011, 0, 12]).format('DDDo'), '12 à·à·à¶±à·', '12 à·à·à¶±à·');
        assert.equal(moment([2011, 0, 13]).format('DDDo'), '13 à·à·à¶±à·', '13 à·à·à¶±à·');
        assert.equal(moment([2011, 0, 14]).format('DDDo'), '14 à·à·à¶±à·', '14 à·à·à¶±à·');
        assert.equal(moment([2011, 0, 15]).format('DDDo'), '15 à·à·à¶±à·', '15 à·à·à¶±à·');
        assert.equal(moment([2011, 0, 16]).format('DDDo'), '16 à·à·à¶±à·', '16 à·à·à¶±à·');
        assert.equal(moment([2011, 0, 17]).format('DDDo'), '17 à·à·à¶±à·', '17 à·à·à¶±à·');
        assert.equal(moment([2011, 0, 18]).format('DDDo'), '18 à·à·à¶±à·', '18 à·à·à¶±à·');
        assert.equal(moment([2011, 0, 19]).format('DDDo'), '19 à·à·à¶±à·', '19 à·à·à¶±à·');
        assert.equal(moment([2011, 0, 20]).format('DDDo'), '20 à·à·à¶±à·', '20 à·à·à¶±à·');

        assert.equal(moment([2011, 0, 21]).format('DDDo'), '21 à·à·à¶±à·', '21 à·à·à¶±à·');
        assert.equal(moment([2011, 0, 22]).format('DDDo'), '22 à·à·à¶±à·', '22 à·à·à¶±à·');
        assert.equal(moment([2011, 0, 23]).format('DDDo'), '23 à·à·à¶±à·', '23 à·à·à¶±à·');
        assert.equal(moment([2011, 0, 24]).format('DDDo'), '24 à·à·à¶±à·', '24 à·à·à¶±à·');
        assert.equal(moment([2011, 0, 25]).format('DDDo'), '25 à·à·à¶±à·', '25 à·à·à¶±à·');
        assert.equal(moment([2011, 0, 26]).format('DDDo'), '26 à·à·à¶±à·', '26 à·à·à¶±à·');
        assert.equal(moment([2011, 0, 27]).format('DDDo'), '27 à·à·à¶±à·', '27 à·à·à¶±à·');
        assert.equal(moment([2011, 0, 28]).format('DDDo'), '28 à·à·à¶±à·', '28 à·à·à¶±à·');
        assert.equal(moment([2011, 0, 29]).format('DDDo'), '29 à·à·à¶±à·', '29 à·à·à¶±à·');
        assert.equal(moment([2011, 0, 30]).format('DDDo'), '30 à·à·à¶±à·', '30 à·à·à¶±à·');

        assert.equal(moment([2011, 0, 31]).format('DDDo'), '31 à·à·à¶±à·', '31 à·à·à¶±à·');
    });

    test('format month', function (assert) {
        var expected = 'à¶¢à¶±à·à·à¶»à· à¶¢à¶±_à¶´à·à¶¶à¶»à·à·à¶»à· à¶´à·à¶¶_à¶¸à·à¶»à·à¶­à· à¶¸à·à¶»à·_à¶à¶´à·âà¶»à·à¶½à· à¶à¶´à·_à¶¸à·à¶ºà· à¶¸à·à¶ºà·_à¶¢à·à¶±à· à¶¢à·à¶±à·_à¶¢à·à¶½à· à¶¢à·à¶½à·_à¶à¶à·à·à·à¶­à· à¶à¶à·_à·à·à¶´à·à¶­à·à¶¸à·à¶¶à¶»à· à·à·à¶´à·_à¶à¶à·à¶­à·à¶¶à¶»à· à¶à¶à·_à¶±à·à·à·à¶¸à·à¶¶à¶»à· à¶±à·à·à·_à¶¯à·à·à·à¶¸à·à¶¶à¶»à· à¶¯à·à·à·'.split('_'), i;
        for (i = 0; i < expected.length; i++) {
            assert.equal(moment([2011, i, 1]).format('MMMM MMM'), expected[i], expected[i]);
        }
    });

    test('format week', function (assert) {
        var expected = 'à¶à¶»à·à¶¯à· à¶à¶»à· à¶_à·à¶³à·à¶¯à· à·à¶³à· à·_à¶à¶à·à¶»à·à·à·à¶¯à· à¶à¶ à¶_à¶¶à¶¯à·à¶¯à· à¶¶à¶¯à· à¶¶_à¶¶à·âà¶»à·à·à·à¶´à¶­à·à¶±à·à¶¯à· à¶¶à·âà¶»à· à¶¶à·âà¶»_à·à·à¶à·à¶»à·à¶¯à· à·à·à¶à· à·à·_à·à·à¶±à·à·à¶»à·à¶¯à· à·à·à¶± à·à·'.split('_'), i;
        for (i = 0; i < expected.length; i++) {
            assert.equal(moment([2011, 0, 2 + i]).format('dddd ddd dd'), expected[i], expected[i]);
        }
    });

    test('from', function (assert) {
        var start = moment([2007, 1, 28]);
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 44}), true),  'à¶­à¶­à·à¶´à¶» à¶à·à·à·à¶´à¶º', '44 seconds = a few seconds');
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 45}), true),  'à¶¸à·à¶±à·à¶­à·à¶­à·à·',      '45 seconds = a minute');
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 89}), true),  'à¶¸à·à¶±à·à¶­à·à¶­à·à·',      '89 seconds = a minute');
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 90}), true),  'à¶¸à·à¶±à·à¶­à·à¶­à· 2',     '90 seconds = 2 minutes');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 44}), true),  'à¶¸à·à¶±à·à¶­à·à¶­à· 44',    '44 minutes = 44 minutes');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 45}), true),  'à¶´à·à¶º',       '45 minutes = an hour');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 89}), true),  'à¶´à·à¶º',       '89 minutes = an hour');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 90}), true),  'à¶´à·à¶º 2',       '90 minutes = 2 hours');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 5}), true),   'à¶´à·à¶º 5',       '5 hours = 5 hours');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 21}), true),  'à¶´à·à¶º 21',      '21 hours = 21 hours');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 22}), true),  'à¶¯à·à¶±à¶º',         '22 hours = a day');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 35}), true),  'à¶¯à·à¶±à¶º',         '35 hours = a day');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 36}), true),  'à¶¯à·à¶± 2',        '36 hours = 2 days');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 1}), true),   'à¶¯à·à¶±à¶º',         '1 day = a day');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 5}), true),   'à¶¯à·à¶± 5',        '5 days = 5 days');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 25}), true),  'à¶¯à·à¶± 25',       '25 days = 25 days');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 26}), true),  'à¶¸à·à·à¶º',       '26 days = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 30}), true),  'à¶¸à·à·à¶º',       '30 days = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 43}), true),  'à¶¸à·à·à¶º',       '43 days = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 46}), true),  'à¶¸à·à· 2',      '46 days = 2 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 74}), true),  'à¶¸à·à· 2',      '75 days = 2 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 76}), true),  'à¶¸à·à· 3',      '76 days = 3 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({M: 1}), true),   'à¶¸à·à·à¶º',       '1 month = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({M: 5}), true),   'à¶¸à·à· 5',      '5 months = 5 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 345}), true), 'à·à·à¶»',        '345 days = a year');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 548}), true), 'à·à·à¶» 2',       '548 days = 2 years');
        assert.equal(start.from(moment([2007, 1, 28]).add({y: 1}), true),   'à·à·à¶»',        '1 year = a year');
        assert.equal(start.from(moment([2007, 1, 28]).add({y: 5}), true),   'à·à·à¶» 5',       '5 years = 5 years');
    });

    test('suffix', function (assert) {
        assert.equal(moment(30000).from(0), 'à¶­à¶­à·à¶´à¶» à¶à·à·à·à¶´à¶ºà¶à·à¶±à·',  'prefix');
        assert.equal(moment(0).from(30000), 'à¶­à¶­à·à¶´à¶» à¶à·à·à·à¶´à¶ºà¶à¶§ à¶´à·à¶»', 'suffix');
    });

    test('now from now', function (assert) {
        assert.equal(moment().fromNow(), 'à¶­à¶­à·à¶´à¶» à¶à·à·à·à¶´à¶ºà¶à¶§ à¶´à·à¶»',  'now from now should display as in the past');
    });

    test('fromNow', function (assert) {
        assert.equal(moment().add({s: 30}).fromNow(), 'à¶­à¶­à·à¶´à¶» à¶à·à·à·à¶´à¶ºà¶à·à¶±à·', 'in a few seconds');
        assert.equal(moment().add({d: 5}).fromNow(), 'à¶¯à·à¶± 5à¶à·à¶±à·', 'in 5 days');
    });

    test('calendar day', function (assert) {
        var a = moment().hours(12).minutes(0).seconds(0);

        assert.equal(moment(a).calendar(),                   'à¶à¶¯ à¶´.à·. 12:00à¶§',     'today at the same time');
        assert.equal(moment(a).add({m: 25}).calendar(),      'à¶à¶¯ à¶´.à·. 12:25à¶§',     'Now plus 25 min');
        assert.equal(moment(a).add({h: 1}).calendar(),       'à¶à¶¯ à¶´.à·. 1:00à¶§',      'Now plus 1 hour');
        assert.equal(moment(a).add({d: 1}).calendar(),       'à·à·à¶§ à¶´.à·. 12:00à¶§',   'tomorrow at the same time');
        assert.equal(moment(a).subtract({h: 1}).calendar(),  'à¶à¶¯ à¶´à·.à·. 11:00à¶§',    'Now minus 1 hour');
        assert.equal(moment(a).subtract({d: 1}).calendar(),  'à¶à¶ºà· à¶´.à·. 12:00à¶§',   'yesterday at the same time');
    });

    test('calendar next week', function (assert) {
        var i, m;
        for (i = 2; i < 7; i++) {
            m = moment().add({d: i});
            assert.equal(m.calendar(),       m.format('dddd LT[à¶§]'),  'Today + ' + i + ' days current time');
            m.hours(0).minutes(0).seconds(0).milliseconds(0);
            assert.equal(m.calendar(),       m.format('dddd LT[à¶§]'),  'Today + ' + i + ' days beginning of day');
            m.hours(23).minutes(59).seconds(59).milliseconds(999);
            assert.equal(m.calendar(),       m.format('dddd LT[à¶§]'),  'Today + ' + i + ' days end of day');
        }
    });

    test('calendar last week', function (assert) {
        var i, m;

        for (i = 2; i < 7; i++) {
            m = moment().subtract({d: i});
            assert.equal(m.calendar(),       m.format('[à¶´à·à·à¶à·à¶º] dddd LT[à¶§]'),  'Today - ' + i + ' days current time');
            m.hours(0).minutes(0).seconds(0).milliseconds(0);
            assert.equal(m.calendar(),       m.format('[à¶´à·à·à¶à·à¶º] dddd LT[à¶§]'),  'Today - ' + i + ' days beginning of day');
            m.hours(23).minutes(59).seconds(59).milliseconds(999);
            assert.equal(m.calendar(),       m.format('[à¶´à·à·à¶à·à¶º] dddd LT[à¶§]'),  'Today - ' + i + ' days end of day');
        }
    });

    test('calendar all else', function (assert) {
        var weeksAgo = moment().subtract({w: 1}),
            weeksFromNow = moment().add({w: 1});

        assert.equal(weeksAgo.calendar(),       weeksAgo.format('L'),  '1 week ago');
        assert.equal(weeksFromNow.calendar(),   weeksFromNow.format('L'),  'in 1 week');

        weeksAgo = moment().subtract({w: 2});
        weeksFromNow = moment().add({w: 2});

        assert.equal(weeksAgo.calendar(),       weeksAgo.format('L'),  '2 weeks ago');
        assert.equal(weeksFromNow.calendar(),   weeksFromNow.format('L'),  'in 2 weeks');
    });

}));

;(function (global, factory) {
   typeof exports === 'object' && typeof module !== 'undefined'
       && typeof require === 'function' ? factory(require('../../moment')) :
   typeof define === 'function' && define.amd ? define(['../../moment'], factory) :
   factory(global.moment)
}(this, function (moment) { 'use strict';

    function each(array, callback) {
        var i;
        for (i = 0; i < array.length; i++) {
            callback(array[i], i, array);
        }
    }

    function objectKeys(obj) {
        if (Object.keys) {
            return Object.keys(obj);
        } else {
            // IE8
            var res = [], i;
            for (i in obj) {
                if (obj.hasOwnProperty(i)) {
                    res.push(i);
                }
            }
            return res;
        }
    }

    // Pick the first defined of two or three arguments.
    function defaults(a, b, c) {
        if (a != null) {
            return a;
        }
        if (b != null) {
            return b;
        }
        return c;
    }

    function defineCommonLocaleTests(locale, options) {
        test('lenient ordinal parsing', function (assert) {
            var i, ordinalStr, testMoment;
            for (i = 1; i <= 31; ++i) {
                ordinalStr = moment([2014, 0, i]).format('YYYY MM Do');
                testMoment = moment(ordinalStr, 'YYYY MM Do');
                assert.equal(testMoment.year(), 2014,
                        'lenient ordinal parsing ' + i + ' year check');
                assert.equal(testMoment.month(), 0,
                        'lenient ordinal parsing ' + i + ' month check');
                assert.equal(testMoment.date(), i,
                        'lenient ordinal parsing ' + i + ' date check');
            }
        });

        test('lenient ordinal parsing of number', function (assert) {
            var i, testMoment;
            for (i = 1; i <= 31; ++i) {
                testMoment = moment('2014 01 ' + i, 'YYYY MM Do');
                assert.equal(testMoment.year(), 2014,
                        'lenient ordinal parsing of number ' + i + ' year check');
                assert.equal(testMoment.month(), 0,
                        'lenient ordinal parsing of number ' + i + ' month check');
                assert.equal(testMoment.date(), i,
                        'lenient ordinal parsing of number ' + i + ' date check');
            }
        });

        test('strict ordinal parsing', function (assert) {
            var i, ordinalStr, testMoment;
            for (i = 1; i <= 31; ++i) {
                ordinalStr = moment([2014, 0, i]).format('YYYY MM Do');
                testMoment = moment(ordinalStr, 'YYYY MM Do', true);
                assert.ok(testMoment.isValid(), 'strict ordinal parsing ' + i);
            }
        });

        test('meridiem invariant', function (assert) {
            var h, m, t1, t2;
            for (h = 0; h < 24; ++h) {
                for (m = 0; m < 60; m += 15) {
                    t1 = moment.utc([2000, 0, 1, h, m]);
                    t2 = moment.utc(t1.format('A h:mm'), 'A h:mm');
                    assert.equal(t2.format('HH:mm'), t1.format('HH:mm'),
                            'meridiem at ' + t1.format('HH:mm'));
                }
            }
        });

        test('date format correctness', function (assert) {
            var data, tokens;
            data = moment.localeData()._longDateFormat;
            tokens = objectKeys(data);
            each(tokens, function (srchToken) {
                // Check each format string to make sure it does not contain any
                // tokens that need to be expanded.
                each(tokens, function (baseToken) {
                    // strip escaped sequences
                    var format = data[baseToken].replace(/(\[[^\]]*\])/g, '');
                    assert.equal(false, !!~format.indexOf(srchToken),
                            'contains ' + srchToken + ' in ' + baseToken);
                });
            });
        });

        test('month parsing correctness', function (assert) {
            var i, m;

            if (locale === 'tr') {
                // I can't fix it :(
                expect(0);
                return;
            }
            function tester(format) {
                var r;
                r = moment(m.format(format), format);
                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format);
                r = moment(m.format(format).toLocaleUpperCase(), format);
                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' upper');
                r = moment(m.format(format).toLocaleLowerCase(), format);
                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' lower');

                r = moment(m.format(format), format, true);
                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' strict');
                r = moment(m.format(format).toLocaleUpperCase(), format, true);
                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' upper strict');
                r = moment(m.format(format).toLocaleLowerCase(), format, true);
                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' lower strict');
            }

            for (i = 0; i < 12; ++i) {
                m = moment([2015, i, 15, 18]);
                tester('MMM');
                tester('MMM.');
                tester('MMMM');
                tester('MMMM.');
            }
        });

        test('weekday parsing correctness', function (assert) {
            var i, m;

            if (locale === 'tr' || locale === 'az') {
                // There is a lower-case letter (Ä±), that converted to upper then
                // lower changes to i
                expect(0);
                return;
            }
            function tester(format) {
                var r, baseMsg = 'weekday ' + m.weekday() + ' fmt ' + format;
                r = moment(m.format(format), format);
                assert.equal(r.weekday(), m.weekday(), baseMsg);
                r = moment(m.format(format).toLocaleUpperCase(), format);
                assert.equal(r.weekday(), m.weekday(), baseMsg + ' upper');
                r = moment(m.format(format).toLocaleLowerCase(), format);
                assert.equal(r.weekday(), m.weekday(), baseMsg + ' lower');

                r = moment(m.format(format), format, true);
                assert.equal(r.weekday(), m.weekday(), baseMsg + ' strict');
                r = moment(m.format(format).toLocaleUpperCase(), format, true);
                assert.equal(r.weekday(), m.weekday(), baseMsg + ' upper strict');
                r = moment(m.format(format).toLocaleLowerCase(), format, true);
                assert.equal(r.weekday(), m.weekday(), baseMsg + ' lower strict');
            }

            for (i = 0; i < 7; ++i) {
                m = moment.utc([2015, i, 15, 18]);
                tester('dd');
                tester('ddd');
                tester('dddd');
            }
        });
    }

    function setupDeprecationHandler(test, moment, scope) {
        test._expectedDeprecations = null;
        test._observedDeprecations = null;
        test._oldSupress = moment.suppressDeprecationWarnings;
        moment.suppressDeprecationWarnings = true;
        test.expectedDeprecations = function () {
            test._expectedDeprecations = arguments;
            test._observedDeprecations = [];
        };
        moment.deprecationHandler = function (name, msg) {
            var deprecationId = matchedDeprecation(name, msg, test._expectedDeprecations);
            if (deprecationId === -1) {
                throw new Error('Unexpected deprecation thrown name=' +
                        name + ' msg=' + msg);
            }
            test._observedDeprecations[deprecationId] = 1;
        };
    }

    function teardownDeprecationHandler(test, moment, scope) {
        moment.suppressDeprecationWarnings = test._oldSupress;

        if (test._expectedDeprecations != null) {
            var missedDeprecations = [];
            each(test._expectedDeprecations, function (deprecationPattern, id) {
                if (test._observedDeprecations[id] !== 1) {
                    missedDeprecations.push(deprecationPattern);
                }
            });
            if (missedDeprecations.length !== 0) {
                throw new Error('Expected deprecation warnings did not happen: ' +
                        missedDeprecations.join(' '));
            }
        }
    }

    function matchedDeprecation(name, msg, deprecations) {
        if (deprecations == null) {
            return -1;
        }
        for (var i = 0; i < deprecations.length; ++i) {
            if (name != null && name === deprecations[i]) {
                return i;
            }
            if (msg != null && msg.substring(0, deprecations[i].length) === deprecations[i]) {
                return i;
            }
        }
        return -1;
    }

    /*global QUnit:false*/

    var test = QUnit.test;

    var expect = QUnit.expect;

    function module (name, lifecycle) {
        QUnit.module(name, {
            setup : function () {
                moment.locale('en');
                moment.createFromInputFallback = function (config) {
                    throw new Error('input not handled by moment: ' + config._i);
                };
                setupDeprecationHandler(test, moment, 'core');
                if (lifecycle && lifecycle.setup) {
                    lifecycle.setup();
                }
            },
            teardown : function () {
                teardownDeprecationHandler(test, moment, 'core');
                if (lifecycle && lifecycle.teardown) {
                    lifecycle.teardown();
                }
            }
        });
    }

    function localeModule (name, lifecycle) {
        QUnit.module('locale:' + name, {
            setup : function () {
                moment.locale(name);
                moment.createFromInputFallback = function (config) {
                    throw new Error('input not handled by moment: ' + config._i);
                };
                setupDeprecationHandler(test, moment, 'locale');
                if (lifecycle && lifecycle.setup) {
                    lifecycle.setup();
                }
            },
            teardown : function () {
                moment.locale('en');
                teardownDeprecationHandler(test, moment, 'locale');
                if (lifecycle && lifecycle.teardown) {
                    lifecycle.teardown();
                }
            }
        });
        defineCommonLocaleTests(name, -1, -1);
    }

    localeModule('sk');

    test('parse', function (assert) {
        var tests = 'januÃ¡r jan._februÃ¡r feb._marec mar._aprÃ­l apr._mÃ¡j mÃ¡j_jÃºn jÃºn._jÃºl jÃºl._august aug._september sep._oktÃ³ber okt._november nov._december dec.'.split('_'), i;
        function equalTest(input, mmm, monthIndex) {
            assert.equal(moment(input, mmm).month(), monthIndex, input + ' should be month ' + (monthIndex + 1));
        }
        for (i = 0; i < 12; i++) {
            tests[i] = tests[i].split(' ');
            equalTest(tests[i][0], 'MMM', i);
            equalTest(tests[i][1], 'MMM', i);
            equalTest(tests[i][0], 'MMMM', i);
            equalTest(tests[i][1], 'MMMM', i);
            equalTest(tests[i][0].toLocaleLowerCase(), 'MMMM', i);
            equalTest(tests[i][1].toLocaleLowerCase(), 'MMMM', i);
            equalTest(tests[i][0].toLocaleUpperCase(), 'MMMM', i);
            equalTest(tests[i][1].toLocaleUpperCase(), 'MMMM', i);
        }
    });

    test('format', function (assert) {
        var a = [
                ['dddd, MMMM Do YYYY, h:mm:ss',  'nedeÄ¾a, februÃ¡r 14. 2010, 3:25:50'],
                ['ddd, h',                       'ne, 3'],
                ['M Mo MM MMMM MMM',             '2 2. 02 februÃ¡r feb'],
                ['YYYY YY',                      '2010 10'],
                ['D Do DD',                      '14 14. 14'],
                ['d do dddd ddd dd',             '0 0. nedeÄ¾a ne ne'],
                ['DDD DDDo DDDD',                '45 45. 045'],
                ['w wo ww',                      '6 6. 06'],
                ['h hh',                         '3 03'],
                ['H HH',                         '15 15'],
                ['m mm',                         '25 25'],
                ['s ss',                         '50 50'],
                ['a A',                          'pm PM'],
                ['DDDo [deÅ v roku]',            '45. deÅ v roku'],
                ['LTS',                          '15:25:50'],
                ['L',                            '14.02.2010'],
                ['LL',                           '14. februÃ¡r 2010'],
                ['LLL',                          '14. februÃ¡r 2010 15:25'],
                ['LLLL',                         'nedeÄ¾a 14. februÃ¡r 2010 15:25'],
                ['l',                            '14.2.2010'],
                ['ll',                           '14. feb 2010'],
                ['lll',                          '14. feb 2010 15:25'],
                ['llll',                         'ne 14. feb 2010 15:25']
            ],
            b = moment(new Date(2010, 1, 14, 15, 25, 50, 125)),
            i;
        for (i = 0; i < a.length; i++) {
            assert.equal(b.format(a[i][0]), a[i][1], a[i][0] + ' ---> ' + a[i][1]);
        }
    });

    test('format ordinal', function (assert) {
        assert.equal(moment([2011, 0, 1]).format('DDDo'), '1.', '1.');
        assert.equal(moment([2011, 0, 2]).format('DDDo'), '2.', '2.');
        assert.equal(moment([2011, 0, 3]).format('DDDo'), '3.', '3.');
        assert.equal(moment([2011, 0, 4]).format('DDDo'), '4.', '4.');
        assert.equal(moment([2011, 0, 5]).format('DDDo'), '5.', '5.');
        assert.equal(moment([2011, 0, 6]).format('DDDo'), '6.', '6.');
        assert.equal(moment([2011, 0, 7]).format('DDDo'), '7.', '7.');
        assert.equal(moment([2011, 0, 8]).format('DDDo'), '8.', '8.');
        assert.equal(moment([2011, 0, 9]).format('DDDo'), '9.', '9.');
        assert.equal(moment([2011, 0, 10]).format('DDDo'), '10.', '10.');

        assert.equal(moment([2011, 0, 11]).format('DDDo'), '11.', '11.');
        assert.equal(moment([2011, 0, 12]).format('DDDo'), '12.', '12.');
        assert.equal(moment([2011, 0, 13]).format('DDDo'), '13.', '13.');
        assert.equal(moment([2011, 0, 14]).format('DDDo'), '14.', '14.');
        assert.equal(moment([2011, 0, 15]).format('DDDo'), '15.', '15.');
        assert.equal(moment([2011, 0, 16]).format('DDDo'), '16.', '16.');
        assert.equal(moment([2011, 0, 17]).format('DDDo'), '17.', '17.');
        assert.equal(moment([2011, 0, 18]).format('DDDo'), '18.', '18.');
        assert.equal(moment([2011, 0, 19]).format('DDDo'), '19.', '19.');
        assert.equal(moment([2011, 0, 20]).format('DDDo'), '20.', '20.');

        assert.equal(moment([2011, 0, 21]).format('DDDo'), '21.', '21.');
        assert.equal(moment([2011, 0, 22]).format('DDDo'), '22.', '22.');
        assert.equal(moment([2011, 0, 23]).format('DDDo'), '23.', '23.');
        assert.equal(moment([2011, 0, 24]).format('DDDo'), '24.', '24.');
        assert.equal(moment([2011, 0, 25]).format('DDDo'), '25.', '25.');
        assert.equal(moment([2011, 0, 26]).format('DDDo'), '26.', '26.');
        assert.equal(moment([2011, 0, 27]).format('DDDo'), '27.', '27.');
        assert.equal(moment([2011, 0, 28]).format('DDDo'), '28.', '28.');
        assert.equal(moment([2011, 0, 29]).format('DDDo'), '29.', '29.');
        assert.equal(moment([2011, 0, 30]).format('DDDo'), '30.', '30.');

        assert.equal(moment([2011, 0, 31]).format('DDDo'), '31.', '31.');
    });

    test('format month', function (assert) {
        var expected = 'januÃ¡r jan_februÃ¡r feb_marec mar_aprÃ­l apr_mÃ¡j mÃ¡j_jÃºn jÃºn_jÃºl jÃºl_august aug_september sep_oktÃ³ber okt_november nov_december dec'.split('_'), i;
        for (i = 0; i < expected.length; i++) {
            assert.equal(moment([2011, i, 1]).format('MMMM MMM'), expected[i], expected[i]);
        }
    });

    test('format week', function (assert) {
        var expected = 'nedeÄ¾a ne ne_pondelok po po_utorok ut ut_streda st st_Å¡tvrtok Å¡t Å¡t_piatok pi pi_sobota so so'.split('_'), i;
        for (i = 0; i < expected.length; i++) {
            assert.equal(moment([2011, 0, 2 + i]).format('dddd ddd dd'), expected[i], expected[i]);
        }
    });

    test('from', function (assert) {
        var start = moment([2007, 1, 28]);
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 44}), true),  'pÃ¡r sekÃºnd',  '44 seconds = a few seconds');
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 45}), true),  'minÃºta',        '45 seconds = a minute');
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 89}), true),  'minÃºta',        '89 seconds = a minute');
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 90}), true),  '2 minÃºty',      '90 seconds = 2 minutes');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 44}), true),  '44 minÃºt',     '44 minutes = 44 minutes');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 45}), true),  'hodina',       '45 minutes = an hour');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 89}), true),  'hodina',       '89 minutes = an hour');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 90}), true),  '2 hodiny',     '90 minutes = 2 hours');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 5}), true),   '5 hodÃ­n',      '5 hours = 5 hours');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 21}), true),  '21 hodÃ­n',     '21 hours = 21 hours');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 22}), true),  'deÅ',       '22 hours = a day');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 35}), true),  'deÅ',       '35 hours = a day');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 36}), true),  '2 dni',         '36 hours = 2 days');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 1}), true),   'deÅ',       '1 day = a day');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 5}), true),   '5 dnÃ­',         '5 days = 5 days');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 25}), true),  '25 dnÃ­',        '25 days = 25 days');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 26}), true),  'mesiac',       '26 days = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 30}), true),  'mesiac',       '30 days = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 43}), true),  'mesiac',       '43 days = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 46}), true),  '2 mesiace',    '46 days = 2 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 74}), true),  '2 mesiace',    '75 days = 2 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 76}), true),  '3 mesiace',    '76 days = 3 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({M: 1}), true),   'mesiac',       '1 month = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({M: 5}), true),   '5 mesiacov',    '5 months = 5 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 345}), true), 'rok',           '345 days = a year');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 548}), true), '2 roky',        '548 days = 2 years');
        assert.equal(start.from(moment([2007, 1, 28]).add({y: 1}), true),   'rok',           '1 year = a year');
        assert.equal(start.from(moment([2007, 1, 28]).add({y: 5}), true),   '5 rokov',         '5 years = 5 years');
    });

    test('suffix', function (assert) {
        assert.equal(moment(30000).from(0), 'za pÃ¡r sekÃºnd',  'prefix');
        assert.equal(moment(0).from(30000), 'pred pÃ¡r sekundami', 'suffix');
    });

    test('now from now', function (assert) {
        assert.equal(moment().fromNow(), 'pred pÃ¡r sekundami',  'now from now should display as in the past');
    });

    test('fromNow (future)', function (assert) {
        assert.equal(moment().add({s: 30}).fromNow(), 'za pÃ¡r sekÃºnd', 'in a few seconds');
        assert.equal(moment().add({m: 1}).fromNow(), 'za minÃºtu', 'in a minute');
        assert.equal(moment().add({m: 3}).fromNow(), 'za 3 minÃºty', 'in 3 minutes');
        assert.equal(moment().add({m: 10}).fromNow(), 'za 10 minÃºt', 'in 10 minutes');
        assert.equal(moment().add({h: 1}).fromNow(), 'za hodinu', 'in an hour');
        assert.equal(moment().add({h: 3}).fromNow(), 'za 3 hodiny', 'in 3 hours');
        assert.equal(moment().add({h: 10}).fromNow(), 'za 10 hodÃ­n', 'in 10 hours');
        assert.equal(moment().add({d: 1}).fromNow(), 'za deÅ', 'in a day');
        assert.equal(moment().add({d: 3}).fromNow(), 'za 3 dni', 'in 3 days');
        assert.equal(moment().add({d: 10}).fromNow(), 'za 10 dnÃ­', 'in 10 days');
        assert.equal(moment().add({M: 1}).fromNow(), 'za mesiac', 'in a month');
        assert.equal(moment().add({M: 3}).fromNow(), 'za 3 mesiace', 'in 3 months');
        assert.equal(moment().add({M: 10}).fromNow(), 'za 10 mesiacov', 'in 10 months');
        assert.equal(moment().add({y: 1}).fromNow(), 'za rok', 'in a year');
        assert.equal(moment().add({y: 3}).fromNow(), 'za 3 roky', 'in 3 years');
        assert.equal(moment().add({y: 10}).fromNow(), 'za 10 rokov', 'in 10 years');
    });

    test('fromNow (past)', function (assert) {
        assert.equal(moment().subtract({s: 30}).fromNow(), 'pred pÃ¡r sekundami', 'a few seconds ago');
        assert.equal(moment().subtract({m: 1}).fromNow(), 'pred minÃºtou', 'a minute ago');
        assert.equal(moment().subtract({m: 3}).fromNow(), 'pred 3 minÃºtami', '3 minutes ago');
        assert.equal(moment().subtract({m: 10}).fromNow(), 'pred 10 minÃºtami', '10 minutes ago');
        assert.equal(moment().subtract({h: 1}).fromNow(), 'pred hodinou', 'an hour ago');
        assert.equal(moment().subtract({h: 3}).fromNow(), 'pred 3 hodinami', '3 hours ago');
        assert.equal(moment().subtract({h: 10}).fromNow(), 'pred 10 hodinami', '10 hours ago');
        assert.equal(moment().subtract({d: 1}).fromNow(), 'pred dÅom', 'a day ago');
        assert.equal(moment().subtract({d: 3}).fromNow(), 'pred 3 dÅami', '3 days ago');
        assert.equal(moment().subtract({d: 10}).fromNow(), 'pred 10 dÅami', '10 days ago');
        assert.equal(moment().subtract({M: 1}).fromNow(), 'pred mesiacom', 'a month ago');
        assert.equal(moment().subtract({M: 3}).fromNow(), 'pred 3 mesiacmi', '3 months ago');
        assert.equal(moment().subtract({M: 10}).fromNow(), 'pred 10 mesiacmi', '10 months ago');
        assert.equal(moment().subtract({y: 1}).fromNow(), 'pred rokom', 'a year ago');
        assert.equal(moment().subtract({y: 3}).fromNow(), 'pred 3 rokmi', '3 years ago');
        assert.equal(moment().subtract({y: 10}).fromNow(), 'pred 10 rokmi', '10 years ago');
    });

    test('calendar day', function (assert) {
        var a = moment().hours(12).minutes(0).seconds(0);

        assert.equal(moment(a).calendar(),                   'dnes o 12:00',     'today at the same time');
        assert.equal(moment(a).add({m: 25}).calendar(),      'dnes o 12:25',     'Now plus 25 min');
        assert.equal(moment(a).add({h: 1}).calendar(),       'dnes o 13:00',     'Now plus 1 hour');
        assert.equal(moment(a).add({d: 1}).calendar(),       'zajtra o 12:00',   'tomorrow at the same time');
        assert.equal(moment(a).subtract({h: 1}).calendar(),  'dnes o 11:00',     'Now minus 1 hour');
        assert.equal(moment(a).subtract({d: 1}).calendar(),  'vÄera o 12:00',    'yesterday at the same time');
    });

    test('calendar next week', function (assert) {
        var i, m, nextDay;
        for (i = 2; i < 7; i++) {
            m = moment().add({d: i});
            nextDay = '';
            switch (m.day()) {
            case 0:
                nextDay = 'v nedeÄ¾u';
                break;
            case 1:
                nextDay = 'v pondelok';
                break;
            case 2:
                nextDay = 'v utorok';
                break;
            case 3:
                nextDay = 'v stredu';
                break;
            case 4:
                nextDay = 'vo Å¡tvrtok';
                break;
            case 5:
                nextDay = 'v piatok';
                break;
            case 6:
                nextDay = 'v sobotu';
                break;
            }
            assert.equal(m.calendar(),       m.format('[' + nextDay + '] [o] LT'),  'Today + ' + i + ' days current time');
            m.hours(0).minutes(0).seconds(0).milliseconds(0);
            assert.equal(m.calendar(),       m.format('[' + nextDay + '] [o] LT'),  'Today + ' + i + ' days beginning of day');
            m.hours(23).minutes(59).seconds(59).milliseconds(999);
            assert.equal(m.calendar(),       m.format('[' + nextDay + '] [o] LT'),  'Today + ' + i + ' days end of day');
        }
    });

    test('calendar last week', function (assert) {
        var i, m, lastDay;
        for (i = 2; i < 7; i++) {
            m = moment().subtract({d: i});
            lastDay = '';
            switch (m.day()) {
            case 0:
                lastDay = 'minulÃº nedeÄ¾u';
                break;
            case 1:
                lastDay = 'minulÃ½ pondelok';
                break;
            case 2:
                lastDay = 'minulÃ½ utorok';
                break;
            case 3:
                lastDay = 'minulÃº stredu';
                break;
            case 4:
                lastDay = 'minulÃ½ Å¡tvrtok';
                break;
            case 5:
                lastDay = 'minulÃ½ piatok';
                break;
            case 6:
                lastDay = 'minulÃº sobotu';
                break;
            }
            assert.equal(m.calendar(),       m.format('[' + lastDay + '] [o] LT'),  'Today - ' + i + ' days current time');
            m.hours(0).minutes(0).seconds(0).milliseconds(0);
            assert.equal(m.calendar(),       m.format('[' + lastDay + '] [o] LT'),  'Today - ' + i + ' days beginning of day');
            m.hours(23).minutes(59).seconds(59).milliseconds(999);
            assert.equal(m.calendar(),       m.format('[' + lastDay + '] [o] LT'),  'Today - ' + i + ' days end of day');
        }
    });

    test('calendar all else', function (assert) {
        var weeksAgo = moment().subtract({w: 1}),
            weeksFromNow = moment().add({w: 1});

        assert.equal(weeksAgo.calendar(),       weeksAgo.format('L'),  '1 week ago');
        assert.equal(weeksFromNow.calendar(),   weeksFromNow.format('L'),  'in 1 week');

        weeksAgo = moment().subtract({w: 2});
        weeksFromNow = moment().add({w: 2});

        assert.equal(weeksAgo.calendar(),       weeksAgo.format('L'),  '2 weeks ago');
        assert.equal(weeksFromNow.calendar(),   weeksFromNow.format('L'),  'in 2 weeks');
    });

    test('humanize duration', function (assert) {
        assert.equal(moment.duration(1, 'minutes').humanize(), 'minÃºta', 'a minute (future)');
        assert.equal(moment.duration(1, 'minutes').humanize(true), 'za minÃºtu', 'in a minute');
        assert.equal(moment.duration(-1, 'minutes').humanize(), 'minÃºta', 'a minute (past)');
        assert.equal(moment.duration(-1, 'minutes').humanize(true), 'pred minÃºtou', 'a minute ago');
    });

    test('weeks year starting sunday formatted', function (assert) {
        assert.equal(moment([2012, 0,  1]).format('w ww wo'), '52 52 52.', 'Jan  1 2012 should be week 52');
        assert.equal(moment([2012, 0,  2]).format('w ww wo'),   '1 01 1.', 'Jan  2 2012 should be week 1');
        assert.equal(moment([2012, 0,  8]).format('w ww wo'),   '1 01 1.', 'Jan  8 2012 should be week 1');
        assert.equal(moment([2012, 0,  9]).format('w ww wo'),   '2 02 2.', 'Jan  9 2012 should be week 2');
        assert.equal(moment([2012, 0, 15]).format('w ww wo'),   '2 02 2.', 'Jan 15 2012 should be week 2');
    });

}));

;(function (global, factory) {
   typeof exports === 'object' && typeof module !== 'undefined'
       && typeof require === 'function' ? factory(require('../../moment')) :
   typeof define === 'function' && define.amd ? define(['../../moment'], factory) :
   factory(global.moment)
}(this, function (moment) { 'use strict';

    function each(array, callback) {
        var i;
        for (i = 0; i < array.length; i++) {
            callback(array[i], i, array);
        }
    }

    function objectKeys(obj) {
        if (Object.keys) {
            return Object.keys(obj);
        } else {
            // IE8
            var res = [], i;
            for (i in obj) {
                if (obj.hasOwnProperty(i)) {
                    res.push(i);
                }
            }
            return res;
        }
    }

    // Pick the first defined of two or three arguments.
    function defaults(a, b, c) {
        if (a != null) {
            return a;
        }
        if (b != null) {
            return b;
        }
        return c;
    }

    function defineCommonLocaleTests(locale, options) {
        test('lenient ordinal parsing', function (assert) {
            var i, ordinalStr, testMoment;
            for (i = 1; i <= 31; ++i) {
                ordinalStr = moment([2014, 0, i]).format('YYYY MM Do');
                testMoment = moment(ordinalStr, 'YYYY MM Do');
                assert.equal(testMoment.year(), 2014,
                        'lenient ordinal parsing ' + i + ' year check');
                assert.equal(testMoment.month(), 0,
                        'lenient ordinal parsing ' + i + ' month check');
                assert.equal(testMoment.date(), i,
                        'lenient ordinal parsing ' + i + ' date check');
            }
        });

        test('lenient ordinal parsing of number', function (assert) {
            var i, testMoment;
            for (i = 1; i <= 31; ++i) {
                testMoment = moment('2014 01 ' + i, 'YYYY MM Do');
                assert.equal(testMoment.year(), 2014,
                        'lenient ordinal parsing of number ' + i + ' year check');
                assert.equal(testMoment.month(), 0,
                        'lenient ordinal parsing of number ' + i + ' month check');
                assert.equal(testMoment.date(), i,
                        'lenient ordinal parsing of number ' + i + ' date check');
            }
        });

        test('strict ordinal parsing', function (assert) {
            var i, ordinalStr, testMoment;
            for (i = 1; i <= 31; ++i) {
                ordinalStr = moment([2014, 0, i]).format('YYYY MM Do');
                testMoment = moment(ordinalStr, 'YYYY MM Do', true);
                assert.ok(testMoment.isValid(), 'strict ordinal parsing ' + i);
            }
        });

        test('meridiem invariant', function (assert) {
            var h, m, t1, t2;
            for (h = 0; h < 24; ++h) {
                for (m = 0; m < 60; m += 15) {
                    t1 = moment.utc([2000, 0, 1, h, m]);
                    t2 = moment.utc(t1.format('A h:mm'), 'A h:mm');
                    assert.equal(t2.format('HH:mm'), t1.format('HH:mm'),
                            'meridiem at ' + t1.format('HH:mm'));
                }
            }
        });

        test('date format correctness', function (assert) {
            var data, tokens;
            data = moment.localeData()._longDateFormat;
            tokens = objectKeys(data);
            each(tokens, function (srchToken) {
                // Check each format string to make sure it does not contain any
                // tokens that need to be expanded.
                each(tokens, function (baseToken) {
                    // strip escaped sequences
                    var format = data[baseToken].replace(/(\[[^\]]*\])/g, '');
                    assert.equal(false, !!~format.indexOf(srchToken),
                            'contains ' + srchToken + ' in ' + baseToken);
                });
            });
        });

        test('month parsing correctness', function (assert) {
            var i, m;

            if (locale === 'tr') {
                // I can't fix it :(
                expect(0);
                return;
            }
            function tester(format) {
                var r;
                r = moment(m.format(format), format);
                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format);
                r = moment(m.format(format).toLocaleUpperCase(), format);
                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' upper');
                r = moment(m.format(format).toLocaleLowerCase(), format);
                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' lower');

                r = moment(m.format(format), format, true);
                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' strict');
                r = moment(m.format(format).toLocaleUpperCase(), format, true);
                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' upper strict');
                r = moment(m.format(format).toLocaleLowerCase(), format, true);
                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' lower strict');
            }

            for (i = 0; i < 12; ++i) {
                m = moment([2015, i, 15, 18]);
                tester('MMM');
                tester('MMM.');
                tester('MMMM');
                tester('MMMM.');
            }
        });

        test('weekday parsing correctness', function (assert) {
            var i, m;

            if (locale === 'tr' || locale === 'az') {
                // There is a lower-case letter (Ä±), that converted to upper then
                // lower changes to i
                expect(0);
                return;
            }
            function tester(format) {
                var r, baseMsg = 'weekday ' + m.weekday() + ' fmt ' + format;
                r = moment(m.format(format), format);
                assert.equal(r.weekday(), m.weekday(), baseMsg);
                r = moment(m.format(format).toLocaleUpperCase(), format);
                assert.equal(r.weekday(), m.weekday(), baseMsg + ' upper');
                r = moment(m.format(format).toLocaleLowerCase(), format);
                assert.equal(r.weekday(), m.weekday(), baseMsg + ' lower');

                r = moment(m.format(format), format, true);
                assert.equal(r.weekday(), m.weekday(), baseMsg + ' strict');
                r = moment(m.format(format).toLocaleUpperCase(), format, true);
                assert.equal(r.weekday(), m.weekday(), baseMsg + ' upper strict');
                r = moment(m.format(format).toLocaleLowerCase(), format, true);
                assert.equal(r.weekday(), m.weekday(), baseMsg + ' lower strict');
            }

            for (i = 0; i < 7; ++i) {
                m = moment.utc([2015, i, 15, 18]);
                tester('dd');
                tester('ddd');
                tester('dddd');
            }
        });
    }

    function setupDeprecationHandler(test, moment, scope) {
        test._expectedDeprecations = null;
        test._observedDeprecations = null;
        test._oldSupress = moment.suppressDeprecationWarnings;
        moment.suppressDeprecationWarnings = true;
        test.expectedDeprecations = function () {
            test._expectedDeprecations = arguments;
            test._observedDeprecations = [];
        };
        moment.deprecationHandler = function (name, msg) {
            var deprecationId = matchedDeprecation(name, msg, test._expectedDeprecations);
            if (deprecationId === -1) {
                throw new Error('Unexpected deprecation thrown name=' +
                        name + ' msg=' + msg);
            }
            test._observedDeprecations[deprecationId] = 1;
        };
    }

    function teardownDeprecationHandler(test, moment, scope) {
        moment.suppressDeprecationWarnings = test._oldSupress;

        if (test._expectedDeprecations != null) {
            var missedDeprecations = [];
            each(test._expectedDeprecations, function (deprecationPattern, id) {
                if (test._observedDeprecations[id] !== 1) {
                    missedDeprecations.push(deprecationPattern);
                }
            });
            if (missedDeprecations.length !== 0) {
                throw new Error('Expected deprecation warnings did not happen: ' +
                        missedDeprecations.join(' '));
            }
        }
    }

    function matchedDeprecation(name, msg, deprecations) {
        if (deprecations == null) {
            return -1;
        }
        for (var i = 0; i < deprecations.length; ++i) {
            if (name != null && name === deprecations[i]) {
                return i;
            }
            if (msg != null && msg.substring(0, deprecations[i].length) === deprecations[i]) {
                return i;
            }
        }
        return -1;
    }

    /*global QUnit:false*/

    var test = QUnit.test;

    var expect = QUnit.expect;

    function module (name, lifecycle) {
        QUnit.module(name, {
            setup : function () {
                moment.locale('en');
                moment.createFromInputFallback = function (config) {
                    throw new Error('input not handled by moment: ' + config._i);
                };
                setupDeprecationHandler(test, moment, 'core');
                if (lifecycle && lifecycle.setup) {
                    lifecycle.setup();
                }
            },
            teardown : function () {
                teardownDeprecationHandler(test, moment, 'core');
                if (lifecycle && lifecycle.teardown) {
                    lifecycle.teardown();
                }
            }
        });
    }

    function localeModule (name, lifecycle) {
        QUnit.module('locale:' + name, {
            setup : function () {
                moment.locale(name);
                moment.createFromInputFallback = function (config) {
                    throw new Error('input not handled by moment: ' + config._i);
                };
                setupDeprecationHandler(test, moment, 'locale');
                if (lifecycle && lifecycle.setup) {
                    lifecycle.setup();
                }
            },
            teardown : function () {
                moment.locale('en');
                teardownDeprecationHandler(test, moment, 'locale');
                if (lifecycle && lifecycle.teardown) {
                    lifecycle.teardown();
                }
            }
        });
        defineCommonLocaleTests(name, -1, -1);
    }

    localeModule('sl');

    test('parse', function (assert) {
        var tests = 'januar jan._februar feb._marec mar._april apr._maj maj_junij jun._julij jul._avgust avg._september sep._oktober okt._november nov._december dec.'.split('_'), i;
        function equalTest(input, mmm, i) {
            assert.equal(moment(input, mmm).month(), i, input + ' should be month ' + (i + 1));
        }
        for (i = 0; i < 12; i++) {
            tests[i] = tests[i].split(' ');
            equalTest(tests[i][0], 'MMM', i);
            equalTest(tests[i][1], 'MMM', i);
            equalTest(tests[i][0], 'MMMM', i);
            equalTest(tests[i][1], 'MMMM', i);
            equalTest(tests[i][0].toLocaleLowerCase(), 'MMMM', i);
            equalTest(tests[i][1].toLocaleLowerCase(), 'MMMM', i);
            equalTest(tests[i][0].toLocaleUpperCase(), 'MMMM', i);
            equalTest(tests[i][1].toLocaleUpperCase(), 'MMMM', i);
        }
    });

    test('format', function (assert) {
        var a = [
                ['dddd, Do MMMM YYYY, h:mm:ss a',      'nedelja, 14. februar 2010, 3:25:50 pm'],
                ['ddd, hA',                            'ned., 3PM'],
                ['M Mo MM MMMM MMM',                   '2 2. 02 februar feb.'],
                ['YYYY YY',                            '2010 10'],
                ['D Do DD',                            '14 14. 14'],
                ['d do dddd ddd dd',                   '0 0. nedelja ned. ne'],
                ['DDD DDDo DDDD',                      '45 45. 045'],
                ['w wo ww',                            '7 7. 07'],
                ['h hh',                               '3 03'],
                ['H HH',                               '15 15'],
                ['m mm',                               '25 25'],
                ['s ss',                               '50 50'],
                ['a A',                                'pm PM'],
                ['[the] DDDo [day of the year]',       'the 45. day of the year'],
                ['LTS',                                '15:25:50'],
                ['L',                                  '14. 02. 2010'],
                ['LL',                                 '14. februar 2010'],
                ['LLL',                                '14. februar 2010 15:25'],
                ['LLLL',                               'nedelja, 14. februar 2010 15:25'],
                ['l',                                  '14. 2. 2010'],
                ['ll',                                 '14. feb. 2010'],
                ['lll',                                '14. feb. 2010 15:25'],
                ['llll',                               'ned., 14. feb. 2010 15:25']
            ],
            b = moment(new Date(2010, 1, 14, 15, 25, 50, 125)),
            i;
        for (i = 0; i < a.length; i++) {
            assert.equal(b.format(a[i][0]), a[i][1], a[i][0] + ' ---> ' + a[i][1]);
        }
    });

    test('format ordinal', function (assert) {
        assert.equal(moment([2011, 0, 1]).format('DDDo'), '1.', '1.');
        assert.equal(moment([2011, 0, 2]).format('DDDo'), '2.', '2.');
        assert.equal(moment([2011, 0, 3]).format('DDDo'), '3.', '3.');
        assert.equal(moment([2011, 0, 4]).format('DDDo'), '4.', '4.');
        assert.equal(moment([2011, 0, 5]).format('DDDo'), '5.', '5.');
        assert.equal(moment([2011, 0, 6]).format('DDDo'), '6.', '6.');
        assert.equal(moment([2011, 0, 7]).format('DDDo'), '7.', '7.');
        assert.equal(moment([2011, 0, 8]).format('DDDo'), '8.', '8.');
        assert.equal(moment([2011, 0, 9]).format('DDDo'), '9.', '9.');
        assert.equal(moment([2011, 0, 10]).format('DDDo'), '10.', '10.');

        assert.equal(moment([2011, 0, 11]).format('DDDo'), '11.', '11.');
        assert.equal(moment([2011, 0, 12]).format('DDDo'), '12.', '12.');
        assert.equal(moment([2011, 0, 13]).format('DDDo'), '13.', '13.');
        assert.equal(moment([2011, 0, 14]).format('DDDo'), '14.', '14.');
        assert.equal(moment([2011, 0, 15]).format('DDDo'), '15.', '15.');
        assert.equal(moment([2011, 0, 16]).format('DDDo'), '16.', '16.');
        assert.equal(moment([2011, 0, 17]).format('DDDo'), '17.', '17.');
        assert.equal(moment([2011, 0, 18]).format('DDDo'), '18.', '18.');
        assert.equal(moment([2011, 0, 19]).format('DDDo'), '19.', '19.');
        assert.equal(moment([2011, 0, 20]).format('DDDo'), '20.', '20.');

        assert.equal(moment([2011, 0, 21]).format('DDDo'), '21.', '21.');
        assert.equal(moment([2011, 0, 22]).format('DDDo'), '22.', '22.');
        assert.equal(moment([2011, 0, 23]).format('DDDo'), '23.', '23.');
        assert.equal(moment([2011, 0, 24]).format('DDDo'), '24.', '24.');
        assert.equal(moment([2011, 0, 25]).format('DDDo'), '25.', '25.');
        assert.equal(moment([2011, 0, 26]).format('DDDo'), '26.', '26.');
        assert.equal(moment([2011, 0, 27]).format('DDDo'), '27.', '27.');
        assert.equal(moment([2011, 0, 28]).format('DDDo'), '28.', '28.');
        assert.equal(moment([2011, 0, 29]).format('DDDo'), '29.', '29.');
        assert.equal(moment([2011, 0, 30]).format('DDDo'), '30.', '30.');

        assert.equal(moment([2011, 0, 31]).format('DDDo'), '31.', '31.');
    });

    test('format month', function (assert) {
        var expected = 'januar jan._februar feb._marec mar._april apr._maj maj._junij jun._julij jul._avgust avg._september sep._oktober okt._november nov._december dec.'.split('_'), i;
        for (i = 0; i < expected.length; i++) {
            assert.equal(moment([2011, i, 1]).format('MMMM MMM'), expected[i], expected[i]);
        }
    });

    test('format week', function (assert) {
        var expected = 'nedelja ned. ne_ponedeljek pon. po_torek tor. to_sreda sre. sr_Äetrtek Äet. Äe_petek pet. pe_sobota sob. so'.split('_'), i;
        for (i = 0; i < expected.length; i++) {
            assert.equal(moment([2011, 0, 2 + i]).format('dddd ddd dd'), expected[i], expected[i]);
        }
    });

    test('from', function (assert) {
        var start = moment([2007, 1, 28]);
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 44}), true),  'nekaj sekund', '44 seconds = a few seconds');
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 45}), true),  'ena minuta',   '45 seconds = a minute');
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 89}), true),  'ena minuta',   '89 seconds = a minute');
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 90}), true),  '2 minuti',     '90 seconds = 2 minutes');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 44}), true),  '44 minut',     '44 minutes = 44 minutes');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 45}), true),  'ena ura',      '45 minutes = an hour');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 89}), true),  'ena ura',      '89 minutes = an hour');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 90}), true),  '2 uri',        '90 minutes = 2 hours');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 5}), true),   '5 ur',         '5 hours = 5 hours');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 21}), true),  '21 ur',        '21 hours = 21 hours');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 22}), true),  'en dan',       '22 hours = a day');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 35}), true),  'en dan',       '35 hours = a day');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 36}), true),  '2 dni',        '36 hours = 2 days');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 1}), true),   'en dan',       '1 day = a day');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 5}), true),   '5 dni',        '5 days = 5 days');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 25}), true),  '25 dni',       '25 days = 25 days');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 26}), true),  'en mesec',     '26 days = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 30}), true),  'en mesec',     '30 days = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 43}), true),  'en mesec',     '43 days = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 46}), true),  '2 meseca',     '46 days = 2 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 74}), true),  '2 meseca',     '75 days = 2 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 76}), true),  '3 mesece',     '76 days = 3 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({M: 1}), true),   'en mesec',     '1 month = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({M: 5}), true),   '5 mesecev',    '5 months = 5 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 345}), true), 'eno leto',     '345 days = a year');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 548}), true), '2 leti',       '548 days = 2 years');
        assert.equal(start.from(moment([2007, 1, 28]).add({y: 1}), true),   'eno leto',     '1 year = a year');
        assert.equal(start.from(moment([2007, 1, 28]).add({y: 5}), true),   '5 let',        '5 years = 5 years');

        assert.equal(start.from(moment([2007, 1, 28]).add({m: 1}), true),  'ena minuta', 'a minute');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 2}), true),  '2 minuti',   '2 minutes');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 3}), true),  '3 minute',   '3 minutes');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 4}), true),  '4 minute',   '4 minutes');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 5}), true),  '5 minut',    '5 minutes');

        assert.equal(start.from(moment([2007, 1, 28]).add({h: 1}), true),  'ena ura', 'an hour');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 2}), true),  '2 uri',   '2 hours');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 3}), true),  '3 ure',   '3 hours');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 4}), true),  '4 ure',   '4 hours');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 5}), true),  '5 ur',    '5 hours');

        assert.equal(start.from(moment([2007, 1, 28]).add({d: 1}), true),  'en dan', 'a day');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 2}), true),  '2 dni',  '2 days');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 3}), true),  '3 dni',  '3 days');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 4}), true),  '4 dni',  '4 days');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 5}), true),  '5 dni',  '5 days');

        assert.equal(start.from(moment([2007, 1, 28]).add({M: 1}), true),  'en mesec',  'a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({M: 2}), true),  '2 meseca',  '2 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({M: 3}), true),  '3 mesece',  '3 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({M: 4}), true),  '4 mesece',  '4 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({M: 5}), true),  '5 mesecev', '5 months');

        assert.equal(start.from(moment([2007, 1, 28]).add({y: 1}), true),  'eno leto', 'a year');
        assert.equal(start.from(moment([2007, 1, 28]).add({y: 2}), true),  '2 leti',   '2 years');
        assert.equal(start.from(moment([2007, 1, 28]).add({y: 3}), true),  '3 leta',   '3 years');
        assert.equal(start.from(moment([2007, 1, 28]).add({y: 4}), true),  '4 leta',   '4 years');
        assert.equal(start.from(moment([2007, 1, 28]).add({y: 5}), true),  '5 let',    '5 years');
    });

    test('suffix', function (assert) {
        assert.equal(moment(30000).from(0), 'Äez nekaj sekund',  'prefix');
        assert.equal(moment(0).from(30000), 'pred nekaj sekundami', 'suffix');
    });

    test('now from now', function (assert) {
        assert.equal(moment().fromNow(), 'pred nekaj sekundami',  'now from now should display as in the past');
    });

    test('fromNow (future)', function (assert) {
        assert.equal(moment().add({s: 30}).fromNow(), 'Äez nekaj sekund', 'in a few seconds');
        assert.equal(moment().add({m: 1}).fromNow(),  'Äez eno minuto', 'in a minute');
        assert.equal(moment().add({m: 2}).fromNow(),  'Äez 2 minuti',   'in 2 minutes');
        assert.equal(moment().add({m: 3}).fromNow(),  'Äez 3 minute',   'in 3 minutes');
        assert.equal(moment().add({m: 4}).fromNow(),  'Äez 4 minute',   'in 4 minutes');
        assert.equal(moment().add({m: 5}).fromNow(),  'Äez 5 minut',    'in 5 minutes');

        assert.equal(moment().add({h: 1}).fromNow(),  'Äez eno uro', 'in an hour');
        assert.equal(moment().add({h: 2}).fromNow(),  'Äez 2 uri',   'in 2 hours');
        assert.equal(moment().add({h: 3}).fromNow(),  'Äez 3 ure',   'in 3 hours');
        assert.equal(moment().add({h: 4}).fromNow(),  'Äez 4 ure',   'in 4 hours');
        assert.equal(moment().add({h: 5}).fromNow(),  'Äez 5 ur',    'in 5 hours');

        assert.equal(moment().add({d: 1}).fromNow(),  'Äez en dan', 'in a day');
        assert.equal(moment().add({d: 2}).fromNow(),  'Äez 2 dni',  'in 2 days');
        assert.equal(moment().add({d: 3}).fromNow(),  'Äez 3 dni',  'in 3 days');
        assert.equal(moment().add({d: 4}).fromNow(),  'Äez 4 dni',  'in 4 days');
        assert.equal(moment().add({d: 5}).fromNow(),  'Äez 5 dni',  'in 5 days');

        assert.equal(moment().add({M: 1}).fromNow(),  'Äez en mesec',  'in a month');
        assert.equal(moment().add({M: 2}).fromNow(),  'Äez 2 meseca',  'in 2 months');
        assert.equal(moment().add({M: 3}).fromNow(),  'Äez 3 mesece',  'in 3 months');
        assert.equal(moment().add({M: 4}).fromNow(),  'Äez 4 mesece',  'in 4 months');
        assert.equal(moment().add({M: 5}).fromNow(),  'Äez 5 mesecev', 'in 5 months');

        assert.equal(moment().add({y: 1}).fromNow(),  'Äez eno leto', 'in a year');
        assert.equal(moment().add({y: 2}).fromNow(),  'Äez 2 leti',   'in 2 years');
        assert.equal(moment().add({y: 3}).fromNow(),  'Äez 3 leta',   'in 3 years');
        assert.equal(moment().add({y: 4}).fromNow(),  'Äez 4 leta',   'in 4 years');
        assert.equal(moment().add({y: 5}).fromNow(),  'Äez 5 let',    'in 5 years');

        assert.equal(moment().subtract({s: 30}).fromNow(), 'pred nekaj sekundami', 'a few seconds ago');

        assert.equal(moment().subtract({m: 1}).fromNow(),  'pred eno minuto', 'a minute ago');
        assert.equal(moment().subtract({m: 2}).fromNow(),  'pred 2 minutama', '2 minutes ago');
        assert.equal(moment().subtract({m: 3}).fromNow(),  'pred 3 minutami', '3 minutes ago');
        assert.equal(moment().subtract({m: 4}).fromNow(),  'pred 4 minutami', '4 minutes ago');
        assert.equal(moment().subtract({m: 5}).fromNow(),  'pred 5 minutami', '5 minutes ago');

        assert.equal(moment().subtract({h: 1}).fromNow(),  'pred eno uro', 'an hour ago');
        assert.equal(moment().subtract({h: 2}).fromNow(),  'pred 2 urama', '2 hours ago');
        assert.equal(moment().subtract({h: 3}).fromNow(),  'pred 3 urami', '3 hours ago');
        assert.equal(moment().subtract({h: 4}).fromNow(),  'pred 4 urami', '4 hours ago');
        assert.equal(moment().subtract({h: 5}).fromNow(),  'pred 5 urami', '5 hours ago');

        assert.equal(moment().subtract({d: 1}).fromNow(),  'pred enim dnem', 'a day ago');
        assert.equal(moment().subtract({d: 2}).fromNow(),  'pred 2 dnevoma', '2 days ago');
        assert.equal(moment().subtract({d: 3}).fromNow(),  'pred 3 dnevi',   '3 days ago');
        assert.equal(moment().subtract({d: 4}).fromNow(),  'pred 4 dnevi',   '4 days ago');
        assert.equal(moment().subtract({d: 5}).fromNow(),  'pred 5 dnevi',   '5 days ago');

        assert.equal(moment().subtract({M: 1}).fromNow(),  'pred enim mesecem', 'a month ago');
        assert.equal(moment().subtract({M: 2}).fromNow(),  'pred 2 mesecema',   '2 months ago');
        assert.equal(moment().subtract({M: 3}).fromNow(),  'pred 3 meseci',     '3 months ago');
        assert.equal(moment().subtract({M: 4}).fromNow(),  'pred 4 meseci',     '4 months ago');
        assert.equal(moment().subtract({M: 5}).fromNow(),  'pred 5 meseci',     '5 months ago');

        assert.equal(moment().subtract({y: 1}).fromNow(),  'pred enim letom', 'a year ago');
        assert.equal(moment().subtract({y: 2}).fromNow(),  'pred 2 letoma',   '2 years ago');
        assert.equal(moment().subtract({y: 3}).fromNow(),  'pred 3 leti',     '3 years ago');
        assert.equal(moment().subtract({y: 4}).fromNow(),  'pred 4 leti',     '4 years ago');
        assert.equal(moment().subtract({y: 5}).fromNow(),  'pred 5 leti',     '5 years ago');
    });

    test('calendar day', function (assert) {
        var a = moment().hours(12).minutes(0).seconds(0);

        assert.equal(moment(a).calendar(),                   'danes ob 12:00',  'today at the same time');
        assert.equal(moment(a).add({m: 25}).calendar(),      'danes ob 12:25',  'Now plus 25 min');
        assert.equal(moment(a).add({h: 1}).calendar(),       'danes ob 13:00',  'Now plus 1 hour');
        assert.equal(moment(a).add({d: 1}).calendar(),       'jutri ob 12:00',  'tomorrow at the same time');
        assert.equal(moment(a).subtract({h: 1}).calendar(),  'danes ob 11:00',  'Now minus 1 hour');
        assert.equal(moment(a).subtract({d: 1}).calendar(),  'vÄeraj ob 12:00', 'yesterday at the same time');
    });

    test('calendar next week', function (assert) {
        var i, m;

        function makeFormat(d) {
            switch (d.day()) {
            case 0:
                return '[v] [nedeljo] [ob] LT';
            case 3:
                return '[v] [sredo] [ob] LT';
            case 6:
                return '[v] [soboto] [ob] LT';
            case 1:
            case 2:
            case 4:
            case 5:
                return '[v] dddd [ob] LT';
            }
        }

        for (i = 2; i < 7; i++) {
            m = moment().add({d: i});
            assert.equal(m.calendar(),       m.format(makeFormat(m)),  'Today + ' + i + ' days current time');
            m.hours(0).minutes(0).seconds(0).milliseconds(0);
            assert.equal(m.calendar(),       m.format(makeFormat(m)),  'Today + ' + i + ' days beginning of day');
            m.hours(23).minutes(59).seconds(59).milliseconds(999);
            assert.equal(m.calendar(),       m.format(makeFormat(m)),  'Today + ' + i + ' days end of day');
        }
    });

    test('calendar last week', function (assert) {
        var i, m;

        function makeFormat(d) {
            switch (d.day()) {
            case 0:
                return '[prejÅ¡njo] [nedeljo] [ob] LT';
            case 3:
                return '[prejÅ¡njo] [sredo] [ob] LT';
            case 6:
                return '[prejÅ¡njo] [soboto] [ob] LT';
            case 1:
            case 2:
            case 4:
            case 5:
                return '[prejÅ¡nji] dddd [ob] LT';
            }
        }

        for (i = 2; i < 7; i++) {
            m = moment().subtract({d: i});
            assert.equal(m.calendar(),       m.format(makeFormat(m)),  'Today - ' + i + ' days current time');
            m.hours(0).minutes(0).seconds(0).milliseconds(0);
            assert.equal(m.calendar(),       m.format(makeFormat(m)),  'Today - ' + i + ' days beginning of day');
            m.hours(23).minutes(59).seconds(59).milliseconds(999);
            assert.equal(m.calendar(),       m.format(makeFormat(m)),  'Today - ' + i + ' days end of day');
        }
    });

    test('calendar all else', function (assert) {
        var weeksAgo = moment().subtract({w: 1}),
            weeksFromNow = moment().add({w: 1});

        assert.equal(weeksAgo.calendar(),       weeksAgo.format('L'),  '1 week ago');
        assert.equal(weeksFromNow.calendar(),   weeksFromNow.format('L'),  'in 1 week');

        weeksAgo = moment().subtract({w: 2});
        weeksFromNow = moment().add({w: 2});

        assert.equal(weeksAgo.calendar(),       weeksAgo.format('L'),  '2 weeks ago');
        assert.equal(weeksFromNow.calendar(),   weeksFromNow.format('L'),  'in 2 weeks');
    });

    test('weeks year starting sunday formatted', function (assert) {
        assert.equal(moment([2011, 11, 26]).format('w ww wo'), '1 01 1.', 'Dec 26 2011 should be week 1');
        assert.equal(moment([2012,  0,  1]).format('w ww wo'), '1 01 1.', 'Jan  1 2012 should be week 1');
        assert.equal(moment([2012,  0,  2]).format('w ww wo'), '2 02 2.', 'Jan  2 2012 should be week 2');
        assert.equal(moment([2012,  0,  8]).format('w ww wo'), '2 02 2.', 'Jan  8 2012 should be week 2');
        assert.equal(moment([2012,  0,  9]).format('w ww wo'), '3 03 3.', 'Jan  9 2012 should be week 3');
    });

}));

;(function (global, factory) {
   typeof exports === 'object' && typeof module !== 'undefined'
       && typeof require === 'function' ? factory(require('../../moment')) :
   typeof define === 'function' && define.amd ? define(['../../moment'], factory) :
   factory(global.moment)
}(this, function (moment) { 'use strict';

    function each(array, callback) {
        var i;
        for (i = 0; i < array.length; i++) {
            callback(array[i], i, array);
        }
    }

    function objectKeys(obj) {
        if (Object.keys) {
            return Object.keys(obj);
        } else {
            // IE8
            var res = [], i;
            for (i in obj) {
                if (obj.hasOwnProperty(i)) {
                    res.push(i);
                }
            }
            return res;
        }
    }

    // Pick the first defined of two or three arguments.
    function defaults(a, b, c) {
        if (a != null) {
            return a;
        }
        if (b != null) {
            return b;
        }
        return c;
    }

    function defineCommonLocaleTests(locale, options) {
        test('lenient ordinal parsing', function (assert) {
            var i, ordinalStr, testMoment;
            for (i = 1; i <= 31; ++i) {
                ordinalStr = moment([2014, 0, i]).format('YYYY MM Do');
                testMoment = moment(ordinalStr, 'YYYY MM Do');
                assert.equal(testMoment.year(), 2014,
                        'lenient ordinal parsing ' + i + ' year check');
                assert.equal(testMoment.month(), 0,
                        'lenient ordinal parsing ' + i + ' month check');
                assert.equal(testMoment.date(), i,
                        'lenient ordinal parsing ' + i + ' date check');
            }
        });

        test('lenient ordinal parsing of number', function (assert) {
            var i, testMoment;
            for (i = 1; i <= 31; ++i) {
                testMoment = moment('2014 01 ' + i, 'YYYY MM Do');
                assert.equal(testMoment.year(), 2014,
                        'lenient ordinal parsing of number ' + i + ' year check');
                assert.equal(testMoment.month(), 0,
                        'lenient ordinal parsing of number ' + i + ' month check');
                assert.equal(testMoment.date(), i,
                        'lenient ordinal parsing of number ' + i + ' date check');
            }
        });

        test('strict ordinal parsing', function (assert) {
            var i, ordinalStr, testMoment;
            for (i = 1; i <= 31; ++i) {
                ordinalStr = moment([2014, 0, i]).format('YYYY MM Do');
                testMoment = moment(ordinalStr, 'YYYY MM Do', true);
                assert.ok(testMoment.isValid(), 'strict ordinal parsing ' + i);
            }
        });

        test('meridiem invariant', function (assert) {
            var h, m, t1, t2;
            for (h = 0; h < 24; ++h) {
                for (m = 0; m < 60; m += 15) {
                    t1 = moment.utc([2000, 0, 1, h, m]);
                    t2 = moment.utc(t1.format('A h:mm'), 'A h:mm');
                    assert.equal(t2.format('HH:mm'), t1.format('HH:mm'),
                            'meridiem at ' + t1.format('HH:mm'));
                }
            }
        });

        test('date format correctness', function (assert) {
            var data, tokens;
            data = moment.localeData()._longDateFormat;
            tokens = objectKeys(data);
            each(tokens, function (srchToken) {
                // Check each format string to make sure it does not contain any
                // tokens that need to be expanded.
                each(tokens, function (baseToken) {
                    // strip escaped sequences
                    var format = data[baseToken].replace(/(\[[^\]]*\])/g, '');
                    assert.equal(false, !!~format.indexOf(srchToken),
                            'contains ' + srchToken + ' in ' + baseToken);
                });
            });
        });

        test('month parsing correctness', function (assert) {
            var i, m;

            if (locale === 'tr') {
                // I can't fix it :(
                expect(0);
                return;
            }
            function tester(format) {
                var r;
                r = moment(m.format(format), format);
                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format);
                r = moment(m.format(format).toLocaleUpperCase(), format);
                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' upper');
                r = moment(m.format(format).toLocaleLowerCase(), format);
                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' lower');

                r = moment(m.format(format), format, true);
                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' strict');
                r = moment(m.format(format).toLocaleUpperCase(), format, true);
                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' upper strict');
                r = moment(m.format(format).toLocaleLowerCase(), format, true);
                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' lower strict');
            }

            for (i = 0; i < 12; ++i) {
                m = moment([2015, i, 15, 18]);
                tester('MMM');
                tester('MMM.');
                tester('MMMM');
                tester('MMMM.');
            }
        });

        test('weekday parsing correctness', function (assert) {
            var i, m;

            if (locale === 'tr' || locale === 'az') {
                // There is a lower-case letter (Ä±), that converted to upper then
                // lower changes to i
                expect(0);
                return;
            }
            function tester(format) {
                var r, baseMsg = 'weekday ' + m.weekday() + ' fmt ' + format;
                r = moment(m.format(format), format);
                assert.equal(r.weekday(), m.weekday(), baseMsg);
                r = moment(m.format(format).toLocaleUpperCase(), format);
                assert.equal(r.weekday(), m.weekday(), baseMsg + ' upper');
                r = moment(m.format(format).toLocaleLowerCase(), format);
                assert.equal(r.weekday(), m.weekday(), baseMsg + ' lower');

                r = moment(m.format(format), format, true);
                assert.equal(r.weekday(), m.weekday(), baseMsg + ' strict');
                r = moment(m.format(format).toLocaleUpperCase(), format, true);
                assert.equal(r.weekday(), m.weekday(), baseMsg + ' upper strict');
                r = moment(m.format(format).toLocaleLowerCase(), format, true);
                assert.equal(r.weekday(), m.weekday(), baseMsg + ' lower strict');
            }

            for (i = 0; i < 7; ++i) {
                m = moment.utc([2015, i, 15, 18]);
                tester('dd');
                tester('ddd');
                tester('dddd');
            }
        });
    }

    function setupDeprecationHandler(test, moment, scope) {
        test._expectedDeprecations = null;
        test._observedDeprecations = null;
        test._oldSupress = moment.suppressDeprecationWarnings;
        moment.suppressDeprecationWarnings = true;
        test.expectedDeprecations = function () {
            test._expectedDeprecations = arguments;
            test._observedDeprecations = [];
        };
        moment.deprecationHandler = function (name, msg) {
            var deprecationId = matchedDeprecation(name, msg, test._expectedDeprecations);
            if (deprecationId === -1) {
                throw new Error('Unexpected deprecation thrown name=' +
                        name + ' msg=' + msg);
            }
            test._observedDeprecations[deprecationId] = 1;
        };
    }

    function teardownDeprecationHandler(test, moment, scope) {
        moment.suppressDeprecationWarnings = test._oldSupress;

        if (test._expectedDeprecations != null) {
            var missedDeprecations = [];
            each(test._expectedDeprecations, function (deprecationPattern, id) {
                if (test._observedDeprecations[id] !== 1) {
                    missedDeprecations.push(deprecationPattern);
                }
            });
            if (missedDeprecations.length !== 0) {
                throw new Error('Expected deprecation warnings did not happen: ' +
                        missedDeprecations.join(' '));
            }
        }
    }

    function matchedDeprecation(name, msg, deprecations) {
        if (deprecations == null) {
            return -1;
        }
        for (var i = 0; i < deprecations.length; ++i) {
            if (name != null && name === deprecations[i]) {
                return i;
            }
            if (msg != null && msg.substring(0, deprecations[i].length) === deprecations[i]) {
                return i;
            }
        }
        return -1;
    }

    /*global QUnit:false*/

    var test = QUnit.test;

    var expect = QUnit.expect;

    function module (name, lifecycle) {
        QUnit.module(name, {
            setup : function () {
                moment.locale('en');
                moment.createFromInputFallback = function (config) {
                    throw new Error('input not handled by moment: ' + config._i);
                };
                setupDeprecationHandler(test, moment, 'core');
                if (lifecycle && lifecycle.setup) {
                    lifecycle.setup();
                }
            },
            teardown : function () {
                teardownDeprecationHandler(test, moment, 'core');
                if (lifecycle && lifecycle.teardown) {
                    lifecycle.teardown();
                }
            }
        });
    }

    function localeModule (name, lifecycle) {
        QUnit.module('locale:' + name, {
            setup : function () {
                moment.locale(name);
                moment.createFromInputFallback = function (config) {
                    throw new Error('input not handled by moment: ' + config._i);
                };
                setupDeprecationHandler(test, moment, 'locale');
                if (lifecycle && lifecycle.setup) {
                    lifecycle.setup();
                }
            },
            teardown : function () {
                moment.locale('en');
                teardownDeprecationHandler(test, moment, 'locale');
                if (lifecycle && lifecycle.teardown) {
                    lifecycle.teardown();
                }
            }
        });
        defineCommonLocaleTests(name, -1, -1);
    }

    localeModule('sq');

    test('parse', function (assert) {
        var i,
            tests = 'Janar Jan_Shkurt Shk_Mars Mar_Prill Pri_Maj Maj_Qershor Qer_Korrik Kor_Gusht Gus_Shtator Sht_Tetor Tet_NÃ«ntor NÃ«n_Dhjetor Dhj'.split('_');

        function equalTest(input, mmm, i) {
            assert.equal(moment(input, mmm).month(), i, input + ' should be month ' + (i + 1));
        }

        for (i = 0; i < 12; i++) {
            tests[i] = tests[i].split(' ');
            equalTest(tests[i][0], 'MMM', i);
            equalTest(tests[i][1], 'MMM', i);
            equalTest(tests[i][0], 'MMMM', i);
            equalTest(tests[i][1], 'MMMM', i);
            equalTest(tests[i][0].toLocaleLowerCase(), 'MMMM', i);
            equalTest(tests[i][1].toLocaleLowerCase(), 'MMMM', i);
            equalTest(tests[i][0].toLocaleUpperCase(), 'MMMM', i);
            equalTest(tests[i][1].toLocaleUpperCase(), 'MMMM', i);
        }
    });

    test('format', function (assert) {
        var a = [
                ['dddd, MMMM Do YYYY, HH:mm:ss',       'E Diel, Shkurt 14. 2010, 15:25:50'],
                ['ddd, HH',                            'Die, 15'],
                ['M Mo MM MMMM MMM',                   '2 2. 02 Shkurt Shk'],
                ['YYYY YY',                            '2010 10'],
                ['D Do DD',                            '14 14. 14'],
                ['d do dddd ddd dd',                   '0 0. E Diel Die D'],
                ['DDD DDDo DDDD',                      '45 45. 045'],
                ['w wo ww',                            '6 6. 06'],
                ['h hh',                               '3 03'],
                ['H HH',                               '15 15'],
                ['m mm',                               '25 25'],
                ['s ss',                               '50 50'],
                ['a A',                                'MD MD'],
                ['[the] DDDo [day of the year]',       'the 45. day of the year'],
                ['LTS',                                '15:25:50'],
                ['L',                                  '14/02/2010'],
                ['LL',                                 '14 Shkurt 2010'],
                ['LLL',                                '14 Shkurt 2010 15:25'],
                ['LLLL',                               'E Diel, 14 Shkurt 2010 15:25'],
                ['l',                                  '14/2/2010'],
                ['ll',                                 '14 Shk 2010'],
                ['lll',                                '14 Shk 2010 15:25'],
                ['llll',                               'Die, 14 Shk 2010 15:25']
            ],
            b = moment(new Date(2010, 1, 14, 15, 25, 50, 125)),
            i;

        for (i = 0; i < a.length; i++) {
            assert.equal(b.format(a[i][0]), a[i][1], a[i][0] + ' ---> ' + a[i][1]);
        }
    });

    test('meridiem', function (assert) {
        assert.equal(moment([2011, 2, 23,  0, 0]).format('A'), 'PD', 'before dawn');
        assert.equal(moment([2011, 2, 23, 12, 0]).format('A'), 'MD', 'noon');
    });

    test('format ordinal', function (assert) {
        assert.equal(moment([2011, 0, 1]).format('DDDo'), '1.', '1.');
        assert.equal(moment([2011, 0, 2]).format('DDDo'), '2.', '2.');
        assert.equal(moment([2011, 0, 3]).format('DDDo'), '3.', '3.');
        assert.equal(moment([2011, 0, 4]).format('DDDo'), '4.', '4.');
        assert.equal(moment([2011, 0, 5]).format('DDDo'), '5.', '5.');
        assert.equal(moment([2011, 0, 6]).format('DDDo'), '6.', '6.');
        assert.equal(moment([2011, 0, 7]).format('DDDo'), '7.', '7.');
        assert.equal(moment([2011, 0, 8]).format('DDDo'), '8.', '8.');
        assert.equal(moment([2011, 0, 9]).format('DDDo'), '9.', '9.');
        assert.equal(moment([2011, 0, 10]).format('DDDo'), '10.', '10.');

        assert.equal(moment([2011, 0, 11]).format('DDDo'), '11.', '11.');
        assert.equal(moment([2011, 0, 12]).format('DDDo'), '12.', '12.');
        assert.equal(moment([2011, 0, 13]).format('DDDo'), '13.', '13.');
        assert.equal(moment([2011, 0, 14]).format('DDDo'), '14.', '14.');
        assert.equal(moment([2011, 0, 15]).format('DDDo'), '15.', '15.');
        assert.equal(moment([2011, 0, 16]).format('DDDo'), '16.', '16.');
        assert.equal(moment([2011, 0, 17]).format('DDDo'), '17.', '17.');
        assert.equal(moment([2011, 0, 18]).format('DDDo'), '18.', '18.');
        assert.equal(moment([2011, 0, 19]).format('DDDo'), '19.', '19.');
        assert.equal(moment([2011, 0, 20]).format('DDDo'), '20.', '20.');

        assert.equal(moment([2011, 0, 21]).format('DDDo'), '21.', '21.');
        assert.equal(moment([2011, 0, 22]).format('DDDo'), '22.', '22.');
        assert.equal(moment([2011, 0, 23]).format('DDDo'), '23.', '23.');
        assert.equal(moment([2011, 0, 24]).format('DDDo'), '24.', '24.');
        assert.equal(moment([2011, 0, 25]).format('DDDo'), '25.', '25.');
        assert.equal(moment([2011, 0, 26]).format('DDDo'), '26.', '26.');
        assert.equal(moment([2011, 0, 27]).format('DDDo'), '27.', '27.');
        assert.equal(moment([2011, 0, 28]).format('DDDo'), '28.', '28.');
        assert.equal(moment([2011, 0, 29]).format('DDDo'), '29.', '29.');
        assert.equal(moment([2011, 0, 30]).format('DDDo'), '30.', '30.');

        assert.equal(moment([2011, 0, 31]).format('DDDo'), '31.', '31.');
    });

    test('format month', function (assert) {
        var i,
            expected = 'Janar Jan_Shkurt Shk_Mars Mar_Prill Pri_Maj Maj_Qershor Qer_Korrik Kor_Gusht Gus_Shtator Sht_Tetor Tet_NÃ«ntor NÃ«n_Dhjetor Dhj'.split('_');

        for (i = 0; i < expected.length; i++) {
            assert.equal(moment([2011, i, 1]).format('MMMM MMM'), expected[i], expected[i]);
        }
    });

    test('format week', function (assert) {
        var i,
            expected = 'E Diel Die D_E HÃ«nÃ« HÃ«n H_E MartÃ« Mar Ma_E MÃ«rkurÃ« MÃ«r MÃ«_E Enjte Enj E_E Premte Pre P_E ShtunÃ« Sht Sh'.split('_');

        for (i = 0; i < expected.length; i++) {
            assert.equal(moment([2011, 0, 2 + i]).format('dddd ddd dd'), expected[i], expected[i]);
        }
    });

    test('from', function (assert) {
        var start = moment([2007, 1, 28]);

        assert.equal(start.from(moment([2007, 1, 28]).add({s: 44}), true),  'disa sekonda', '44 seconds = a few seconds');
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 45}), true),  'njÃ« minutÃ«',      '45 seconds = a minute');
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 89}), true),  'njÃ« minutÃ«',      '89 seconds = a minute');
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 90}), true),  '2 minuta',     '90 seconds = 2 minutes');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 44}), true),  '44 minuta',    '44 minutes = 44 minutes');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 45}), true),  'njÃ« orÃ«',       '45 minutes = an hour');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 89}), true),  'njÃ« orÃ«',       '89 minutes = an hour');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 90}), true),  '2 orÃ«',       '90 minutes = 2 hours');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 5}), true),   '5 orÃ«',       '5 hours = 5 hours');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 21}), true),  '21 orÃ«',      '21 hours = 21 hours');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 22}), true),  'njÃ« ditÃ«',         '22 hours = a day');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 35}), true),  'njÃ« ditÃ«',         '35 hours = a day');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 36}), true),  '2 ditÃ«',        '36 hours = 2 days');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 1}), true),   'njÃ« ditÃ«',         '1 day = a day');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 5}), true),   '5 ditÃ«',        '5 days = 5 days');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 25}), true),  '25 ditÃ«',       '25 days = 25 days');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 26}), true),  'njÃ« muaj',       '26 days = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 30}), true),  'njÃ« muaj',       '30 days = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 43}), true),  'njÃ« muaj',       '43 days = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 46}), true),  '2 muaj',      '46 days = 2 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 74}), true),  '2 muaj',      '75 days = 2 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 76}), true),  '3 muaj',      '76 days = 3 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({M: 1}), true),   'njÃ« muaj',       '1 month = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({M: 5}), true),   '5 muaj',      '5 months = 5 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 345}), true), 'njÃ« vit',        '345 days = a year');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 548}), true), '2 vite',       '548 days = 2 years');
        assert.equal(start.from(moment([2007, 1, 28]).add({y: 1}), true),   'njÃ« vit',        '1 year = a year');
        assert.equal(start.from(moment([2007, 1, 28]).add({y: 5}), true),   '5 vite',       '5 years = 5 years');
    });

    test('suffix', function (assert) {
        assert.equal(moment(30000).from(0), 'nÃ« disa sekonda',  'prefix');
        assert.equal(moment(0).from(30000), 'disa sekonda mÃ« parÃ«', 'suffix');
    });

    test('now from now', function (assert) {
        assert.equal(moment().fromNow(), 'disa sekonda mÃ« parÃ«',  'now from now should display as in the past');
    });

    test('fromNow', function (assert) {
        assert.equal(moment().add({s: 30}).fromNow(), 'nÃ« disa sekonda', 'in a few seconds');
        assert.equal(moment().add({d: 5}).fromNow(), 'nÃ« 5 ditÃ«', 'in 5 days');
    });

    test('calendar day', function (assert) {
        var a = moment().hours(12).minutes(0).seconds(0);

        assert.equal(moment(a).calendar(),                   'Sot nÃ« 12:00',   'today at the same time');
        assert.equal(moment(a).add({m: 25}).calendar(),      'Sot nÃ« 12:25',   'Now plus 25 min');
        assert.equal(moment(a).add({h: 1}).calendar(),       'Sot nÃ« 13:00',   'Now plus 1 hour');
        assert.equal(moment(a).add({d: 1}).calendar(),       'NesÃ«r nÃ« 12:00', 'tomorrow at the same time');
        assert.equal(moment(a).subtract({h: 1}).calendar(),  'Sot nÃ« 11:00',   'Now minus 1 hour');
        assert.equal(moment(a).subtract({d: 1}).calendar(),  'Dje nÃ« 12:00',   'yesterday at the same time');
    });

    test('calendar next week', function (assert) {
        var i, m;

        for (i = 2; i < 7; i++) {
            m = moment().add({d: i});
            assert.equal(m.calendar(),       m.format('dddd [nÃ«] LT'),  'Today + ' + i + ' days current time');
            m.hours(0).minutes(0).seconds(0).milliseconds(0);
            assert.equal(m.calendar(),       m.format('dddd [nÃ«] LT'),  'Today + ' + i + ' days beginning of day');
            m.hours(23).minutes(59).seconds(59).milliseconds(999);
            assert.equal(m.calendar(),       m.format('dddd [nÃ«] LT'),  'Today + ' + i + ' days end of day');
        }
    });

    test('calendar last week', function (assert) {
        var i, m;

        for (i = 2; i < 7; i++) {
            m = moment().subtract({d: i});
            assert.equal(m.calendar(),       m.format('dddd [e kaluar nÃ«] LT'),  'Today - ' + i + ' days current time');
            m.hours(0).minutes(0).seconds(0).milliseconds(0);
            assert.equal(m.calendar(),       m.format('dddd [e kaluar nÃ«] LT'),  'Today - ' + i + ' days beginning of day');
            m.hours(23).minutes(59).seconds(59).milliseconds(999);
            assert.equal(m.calendar(),       m.format('dddd [e kaluar nÃ«] LT'),  'Today - ' + i + ' days end of day');
        }
    });

    test('calendar all else', function (assert) {
        var weeksAgo = moment().subtract({w: 1}),
            weeksFromNow = moment().add({w: 1});

        assert.equal(weeksAgo.calendar(),       weeksAgo.format('L'),  '1 week ago');
        assert.equal(weeksFromNow.calendar(),   weeksFromNow.format('L'),  'in 1 week');

        weeksAgo = moment().subtract({w: 2});
        weeksFromNow = moment().add({w: 2});

        assert.equal(weeksAgo.calendar(),       weeksAgo.format('L'),  '2 weeks ago');
        assert.equal(weeksFromNow.calendar(),   weeksFromNow.format('L'),  'in 2 weeks');
    });

    test('weeks year starting sunday formatted', function (assert) {
        assert.equal(moment([2012, 0,  1]).format('w ww wo'), '52 52 52.', 'Jan  1 2012 should be week 52');
        assert.equal(moment([2012, 0,  2]).format('w ww wo'),   '1 01 1.', 'Jan  2 2012 should be week 1');
        assert.equal(moment([2012, 0,  8]).format('w ww wo'),   '1 01 1.', 'Jan  8 2012 should be week 1');
        assert.equal(moment([2012, 0,  9]).format('w ww wo'),   '2 02 2.', 'Jan  9 2012 should be week 2');
        assert.equal(moment([2012, 0, 15]).format('w ww wo'),   '2 02 2.', 'Jan 15 2012 should be week 2');
    });

}));

;(function (global, factory) {
   typeof exports === 'object' && typeof module !== 'undefined'
       && typeof require === 'function' ? factory(require('../../moment')) :
   typeof define === 'function' && define.amd ? define(['../../moment'], factory) :
   factory(global.moment)
}(this, function (moment) { 'use strict';

    function each(array, callback) {
        var i;
        for (i = 0; i < array.length; i++) {
            callback(array[i], i, array);
        }
    }

    function objectKeys(obj) {
        if (Object.keys) {
            return Object.keys(obj);
        } else {
            // IE8
            var res = [], i;
            for (i in obj) {
                if (obj.hasOwnProperty(i)) {
                    res.push(i);
                }
            }
            return res;
        }
    }

    // Pick the first defined of two or three arguments.
    function defaults(a, b, c) {
        if (a != null) {
            return a;
        }
        if (b != null) {
            return b;
        }
        return c;
    }

    function defineCommonLocaleTests(locale, options) {
        test('lenient ordinal parsing', function (assert) {
            var i, ordinalStr, testMoment;
            for (i = 1; i <= 31; ++i) {
                ordinalStr = moment([2014, 0, i]).format('YYYY MM Do');
                testMoment = moment(ordinalStr, 'YYYY MM Do');
                assert.equal(testMoment.year(), 2014,
                        'lenient ordinal parsing ' + i + ' year check');
                assert.equal(testMoment.month(), 0,
                        'lenient ordinal parsing ' + i + ' month check');
                assert.equal(testMoment.date(), i,
                        'lenient ordinal parsing ' + i + ' date check');
            }
        });

        test('lenient ordinal parsing of number', function (assert) {
            var i, testMoment;
            for (i = 1; i <= 31; ++i) {
                testMoment = moment('2014 01 ' + i, 'YYYY MM Do');
                assert.equal(testMoment.year(), 2014,
                        'lenient ordinal parsing of number ' + i + ' year check');
                assert.equal(testMoment.month(), 0,
                        'lenient ordinal parsing of number ' + i + ' month check');
                assert.equal(testMoment.date(), i,
                        'lenient ordinal parsing of number ' + i + ' date check');
            }
        });

        test('strict ordinal parsing', function (assert) {
            var i, ordinalStr, testMoment;
            for (i = 1; i <= 31; ++i) {
                ordinalStr = moment([2014, 0, i]).format('YYYY MM Do');
                testMoment = moment(ordinalStr, 'YYYY MM Do', true);
                assert.ok(testMoment.isValid(), 'strict ordinal parsing ' + i);
            }
        });

        test('meridiem invariant', function (assert) {
            var h, m, t1, t2;
            for (h = 0; h < 24; ++h) {
                for (m = 0; m < 60; m += 15) {
                    t1 = moment.utc([2000, 0, 1, h, m]);
                    t2 = moment.utc(t1.format('A h:mm'), 'A h:mm');
                    assert.equal(t2.format('HH:mm'), t1.format('HH:mm'),
                            'meridiem at ' + t1.format('HH:mm'));
                }
            }
        });

        test('date format correctness', function (assert) {
            var data, tokens;
            data = moment.localeData()._longDateFormat;
            tokens = objectKeys(data);
            each(tokens, function (srchToken) {
                // Check each format string to make sure it does not contain any
                // tokens that need to be expanded.
                each(tokens, function (baseToken) {
                    // strip escaped sequences
                    var format = data[baseToken].replace(/(\[[^\]]*\])/g, '');
                    assert.equal(false, !!~format.indexOf(srchToken),
                            'contains ' + srchToken + ' in ' + baseToken);
                });
            });
        });

        test('month parsing correctness', function (assert) {
            var i, m;

            if (locale === 'tr') {
                // I can't fix it :(
                expect(0);
                return;
            }
            function tester(format) {
                var r;
                r = moment(m.format(format), format);
                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format);
                r = moment(m.format(format).toLocaleUpperCase(), format);
                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' upper');
                r = moment(m.format(format).toLocaleLowerCase(), format);
                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' lower');

                r = moment(m.format(format), format, true);
                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' strict');
                r = moment(m.format(format).toLocaleUpperCase(), format, true);
                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' upper strict');
                r = moment(m.format(format).toLocaleLowerCase(), format, true);
                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' lower strict');
            }

            for (i = 0; i < 12; ++i) {
                m = moment([2015, i, 15, 18]);
                tester('MMM');
                tester('MMM.');
                tester('MMMM');
                tester('MMMM.');
            }
        });

        test('weekday parsing correctness', function (assert) {
            var i, m;

            if (locale === 'tr' || locale === 'az') {
                // There is a lower-case letter (Ä±), that converted to upper then
                // lower changes to i
                expect(0);
                return;
            }
            function tester(format) {
                var r, baseMsg = 'weekday ' + m.weekday() + ' fmt ' + format;
                r = moment(m.format(format), format);
                assert.equal(r.weekday(), m.weekday(), baseMsg);
                r = moment(m.format(format).toLocaleUpperCase(), format);
                assert.equal(r.weekday(), m.weekday(), baseMsg + ' upper');
                r = moment(m.format(format).toLocaleLowerCase(), format);
                assert.equal(r.weekday(), m.weekday(), baseMsg + ' lower');

                r = moment(m.format(format), format, true);
                assert.equal(r.weekday(), m.weekday(), baseMsg + ' strict');
                r = moment(m.format(format).toLocaleUpperCase(), format, true);
                assert.equal(r.weekday(), m.weekday(), baseMsg + ' upper strict');
                r = moment(m.format(format).toLocaleLowerCase(), format, true);
                assert.equal(r.weekday(), m.weekday(), baseMsg + ' lower strict');
            }

            for (i = 0; i < 7; ++i) {
                m = moment.utc([2015, i, 15, 18]);
                tester('dd');
                tester('ddd');
                tester('dddd');
            }
        });
    }

    function setupDeprecationHandler(test, moment, scope) {
        test._expectedDeprecations = null;
        test._observedDeprecations = null;
        test._oldSupress = moment.suppressDeprecationWarnings;
        moment.suppressDeprecationWarnings = true;
        test.expectedDeprecations = function () {
            test._expectedDeprecations = arguments;
            test._observedDeprecations = [];
        };
        moment.deprecationHandler = function (name, msg) {
            var deprecationId = matchedDeprecation(name, msg, test._expectedDeprecations);
            if (deprecationId === -1) {
                throw new Error('Unexpected deprecation thrown name=' +
                        name + ' msg=' + msg);
            }
            test._observedDeprecations[deprecationId] = 1;
        };
    }

    function teardownDeprecationHandler(test, moment, scope) {
        moment.suppressDeprecationWarnings = test._oldSupress;

        if (test._expectedDeprecations != null) {
            var missedDeprecations = [];
            each(test._expectedDeprecations, function (deprecationPattern, id) {
                if (test._observedDeprecations[id] !== 1) {
                    missedDeprecations.push(deprecationPattern);
                }
            });
            if (missedDeprecations.length !== 0) {
                throw new Error('Expected deprecation warnings did not happen: ' +
                        missedDeprecations.join(' '));
            }
        }
    }

    function matchedDeprecation(name, msg, deprecations) {
        if (deprecations == null) {
            return -1;
        }
        for (var i = 0; i < deprecations.length; ++i) {
            if (name != null && name === deprecations[i]) {
                return i;
            }
            if (msg != null && msg.substring(0, deprecations[i].length) === deprecations[i]) {
                return i;
            }
        }
        return -1;
    }

    /*global QUnit:false*/

    var test = QUnit.test;

    var expect = QUnit.expect;

    function module (name, lifecycle) {
        QUnit.module(name, {
            setup : function () {
                moment.locale('en');
                moment.createFromInputFallback = function (config) {
                    throw new Error('input not handled by moment: ' + config._i);
                };
                setupDeprecationHandler(test, moment, 'core');
                if (lifecycle && lifecycle.setup) {
                    lifecycle.setup();
                }
            },
            teardown : function () {
                teardownDeprecationHandler(test, moment, 'core');
                if (lifecycle && lifecycle.teardown) {
                    lifecycle.teardown();
                }
            }
        });
    }

    function localeModule (name, lifecycle) {
        QUnit.module('locale:' + name, {
            setup : function () {
                moment.locale(name);
                moment.createFromInputFallback = function (config) {
                    throw new Error('input not handled by moment: ' + config._i);
                };
                setupDeprecationHandler(test, moment, 'locale');
                if (lifecycle && lifecycle.setup) {
                    lifecycle.setup();
                }
            },
            teardown : function () {
                moment.locale('en');
                teardownDeprecationHandler(test, moment, 'locale');
                if (lifecycle && lifecycle.teardown) {
                    lifecycle.teardown();
                }
            }
        });
        defineCommonLocaleTests(name, -1, -1);
    }

    localeModule('sr-cyrl');

    test('parse', function (assert) {
        var tests = 'ÑÐ°Ð½ÑÐ°Ñ ÑÐ°Ð½._ÑÐµÐ±ÑÑÐ°Ñ ÑÐµÐ±._Ð¼Ð°ÑÑ Ð¼Ð°Ñ._Ð°Ð¿ÑÐ¸Ð» Ð°Ð¿Ñ._Ð¼Ð°Ñ Ð¼Ð°Ñ_ÑÑÐ½ ÑÑÐ½_ÑÑÐ» ÑÑÐ»_Ð°Ð²Ð³ÑÑÑ Ð°Ð²Ð³._ÑÐµÐ¿ÑÐµÐ¼Ð±Ð°Ñ ÑÐµÐ¿._Ð¾ÐºÑÐ¾Ð±Ð°Ñ Ð¾ÐºÑ._Ð½Ð¾Ð²ÐµÐ¼Ð±Ð°Ñ Ð½Ð¾Ð²._Ð´ÐµÑÐµÐ¼Ð±Ð°Ñ Ð´ÐµÑ.'.split('_'),
            i;
        function equalTest(input, mmm, i) {
            assert.equal(moment(input, mmm).month(), i, input + ' should be month ' + (i + 1));
        }
        for (i = 0; i < 12; i++) {
            tests[i] = tests[i].split(' ');
            equalTest(tests[i][0], 'MMM', i);
            equalTest(tests[i][1], 'MMM', i);
            equalTest(tests[i][0], 'MMMM', i);
            equalTest(tests[i][1], 'MMMM', i);
            equalTest(tests[i][0].toLocaleLowerCase(), 'MMMM', i);
            equalTest(tests[i][1].toLocaleLowerCase(), 'MMMM', i);
            equalTest(tests[i][0].toLocaleUpperCase(), 'MMMM', i);
            equalTest(tests[i][1].toLocaleUpperCase(), 'MMMM', i);
        }
    });

    test('format', function (assert) {
        var a = [
                ['dddd, Do MMMM YYYY, h:mm:ss a',      'Ð½ÐµÐ´ÐµÑÐ°, 14. ÑÐµÐ±ÑÑÐ°Ñ 2010, 3:25:50 pm'],
                ['ddd, hA',                            'Ð½ÐµÐ´., 3PM'],
                ['M Mo MM MMMM MMM',                   '2 2. 02 ÑÐµÐ±ÑÑÐ°Ñ ÑÐµÐ±.'],
                ['YYYY YY',                            '2010 10'],
                ['D Do DD',                            '14 14. 14'],
                ['d do dddd ddd dd',                   '0 0. Ð½ÐµÐ´ÐµÑÐ° Ð½ÐµÐ´. Ð½Ðµ'],
                ['DDD DDDo DDDD',                      '45 45. 045'],
                ['w wo ww',                            '7 7. 07'],
                ['h hh',                               '3 03'],
                ['H HH',                               '15 15'],
                ['m mm',                               '25 25'],
                ['s ss',                               '50 50'],
                ['a A',                                'pm PM'],
                ['[the] DDDo [day of the year]',       'the 45. day of the year'],
                ['LTS',                                '15:25:50'],
                ['L',                                  '14. 02. 2010'],
                ['LL',                                 '14. ÑÐµÐ±ÑÑÐ°Ñ 2010'],
                ['LLL',                                '14. ÑÐµÐ±ÑÑÐ°Ñ 2010 15:25'],
                ['LLLL',                               'Ð½ÐµÐ´ÐµÑÐ°, 14. ÑÐµÐ±ÑÑÐ°Ñ 2010 15:25'],
                ['l',                                  '14. 2. 2010'],
                ['ll',                                 '14. ÑÐµÐ±. 2010'],
                ['lll',                                '14. ÑÐµÐ±. 2010 15:25'],
                ['llll',                               'Ð½ÐµÐ´., 14. ÑÐµÐ±. 2010 15:25']
            ],
            b = moment(new Date(2010, 1, 14, 15, 25, 50, 125)),
            i;
        for (i = 0; i < a.length; i++) {
            assert.equal(b.format(a[i][0]), a[i][1], a[i][0] + ' ---> ' + a[i][1]);
        }
    });

    test('format ordinal', function (assert) {
        assert.equal(moment([2011, 0, 1]).format('DDDo'), '1.', '1.');
        assert.equal(moment([2011, 0, 2]).format('DDDo'), '2.', '2.');
        assert.equal(moment([2011, 0, 3]).format('DDDo'), '3.', '3.');
        assert.equal(moment([2011, 0, 4]).format('DDDo'), '4.', '4.');
        assert.equal(moment([2011, 0, 5]).format('DDDo'), '5.', '5.');
        assert.equal(moment([2011, 0, 6]).format('DDDo'), '6.', '6.');
        assert.equal(moment([2011, 0, 7]).format('DDDo'), '7.', '7.');
        assert.equal(moment([2011, 0, 8]).format('DDDo'), '8.', '8.');
        assert.equal(moment([2011, 0, 9]).format('DDDo'), '9.', '9.');
        assert.equal(moment([2011, 0, 10]).format('DDDo'), '10.', '10.');

        assert.equal(moment([2011, 0, 11]).format('DDDo'), '11.', '11.');
        assert.equal(moment([2011, 0, 12]).format('DDDo'), '12.', '12.');
        assert.equal(moment([2011, 0, 13]).format('DDDo'), '13.', '13.');
        assert.equal(moment([2011, 0, 14]).format('DDDo'), '14.', '14.');
        assert.equal(moment([2011, 0, 15]).format('DDDo'), '15.', '15.');
        assert.equal(moment([2011, 0, 16]).format('DDDo'), '16.', '16.');
        assert.equal(moment([2011, 0, 17]).format('DDDo'), '17.', '17.');
        assert.equal(moment([2011, 0, 18]).format('DDDo'), '18.', '18.');
        assert.equal(moment([2011, 0, 19]).format('DDDo'), '19.', '19.');
        assert.equal(moment([2011, 0, 20]).format('DDDo'), '20.', '20.');

        assert.equal(moment([2011, 0, 21]).format('DDDo'), '21.', '21.');
        assert.equal(moment([2011, 0, 22]).format('DDDo'), '22.', '22.');
        assert.equal(moment([2011, 0, 23]).format('DDDo'), '23.', '23.');
        assert.equal(moment([2011, 0, 24]).format('DDDo'), '24.', '24.');
        assert.equal(moment([2011, 0, 25]).format('DDDo'), '25.', '25.');
        assert.equal(moment([2011, 0, 26]).format('DDDo'), '26.', '26.');
        assert.equal(moment([2011, 0, 27]).format('DDDo'), '27.', '27.');
        assert.equal(moment([2011, 0, 28]).format('DDDo'), '28.', '28.');
        assert.equal(moment([2011, 0, 29]).format('DDDo'), '29.', '29.');
        assert.equal(moment([2011, 0, 30]).format('DDDo'), '30.', '30.');

        assert.equal(moment([2011, 0, 31]).format('DDDo'), '31.', '31.');
    });

    test('format month', function (assert) {
        var expected = 'ÑÐ°Ð½ÑÐ°Ñ ÑÐ°Ð½._ÑÐµÐ±ÑÑÐ°Ñ ÑÐµÐ±._Ð¼Ð°ÑÑ Ð¼Ð°Ñ._Ð°Ð¿ÑÐ¸Ð» Ð°Ð¿Ñ._Ð¼Ð°Ñ Ð¼Ð°Ñ_ÑÑÐ½ ÑÑÐ½_ÑÑÐ» ÑÑÐ»_Ð°Ð²Ð³ÑÑÑ Ð°Ð²Ð³._ÑÐµÐ¿ÑÐµÐ¼Ð±Ð°Ñ ÑÐµÐ¿._Ð¾ÐºÑÐ¾Ð±Ð°Ñ Ð¾ÐºÑ._Ð½Ð¾Ð²ÐµÐ¼Ð±Ð°Ñ Ð½Ð¾Ð²._Ð´ÐµÑÐµÐ¼Ð±Ð°Ñ Ð´ÐµÑ.'.split('_'),
            i;
        for (i = 0; i < expected.length; i++) {
            assert.equal(moment([2011, i, 1]).format('MMMM MMM'), expected[i], expected[i]);
        }
    });

    test('format week', function (assert) {
        var expected = 'Ð½ÐµÐ´ÐµÑÐ° Ð½ÐµÐ´. Ð½Ðµ_Ð¿Ð¾Ð½ÐµÐ´ÐµÑÐ°Ðº Ð¿Ð¾Ð½. Ð¿Ð¾_ÑÑÐ¾ÑÐ°Ðº ÑÑÐ¾. ÑÑ_ÑÑÐµÐ´Ð° ÑÑÐµ. ÑÑ_ÑÐµÑÐ²ÑÑÐ°Ðº ÑÐµÑ. ÑÐµ_Ð¿ÐµÑÐ°Ðº Ð¿ÐµÑ. Ð¿Ðµ_ÑÑÐ±Ð¾ÑÐ° ÑÑÐ±. ÑÑ'.split('_'),
            i;
        for (i = 0; i < expected.length; i++) {
            assert.equal(moment([2011, 0, 2 + i]).format('dddd ddd dd'), expected[i], expected[i]);
        }
    });

    test('from', function (assert) {
        var start = moment([2007, 1, 28]);
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 44}), true),  'Ð½ÐµÐºÐ¾Ð»Ð¸ÐºÐ¾ ÑÐµÐºÑÐ½Ð´Ð¸', '44 seconds = a few seconds');
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 45}), true),  'ÑÐµÐ´Ð°Ð½ Ð¼Ð¸Ð½ÑÑ',   '45 seconds = a minute');
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 89}), true),  'ÑÐµÐ´Ð°Ð½ Ð¼Ð¸Ð½ÑÑ',   '89 seconds = a minute');
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 90}), true),  '2 Ð¼Ð¸Ð½ÑÑÐµ',     '90 seconds = 2 minutes');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 44}), true),  '44 Ð¼Ð¸Ð½ÑÑÐ°',     '44 minutes = 44 minutes');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 45}), true),  'ÑÐµÐ´Ð°Ð½ ÑÐ°Ñ',      '45 minutes = an hour');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 89}), true),  'ÑÐµÐ´Ð°Ð½ ÑÐ°Ñ',      '89 minutes = an hour');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 90}), true),  '2 ÑÐ°ÑÐ°',        '90 minutes = 2 hours');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 5}), true),   '5 ÑÐ°ÑÐ¸',         '5 hours = 5 hours');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 21}), true),  '21 ÑÐ°ÑÐ¸',        '21 hours = 21 hours');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 22}), true),  'Ð´Ð°Ð½',       '22 hours = a day');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 35}), true),  'Ð´Ð°Ð½',       '35 hours = a day');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 36}), true),  '2 Ð´Ð°Ð½Ð°',        '36 hours = 2 days');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 1}), true),   'Ð´Ð°Ð½',       '1 day = a day');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 5}), true),   '5 Ð´Ð°Ð½Ð°',        '5 days = 5 days');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 25}), true),  '25 Ð´Ð°Ð½Ð°',       '25 days = 25 days');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 26}), true),  'Ð¼ÐµÑÐµÑ',     '26 days = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 30}), true),  'Ð¼ÐµÑÐµÑ',     '30 days = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 43}), true),  'Ð¼ÐµÑÐµÑ',     '43 days = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 46}), true),  '2 Ð¼ÐµÑÐµÑÐ°',     '46 days = 2 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 74}), true),  '2 Ð¼ÐµÑÐµÑÐ°',     '75 days = 2 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 76}), true),  '3 Ð¼ÐµÑÐµÑÐ°',     '76 days = 3 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({M: 1}), true),   'Ð¼ÐµÑÐµÑ',     '1 month = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({M: 5}), true),   '5 Ð¼ÐµÑÐµÑÐ¸',    '5 months = 5 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 345}), true), 'Ð³Ð¾Ð´Ð¸Ð½Ñ',     '345 days = a year');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 548}), true), '2 Ð³Ð¾Ð´Ð¸Ð½Ðµ',       '548 days = 2 years');
        assert.equal(start.from(moment([2007, 1, 28]).add({y: 1}), true),   'Ð³Ð¾Ð´Ð¸Ð½Ñ',     '1 year = a year');
        assert.equal(start.from(moment([2007, 1, 28]).add({y: 5}), true),   '5 Ð³Ð¾Ð´Ð¸Ð½Ð°',        '5 years = 5 years');
    });

    test('suffix', function (assert) {
        assert.equal(moment(30000).from(0), 'Ð·Ð° Ð½ÐµÐºÐ¾Ð»Ð¸ÐºÐ¾ ÑÐµÐºÑÐ½Ð´Ð¸',  'prefix');
        assert.equal(moment(0).from(30000), 'Ð¿ÑÐµ Ð½ÐµÐºÐ¾Ð»Ð¸ÐºÐ¾ ÑÐµÐºÑÐ½Ð´Ð¸', 'prefix');
    });

    test('now from now', function (assert) {
        assert.equal(moment().fromNow(), 'Ð¿ÑÐµ Ð½ÐµÐºÐ¾Ð»Ð¸ÐºÐ¾ ÑÐµÐºÑÐ½Ð´Ð¸',  'now from now should display as in the past');
    });

    test('fromNow', function (assert) {
        assert.equal(moment().add({s: 30}).fromNow(), 'Ð·Ð° Ð½ÐµÐºÐ¾Ð»Ð¸ÐºÐ¾ ÑÐµÐºÑÐ½Ð´Ð¸', 'in a few seconds');
        assert.equal(moment().add({d: 5}).fromNow(), 'Ð·Ð° 5 Ð´Ð°Ð½Ð°', 'in 5 days');
    });

    test('calendar day', function (assert) {
        var a = moment().hours(12).minutes(0).seconds(0);

        assert.equal(moment(a).calendar(),                   'Ð´Ð°Ð½Ð°Ñ Ñ 12:00',  'today at the same time');
        assert.equal(moment(a).add({m: 25}).calendar(),      'Ð´Ð°Ð½Ð°Ñ Ñ 12:25',  'Now plus 25 min');
        assert.equal(moment(a).add({h: 1}).calendar(),       'Ð´Ð°Ð½Ð°Ñ Ñ 13:00',  'Now plus 1 hour');
        assert.equal(moment(a).add({d: 1}).calendar(),       'ÑÑÑÑÐ° Ñ 12:00',  'tomorrow at the same time');
        assert.equal(moment(a).subtract({h: 1}).calendar(),  'Ð´Ð°Ð½Ð°Ñ Ñ 11:00',  'Now minus 1 hour');
        assert.equal(moment(a).subtract({d: 1}).calendar(),  'ÑÑÑÐµ Ñ 12:00',   'yesterday at the same time');
    });

    test('calendar next week', function (assert) {
        var i, m;

        function makeFormat(d) {
            switch (d.day()) {
            case 0:
                return '[Ñ] [Ð½ÐµÐ´ÐµÑÑ] [Ñ] LT';
            case 3:
                return '[Ñ] [ÑÑÐµÐ´Ñ] [Ñ] LT';
            case 6:
                return '[Ñ] [ÑÑÐ±Ð¾ÑÑ] [Ñ] LT';
            case 1:
            case 2:
            case 4:
            case 5:
                return '[Ñ] dddd [Ñ] LT';
            }
        }

        for (i = 2; i < 7; i++) {
            m = moment().add({d: i});
            assert.equal(m.calendar(),       m.format(makeFormat(m)),  'Today + ' + i + ' days current time');
            m.hours(0).minutes(0).seconds(0).milliseconds(0);
            assert.equal(m.calendar(),       m.format(makeFormat(m)),  'Today + ' + i + ' days beginning of day');
            m.hours(23).minutes(59).seconds(59).milliseconds(999);
            assert.equal(m.calendar(),       m.format(makeFormat(m)),  'Today + ' + i + ' days end of day');
        }
    });

    test('calendar last week', function (assert) {
        var i, m;

        function makeFormat(d) {
            var lastWeekDay = [
                    '[Ð¿ÑÐ¾ÑÐ»Ðµ] [Ð½ÐµÐ´ÐµÑÐµ] [Ñ] LT',
                    '[Ð¿ÑÐ¾ÑÐ»Ð¾Ð³] [Ð¿Ð¾Ð½ÐµÐ´ÐµÑÐºÐ°] [Ñ] LT',
                    '[Ð¿ÑÐ¾ÑÐ»Ð¾Ð³] [ÑÑÐ¾ÑÐºÐ°] [Ñ] LT',
                    '[Ð¿ÑÐ¾ÑÐ»Ðµ] [ÑÑÐµÐ´Ðµ] [Ñ] LT',
                    '[Ð¿ÑÐ¾ÑÐ»Ð¾Ð³] [ÑÐµÑÐ²ÑÑÐºÐ°] [Ñ] LT',
                    '[Ð¿ÑÐ¾ÑÐ»Ð¾Ð³] [Ð¿ÐµÑÐºÐ°] [Ñ] LT',
                    '[Ð¿ÑÐ¾ÑÐ»Ðµ] [ÑÑÐ±Ð¾ÑÐµ] [Ñ] LT'
                ];

            return lastWeekDay[d.day()];
        }

        for (i = 2; i < 7; i++) {
            m = moment().subtract({d: i});
            assert.equal(m.calendar(),       m.format(makeFormat(m)),  'Today - ' + i + ' days current time');
            m.hours(0).minutes(0).seconds(0).milliseconds(0);
            assert.equal(m.calendar(),       m.format(makeFormat(m)),  'Today - ' + i + ' days beginning of day');
            m.hours(23).minutes(59).seconds(59).milliseconds(999);
            assert.equal(m.calendar(),       m.format(makeFormat(m)),  'Today - ' + i + ' days end of day');
        }
    });

    test('calendar all else', function (assert) {
        var weeksAgo = moment().subtract({w: 1}),
            weeksFromNow = moment().add({w: 1});

        assert.equal(weeksAgo.calendar(),       weeksAgo.format('L'),  '1 week ago');
        assert.equal(weeksFromNow.calendar(),   weeksFromNow.format('L'),  'in 1 week');

        weeksAgo = moment().subtract({w: 2});
        weeksFromNow = moment().add({w: 2});

        assert.equal(weeksAgo.calendar(),       weeksAgo.format('L'),  '2 weeks ago');
        assert.equal(weeksFromNow.calendar(),   weeksFromNow.format('L'),  'in 2 weeks');
    });

    test('weeks year starting sunday formatted', function (assert) {
        assert.equal(moment([2011, 11, 26]).format('w ww wo'), '1 01 1.', 'Dec 26 2011 should be week 1');
        assert.equal(moment([2012,  0,  1]).format('w ww wo'), '1 01 1.', 'Jan  1 2012 should be week 1');
        assert.equal(moment([2012,  0,  2]).format('w ww wo'), '2 02 2.', 'Jan  2 2012 should be week 2');
        assert.equal(moment([2012,  0,  8]).format('w ww wo'), '2 02 2.', 'Jan  8 2012 should be week 2');
        assert.equal(moment([2012,  0,  9]).format('w ww wo'), '3 03 3.', 'Jan  9 2012 should be week 3');
    });

}));

;(function (global, factory) {
   typeof exports === 'object' && typeof module !== 'undefined'
       && typeof require === 'function' ? factory(require('../../moment')) :
   typeof define === 'function' && define.amd ? define(['../../moment'], factory) :
   factory(global.moment)
}(this, function (moment) { 'use strict';

    function each(array, callback) {
        var i;
        for (i = 0; i < array.length; i++) {
            callback(array[i], i, array);
        }
    }

    function objectKeys(obj) {
        if (Object.keys) {
            return Object.keys(obj);
        } else {
            // IE8
            var res = [], i;
            for (i in obj) {
                if (obj.hasOwnProperty(i)) {
                    res.push(i);
                }
            }
            return res;
        }
    }

    // Pick the first defined of two or three arguments.
    function defaults(a, b, c) {
        if (a != null) {
            return a;
        }
        if (b != null) {
            return b;
        }
        return c;
    }

    function defineCommonLocaleTests(locale, options) {
        test('lenient ordinal parsing', function (assert) {
            var i, ordinalStr, testMoment;
            for (i = 1; i <= 31; ++i) {
                ordinalStr = moment([2014, 0, i]).format('YYYY MM Do');
                testMoment = moment(ordinalStr, 'YYYY MM Do');
                assert.equal(testMoment.year(), 2014,
                        'lenient ordinal parsing ' + i + ' year check');
                assert.equal(testMoment.month(), 0,
                        'lenient ordinal parsing ' + i + ' month check');
                assert.equal(testMoment.date(), i,
                        'lenient ordinal parsing ' + i + ' date check');
            }
        });

        test('lenient ordinal parsing of number', function (assert) {
            var i, testMoment;
            for (i = 1; i <= 31; ++i) {
                testMoment = moment('2014 01 ' + i, 'YYYY MM Do');
                assert.equal(testMoment.year(), 2014,
                        'lenient ordinal parsing of number ' + i + ' year check');
                assert.equal(testMoment.month(), 0,
                        'lenient ordinal parsing of number ' + i + ' month check');
                assert.equal(testMoment.date(), i,
                        'lenient ordinal parsing of number ' + i + ' date check');
            }
        });

        test('strict ordinal parsing', function (assert) {
            var i, ordinalStr, testMoment;
            for (i = 1; i <= 31; ++i) {
                ordinalStr = moment([2014, 0, i]).format('YYYY MM Do');
                testMoment = moment(ordinalStr, 'YYYY MM Do', true);
                assert.ok(testMoment.isValid(), 'strict ordinal parsing ' + i);
            }
        });

        test('meridiem invariant', function (assert) {
            var h, m, t1, t2;
            for (h = 0; h < 24; ++h) {
                for (m = 0; m < 60; m += 15) {
                    t1 = moment.utc([2000, 0, 1, h, m]);
                    t2 = moment.utc(t1.format('A h:mm'), 'A h:mm');
                    assert.equal(t2.format('HH:mm'), t1.format('HH:mm'),
                            'meridiem at ' + t1.format('HH:mm'));
                }
            }
        });

        test('date format correctness', function (assert) {
            var data, tokens;
            data = moment.localeData()._longDateFormat;
            tokens = objectKeys(data);
            each(tokens, function (srchToken) {
                // Check each format string to make sure it does not contain any
                // tokens that need to be expanded.
                each(tokens, function (baseToken) {
                    // strip escaped sequences
                    var format = data[baseToken].replace(/(\[[^\]]*\])/g, '');
                    assert.equal(false, !!~format.indexOf(srchToken),
                            'contains ' + srchToken + ' in ' + baseToken);
                });
            });
        });

        test('month parsing correctness', function (assert) {
            var i, m;

            if (locale === 'tr') {
                // I can't fix it :(
                expect(0);
                return;
            }
            function tester(format) {
                var r;
                r = moment(m.format(format), format);
                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format);
                r = moment(m.format(format).toLocaleUpperCase(), format);
                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' upper');
                r = moment(m.format(format).toLocaleLowerCase(), format);
                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' lower');

                r = moment(m.format(format), format, true);
                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' strict');
                r = moment(m.format(format).toLocaleUpperCase(), format, true);
                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' upper strict');
                r = moment(m.format(format).toLocaleLowerCase(), format, true);
                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' lower strict');
            }

            for (i = 0; i < 12; ++i) {
                m = moment([2015, i, 15, 18]);
                tester('MMM');
                tester('MMM.');
                tester('MMMM');
                tester('MMMM.');
            }
        });

        test('weekday parsing correctness', function (assert) {
            var i, m;

            if (locale === 'tr' || locale === 'az') {
                // There is a lower-case letter (Ä±), that converted to upper then
                // lower changes to i
                expect(0);
                return;
            }
            function tester(format) {
                var r, baseMsg = 'weekday ' + m.weekday() + ' fmt ' + format;
                r = moment(m.format(format), format);
                assert.equal(r.weekday(), m.weekday(), baseMsg);
                r = moment(m.format(format).toLocaleUpperCase(), format);
                assert.equal(r.weekday(), m.weekday(), baseMsg + ' upper');
                r = moment(m.format(format).toLocaleLowerCase(), format);
                assert.equal(r.weekday(), m.weekday(), baseMsg + ' lower');

                r = moment(m.format(format), format, true);
                assert.equal(r.weekday(), m.weekday(), baseMsg + ' strict');
                r = moment(m.format(format).toLocaleUpperCase(), format, true);
                assert.equal(r.weekday(), m.weekday(), baseMsg + ' upper strict');
                r = moment(m.format(format).toLocaleLowerCase(), format, true);
                assert.equal(r.weekday(), m.weekday(), baseMsg + ' lower strict');
            }

            for (i = 0; i < 7; ++i) {
                m = moment.utc([2015, i, 15, 18]);
                tester('dd');
                tester('ddd');
                tester('dddd');
            }
        });
    }

    function setupDeprecationHandler(test, moment, scope) {
        test._expectedDeprecations = null;
        test._observedDeprecations = null;
        test._oldSupress = moment.suppressDeprecationWarnings;
        moment.suppressDeprecationWarnings = true;
        test.expectedDeprecations = function () {
            test._expectedDeprecations = arguments;
            test._observedDeprecations = [];
        };
        moment.deprecationHandler = function (name, msg) {
            var deprecationId = matchedDeprecation(name, msg, test._expectedDeprecations);
            if (deprecationId === -1) {
                throw new Error('Unexpected deprecation thrown name=' +
                        name + ' msg=' + msg);
            }
            test._observedDeprecations[deprecationId] = 1;
        };
    }

    function teardownDeprecationHandler(test, moment, scope) {
        moment.suppressDeprecationWarnings = test._oldSupress;

        if (test._expectedDeprecations != null) {
            var missedDeprecations = [];
            each(test._expectedDeprecations, function (deprecationPattern, id) {
                if (test._observedDeprecations[id] !== 1) {
                    missedDeprecations.push(deprecationPattern);
                }
            });
            if (missedDeprecations.length !== 0) {
                throw new Error('Expected deprecation warnings did not happen: ' +
                        missedDeprecations.join(' '));
            }
        }
    }

    function matchedDeprecation(name, msg, deprecations) {
        if (deprecations == null) {
            return -1;
        }
        for (var i = 0; i < deprecations.length; ++i) {
            if (name != null && name === deprecations[i]) {
                return i;
            }
            if (msg != null && msg.substring(0, deprecations[i].length) === deprecations[i]) {
                return i;
            }
        }
        return -1;
    }

    /*global QUnit:false*/

    var test = QUnit.test;

    var expect = QUnit.expect;

    function module (name, lifecycle) {
        QUnit.module(name, {
            setup : function () {
                moment.locale('en');
                moment.createFromInputFallback = function (config) {
                    throw new Error('input not handled by moment: ' + config._i);
                };
                setupDeprecationHandler(test, moment, 'core');
                if (lifecycle && lifecycle.setup) {
                    lifecycle.setup();
                }
            },
            teardown : function () {
                teardownDeprecationHandler(test, moment, 'core');
                if (lifecycle && lifecycle.teardown) {
                    lifecycle.teardown();
                }
            }
        });
    }

    function localeModule (name, lifecycle) {
        QUnit.module('locale:' + name, {
            setup : function () {
                moment.locale(name);
                moment.createFromInputFallback = function (config) {
                    throw new Error('input not handled by moment: ' + config._i);
                };
                setupDeprecationHandler(test, moment, 'locale');
                if (lifecycle && lifecycle.setup) {
                    lifecycle.setup();
                }
            },
            teardown : function () {
                moment.locale('en');
                teardownDeprecationHandler(test, moment, 'locale');
                if (lifecycle && lifecycle.teardown) {
                    lifecycle.teardown();
                }
            }
        });
        defineCommonLocaleTests(name, -1, -1);
    }

    localeModule('sr');

    test('parse', function (assert) {
        var tests = 'januar jan._februar feb._mart mar._april apr._maj maj_jun jun_jul jul_avgust avg._septembar sep._oktobar okt._novembar nov._decembar dec.'.split('_'),
            i;
        function equalTest(input, mmm, i) {
            assert.equal(moment(input, mmm).month(), i, input + ' should be month ' + (i + 1));
        }
        for (i = 0; i < 12; i++) {
            tests[i] = tests[i].split(' ');
            equalTest(tests[i][0], 'MMM', i);
            equalTest(tests[i][1], 'MMM', i);
            equalTest(tests[i][0], 'MMMM', i);
            equalTest(tests[i][1], 'MMMM', i);
            equalTest(tests[i][0].toLocaleLowerCase(), 'MMMM', i);
            equalTest(tests[i][1].toLocaleLowerCase(), 'MMMM', i);
            equalTest(tests[i][0].toLocaleUpperCase(), 'MMMM', i);
            equalTest(tests[i][1].toLocaleUpperCase(), 'MMMM', i);
        }
    });

    test('format', function (assert) {
        var a = [
                ['dddd, Do MMMM YYYY, h:mm:ss a',      'nedelja, 14. februar 2010, 3:25:50 pm'],
                ['ddd, hA',                            'ned., 3PM'],
                ['M Mo MM MMMM MMM',                   '2 2. 02 februar feb.'],
                ['YYYY YY',                            '2010 10'],
                ['D Do DD',                            '14 14. 14'],
                ['d do dddd ddd dd',                   '0 0. nedelja ned. ne'],
                ['DDD DDDo DDDD',                      '45 45. 045'],
                ['w wo ww',                            '7 7. 07'],
                ['h hh',                               '3 03'],
                ['H HH',                               '15 15'],
                ['m mm',                               '25 25'],
                ['s ss',                               '50 50'],
                ['a A',                                'pm PM'],
                ['[the] DDDo [day of the year]',       'the 45. day of the year'],
                ['LTS',                                '15:25:50'],
                ['L',                                  '14. 02. 2010'],
                ['LL',                                 '14. februar 2010'],
                ['LLL',                                '14. februar 2010 15:25'],
                ['LLLL',                               'nedelja, 14. februar 2010 15:25'],
                ['l',                                  '14. 2. 2010'],
                ['ll',                                 '14. feb. 2010'],
                ['lll',                                '14. feb. 2010 15:25'],
                ['llll',                               'ned., 14. feb. 2010 15:25']
            ],
            b = moment(new Date(2010, 1, 14, 15, 25, 50, 125)),
            i;
        for (i = 0; i < a.length; i++) {
            assert.equal(b.format(a[i][0]), a[i][1], a[i][0] + ' ---> ' + a[i][1]);
        }
    });

    test('format ordinal', function (assert) {
        assert.equal(moment([2011, 0, 1]).format('DDDo'), '1.', '1.');
        assert.equal(moment([2011, 0, 2]).format('DDDo'), '2.', '2.');
        assert.equal(moment([2011, 0, 3]).format('DDDo'), '3.', '3.');
        assert.equal(moment([2011, 0, 4]).format('DDDo'), '4.', '4.');
        assert.equal(moment([2011, 0, 5]).format('DDDo'), '5.', '5.');
        assert.equal(moment([2011, 0, 6]).format('DDDo'), '6.', '6.');
        assert.equal(moment([2011, 0, 7]).format('DDDo'), '7.', '7.');
        assert.equal(moment([2011, 0, 8]).format('DDDo'), '8.', '8.');
        assert.equal(moment([2011, 0, 9]).format('DDDo'), '9.', '9.');
        assert.equal(moment([2011, 0, 10]).format('DDDo'), '10.', '10.');

        assert.equal(moment([2011, 0, 11]).format('DDDo'), '11.', '11.');
        assert.equal(moment([2011, 0, 12]).format('DDDo'), '12.', '12.');
        assert.equal(moment([2011, 0, 13]).format('DDDo'), '13.', '13.');
        assert.equal(moment([2011, 0, 14]).format('DDDo'), '14.', '14.');
        assert.equal(moment([2011, 0, 15]).format('DDDo'), '15.', '15.');
        assert.equal(moment([2011, 0, 16]).format('DDDo'), '16.', '16.');
        assert.equal(moment([2011, 0, 17]).format('DDDo'), '17.', '17.');
        assert.equal(moment([2011, 0, 18]).format('DDDo'), '18.', '18.');
        assert.equal(moment([2011, 0, 19]).format('DDDo'), '19.', '19.');
        assert.equal(moment([2011, 0, 20]).format('DDDo'), '20.', '20.');

        assert.equal(moment([2011, 0, 21]).format('DDDo'), '21.', '21.');
        assert.equal(moment([2011, 0, 22]).format('DDDo'), '22.', '22.');
        assert.equal(moment([2011, 0, 23]).format('DDDo'), '23.', '23.');
        assert.equal(moment([2011, 0, 24]).format('DDDo'), '24.', '24.');
        assert.equal(moment([2011, 0, 25]).format('DDDo'), '25.', '25.');
        assert.equal(moment([2011, 0, 26]).format('DDDo'), '26.', '26.');
        assert.equal(moment([2011, 0, 27]).format('DDDo'), '27.', '27.');
        assert.equal(moment([2011, 0, 28]).format('DDDo'), '28.', '28.');
        assert.equal(moment([2011, 0, 29]).format('DDDo'), '29.', '29.');
        assert.equal(moment([2011, 0, 30]).format('DDDo'), '30.', '30.');

        assert.equal(moment([2011, 0, 31]).format('DDDo'), '31.', '31.');
    });

    test('format month', function (assert) {
        var expected = 'januar jan._februar feb._mart mar._april apr._maj maj_jun jun_jul jul_avgust avg._septembar sep._oktobar okt._novembar nov._decembar dec.'.split('_'),
            i;
        for (i = 0; i < expected.length; i++) {
            assert.equal(moment([2011, i, 1]).format('MMMM MMM'), expected[i], expected[i]);
        }
    });

    test('format week', function (assert) {
        var expected = 'nedelja ned. ne_ponedeljak pon. po_utorak uto. ut_sreda sre. sr_Äetvrtak Äet. Äe_petak pet. pe_subota sub. su'.split('_'),
            i;
        for (i = 0; i < expected.length; i++) {
            assert.equal(moment([2011, 0, 2 + i]).format('dddd ddd dd'), expected[i], expected[i]);
        }
    });

    test('from', function (assert) {
        var start = moment([2007, 1, 28]);
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 44}), true),  'nekoliko sekundi', '44 seconds = a few seconds');
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 45}), true),  'jedan minut',   '45 seconds = a minute');
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 89}), true),  'jedan minut',   '89 seconds = a minute');
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 90}), true),  '2 minute',     '90 seconds = 2 minutes');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 44}), true),  '44 minuta',     '44 minutes = 44 minutes');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 45}), true),  'jedan sat',      '45 minutes = an hour');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 89}), true),  'jedan sat',      '89 minutes = an hour');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 90}), true),  '2 sata',        '90 minutes = 2 hours');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 5}), true),   '5 sati',         '5 hours = 5 hours');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 21}), true),  '21 sati',        '21 hours = 21 hours');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 22}), true),  'dan',       '22 hours = a day');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 35}), true),  'dan',       '35 hours = a day');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 36}), true),  '2 dana',        '36 hours = 2 days');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 1}), true),   'dan',       '1 day = a day');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 5}), true),   '5 dana',        '5 days = 5 days');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 25}), true),  '25 dana',       '25 days = 25 days');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 26}), true),  'mesec',     '26 days = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 30}), true),  'mesec',     '30 days = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 43}), true),  'mesec',     '43 days = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 46}), true),  '2 meseca',     '46 days = 2 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 74}), true),  '2 meseca',     '75 days = 2 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 76}), true),  '3 meseca',     '76 days = 3 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({M: 1}), true),   'mesec',     '1 month = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({M: 5}), true),   '5 meseci',    '5 months = 5 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 345}), true), 'godinu',     '345 days = a year');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 548}), true), '2 godine',       '548 days = 2 years');
        assert.equal(start.from(moment([2007, 1, 28]).add({y: 1}), true),   'godinu',     '1 year = a year');
        assert.equal(start.from(moment([2007, 1, 28]).add({y: 5}), true),   '5 godina',        '5 years = 5 years');
    });

    test('suffix', function (assert) {
        assert.equal(moment(30000).from(0), 'za nekoliko sekundi',  'prefix');
        assert.equal(moment(0).from(30000), 'pre nekoliko sekundi', 'prefix');
    });

    test('now from now', function (assert) {
        assert.equal(moment().fromNow(), 'pre nekoliko sekundi',  'now from now should display as in the past');
    });

    test('fromNow', function (assert) {
        assert.equal(moment().add({s: 30}).fromNow(), 'za nekoliko sekundi', 'in a few seconds');
        assert.equal(moment().add({d: 5}).fromNow(), 'za 5 dana', 'in 5 days');
    });

    test('calendar day', function (assert) {
        var a = moment().hours(12).minutes(0).seconds(0);

        assert.equal(moment(a).calendar(),                   'danas u 12:00',  'today at the same time');
        assert.equal(moment(a).add({m: 25}).calendar(),      'danas u 12:25',  'Now plus 25 min');
        assert.equal(moment(a).add({h: 1}).calendar(),       'danas u 13:00',  'Now plus 1 hour');
        assert.equal(moment(a).add({d: 1}).calendar(),       'sutra u 12:00',  'tomorrow at the same time');
        assert.equal(moment(a).subtract({h: 1}).calendar(),  'danas u 11:00',  'Now minus 1 hour');
        assert.equal(moment(a).subtract({d: 1}).calendar(),  'juÄe u 12:00',   'yesterday at the same time');
    });

    test('calendar next week', function (assert) {
        var i, m;

        function makeFormat(d) {
            switch (d.day()) {
            case 0:
                return '[u] [nedelju] [u] LT';
            case 3:
                return '[u] [sredu] [u] LT';
            case 6:
                return '[u] [subotu] [u] LT';
            case 1:
            case 2:
            case 4:
            case 5:
                return '[u] dddd [u] LT';
            }
        }

        for (i = 2; i < 7; i++) {
            m = moment().add({d: i});
            assert.equal(m.calendar(),       m.format(makeFormat(m)),  'Today + ' + i + ' days current time');
            m.hours(0).minutes(0).seconds(0).milliseconds(0);
            assert.equal(m.calendar(),       m.format(makeFormat(m)),  'Today + ' + i + ' days beginning of day');
            m.hours(23).minutes(59).seconds(59).milliseconds(999);
            assert.equal(m.calendar(),       m.format(makeFormat(m)),  'Today + ' + i + ' days end of day');
        }
    });

    test('calendar last week', function (assert) {
        var i, m;

        function makeFormat(d) {
            var lastWeekDay = [
                    '[proÅ¡le] [nedelje] [u] LT',
                    '[proÅ¡log] [ponedeljka] [u] LT',
                    '[proÅ¡log] [utorka] [u] LT',
                    '[proÅ¡le] [srede] [u] LT',
                    '[proÅ¡log] [Äetvrtka] [u] LT',
                    '[proÅ¡log] [petka] [u] LT',
                    '[proÅ¡le] [subote] [u] LT'
                ];

            return lastWeekDay[d.day()];
        }

        for (i = 2; i < 7; i++) {
            m = moment().subtract({d: i});
            assert.equal(m.calendar(),       m.format(makeFormat(m)),  'Today - ' + i + ' days current time');
            m.hours(0).minutes(0).seconds(0).milliseconds(0);
            assert.equal(m.calendar(),       m.format(makeFormat(m)),  'Today - ' + i + ' days beginning of day');
            m.hours(23).minutes(59).seconds(59).milliseconds(999);
            assert.equal(m.calendar(),       m.format(makeFormat(m)),  'Today - ' + i + ' days end of day');
        }
    });

    test('calendar all else', function (assert) {
        var weeksAgo = moment().subtract({w: 1}),
            weeksFromNow = moment().add({w: 1});

        assert.equal(weeksAgo.calendar(),       weeksAgo.format('L'),  '1 week ago');
        assert.equal(weeksFromNow.calendar(),   weeksFromNow.format('L'),  'in 1 week');

        weeksAgo = moment().subtract({w: 2});
        weeksFromNow = moment().add({w: 2});

        assert.equal(weeksAgo.calendar(),       weeksAgo.format('L'),  '2 weeks ago');
        assert.equal(weeksFromNow.calendar(),   weeksFromNow.format('L'),  'in 2 weeks');
    });

    test('weeks year starting sunday formatted', function (assert) {
        assert.equal(moment([2011, 11, 26]).format('w ww wo'), '1 01 1.', 'Dec 26 2011 should be week 1');
        assert.equal(moment([2012,  0,  1]).format('w ww wo'), '1 01 1.', 'Jan  1 2012 should be week 1');
        assert.equal(moment([2012,  0,  2]).format('w ww wo'), '2 02 2.', 'Jan  2 2012 should be week 2');
        assert.equal(moment([2012,  0,  8]).format('w ww wo'), '2 02 2.', 'Jan  8 2012 should be week 2');
        assert.equal(moment([2012,  0,  9]).format('w ww wo'), '3 03 3.', 'Jan  9 2012 should be week 3');
    });

}));

;(function (global, factory) {
   typeof exports === 'object' && typeof module !== 'undefined'
       && typeof require === 'function' ? factory(require('../../moment')) :
   typeof define === 'function' && define.amd ? define(['../../moment'], factory) :
   factory(global.moment)
}(this, function (moment) { 'use strict';

    function each(array, callback) {
        var i;
        for (i = 0; i < array.length; i++) {
            callback(array[i], i, array);
        }
    }

    function objectKeys(obj) {
        if (Object.keys) {
            return Object.keys(obj);
        } else {
            // IE8
            var res = [], i;
            for (i in obj) {
                if (obj.hasOwnProperty(i)) {
                    res.push(i);
                }
            }
            return res;
        }
    }

    // Pick the first defined of two or three arguments.
    function defaults(a, b, c) {
        if (a != null) {
            return a;
        }
        if (b != null) {
            return b;
        }
        return c;
    }

    function defineCommonLocaleTests(locale, options) {
        test('lenient ordinal parsing', function (assert) {
            var i, ordinalStr, testMoment;
            for (i = 1; i <= 31; ++i) {
                ordinalStr = moment([2014, 0, i]).format('YYYY MM Do');
                testMoment = moment(ordinalStr, 'YYYY MM Do');
                assert.equal(testMoment.year(), 2014,
                        'lenient ordinal parsing ' + i + ' year check');
                assert.equal(testMoment.month(), 0,
                        'lenient ordinal parsing ' + i + ' month check');
                assert.equal(testMoment.date(), i,
                        'lenient ordinal parsing ' + i + ' date check');
            }
        });

        test('lenient ordinal parsing of number', function (assert) {
            var i, testMoment;
            for (i = 1; i <= 31; ++i) {
                testMoment = moment('2014 01 ' + i, 'YYYY MM Do');
                assert.equal(testMoment.year(), 2014,
                        'lenient ordinal parsing of number ' + i + ' year check');
                assert.equal(testMoment.month(), 0,
                        'lenient ordinal parsing of number ' + i + ' month check');
                assert.equal(testMoment.date(), i,
                        'lenient ordinal parsing of number ' + i + ' date check');
            }
        });

        test('strict ordinal parsing', function (assert) {
            var i, ordinalStr, testMoment;
            for (i = 1; i <= 31; ++i) {
                ordinalStr = moment([2014, 0, i]).format('YYYY MM Do');
                testMoment = moment(ordinalStr, 'YYYY MM Do', true);
                assert.ok(testMoment.isValid(), 'strict ordinal parsing ' + i);
            }
        });

        test('meridiem invariant', function (assert) {
            var h, m, t1, t2;
            for (h = 0; h < 24; ++h) {
                for (m = 0; m < 60; m += 15) {
                    t1 = moment.utc([2000, 0, 1, h, m]);
                    t2 = moment.utc(t1.format('A h:mm'), 'A h:mm');
                    assert.equal(t2.format('HH:mm'), t1.format('HH:mm'),
                            'meridiem at ' + t1.format('HH:mm'));
                }
            }
        });

        test('date format correctness', function (assert) {
            var data, tokens;
            data = moment.localeData()._longDateFormat;
            tokens = objectKeys(data);
            each(tokens, function (srchToken) {
                // Check each format string to make sure it does not contain any
                // tokens that need to be expanded.
                each(tokens, function (baseToken) {
                    // strip escaped sequences
                    var format = data[baseToken].replace(/(\[[^\]]*\])/g, '');
                    assert.equal(false, !!~format.indexOf(srchToken),
                            'contains ' + srchToken + ' in ' + baseToken);
                });
            });
        });

        test('month parsing correctness', function (assert) {
            var i, m;

            if (locale === 'tr') {
                // I can't fix it :(
                expect(0);
                return;
            }
            function tester(format) {
                var r;
                r = moment(m.format(format), format);
                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format);
                r = moment(m.format(format).toLocaleUpperCase(), format);
                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' upper');
                r = moment(m.format(format).toLocaleLowerCase(), format);
                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' lower');

                r = moment(m.format(format), format, true);
                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' strict');
                r = moment(m.format(format).toLocaleUpperCase(), format, true);
                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' upper strict');
                r = moment(m.format(format).toLocaleLowerCase(), format, true);
                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' lower strict');
            }

            for (i = 0; i < 12; ++i) {
                m = moment([2015, i, 15, 18]);
                tester('MMM');
                tester('MMM.');
                tester('MMMM');
                tester('MMMM.');
            }
        });

        test('weekday parsing correctness', function (assert) {
            var i, m;

            if (locale === 'tr' || locale === 'az') {
                // There is a lower-case letter (Ä±), that converted to upper then
                // lower changes to i
                expect(0);
                return;
            }
            function tester(format) {
                var r, baseMsg = 'weekday ' + m.weekday() + ' fmt ' + format;
                r = moment(m.format(format), format);
                assert.equal(r.weekday(), m.weekday(), baseMsg);
                r = moment(m.format(format).toLocaleUpperCase(), format);
                assert.equal(r.weekday(), m.weekday(), baseMsg + ' upper');
                r = moment(m.format(format).toLocaleLowerCase(), format);
                assert.equal(r.weekday(), m.weekday(), baseMsg + ' lower');

                r = moment(m.format(format), format, true);
                assert.equal(r.weekday(), m.weekday(), baseMsg + ' strict');
                r = moment(m.format(format).toLocaleUpperCase(), format, true);
                assert.equal(r.weekday(), m.weekday(), baseMsg + ' upper strict');
                r = moment(m.format(format).toLocaleLowerCase(), format, true);
                assert.equal(r.weekday(), m.weekday(), baseMsg + ' lower strict');
            }

            for (i = 0; i < 7; ++i) {
                m = moment.utc([2015, i, 15, 18]);
                tester('dd');
                tester('ddd');
                tester('dddd');
            }
        });
    }

    function setupDeprecationHandler(test, moment, scope) {
        test._expectedDeprecations = null;
        test._observedDeprecations = null;
        test._oldSupress = moment.suppressDeprecationWarnings;
        moment.suppressDeprecationWarnings = true;
        test.expectedDeprecations = function () {
            test._expectedDeprecations = arguments;
            test._observedDeprecations = [];
        };
        moment.deprecationHandler = function (name, msg) {
            var deprecationId = matchedDeprecation(name, msg, test._expectedDeprecations);
            if (deprecationId === -1) {
                throw new Error('Unexpected deprecation thrown name=' +
                        name + ' msg=' + msg);
            }
            test._observedDeprecations[deprecationId] = 1;
        };
    }

    function teardownDeprecationHandler(test, moment, scope) {
        moment.suppressDeprecationWarnings = test._oldSupress;

        if (test._expectedDeprecations != null) {
            var missedDeprecations = [];
            each(test._expectedDeprecations, function (deprecationPattern, id) {
                if (test._observedDeprecations[id] !== 1) {
                    missedDeprecations.push(deprecationPattern);
                }
            });
            if (missedDeprecations.length !== 0) {
                throw new Error('Expected deprecation warnings did not happen: ' +
                        missedDeprecations.join(' '));
            }
        }
    }

    function matchedDeprecation(name, msg, deprecations) {
        if (deprecations == null) {
            return -1;
        }
        for (var i = 0; i < deprecations.length; ++i) {
            if (name != null && name === deprecations[i]) {
                return i;
            }
            if (msg != null && msg.substring(0, deprecations[i].length) === deprecations[i]) {
                return i;
            }
        }
        return -1;
    }

    /*global QUnit:false*/

    var test = QUnit.test;

    var expect = QUnit.expect;

    function module (name, lifecycle) {
        QUnit.module(name, {
            setup : function () {
                moment.locale('en');
                moment.createFromInputFallback = function (config) {
                    throw new Error('input not handled by moment: ' + config._i);
                };
                setupDeprecationHandler(test, moment, 'core');
                if (lifecycle && lifecycle.setup) {
                    lifecycle.setup();
                }
            },
            teardown : function () {
                teardownDeprecationHandler(test, moment, 'core');
                if (lifecycle && lifecycle.teardown) {
                    lifecycle.teardown();
                }
            }
        });
    }

    function localeModule (name, lifecycle) {
        QUnit.module('locale:' + name, {
            setup : function () {
                moment.locale(name);
                moment.createFromInputFallback = function (config) {
                    throw new Error('input not handled by moment: ' + config._i);
                };
                setupDeprecationHandler(test, moment, 'locale');
                if (lifecycle && lifecycle.setup) {
                    lifecycle.setup();
                }
            },
            teardown : function () {
                moment.locale('en');
                teardownDeprecationHandler(test, moment, 'locale');
                if (lifecycle && lifecycle.teardown) {
                    lifecycle.teardown();
                }
            }
        });
        defineCommonLocaleTests(name, -1, -1);
    }

    localeModule('ss');

    test('parse', function (assert) {
        var tests = "Bhimbidvwane Bhi_Indlovana Ina_Indlov'lenkhulu Inu_Mabasa Mab_Inkhwekhweti Ink_Inhlaba Inh_Kholwane Kho_Ingci Igc_Inyoni Iny_Imphala Imp_Lweti lwe_Ingongoni Igo".split('_'), i;
        function equalTest(input, mmm, i) {
            assert.equal(moment(input, mmm).month(), i, input + ' should be month ' + (i + 1));
        }
        for (i = 0; i < 12; i++) {
            tests[i] = tests[i].split(' ');
            equalTest(tests[i][0], 'MMM', i);
            equalTest(tests[i][1], 'MMM', i);
            equalTest(tests[i][0], 'MMMM', i);
            equalTest(tests[i][1], 'MMMM', i);
            equalTest(tests[i][0].toLocaleLowerCase(), 'MMMM', i);
            equalTest(tests[i][1].toLocaleLowerCase(), 'MMMM', i);
            equalTest(tests[i][0].toLocaleUpperCase(), 'MMMM', i);
            equalTest(tests[i][1].toLocaleUpperCase(), 'MMMM', i);
        }
    });

    test('parse meridiem', function (assert) {
        var i,
            b = moment(),
            meridiemTests = [
                // h a patterns, expected hours, isValid
                ['10 ekuseni',   10, true],
                ['11 emini',   11, true],
                ['3 entsambama',   15, true],
                ['4 entsambama',   16, true],
                ['6 entsambama',   18, true],
                ['7 ebusuku',   19, true],
                ['12 ebusuku',   0, true],
                ['10 am',   10, false],
                ['10 pm',   10, false]
            ],
            parsed;

        // test that a formatted moment including meridiem string can be parsed back to the same moment
        assert.ok(b.isSame(moment(b.format('h:mm:ss a'), 'h:mm:ss a', 'ss', true), 'seconds'), b.format('h:mm:ss a') + ' should be equal to ' + moment(b.format('h:mm:ss a'), 'h:mm:ss a', 'ss', true).format('h:mm:ss a'));

        // test that a formatted moment having a meridiem string can be parsed with strict flag
        assert.ok(moment(b.format('h:mm:ss a'), 'h:mm:ss a', 'ss', true).isValid(), b.format('h:mm:ss a') + ' should be parsed as valid');

        for (i = 0; i < meridiemTests.length; i++) {
            parsed = moment(meridiemTests[i][0], 'h a', 'ss', true);
            assert.equal(parsed.isValid(), meridiemTests[i][2], 'validity for ' + meridiemTests[i][0]);
            if (parsed.isValid()) {
                assert.equal(parsed.hours(), meridiemTests[i][1], 'hours for ' + meridiemTests[i][0]);
            }
        }
    });

    test('format', function (assert) {
        var a = [
                ['dddd, MMMM Do YYYY, h:mm:ss a',      'Lisontfo, Indlovana 14 2010, 3:25:50 entsambama'],
                ['ddd, h A',                            'Lis, 3 entsambama'],
                ['M Mo MM MMMM MMM',                   '2 2 02 Indlovana Ina'],
                ['YYYY YY',                            '2010 10'],
                ['D Do DD',                            '14 14 14'],
                ['d do dddd ddd dd',                   '0 0 Lisontfo Lis Li'],
                ['DDD DDDo DDDD',                      '45 45 045'],
                ['w wo ww',                            '6 6 06'],
                ['h hh',                               '3 03'],
                ['H HH',                               '15 15'],
                ['m mm',                               '25 25'],
                ['s ss',                               '50 50'],
                ['a A',                                'entsambama entsambama'],
                ['[Lilanga] DDDo [lilanga lelinyaka]', 'Lilanga 45 lilanga lelinyaka'],
                ['LTS',                                '3:25:50 entsambama'],
                ['L',                                  '14/02/2010'],
                ['LL',                                 '14 Indlovana 2010'],
                ['LLL',                                '14 Indlovana 2010 3:25 entsambama'],
                ['LLLL',                               'Lisontfo, 14 Indlovana 2010 3:25 entsambama'],
                ['l',                                  '14/2/2010'],
                ['ll',                                 '14 Ina 2010'],
                ['lll',                                '14 Ina 2010 3:25 entsambama'],
                ['llll',                               'Lis, 14 Ina 2010 3:25 entsambama']
            ],
            b = moment(new Date(2010, 1, 14, 15, 25, 50, 125)),
            i;
        for (i = 0; i < a.length; i++) {
            assert.equal(b.format(a[i][0]), a[i][1], a[i][0] + ' ---> ' + a[i][1]);
        }
    });

    test('format ordinal', function (assert) {
        assert.equal(moment([2011, 0, 1]).format('DDDo'), '1', '1');
        assert.equal(moment([2011, 0, 2]).format('DDDo'), '2', '2');
        assert.equal(moment([2011, 0, 3]).format('DDDo'), '3', '3');
        assert.equal(moment([2011, 0, 4]).format('DDDo'), '4', '4');
        assert.equal(moment([2011, 0, 5]).format('DDDo'), '5', '5');
        assert.equal(moment([2011, 0, 6]).format('DDDo'), '6', '6');
        assert.equal(moment([2011, 0, 7]).format('DDDo'), '7', '7');
        assert.equal(moment([2011, 0, 8]).format('DDDo'), '8', '8');
        assert.equal(moment([2011, 0, 9]).format('DDDo'), '9', '9');
        assert.equal(moment([2011, 0, 10]).format('DDDo'), '10', '10');

        assert.equal(moment([2011, 0, 11]).format('DDDo'), '11', '11');
        assert.equal(moment([2011, 0, 12]).format('DDDo'), '12', '12');
        assert.equal(moment([2011, 0, 13]).format('DDDo'), '13', '13');
        assert.equal(moment([2011, 0, 14]).format('DDDo'), '14', '14');
        assert.equal(moment([2011, 0, 15]).format('DDDo'), '15', '15');
        assert.equal(moment([2011, 0, 16]).format('DDDo'), '16', '16');
        assert.equal(moment([2011, 0, 17]).format('DDDo'), '17', '17');
        assert.equal(moment([2011, 0, 18]).format('DDDo'), '18', '18');
        assert.equal(moment([2011, 0, 19]).format('DDDo'), '19', '19');
        assert.equal(moment([2011, 0, 20]).format('DDDo'), '20', '20');

        assert.equal(moment([2011, 0, 21]).format('DDDo'), '21', '21');
        assert.equal(moment([2011, 0, 22]).format('DDDo'), '22', '22');
        assert.equal(moment([2011, 0, 23]).format('DDDo'), '23', '23');
        assert.equal(moment([2011, 0, 24]).format('DDDo'), '24', '24');
        assert.equal(moment([2011, 0, 25]).format('DDDo'), '25', '25');
        assert.equal(moment([2011, 0, 26]).format('DDDo'), '26', '26');
        assert.equal(moment([2011, 0, 27]).format('DDDo'), '27', '27');
        assert.equal(moment([2011, 0, 28]).format('DDDo'), '28', '28');
        assert.equal(moment([2011, 0, 29]).format('DDDo'), '29', '29');
        assert.equal(moment([2011, 0, 30]).format('DDDo'), '30', '30');

        assert.equal(moment([2011, 0, 31]).format('DDDo'), '31', '31');
    });

    test('format month', function (assert) {
        var expected = "Bhimbidvwane Bhi_Indlovana Ina_Indlov'lenkhulu Inu_Mabasa Mab_Inkhwekhweti Ink_Inhlaba Inh_Kholwane Kho_Ingci Igc_Inyoni Iny_Imphala Imp_Lweti Lwe_Ingongoni Igo".split('_'), i;
        for (i = 0; i < expected.length; i++) {
            assert.equal(moment([2011, i, 1]).format('MMMM MMM'), expected[i], expected[i]);
        }
    });

    test('format week', function (assert) {
        var expected = 'Lisontfo Lis Li_Umsombuluko Umb Us_Lesibili Lsb Lb_Lesitsatfu Les Lt_Lesine Lsi Ls_Lesihlanu Lsh Lh_Umgcibelo Umg Ug'.split('_'), i;
        for (i = 0; i < expected.length; i++) {
            assert.equal(moment([2011, 0, 2 + i]).format('dddd ddd dd'), expected[i], expected[i]);
        }
    });

    test('from', function (assert) {
        var start = moment([2007, 1, 28]);
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 44}), true),  'emizuzwana lomcane', '44 seconds = a few seconds');
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 45}), true),  'umzuzu',      '45 seconds = a minute');
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 89}), true),  'umzuzu',      '89 seconds = a minute');
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 90}), true),  '2 emizuzu',     '90 seconds = 2 minutes');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 44}), true),  '44 emizuzu',    '44 minutes = 44 minutes');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 45}), true),  'lihora',       '45 minutes = an hour');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 89}), true),  'lihora',       '89 minutes = an hour');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 90}), true),  '2 emahora',       '90 minutes = 2 hours');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 5}), true),   '5 emahora',       '5 hours = 5 hours');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 21}), true),  '21 emahora',      '21 hours = 21 hours');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 22}), true),  'lilanga',         '22 hours = a day');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 35}), true),  'lilanga',         '35 hours = a day');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 36}), true),  '2 emalanga',        '36 hours = 2 days');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 1}), true),   'lilanga',         '1 day = a day');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 5}), true),   '5 emalanga',        '5 days = 5 days');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 25}), true),  '25 emalanga',       '25 days = 25 days');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 26}), true),  'inyanga',       '26 days = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 30}), true),  'inyanga',       '30 days = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 43}), true),  'inyanga',       '43 days = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 46}), true),  '2 tinyanga',      '46 days = 2 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 74}), true),  '2 tinyanga',      '75 days = 2 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 76}), true),  '3 tinyanga',      '76 days = 3 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({M: 1}), true),   'inyanga',       '1 month = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({M: 5}), true),   '5 tinyanga',      '5 months = 5 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 345}), true), 'umnyaka',        '345 days = a year');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 548}), true), '2 iminyaka',       '548 days = 2 years');
        assert.equal(start.from(moment([2007, 1, 28]).add({y: 1}), true),   'umnyaka',        '1 year = a year');
        assert.equal(start.from(moment([2007, 1, 28]).add({y: 5}), true),   '5 iminyaka',       '5 years = 5 years');
    });

    test('suffix', function (assert) {
        assert.equal(moment(30000).from(0), 'nga emizuzwana lomcane',  'prefix');
        assert.equal(moment(0).from(30000), 'wenteka nga emizuzwana lomcane', 'suffix');
    });

    test('now from now', function (assert) {
        assert.equal(moment().fromNow(), 'wenteka nga emizuzwana lomcane',  'now from now should display as in the past');
    });

    test('fromNow', function (assert) {
        assert.equal(moment().add({s: 30}).fromNow(), 'nga emizuzwana lomcane', 'in a few seconds');
        assert.equal(moment().add({d: 5}).fromNow(), 'nga 5 emalanga', 'in 5 days');
    });

    test('calendar day', function (assert) {
        var a = moment().hours(12).minutes(0).seconds(0);

        assert.equal(moment(a).calendar(),                   'Namuhla nga 12:00 emini',      'Today at the same time');
        assert.equal(moment(a).add({m: 25}).calendar(),      'Namuhla nga 12:25 emini',      'Now plus 25 min');
        assert.equal(moment(a).add({h: 1}).calendar(),       'Namuhla nga 1:00 emini',      'Now plus 1 hour');
        assert.equal(moment(a).add({d: 1}).calendar(),       'Kusasa nga 12:00 emini',   'tomorrow at the same time');
        assert.equal(moment(a).subtract({h: 1}).calendar(),  'Namuhla nga 11:00 emini',      'Now minus 1 hour');
        assert.equal(moment(a).subtract({d: 1}).calendar(),  'Itolo nga 12:00 emini',  'yesterday at the same time');
    });

    test('calendar next week', function (assert) {
        var i, m;
        for (i = 2; i < 7; i++) {
            m = moment().add({d: i});
            assert.equal(m.calendar(),       m.format('dddd [nga] LT'),  'Today + ' + i + ' days current time');
            m.hours(0).minutes(0).seconds(0).milliseconds(0);
            assert.equal(m.calendar(),       m.format('dddd [nga] LT'),  'Today + ' + i + ' days beginning of day');
            m.hours(23).minutes(59).seconds(59).milliseconds(999);
            assert.equal(m.calendar(),       m.format('dddd [nga] LT'),  'Today + ' + i + ' days end of day');
        }
    });

    test('calendar last week', function (assert) {
        var i, m;

        for (i = 2; i < 7; i++) {
            m = moment().subtract({d: i});
            assert.equal(m.calendar(),       m.format('dddd [leliphelile] [nga] LT'),  'Today - ' + i + ' days current time');
            m.hours(0).minutes(0).seconds(0).milliseconds(0);
            assert.equal(m.calendar(),       m.format('dddd [leliphelile] [nga] LT'),  'Today - ' + i + ' days beginning of day');
            m.hours(23).minutes(59).seconds(59).milliseconds(999);
            assert.equal(m.calendar(),       m.format('dddd [leliphelile] [nga] LT'),  'Today - ' + i + ' days end of day');
        }
    });

    test('calendar all else', function (assert) {
        var weeksAgo = moment().subtract({w: 1}),
            weeksFromNow = moment().add({w: 1});

        assert.equal(weeksAgo.calendar(),       weeksAgo.format('L'),  '1 week ago');
        assert.equal(weeksFromNow.calendar(),   weeksFromNow.format('L'),  'in 1 week');

        weeksAgo = moment().subtract({w: 2});
        weeksFromNow = moment().add({w: 2});

        assert.equal(weeksAgo.calendar(),       weeksAgo.format('L'),  '2 weeks ago');
        assert.equal(weeksFromNow.calendar(),   weeksFromNow.format('L'),  'in 2 weeks');
    });

    test('weeks year starting sunday formatted', function (assert) {
        assert.equal(moment([2012, 0,  1]).format('w ww wo'), '52 52 52', 'Jan  1 2012 should be week 52');
        assert.equal(moment([2012, 0,  2]).format('w ww wo'),   '1 01 1', 'Jan  4 2012 should be week 1');
        assert.equal(moment([2012, 0,  8]).format('w ww wo'),   '1 01 1', 'Jan  8 2012 should be week 1');
        assert.equal(moment([2012, 0,  9]).format('w ww wo'),   '2 02 2', 'Jan  9 2012 should be week 2');
        assert.equal(moment([2012, 0, 15]).format('w ww wo'),   '2 02 2', 'Jan 15 2012 should be week 2');
    });

}));

;(function (global, factory) {
   typeof exports === 'object' && typeof module !== 'undefined'
       && typeof require === 'function' ? factory(require('../../moment')) :
   typeof define === 'function' && define.amd ? define(['../../moment'], factory) :
   factory(global.moment)
}(this, function (moment) { 'use strict';

    function each(array, callback) {
        var i;
        for (i = 0; i < array.length; i++) {
            callback(array[i], i, array);
        }
    }

    function objectKeys(obj) {
        if (Object.keys) {
            return Object.keys(obj);
        } else {
            // IE8
            var res = [], i;
            for (i in obj) {
                if (obj.hasOwnProperty(i)) {
                    res.push(i);
                }
            }
            return res;
        }
    }

    // Pick the first defined of two or three arguments.
    function defaults(a, b, c) {
        if (a != null) {
            return a;
        }
        if (b != null) {
            return b;
        }
        return c;
    }

    function defineCommonLocaleTests(locale, options) {
        test('lenient ordinal parsing', function (assert) {
            var i, ordinalStr, testMoment;
            for (i = 1; i <= 31; ++i) {
                ordinalStr = moment([2014, 0, i]).format('YYYY MM Do');
                testMoment = moment(ordinalStr, 'YYYY MM Do');
                assert.equal(testMoment.year(), 2014,
                        'lenient ordinal parsing ' + i + ' year check');
                assert.equal(testMoment.month(), 0,
                        'lenient ordinal parsing ' + i + ' month check');
                assert.equal(testMoment.date(), i,
                        'lenient ordinal parsing ' + i + ' date check');
            }
        });

        test('lenient ordinal parsing of number', function (assert) {
            var i, testMoment;
            for (i = 1; i <= 31; ++i) {
                testMoment = moment('2014 01 ' + i, 'YYYY MM Do');
                assert.equal(testMoment.year(), 2014,
                        'lenient ordinal parsing of number ' + i + ' year check');
                assert.equal(testMoment.month(), 0,
                        'lenient ordinal parsing of number ' + i + ' month check');
                assert.equal(testMoment.date(), i,
                        'lenient ordinal parsing of number ' + i + ' date check');
            }
        });

        test('strict ordinal parsing', function (assert) {
            var i, ordinalStr, testMoment;
            for (i = 1; i <= 31; ++i) {
                ordinalStr = moment([2014, 0, i]).format('YYYY MM Do');
                testMoment = moment(ordinalStr, 'YYYY MM Do', true);
                assert.ok(testMoment.isValid(), 'strict ordinal parsing ' + i);
            }
        });

        test('meridiem invariant', function (assert) {
            var h, m, t1, t2;
            for (h = 0; h < 24; ++h) {
                for (m = 0; m < 60; m += 15) {
                    t1 = moment.utc([2000, 0, 1, h, m]);
                    t2 = moment.utc(t1.format('A h:mm'), 'A h:mm');
                    assert.equal(t2.format('HH:mm'), t1.format('HH:mm'),
                            'meridiem at ' + t1.format('HH:mm'));
                }
            }
        });

        test('date format correctness', function (assert) {
            var data, tokens;
            data = moment.localeData()._longDateFormat;
            tokens = objectKeys(data);
            each(tokens, function (srchToken) {
                // Check each format string to make sure it does not contain any
                // tokens that need to be expanded.
                each(tokens, function (baseToken) {
                    // strip escaped sequences
                    var format = data[baseToken].replace(/(\[[^\]]*\])/g, '');
                    assert.equal(false, !!~format.indexOf(srchToken),
                            'contains ' + srchToken + ' in ' + baseToken);
                });
            });
        });

        test('month parsing correctness', function (assert) {
            var i, m;

            if (locale === 'tr') {
                // I can't fix it :(
                expect(0);
                return;
            }
            function tester(format) {
                var r;
                r = moment(m.format(format), format);
                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format);
                r = moment(m.format(format).toLocaleUpperCase(), format);
                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' upper');
                r = moment(m.format(format).toLocaleLowerCase(), format);
                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' lower');

                r = moment(m.format(format), format, true);
                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' strict');
                r = moment(m.format(format).toLocaleUpperCase(), format, true);
                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' upper strict');
                r = moment(m.format(format).toLocaleLowerCase(), format, true);
                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' lower strict');
            }

            for (i = 0; i < 12; ++i) {
                m = moment([2015, i, 15, 18]);
                tester('MMM');
                tester('MMM.');
                tester('MMMM');
                tester('MMMM.');
            }
        });

        test('weekday parsing correctness', function (assert) {
            var i, m;

            if (locale === 'tr' || locale === 'az') {
                // There is a lower-case letter (Ä±), that converted to upper then
                // lower changes to i
                expect(0);
                return;
            }
            function tester(format) {
                var r, baseMsg = 'weekday ' + m.weekday() + ' fmt ' + format;
                r = moment(m.format(format), format);
                assert.equal(r.weekday(), m.weekday(), baseMsg);
                r = moment(m.format(format).toLocaleUpperCase(), format);
                assert.equal(r.weekday(), m.weekday(), baseMsg + ' upper');
                r = moment(m.format(format).toLocaleLowerCase(), format);
                assert.equal(r.weekday(), m.weekday(), baseMsg + ' lower');

                r = moment(m.format(format), format, true);
                assert.equal(r.weekday(), m.weekday(), baseMsg + ' strict');
                r = moment(m.format(format).toLocaleUpperCase(), format, true);
                assert.equal(r.weekday(), m.weekday(), baseMsg + ' upper strict');
                r = moment(m.format(format).toLocaleLowerCase(), format, true);
                assert.equal(r.weekday(), m.weekday(), baseMsg + ' lower strict');
            }

            for (i = 0; i < 7; ++i) {
                m = moment.utc([2015, i, 15, 18]);
                tester('dd');
                tester('ddd');
                tester('dddd');
            }
        });
    }

    function setupDeprecationHandler(test, moment, scope) {
        test._expectedDeprecations = null;
        test._observedDeprecations = null;
        test._oldSupress = moment.suppressDeprecationWarnings;
        moment.suppressDeprecationWarnings = true;
        test.expectedDeprecations = function () {
            test._expectedDeprecations = arguments;
            test._observedDeprecations = [];
        };
        moment.deprecationHandler = function (name, msg) {
            var deprecationId = matchedDeprecation(name, msg, test._expectedDeprecations);
            if (deprecationId === -1) {
                throw new Error('Unexpected deprecation thrown name=' +
                        name + ' msg=' + msg);
            }
            test._observedDeprecations[deprecationId] = 1;
        };
    }

    function teardownDeprecationHandler(test, moment, scope) {
        moment.suppressDeprecationWarnings = test._oldSupress;

        if (test._expectedDeprecations != null) {
            var missedDeprecations = [];
            each(test._expectedDeprecations, function (deprecationPattern, id) {
                if (test._observedDeprecations[id] !== 1) {
                    missedDeprecations.push(deprecationPattern);
                }
            });
            if (missedDeprecations.length !== 0) {
                throw new Error('Expected deprecation warnings did not happen: ' +
                        missedDeprecations.join(' '));
            }
        }
    }

    function matchedDeprecation(name, msg, deprecations) {
        if (deprecations == null) {
            return -1;
        }
        for (var i = 0; i < deprecations.length; ++i) {
            if (name != null && name === deprecations[i]) {
                return i;
            }
            if (msg != null && msg.substring(0, deprecations[i].length) === deprecations[i]) {
                return i;
            }
        }
        return -1;
    }

    /*global QUnit:false*/

    var test = QUnit.test;

    var expect = QUnit.expect;

    function module (name, lifecycle) {
        QUnit.module(name, {
            setup : function () {
                moment.locale('en');
                moment.createFromInputFallback = function (config) {
                    throw new Error('input not handled by moment: ' + config._i);
                };
                setupDeprecationHandler(test, moment, 'core');
                if (lifecycle && lifecycle.setup) {
                    lifecycle.setup();
                }
            },
            teardown : function () {
                teardownDeprecationHandler(test, moment, 'core');
                if (lifecycle && lifecycle.teardown) {
                    lifecycle.teardown();
                }
            }
        });
    }

    function localeModule (name, lifecycle) {
        QUnit.module('locale:' + name, {
            setup : function () {
                moment.locale(name);
                moment.createFromInputFallback = function (config) {
                    throw new Error('input not handled by moment: ' + config._i);
                };
                setupDeprecationHandler(test, moment, 'locale');
                if (lifecycle && lifecycle.setup) {
                    lifecycle.setup();
                }
            },
            teardown : function () {
                moment.locale('en');
                teardownDeprecationHandler(test, moment, 'locale');
                if (lifecycle && lifecycle.teardown) {
                    lifecycle.teardown();
                }
            }
        });
        defineCommonLocaleTests(name, -1, -1);
    }

    localeModule('sv');

    test('parse', function (assert) {
        var tests = 'januari jan_februari feb_mars mar_april apr_maj maj_juni jun_juli jul_augusti aug_september sep_oktober okt_november nov_december dec'.split('_'), i;
        function equalTest(input, mmm, i) {
            assert.equal(moment(input, mmm).month(), i, input + ' should be month ' + (i + 1));
        }
        for (i = 0; i < 12; i++) {
            tests[i] = tests[i].split(' ');
            equalTest(tests[i][0], 'MMM', i);
            equalTest(tests[i][1], 'MMM', i);
            equalTest(tests[i][0], 'MMMM', i);
            equalTest(tests[i][1], 'MMMM', i);
            equalTest(tests[i][0].toLocaleLowerCase(), 'MMMM', i);
            equalTest(tests[i][1].toLocaleLowerCase(), 'MMMM', i);
            equalTest(tests[i][0].toLocaleUpperCase(), 'MMMM', i);
            equalTest(tests[i][1].toLocaleUpperCase(), 'MMMM', i);
        }
    });

    test('format', function (assert) {
        var a = [
                ['dddd, MMMM Do YYYY, h:mm:ss a',      'sÃ¶ndag, februari 14e 2010, 3:25:50 pm'],
                ['ddd, hA',                            'sÃ¶n, 3PM'],
                ['M Mo MM MMMM MMM',                   '2 2a 02 februari feb'],
                ['YYYY YY',                            '2010 10'],
                ['D Do DD',                            '14 14e 14'],
                ['d do dddd ddd dd',                   '0 0e sÃ¶ndag sÃ¶n sÃ¶'],
                ['DDD DDDo DDDD',                      '45 45e 045'],
                ['w wo ww',                            '6 6e 06'],
                ['h hh',                               '3 03'],
                ['H HH',                               '15 15'],
                ['m mm',                               '25 25'],
                ['s ss',                               '50 50'],
                ['a A',                                'pm PM'],
                ['[the] DDDo [day of the year]',       'the 45e day of the year'],
                ['LTS',                                '15:25:50'],
                ['L',                                  '2010-02-14'],
                ['LL',                                 '14 februari 2010'],
                ['LLL',                                '14 februari 2010 kl. 15:25'],
                ['LLLL',                               'sÃ¶ndag 14 februari 2010 kl. 15:25'],
                ['l',                                  '2010-2-14'],
                ['ll',                                 '14 feb 2010'],
                ['lll',                                '14 feb 2010 15:25'],
                ['llll',                               'sÃ¶n 14 feb 2010 15:25']
            ],
            b = moment(new Date(2010, 1, 14, 15, 25, 50, 125)),
            i;
        for (i = 0; i < a.length; i++) {
            assert.equal(b.format(a[i][0]), a[i][1], a[i][0] + ' ---> ' + a[i][1]);
        }
    });

    test('format ordinal', function (assert) {
        assert.equal(moment([2011, 0, 1]).format('DDDo'), '1a', '1a');
        assert.equal(moment([2011, 0, 2]).format('DDDo'), '2a', '2a');
        assert.equal(moment([2011, 0, 3]).format('DDDo'), '3e', '3e');
        assert.equal(moment([2011, 0, 4]).format('DDDo'), '4e', '4e');
        assert.equal(moment([2011, 0, 5]).format('DDDo'), '5e', '5e');
        assert.equal(moment([2011, 0, 6]).format('DDDo'), '6e', '6e');
        assert.equal(moment([2011, 0, 7]).format('DDDo'), '7e', '7e');
        assert.equal(moment([2011, 0, 8]).format('DDDo'), '8e', '8e');
        assert.equal(moment([2011, 0, 9]).format('DDDo'), '9e', '9e');
        assert.equal(moment([2011, 0, 10]).format('DDDo'), '10e', '10e');

        assert.equal(moment([2011, 0, 11]).format('DDDo'), '11e', '11e');
        assert.equal(moment([2011, 0, 12]).format('DDDo'), '12e', '12e');
        assert.equal(moment([2011, 0, 13]).format('DDDo'), '13e', '13e');
        assert.equal(moment([2011, 0, 14]).format('DDDo'), '14e', '14e');
        assert.equal(moment([2011, 0, 15]).format('DDDo'), '15e', '15e');
        assert.equal(moment([2011, 0, 16]).format('DDDo'), '16e', '16e');
        assert.equal(moment([2011, 0, 17]).format('DDDo'), '17e', '17e');
        assert.equal(moment([2011, 0, 18]).format('DDDo'), '18e', '18e');
        assert.equal(moment([2011, 0, 19]).format('DDDo'), '19e', '19e');
        assert.equal(moment([2011, 0, 20]).format('DDDo'), '20e', '20e');

        assert.equal(moment([2011, 0, 21]).format('DDDo'), '21a', '21a');
        assert.equal(moment([2011, 0, 22]).format('DDDo'), '22a', '22a');
        assert.equal(moment([2011, 0, 23]).format('DDDo'), '23e', '23e');
        assert.equal(moment([2011, 0, 24]).format('DDDo'), '24e', '24e');
        assert.equal(moment([2011, 0, 25]).format('DDDo'), '25e', '25e');
        assert.equal(moment([2011, 0, 26]).format('DDDo'), '26e', '26e');
        assert.equal(moment([2011, 0, 27]).format('DDDo'), '27e', '27e');
        assert.equal(moment([2011, 0, 28]).format('DDDo'), '28e', '28e');
        assert.equal(moment([2011, 0, 29]).format('DDDo'), '29e', '29e');
        assert.equal(moment([2011, 0, 30]).format('DDDo'), '30e', '30e');

        assert.equal(moment([2011, 0, 31]).format('DDDo'), '31a', '31a');
    });

    test('format month', function (assert) {
        var expected = 'januari jan_februari feb_mars mar_april apr_maj maj_juni jun_juli jul_augusti aug_september sep_oktober okt_november nov_december dec'.split('_'), i;
        for (i = 0; i < expected.length; i++) {
            assert.equal(moment([2011, i, 1]).format('MMMM MMM'), expected[i], expected[i]);
        }
    });

    test('format week', function (assert) {
        var expected = 'sÃ¶ndag sÃ¶n sÃ¶_mÃ¥ndag mÃ¥n mÃ¥_tisdag tis ti_onsdag ons on_torsdag tor to_fredag fre fr_lÃ¶rdag lÃ¶r lÃ¶'.split('_'), i;
        for (i = 0; i < expected.length; i++) {
            assert.equal(moment([2011, 0, 2 + i]).format('dddd ddd dd'), expected[i], expected[i]);
        }
    });

    test('from', function (assert) {
        var start = moment([2007, 1, 28]);
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 44}), true),  'nÃ¥gra sekunder', '44 seconds = a few seconds');
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 45}), true),  'en minut',      '45 seconds = a minute');
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 89}), true),  'en minut',      '89 seconds = a minute');
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 90}), true),  '2 minuter',     '90 seconds = 2 minutes');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 44}), true),  '44 minuter',    '44 minutes = 44 minutes');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 45}), true),  'en timme',       '45 minutes = an hour');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 89}), true),  'en timme',       '89 minutes = an hour');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 90}), true),  '2 timmar',       '90 minutes = 2 hours');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 5}), true),   '5 timmar',       '5 hours = 5 hours');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 21}), true),  '21 timmar',      '21 hours = 21 hours');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 22}), true),  'en dag',         '22 hours = a day');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 35}), true),  'en dag',         '35 hours = a day');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 36}), true),  '2 dagar',        '36 hours = 2 days');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 1}), true),   'en dag',         '1 day = a day');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 5}), true),   '5 dagar',        '5 days = 5 days');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 25}), true),  '25 dagar',       '25 days = 25 days');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 26}), true),  'en mÃ¥nad',       '26 days = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 30}), true),  'en mÃ¥nad',       '30 days = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 43}), true),  'en mÃ¥nad',       '43 days = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 46}), true),  '2 mÃ¥nader',      '46 days = 2 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 74}), true),  '2 mÃ¥nader',      '75 days = 2 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 76}), true),  '3 mÃ¥nader',      '76 days = 3 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({M: 1}), true),   'en mÃ¥nad',       '1 month = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({M: 5}), true),   '5 mÃ¥nader',      '5 months = 5 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 345}), true), 'ett Ã¥r',        '345 days = a year');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 548}), true), '2 Ã¥r',       '548 days = 2 years');
        assert.equal(start.from(moment([2007, 1, 28]).add({y: 1}), true),   'ett Ã¥r',        '1 year = a year');
        assert.equal(start.from(moment([2007, 1, 28]).add({y: 5}), true),   '5 Ã¥r',       '5 years = 5 years');
    });

    test('suffix', function (assert) {
        assert.equal(moment(30000).from(0), 'om nÃ¥gra sekunder',  'prefix');
        assert.equal(moment(0).from(30000), 'fÃ¶r nÃ¥gra sekunder sedan', 'suffix');
    });

    test('now from now', function (assert) {
        assert.equal(moment().fromNow(), 'fÃ¶r nÃ¥gra sekunder sedan',  'now from now should display as in the past');
    });

    test('fromNow', function (assert) {
        assert.equal(moment().add({s: 30}).fromNow(), 'om nÃ¥gra sekunder', 'in a few seconds');
        assert.equal(moment().add({d: 5}).fromNow(), 'om 5 dagar', 'in 5 days');
    });

    test('calendar day', function (assert) {
        var a = moment().hours(12).minutes(0).seconds(0);

        assert.equal(moment(a).calendar(),                   'Idag 12:00',     'today at the same time');
        assert.equal(moment(a).add({m: 25}).calendar(),      'Idag 12:25',     'Now plus 25 min');
        assert.equal(moment(a).add({h: 1}).calendar(),       'Idag 13:00',     'Now plus 1 hour');
        assert.equal(moment(a).add({d: 1}).calendar(),       'Imorgon 12:00',  'tomorrow at the same time');
        assert.equal(moment(a).subtract({h: 1}).calendar(),  'Idag 11:00',     'Now minus 1 hour');
        assert.equal(moment(a).subtract({d: 1}).calendar(),  'IgÃ¥r 12:00',     'yesterday at the same time');
    });

    test('calendar next week', function (assert) {
        var i, m;
        for (i = 2; i < 7; i++) {
            m = moment().add({d: i});
            assert.equal(m.calendar(),       m.format('[PÃ¥] dddd LT'),  'Today + ' + i + ' days current time');
            m.hours(0).minutes(0).seconds(0).milliseconds(0);
            assert.equal(m.calendar(),       m.format('[PÃ¥] dddd LT'),  'Today + ' + i + ' days beginning of day');
            m.hours(23).minutes(59).seconds(59).milliseconds(999);
            assert.equal(m.calendar(),       m.format('[PÃ¥] dddd LT'),  'Today + ' + i + ' days end of day');
        }
    });

    test('calendar last week', function (assert) {
        var i, m;
        for (i = 2; i < 7; i++) {
            m = moment().subtract({d: i});
            assert.equal(m.calendar(),       m.format('[I] dddd[s] LT'),  'Today - ' + i + ' days current time');
            m.hours(0).minutes(0).seconds(0).milliseconds(0);
            assert.equal(m.calendar(),       m.format('[I] dddd[s] LT'),  'Today - ' + i + ' days beginning of day');
            m.hours(23).minutes(59).seconds(59).milliseconds(999);
            assert.equal(m.calendar(),       m.format('[I] dddd[s] LT'),  'Today - ' + i + ' days end of day');
        }
    });

    test('calendar all else', function (assert) {
        var weeksAgo = moment().subtract({w: 1}),
            weeksFromNow = moment().add({w: 1});

        assert.equal(weeksAgo.calendar(),       weeksAgo.format('L'),  '1 week ago');
        assert.equal(weeksFromNow.calendar(),   weeksFromNow.format('L'),  'in 1 week');

        weeksAgo = moment().subtract({w: 2});
        weeksFromNow = moment().add({w: 2});

        assert.equal(weeksAgo.calendar(),       weeksAgo.format('L'),  '2 weeks ago');
        assert.equal(weeksFromNow.calendar(),   weeksFromNow.format('L'),  'in 2 weeks');
    });

    test('weeks year starting sunday formatted', function (assert) {
        assert.equal(moment([2012, 0,  1]).format('w ww wo'), '52 52 52a', 'Jan  1 2012 should be week 52');
        assert.equal(moment([2012, 0,  2]).format('w ww wo'),   '1 01 1a', 'Jan  2 2012 should be week 1');
        assert.equal(moment([2012, 0,  8]).format('w ww wo'),   '1 01 1a', 'Jan  8 2012 should be week 1');
        assert.equal(moment([2012, 0,  9]).format('w ww wo'),   '2 02 2a', 'Jan  9 2012 should be week 2');
        assert.equal(moment([2012, 0, 15]).format('w ww wo'),   '2 02 2a', 'Jan 15 2012 should be week 2');
    });

}));

;(function (global, factory) {
   typeof exports === 'object' && typeof module !== 'undefined'
       && typeof require === 'function' ? factory(require('../../moment')) :
   typeof define === 'function' && define.amd ? define(['../../moment'], factory) :
   factory(global.moment)
}(this, function (moment) { 'use strict';

    function each(array, callback) {
        var i;
        for (i = 0; i < array.length; i++) {
            callback(array[i], i, array);
        }
    }

    function objectKeys(obj) {
        if (Object.keys) {
            return Object.keys(obj);
        } else {
            // IE8
            var res = [], i;
            for (i in obj) {
                if (obj.hasOwnProperty(i)) {
                    res.push(i);
                }
            }
            return res;
        }
    }

    // Pick the first defined of two or three arguments.
    function defaults(a, b, c) {
        if (a != null) {
            return a;
        }
        if (b != null) {
            return b;
        }
        return c;
    }

    function defineCommonLocaleTests(locale, options) {
        test('lenient ordinal parsing', function (assert) {
            var i, ordinalStr, testMoment;
            for (i = 1; i <= 31; ++i) {
                ordinalStr = moment([2014, 0, i]).format('YYYY MM Do');
                testMoment = moment(ordinalStr, 'YYYY MM Do');
                assert.equal(testMoment.year(), 2014,
                        'lenient ordinal parsing ' + i + ' year check');
                assert.equal(testMoment.month(), 0,
                        'lenient ordinal parsing ' + i + ' month check');
                assert.equal(testMoment.date(), i,
                        'lenient ordinal parsing ' + i + ' date check');
            }
        });

        test('lenient ordinal parsing of number', function (assert) {
            var i, testMoment;
            for (i = 1; i <= 31; ++i) {
                testMoment = moment('2014 01 ' + i, 'YYYY MM Do');
                assert.equal(testMoment.year(), 2014,
                        'lenient ordinal parsing of number ' + i + ' year check');
                assert.equal(testMoment.month(), 0,
                        'lenient ordinal parsing of number ' + i + ' month check');
                assert.equal(testMoment.date(), i,
                        'lenient ordinal parsing of number ' + i + ' date check');
            }
        });

        test('strict ordinal parsing', function (assert) {
            var i, ordinalStr, testMoment;
            for (i = 1; i <= 31; ++i) {
                ordinalStr = moment([2014, 0, i]).format('YYYY MM Do');
                testMoment = moment(ordinalStr, 'YYYY MM Do', true);
                assert.ok(testMoment.isValid(), 'strict ordinal parsing ' + i);
            }
        });

        test('meridiem invariant', function (assert) {
            var h, m, t1, t2;
            for (h = 0; h < 24; ++h) {
                for (m = 0; m < 60; m += 15) {
                    t1 = moment.utc([2000, 0, 1, h, m]);
                    t2 = moment.utc(t1.format('A h:mm'), 'A h:mm');
                    assert.equal(t2.format('HH:mm'), t1.format('HH:mm'),
                            'meridiem at ' + t1.format('HH:mm'));
                }
            }
        });

        test('date format correctness', function (assert) {
            var data, tokens;
            data = moment.localeData()._longDateFormat;
            tokens = objectKeys(data);
            each(tokens, function (srchToken) {
                // Check each format string to make sure it does not contain any
                // tokens that need to be expanded.
                each(tokens, function (baseToken) {
                    // strip escaped sequences
                    var format = data[baseToken].replace(/(\[[^\]]*\])/g, '');
                    assert.equal(false, !!~format.indexOf(srchToken),
                            'contains ' + srchToken + ' in ' + baseToken);
                });
            });
        });

        test('month parsing correctness', function (assert) {
            var i, m;

            if (locale === 'tr') {
                // I can't fix it :(
                expect(0);
                return;
            }
            function tester(format) {
                var r;
                r = moment(m.format(format), format);
                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format);
                r = moment(m.format(format).toLocaleUpperCase(), format);
                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' upper');
                r = moment(m.format(format).toLocaleLowerCase(), format);
                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' lower');

                r = moment(m.format(format), format, true);
                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' strict');
                r = moment(m.format(format).toLocaleUpperCase(), format, true);
                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' upper strict');
                r = moment(m.format(format).toLocaleLowerCase(), format, true);
                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' lower strict');
            }

            for (i = 0; i < 12; ++i) {
                m = moment([2015, i, 15, 18]);
                tester('MMM');
                tester('MMM.');
                tester('MMMM');
                tester('MMMM.');
            }
        });

        test('weekday parsing correctness', function (assert) {
            var i, m;

            if (locale === 'tr' || locale === 'az') {
                // There is a lower-case letter (Ä±), that converted to upper then
                // lower changes to i
                expect(0);
                return;
            }
            function tester(format) {
                var r, baseMsg = 'weekday ' + m.weekday() + ' fmt ' + format;
                r = moment(m.format(format), format);
                assert.equal(r.weekday(), m.weekday(), baseMsg);
                r = moment(m.format(format).toLocaleUpperCase(), format);
                assert.equal(r.weekday(), m.weekday(), baseMsg + ' upper');
                r = moment(m.format(format).toLocaleLowerCase(), format);
                assert.equal(r.weekday(), m.weekday(), baseMsg + ' lower');

                r = moment(m.format(format), format, true);
                assert.equal(r.weekday(), m.weekday(), baseMsg + ' strict');
                r = moment(m.format(format).toLocaleUpperCase(), format, true);
                assert.equal(r.weekday(), m.weekday(), baseMsg + ' upper strict');
                r = moment(m.format(format).toLocaleLowerCase(), format, true);
                assert.equal(r.weekday(), m.weekday(), baseMsg + ' lower strict');
            }

            for (i = 0; i < 7; ++i) {
                m = moment.utc([2015, i, 15, 18]);
                tester('dd');
                tester('ddd');
                tester('dddd');
            }
        });
    }

    function setupDeprecationHandler(test, moment, scope) {
        test._expectedDeprecations = null;
        test._observedDeprecations = null;
        test._oldSupress = moment.suppressDeprecationWarnings;
        moment.suppressDeprecationWarnings = true;
        test.expectedDeprecations = function () {
            test._expectedDeprecations = arguments;
            test._observedDeprecations = [];
        };
        moment.deprecationHandler = function (name, msg) {
            var deprecationId = matchedDeprecation(name, msg, test._expectedDeprecations);
            if (deprecationId === -1) {
                throw new Error('Unexpected deprecation thrown name=' +
                        name + ' msg=' + msg);
            }
            test._observedDeprecations[deprecationId] = 1;
        };
    }

    function teardownDeprecationHandler(test, moment, scope) {
        moment.suppressDeprecationWarnings = test._oldSupress;

        if (test._expectedDeprecations != null) {
            var missedDeprecations = [];
            each(test._expectedDeprecations, function (deprecationPattern, id) {
                if (test._observedDeprecations[id] !== 1) {
                    missedDeprecations.push(deprecationPattern);
                }
            });
            if (missedDeprecations.length !== 0) {
                throw new Error('Expected deprecation warnings did not happen: ' +
                        missedDeprecations.join(' '));
            }
        }
    }

    function matchedDeprecation(name, msg, deprecations) {
        if (deprecations == null) {
            return -1;
        }
        for (var i = 0; i < deprecations.length; ++i) {
            if (name != null && name === deprecations[i]) {
                return i;
            }
            if (msg != null && msg.substring(0, deprecations[i].length) === deprecations[i]) {
                return i;
            }
        }
        return -1;
    }

    /*global QUnit:false*/

    var test = QUnit.test;

    var expect = QUnit.expect;

    function module (name, lifecycle) {
        QUnit.module(name, {
            setup : function () {
                moment.locale('en');
                moment.createFromInputFallback = function (config) {
                    throw new Error('input not handled by moment: ' + config._i);
                };
                setupDeprecationHandler(test, moment, 'core');
                if (lifecycle && lifecycle.setup) {
                    lifecycle.setup();
                }
            },
            teardown : function () {
                teardownDeprecationHandler(test, moment, 'core');
                if (lifecycle && lifecycle.teardown) {
                    lifecycle.teardown();
                }
            }
        });
    }

    function localeModule (name, lifecycle) {
        QUnit.module('locale:' + name, {
            setup : function () {
                moment.locale(name);
                moment.createFromInputFallback = function (config) {
                    throw new Error('input not handled by moment: ' + config._i);
                };
                setupDeprecationHandler(test, moment, 'locale');
                if (lifecycle && lifecycle.setup) {
                    lifecycle.setup();
                }
            },
            teardown : function () {
                moment.locale('en');
                teardownDeprecationHandler(test, moment, 'locale');
                if (lifecycle && lifecycle.teardown) {
                    lifecycle.teardown();
                }
            }
        });
        defineCommonLocaleTests(name, -1, -1);
    }

    localeModule('sw');

    test('parse', function (assert) {
        var tests = 'Januari Jan_Februari Feb_Machi Mac_Aprili Apr_Mei Mei_Juni Jun_Julai Jul_Agosti Ago_Septemba Sep_Oktoba Okt_Novemba Nov_Desemba Des'.split('_'), i;
        function equalTest(input, mmm, i) {
            assert.equal(moment(input, mmm).month(), i, input + ' should be month ' + (i + 1));
        }
        for (i = 0; i < 12; i++) {
            tests[i] = tests[i].split(' ');
            equalTest(tests[i][0], 'MMM', i);
            equalTest(tests[i][1], 'MMM', i);
            equalTest(tests[i][0], 'MMMM', i);
            equalTest(tests[i][1], 'MMMM', i);
            equalTest(tests[i][0].toLocaleLowerCase(), 'MMMM', i);
            equalTest(tests[i][1].toLocaleLowerCase(), 'MMMM', i);
            equalTest(tests[i][0].toLocaleUpperCase(), 'MMMM', i);
            equalTest(tests[i][1].toLocaleUpperCase(), 'MMMM', i);
        }
    });

    test('format', function (assert) {
        var a = [
                ['dddd, MMMM Do YYYY, h:mm:ss a',      'Jumapili, Februari 14 2010, 3:25:50 pm'],
                ['ddd, hA',                            'Jpl, 3PM'],
                ['M Mo MM MMMM MMM',                   '2 2 02 Februari Feb'],
                ['YYYY YY',                            '2010 10'],
                ['D Do DD',                            '14 14 14'],
                ['d do dddd ddd dd',                   '0 0 Jumapili Jpl J2'],
                ['DDD DDDo DDDD',                      '45 45 045'],
                ['w wo ww',                            '7 7 07'],
                ['h hh',                               '3 03'],
                ['H HH',                               '15 15'],
                ['m mm',                               '25 25'],
                ['s ss',                               '50 50'],
                ['a A',                                'pm PM'],
                ['[siku] DDDo [ya mwaka]',             'siku 45 ya mwaka'],
                ['LTS',                                '15:25:50'],
                ['L',                                  '14.02.2010'],
                ['LL',                                 '14 Februari 2010'],
                ['LLL',                                '14 Februari 2010 15:25'],
                ['LLLL',                               'Jumapili, 14 Februari 2010 15:25'],
                ['l',                                  '14.2.2010'],
                ['ll',                                 '14 Feb 2010'],
                ['lll',                                '14 Feb 2010 15:25'],
                ['llll',                               'Jpl, 14 Feb 2010 15:25']
            ],
            b = moment(new Date(2010, 1, 14, 15, 25, 50, 125)),
            i;
        for (i = 0; i < a.length; i++) {
            assert.equal(b.format(a[i][0]), a[i][1], a[i][0] + ' ---> ' + a[i][1]);
        }
    });

    test('format ordinal', function (assert) {
        assert.equal(moment([2011, 0, 1]).format('DDDo'), '1', '1');
        assert.equal(moment([2011, 0, 2]).format('DDDo'), '2', '2');
        assert.equal(moment([2011, 0, 3]).format('DDDo'), '3', '3');
        assert.equal(moment([2011, 0, 4]).format('DDDo'), '4', '4');
        assert.equal(moment([2011, 0, 5]).format('DDDo'), '5', '5');
        assert.equal(moment([2011, 0, 6]).format('DDDo'), '6', '6');
        assert.equal(moment([2011, 0, 7]).format('DDDo'), '7', '7');
        assert.equal(moment([2011, 0, 8]).format('DDDo'), '8', '8');
        assert.equal(moment([2011, 0, 9]).format('DDDo'), '9', '9');
        assert.equal(moment([2011, 0, 10]).format('DDDo'), '10', '10');

        assert.equal(moment([2011, 0, 11]).format('DDDo'), '11', '11');
        assert.equal(moment([2011, 0, 12]).format('DDDo'), '12', '12');
        assert.equal(moment([2011, 0, 13]).format('DDDo'), '13', '13');
        assert.equal(moment([2011, 0, 14]).format('DDDo'), '14', '14');
        assert.equal(moment([2011, 0, 15]).format('DDDo'), '15', '15');
        assert.equal(moment([2011, 0, 16]).format('DDDo'), '16', '16');
        assert.equal(moment([2011, 0, 17]).format('DDDo'), '17', '17');
        assert.equal(moment([2011, 0, 18]).format('DDDo'), '18', '18');
        assert.equal(moment([2011, 0, 19]).format('DDDo'), '19', '19');
        assert.equal(moment([2011, 0, 20]).format('DDDo'), '20', '20');

        assert.equal(moment([2011, 0, 21]).format('DDDo'), '21', '21');
        assert.equal(moment([2011, 0, 22]).format('DDDo'), '22', '22');
        assert.equal(moment([2011, 0, 23]).format('DDDo'), '23', '23');
        assert.equal(moment([2011, 0, 24]).format('DDDo'), '24', '24');
        assert.equal(moment([2011, 0, 25]).format('DDDo'), '25', '25');
        assert.equal(moment([2011, 0, 26]).format('DDDo'), '26', '26');
        assert.equal(moment([2011, 0, 27]).format('DDDo'), '27', '27');
        assert.equal(moment([2011, 0, 28]).format('DDDo'), '28', '28');
        assert.equal(moment([2011, 0, 29]).format('DDDo'), '29', '29');
        assert.equal(moment([2011, 0, 30]).format('DDDo'), '30', '30');

        assert.equal(moment([2011, 0, 31]).format('DDDo'), '31', '31');
    });

    test('format month', function (assert) {
        var expected = 'Januari Jan_Februari Feb_Machi Mac_Aprili Apr_Mei Mei_Juni Jun_Julai Jul_Agosti Ago_Septemba Sep_Oktoba Okt_Novemba Nov_Desemba Des'.split('_'), i;
        for (i = 0; i < expected.length; i++) {
            assert.equal(moment([2011, i, 1]).format('MMMM MMM'), expected[i], expected[i]);
        }
    });

    test('format week', function (assert) {
        var expected = 'Jumapili Jpl J2_Jumatatu Jtat J3_Jumanne Jnne J4_Jumatano Jtan J5_Alhamisi Alh Al_Ijumaa Ijm Ij_Jumamosi Jmos J1'.split('_'), i;
        for (i = 0; i < expected.length; i++) {
            assert.equal(moment([2011, 0, 2 + i]).format('dddd ddd dd'), expected[i], expected[i]);
        }
    });

    test('from', function (assert) {
        var start = moment([2007, 1, 28]);
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 44}), true),  'hivi punde',   '44 seconds = a few seconds');
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 45}), true),  'dakika moja',  '45 seconds = a minute');
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 89}), true),  'dakika moja',  '89 seconds = a minute');
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 90}), true),  'dakika 2',     '90 seconds = 2 minutes');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 44}), true),  'dakika 44',    '44 minutes = 44 minutes');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 45}), true),  'saa limoja',   '45 minutes = an hour');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 89}), true),  'saa limoja',   '89 minutes = an hour');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 90}), true),  'masaa 2',      '90 minutes = 2 hours');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 5}), true),   'masaa 5',      '5 hours = 5 hours');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 21}), true),  'masaa 21',     '21 hours = 21 hours');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 22}), true),  'siku moja',    '22 hours = a day');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 35}), true),  'siku moja',    '35 hours = a day');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 36}), true),  'masiku 2',     '36 hours = 2 days');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 1}), true),   'siku moja',    '1 day = a day');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 5}), true),   'masiku 5',     '5 days = 5 days');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 25}), true),  'masiku 25',    '25 days = 25 days');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 26}), true),  'mwezi mmoja',  '26 days = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 30}), true),  'mwezi mmoja',  '30 days = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 43}), true),  'mwezi mmoja',  '43 days = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 46}), true),  'miezi 2',      '46 days = 2 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 74}), true),  'miezi 2',      '75 days = 2 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 76}), true),  'miezi 3',      '76 days = 3 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({M: 1}), true),   'mwezi mmoja',  '1 month = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({M: 5}), true),   'miezi 5',      '5 months = 5 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 345}), true), 'mwaka mmoja',  '345 days = a year');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 548}), true), 'miaka 2',      '548 days = 2 years');
        assert.equal(start.from(moment([2007, 1, 28]).add({y: 1}), true),   'mwaka mmoja',  '1 year = a year');
        assert.equal(start.from(moment([2007, 1, 28]).add({y: 5}), true),   'miaka 5',      '5 years = 5 years');
    });

    test('suffix', function (assert) {
        assert.equal(moment(30000).from(0), 'hivi punde baadaye',  'prefix');
        assert.equal(moment(0).from(30000), 'tokea hivi punde', 'suffix');
    });

    test('now from now', function (assert) {
        assert.equal(moment().fromNow(), 'tokea hivi punde',  'now from now should display as in the past');
    });

    test('fromNow', function (assert) {
        assert.equal(moment().add({s: 30}).fromNow(), 'hivi punde baadaye', 'in a few seconds');
        assert.equal(moment().add({d: 5}).fromNow(), 'masiku 5 baadaye', 'in 5 days');
    });

    test('calendar day', function (assert) {
        var a = moment().hours(12).minutes(0).seconds(0);
        assert.equal(moment(a).calendar(),                   'leo saa 12:00',      'today at the same time');
        assert.equal(moment(a).add({m: 25}).calendar(),      'leo saa 12:25',      'Now plus 25 min');
        assert.equal(moment(a).add({h: 1}).calendar(),       'leo saa 13:00',      'Now plus 1 hour');
        assert.equal(moment(a).add({d: 1}).calendar(),       'kesho saa 12:00',    'tomorrow at the same time');
        assert.equal(moment(a).subtract({h: 1}).calendar(),  'leo saa 11:00',      'Now minus 1 hour');
        assert.equal(moment(a).subtract({d: 1}).calendar(),  'jana 12:00',         'yesterday at the same time');
    });

    test('calendar next week', function (assert) {
        var i, m;
        for (i = 2; i < 7; i++) {
            m = moment().add({d: i});
            assert.equal(m.calendar(),       m.format('[wiki ijayo] dddd [saat] LT'),  'Today + ' + i + ' days current time');
            m.hours(0).minutes(0).seconds(0).milliseconds(0);
            assert.equal(m.calendar(),       m.format('[wiki ijayo] dddd [saat] LT'),  'Today + ' + i + ' days beginning of day');
            m.hours(23).minutes(59).seconds(59).milliseconds(999);
            assert.equal(m.calendar(),       m.format('[wiki ijayo] dddd [saat] LT'),  'Today + ' + i + ' days end of day');
        }
    });

    test('calendar last week', function (assert) {
        var i, m;

        for (i = 2; i < 7; i++) {
            m = moment().subtract({d: i});
            assert.equal(m.calendar(),       m.format('[wiki iliyopita] dddd [saat] LT'),  'Today - ' + i + ' days current time');
            m.hours(0).minutes(0).seconds(0).milliseconds(0);
            assert.equal(m.calendar(),       m.format('[wiki iliyopita] dddd [saat] LT'),  'Today - ' + i + ' days beginning of day');
            m.hours(23).minutes(59).seconds(59).milliseconds(999);
            assert.equal(m.calendar(),       m.format('[wiki iliyopita] dddd [saat] LT'),  'Today - ' + i + ' days end of day');
        }
    });

    test('calendar all else', function (assert) {
        var weeksAgo = moment().subtract({w: 1}),
            weeksFromNow = moment().add({w: 1});

        assert.equal(weeksAgo.calendar(),       weeksAgo.format('L'),      '1 week ago');
        assert.equal(weeksFromNow.calendar(),   weeksFromNow.format('L'),  'in 1 week');

        weeksAgo = moment().subtract({w: 2});
        weeksFromNow = moment().add({w: 2});

        assert.equal(weeksAgo.calendar(),       weeksAgo.format('L'),  '2 weeks ago');
        assert.equal(weeksFromNow.calendar(),   weeksFromNow.format('L'),  'in 2 weeks');
    });

    test('weeks year starting sunday format', function (assert) {
        assert.equal(moment([2011, 11, 26]).format('w ww wo'), '1 01 1', 'Dec 26 2011 should be week 1');
        assert.equal(moment([2012,  0,  1]).format('w ww wo'), '1 01 1', 'Jan  1 2012 should be week 1');
        assert.equal(moment([2012,  0,  2]).format('w ww wo'), '2 02 2', 'Jan  2 2012 should be week 2');
        assert.equal(moment([2012,  0,  8]).format('w ww wo'), '2 02 2', 'Jan  8 2012 should be week 2');
        assert.equal(moment([2012,  0,  9]).format('w ww wo'), '3 03 3', 'Jan  9 2012 should be week 3');
    });

}));

;(function (global, factory) {
   typeof exports === 'object' && typeof module !== 'undefined'
       && typeof require === 'function' ? factory(require('../../moment')) :
   typeof define === 'function' && define.amd ? define(['../../moment'], factory) :
   factory(global.moment)
}(this, function (moment) { 'use strict';

    function each(array, callback) {
        var i;
        for (i = 0; i < array.length; i++) {
            callback(array[i], i, array);
        }
    }

    function objectKeys(obj) {
        if (Object.keys) {
            return Object.keys(obj);
        } else {
            // IE8
            var res = [], i;
            for (i in obj) {
                if (obj.hasOwnProperty(i)) {
                    res.push(i);
                }
            }
            return res;
        }
    }

    // Pick the first defined of two or three arguments.
    function defaults(a, b, c) {
        if (a != null) {
            return a;
        }
        if (b != null) {
            return b;
        }
        return c;
    }

    function defineCommonLocaleTests(locale, options) {
        test('lenient ordinal parsing', function (assert) {
            var i, ordinalStr, testMoment;
            for (i = 1; i <= 31; ++i) {
                ordinalStr = moment([2014, 0, i]).format('YYYY MM Do');
                testMoment = moment(ordinalStr, 'YYYY MM Do');
                assert.equal(testMoment.year(), 2014,
                        'lenient ordinal parsing ' + i + ' year check');
                assert.equal(testMoment.month(), 0,
                        'lenient ordinal parsing ' + i + ' month check');
                assert.equal(testMoment.date(), i,
                        'lenient ordinal parsing ' + i + ' date check');
            }
        });

        test('lenient ordinal parsing of number', function (assert) {
            var i, testMoment;
            for (i = 1; i <= 31; ++i) {
                testMoment = moment('2014 01 ' + i, 'YYYY MM Do');
                assert.equal(testMoment.year(), 2014,
                        'lenient ordinal parsing of number ' + i + ' year check');
                assert.equal(testMoment.month(), 0,
                        'lenient ordinal parsing of number ' + i + ' month check');
                assert.equal(testMoment.date(), i,
                        'lenient ordinal parsing of number ' + i + ' date check');
            }
        });

        test('strict ordinal parsing', function (assert) {
            var i, ordinalStr, testMoment;
            for (i = 1; i <= 31; ++i) {
                ordinalStr = moment([2014, 0, i]).format('YYYY MM Do');
                testMoment = moment(ordinalStr, 'YYYY MM Do', true);
                assert.ok(testMoment.isValid(), 'strict ordinal parsing ' + i);
            }
        });

        test('meridiem invariant', function (assert) {
            var h, m, t1, t2;
            for (h = 0; h < 24; ++h) {
                for (m = 0; m < 60; m += 15) {
                    t1 = moment.utc([2000, 0, 1, h, m]);
                    t2 = moment.utc(t1.format('A h:mm'), 'A h:mm');
                    assert.equal(t2.format('HH:mm'), t1.format('HH:mm'),
                            'meridiem at ' + t1.format('HH:mm'));
                }
            }
        });

        test('date format correctness', function (assert) {
            var data, tokens;
            data = moment.localeData()._longDateFormat;
            tokens = objectKeys(data);
            each(tokens, function (srchToken) {
                // Check each format string to make sure it does not contain any
                // tokens that need to be expanded.
                each(tokens, function (baseToken) {
                    // strip escaped sequences
                    var format = data[baseToken].replace(/(\[[^\]]*\])/g, '');
                    assert.equal(false, !!~format.indexOf(srchToken),
                            'contains ' + srchToken + ' in ' + baseToken);
                });
            });
        });

        test('month parsing correctness', function (assert) {
            var i, m;

            if (locale === 'tr') {
                // I can't fix it :(
                expect(0);
                return;
            }
            function tester(format) {
                var r;
                r = moment(m.format(format), format);
                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format);
                r = moment(m.format(format).toLocaleUpperCase(), format);
                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' upper');
                r = moment(m.format(format).toLocaleLowerCase(), format);
                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' lower');

                r = moment(m.format(format), format, true);
                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' strict');
                r = moment(m.format(format).toLocaleUpperCase(), format, true);
                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' upper strict');
                r = moment(m.format(format).toLocaleLowerCase(), format, true);
                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' lower strict');
            }

            for (i = 0; i < 12; ++i) {
                m = moment([2015, i, 15, 18]);
                tester('MMM');
                tester('MMM.');
                tester('MMMM');
                tester('MMMM.');
            }
        });

        test('weekday parsing correctness', function (assert) {
            var i, m;

            if (locale === 'tr' || locale === 'az') {
                // There is a lower-case letter (Ä±), that converted to upper then
                // lower changes to i
                expect(0);
                return;
            }
            function tester(format) {
                var r, baseMsg = 'weekday ' + m.weekday() + ' fmt ' + format;
                r = moment(m.format(format), format);
                assert.equal(r.weekday(), m.weekday(), baseMsg);
                r = moment(m.format(format).toLocaleUpperCase(), format);
                assert.equal(r.weekday(), m.weekday(), baseMsg + ' upper');
                r = moment(m.format(format).toLocaleLowerCase(), format);
                assert.equal(r.weekday(), m.weekday(), baseMsg + ' lower');

                r = moment(m.format(format), format, true);
                assert.equal(r.weekday(), m.weekday(), baseMsg + ' strict');
                r = moment(m.format(format).toLocaleUpperCase(), format, true);
                assert.equal(r.weekday(), m.weekday(), baseMsg + ' upper strict');
                r = moment(m.format(format).toLocaleLowerCase(), format, true);
                assert.equal(r.weekday(), m.weekday(), baseMsg + ' lower strict');
            }

            for (i = 0; i < 7; ++i) {
                m = moment.utc([2015, i, 15, 18]);
                tester('dd');
                tester('ddd');
                tester('dddd');
            }
        });
    }

    function setupDeprecationHandler(test, moment, scope) {
        test._expectedDeprecations = null;
        test._observedDeprecations = null;
        test._oldSupress = moment.suppressDeprecationWarnings;
        moment.suppressDeprecationWarnings = true;
        test.expectedDeprecations = function () {
            test._expectedDeprecations = arguments;
            test._observedDeprecations = [];
        };
        moment.deprecationHandler = function (name, msg) {
            var deprecationId = matchedDeprecation(name, msg, test._expectedDeprecations);
            if (deprecationId === -1) {
                throw new Error('Unexpected deprecation thrown name=' +
                        name + ' msg=' + msg);
            }
            test._observedDeprecations[deprecationId] = 1;
        };
    }

    function teardownDeprecationHandler(test, moment, scope) {
        moment.suppressDeprecationWarnings = test._oldSupress;

        if (test._expectedDeprecations != null) {
            var missedDeprecations = [];
            each(test._expectedDeprecations, function (deprecationPattern, id) {
                if (test._observedDeprecations[id] !== 1) {
                    missedDeprecations.push(deprecationPattern);
                }
            });
            if (missedDeprecations.length !== 0) {
                throw new Error('Expected deprecation warnings did not happen: ' +
                        missedDeprecations.join(' '));
            }
        }
    }

    function matchedDeprecation(name, msg, deprecations) {
        if (deprecations == null) {
            return -1;
        }
        for (var i = 0; i < deprecations.length; ++i) {
            if (name != null && name === deprecations[i]) {
                return i;
            }
            if (msg != null && msg.substring(0, deprecations[i].length) === deprecations[i]) {
                return i;
            }
        }
        return -1;
    }

    /*global QUnit:false*/

    var test = QUnit.test;

    var expect = QUnit.expect;

    function module (name, lifecycle) {
        QUnit.module(name, {
            setup : function () {
                moment.locale('en');
                moment.createFromInputFallback = function (config) {
                    throw new Error('input not handled by moment: ' + config._i);
                };
                setupDeprecationHandler(test, moment, 'core');
                if (lifecycle && lifecycle.setup) {
                    lifecycle.setup();
                }
            },
            teardown : function () {
                teardownDeprecationHandler(test, moment, 'core');
                if (lifecycle && lifecycle.teardown) {
                    lifecycle.teardown();
                }
            }
        });
    }

    function localeModule (name, lifecycle) {
        QUnit.module('locale:' + name, {
            setup : function () {
                moment.locale(name);
                moment.createFromInputFallback = function (config) {
                    throw new Error('input not handled by moment: ' + config._i);
                };
                setupDeprecationHandler(test, moment, 'locale');
                if (lifecycle && lifecycle.setup) {
                    lifecycle.setup();
                }
            },
            teardown : function () {
                moment.locale('en');
                teardownDeprecationHandler(test, moment, 'locale');
                if (lifecycle && lifecycle.teardown) {
                    lifecycle.teardown();
                }
            }
        });
        defineCommonLocaleTests(name, -1, -1);
    }

    localeModule('ta');

    test('parse', function (assert) {
        var tests = 'à®à®©à®µà®°à®¿ à®à®©à®µà®°à®¿_à®ªà®¿à®ªà¯à®°à®µà®°à®¿ à®ªà®¿à®ªà¯à®°à®µà®°à®¿_à®®à®¾à®°à¯à®à¯ à®®à®¾à®°à¯à®à¯_à®à®ªà¯à®°à®²à¯ à®à®ªà¯à®°à®²à¯_à®®à¯ à®®à¯_à®à¯à®©à¯ à®à¯à®©à¯_à®à¯à®²à¯ à®à¯à®²à¯_à®à®à®¸à¯à®à¯ à®à®à®¸à¯à®à¯_à®à¯à®ªà¯à®à¯à®®à¯à®ªà®°à¯ à®à¯à®ªà¯à®à¯à®®à¯à®ªà®°à¯_à®à®à¯à®à¯à®¾à®ªà®°à¯ à®à®à¯à®à¯à®¾à®ªà®°à¯_à®¨à®µà®®à¯à®ªà®°à¯ à®¨à®µà®®à¯à®ªà®°à¯_à®à®¿à®à®®à¯à®ªà®°à¯ à®à®¿à®à®®à¯à®ªà®°à¯'.split('_'), i;
        function equalTest(input, mmm, i) {
            assert.equal(moment(input, mmm).month(), i, input + ' should be month ' + (i + 1));
        }
        for (i = 0; i < 12; i++) {
            tests[i] = tests[i].split(' ');
            equalTest(tests[i][0], 'MMM', i);
            equalTest(tests[i][1], 'MMM', i);
            equalTest(tests[i][0], 'MMMM', i);
            equalTest(tests[i][1], 'MMMM', i);
            equalTest(tests[i][0].toLocaleLowerCase(), 'MMMM', i);
            equalTest(tests[i][1].toLocaleLowerCase(), 'MMMM', i);
            equalTest(tests[i][0].toLocaleUpperCase(), 'MMMM', i);
            equalTest(tests[i][1].toLocaleUpperCase(), 'MMMM', i);
        }
    });

    test('format', function (assert) {
        var a = [
                ['dddd, MMMM Do YYYY, h:mm:ss a', 'à®à®¾à®¯à®¿à®±à¯à®±à¯à®à¯à®à®¿à®´à®®à¯, à®ªà®¿à®ªà¯à®°à®µà®°à®¿ à¯§à¯ªà®µà®¤à¯ à¯¨à¯¦à¯§à¯¦, à¯©:à¯¨à¯«:à¯«à¯¦  à®à®±à¯à®ªà®¾à®à¯'],
                ['ddd, hA',                       'à®à®¾à®¯à®¿à®±à¯, à¯© à®à®±à¯à®ªà®¾à®à¯'],
                ['M Mo MM MMMM MMM',              'à¯¨ à¯¨à®µà®¤à¯ à¯¦à¯¨ à®ªà®¿à®ªà¯à®°à®µà®°à®¿ à®ªà®¿à®ªà¯à®°à®µà®°à®¿'],
                ['YYYY YY',                       'à¯¨à¯¦à¯§à¯¦ à¯§à¯¦'],
                ['D Do DD',                       'à¯§à¯ª à¯§à¯ªà®µà®¤à¯ à¯§à¯ª'],
                ['d do dddd ddd dd',              'à¯¦ à¯¦à®µà®¤à¯ à®à®¾à®¯à®¿à®±à¯à®±à¯à®à¯à®à®¿à®´à®®à¯ à®à®¾à®¯à®¿à®±à¯ à®à®¾'],
                ['DDD DDDo DDDD',                 'à¯ªà¯« à¯ªà¯«à®µà®¤à¯ à¯¦à¯ªà¯«'],
                ['w wo ww',                       'à¯® à¯®à®µà®¤à¯ à¯¦à¯®'],
                ['h hh',                          'à¯© à¯¦à¯©'],
                ['H HH',                          'à¯§à¯« à¯§à¯«'],
                ['m mm',                          'à¯¨à¯« à¯¨à¯«'],
                ['s ss',                          'à¯«à¯¦ à¯«à¯¦'],
                ['a A',                           ' à®à®±à¯à®ªà®¾à®à¯  à®à®±à¯à®ªà®¾à®à¯'],
                ['[à®à®£à¯à®à®¿à®©à¯] DDDo  [à®¨à®¾à®³à¯]', 'à®à®£à¯à®à®¿à®©à¯ à¯ªà¯«à®µà®¤à¯  à®¨à®¾à®³à¯'],
                ['LTS',                           'à¯§à¯«:à¯¨à¯«:à¯«à¯¦'],
                ['L',                             'à¯§à¯ª/à¯¦à¯¨/à¯¨à¯¦à¯§à¯¦'],
                ['LL',                            'à¯§à¯ª à®ªà®¿à®ªà¯à®°à®µà®°à®¿ à¯¨à¯¦à¯§à¯¦'],
                ['LLL',                           'à¯§à¯ª à®ªà®¿à®ªà¯à®°à®µà®°à®¿ à¯¨à¯¦à¯§à¯¦, à¯§à¯«:à¯¨à¯«'],
                ['LLLL',                          'à®à®¾à®¯à®¿à®±à¯à®±à¯à®à¯à®à®¿à®´à®®à¯, à¯§à¯ª à®ªà®¿à®ªà¯à®°à®µà®°à®¿ à¯¨à¯¦à¯§à¯¦, à¯§à¯«:à¯¨à¯«'],
                ['l',                             'à¯§à¯ª/à¯¨/à¯¨à¯¦à¯§à¯¦'],
                ['ll',                            'à¯§à¯ª à®ªà®¿à®ªà¯à®°à®µà®°à®¿ à¯¨à¯¦à¯§à¯¦'],
                ['lll',                           'à¯§à¯ª à®ªà®¿à®ªà¯à®°à®µà®°à®¿ à¯¨à¯¦à¯§à¯¦, à¯§à¯«:à¯¨à¯«'],
                ['llll',                          'à®à®¾à®¯à®¿à®±à¯, à¯§à¯ª à®ªà®¿à®ªà¯à®°à®µà®°à®¿ à¯¨à¯¦à¯§à¯¦, à¯§à¯«:à¯¨à¯«']
            ],
            b = moment(new Date(2010, 1, 14, 15, 25, 50, 125)),
            i;
        for (i = 0; i < a.length; i++) {
            assert.equal(b.format(a[i][0]), a[i][1], a[i][0] + ' ---> ' + a[i][1]);
        }
    });

    test('format ordinal', function (assert) {
        assert.equal(moment([2011, 0, 1]).format('DDDo'), 'à¯§à®µà®¤à¯', 'à¯§à®µà®¤à¯');
        assert.equal(moment([2011, 0, 2]).format('DDDo'), 'à¯¨à®µà®¤à¯', 'à¯¨à®µà®¤à¯');
        assert.equal(moment([2011, 0, 3]).format('DDDo'), 'à¯©à®µà®¤à¯', 'à¯©à®µà®¤à¯');
        assert.equal(moment([2011, 0, 4]).format('DDDo'), 'à¯ªà®µà®¤à¯', 'à¯ªà®µà®¤à¯');
        assert.equal(moment([2011, 0, 5]).format('DDDo'), 'à¯«à®µà®¤à¯', 'à¯«à®µà®¤à¯');
        assert.equal(moment([2011, 0, 6]).format('DDDo'), 'à¯¬à®µà®¤à¯', 'à¯¬à®µà®¤à¯');
        assert.equal(moment([2011, 0, 7]).format('DDDo'), 'à¯­à®µà®¤à¯', 'à¯­à®µà®¤à¯');
        assert.equal(moment([2011, 0, 8]).format('DDDo'), 'à¯®à®µà®¤à¯', 'à¯®à®µà®¤à¯');
        assert.equal(moment([2011, 0, 9]).format('DDDo'), 'à¯¯à®µà®¤à¯', 'à¯¯à®µà®¤à¯');
        assert.equal(moment([2011, 0, 10]).format('DDDo'), 'à¯§à¯¦à®µà®¤à¯', 'à¯§à¯¦à®µà®¤à¯');

        assert.equal(moment([2011, 0, 11]).format('DDDo'), 'à¯§à¯§à®µà®¤à¯', 'à¯§à¯§à®µà®¤à¯');
        assert.equal(moment([2011, 0, 12]).format('DDDo'), 'à¯§à¯¨à®µà®¤à¯', 'à¯§à¯¨à®µà®¤à¯');
        assert.equal(moment([2011, 0, 13]).format('DDDo'), 'à¯§à¯©à®µà®¤à¯', 'à¯§à¯©à®µà®¤à¯');
        assert.equal(moment([2011, 0, 14]).format('DDDo'), 'à¯§à¯ªà®µà®¤à¯', 'à¯§à¯ªà®µà®¤à¯');
        assert.equal(moment([2011, 0, 15]).format('DDDo'), 'à¯§à¯«à®µà®¤à¯', 'à¯§à¯«à®µà®¤à¯');
        assert.equal(moment([2011, 0, 16]).format('DDDo'), 'à¯§à¯¬à®µà®¤à¯', 'à¯§à¯¬à®µà®¤à¯');
        assert.equal(moment([2011, 0, 17]).format('DDDo'), 'à¯§à¯­à®µà®¤à¯', 'à¯§à¯­à®µà®¤à¯');
        assert.equal(moment([2011, 0, 18]).format('DDDo'), 'à¯§à¯®à®µà®¤à¯', 'à¯§à¯®à®µà®¤à¯');
        assert.equal(moment([2011, 0, 19]).format('DDDo'), 'à¯§à¯¯à®µà®¤à¯', 'à¯§à¯¯à®µà®¤à¯');
        assert.equal(moment([2011, 0, 20]).format('DDDo'), 'à¯¨à¯¦à®µà®¤à¯', 'à¯¨à¯¦à®µà®¤à¯');

        assert.equal(moment([2011, 0, 21]).format('DDDo'), 'à¯¨à¯§à®µà®¤à¯', 'à¯¨à¯§à®µà®¤à¯');
        assert.equal(moment([2011, 0, 22]).format('DDDo'), 'à¯¨à¯¨à®µà®¤à¯', 'à¯¨à¯¨à®µà®¤à¯');
        assert.equal(moment([2011, 0, 23]).format('DDDo'), 'à¯¨à¯©à®µà®¤à¯', 'à¯¨à¯©à®µà®¤à¯');
        assert.equal(moment([2011, 0, 24]).format('DDDo'), 'à¯¨à¯ªà®µà®¤à¯', 'à¯¨à¯ªà®µà®¤à¯');
        assert.equal(moment([2011, 0, 25]).format('DDDo'), 'à¯¨à¯«à®µà®¤à¯', 'à¯¨à¯«à®µà®¤à¯');
        assert.equal(moment([2011, 0, 26]).format('DDDo'), 'à¯¨à¯¬à®µà®¤à¯', 'à¯¨à¯¬à®µà®¤à¯');
        assert.equal(moment([2011, 0, 27]).format('DDDo'), 'à¯¨à¯­à®µà®¤à¯', 'à¯¨à¯­à®µà®¤à¯');
        assert.equal(moment([2011, 0, 28]).format('DDDo'), 'à¯¨à¯®à®µà®¤à¯', 'à¯¨à¯®à®µà®¤à¯');
        assert.equal(moment([2011, 0, 29]).format('DDDo'), 'à¯¨à¯¯à®µà®¤à¯', 'à¯¨à¯¯à®µà®¤à¯');
        assert.equal(moment([2011, 0, 30]).format('DDDo'), 'à¯©à¯¦à®µà®¤à¯', 'à¯©à¯¦à®µà®¤à¯');

        assert.equal(moment([2011, 0, 31]).format('DDDo'), 'à¯©à¯§à®µà®¤à¯', 'à¯©à¯§à®µà®¤à¯');
    });

    test('format month', function (assert) {
        var expected = 'à®à®©à®µà®°à®¿ à®à®©à®µà®°à®¿_à®ªà®¿à®ªà¯à®°à®µà®°à®¿ à®ªà®¿à®ªà¯à®°à®µà®°à®¿_à®®à®¾à®°à¯à®à¯ à®®à®¾à®°à¯à®à¯_à®à®ªà¯à®°à®²à¯ à®à®ªà¯à®°à®²à¯_à®®à¯ à®®à¯_à®à¯à®©à¯ à®à¯à®©à¯_à®à¯à®²à¯ à®à¯à®²à¯_à®à®à®¸à¯à®à¯ à®à®à®¸à¯à®à¯_à®à¯à®ªà¯à®à¯à®®à¯à®ªà®°à¯ à®à¯à®ªà¯à®à¯à®®à¯à®ªà®°à¯_à®à®à¯à®à¯à®¾à®ªà®°à¯ à®à®à¯à®à¯à®¾à®ªà®°à¯_à®¨à®µà®®à¯à®ªà®°à¯ à®¨à®µà®®à¯à®ªà®°à¯_à®à®¿à®à®®à¯à®ªà®°à¯ à®à®¿à®à®®à¯à®ªà®°à¯'.split('_'), i;
        for (i = 0; i < expected.length; i++) {
            assert.equal(moment([2011, i, 1]).format('MMMM MMM'), expected[i], expected[i]);
        }
    });

    test('format week', function (assert) {
        var expected = 'à®à®¾à®¯à®¿à®±à¯à®±à¯à®à¯à®à®¿à®´à®®à¯ à®à®¾à®¯à®¿à®±à¯ à®à®¾_à®¤à®¿à®à¯à®à®à¯à®à®¿à®´à®®à¯ à®¤à®¿à®à¯à®à®³à¯ à®¤à®¿_à®à¯à®µà¯à®µà®¾à®¯à¯à®à®¿à®´à®®à¯ à®à¯à®µà¯à®µà®¾à®¯à¯ à®à¯_à®ªà¯à®¤à®©à¯à®à®¿à®´à®®à¯ à®ªà¯à®¤à®©à¯ à®ªà¯_à®µà®¿à®¯à®¾à®´à®à¯à®à®¿à®´à®®à¯ à®µà®¿à®¯à®¾à®´à®©à¯ à®µà®¿_à®µà¯à®³à¯à®³à®¿à®à¯à®à®¿à®´à®®à¯ à®µà¯à®³à¯à®³à®¿ à®µà¯_à®à®©à®¿à®à¯à®à®¿à®´à®®à¯ à®à®©à®¿ à®'.split('_'), i;
        for (i = 0; i < expected.length; i++) {
            assert.equal(moment([2011, 0, 2 + i]).format('dddd ddd dd'), expected[i], expected[i]);
        }
    });

    test('from', function (assert) {
        var start = moment([2007, 1, 28]);
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 44}), true),  'à®à®°à¯ à®à®¿à®² à®µà®¿à®¨à®¾à®à®¿à®à®³à¯', '44 à®µà®¿à®¨à®¾à®à®¿à®à®³à¯ = à®à®°à¯ à®à®¿à®² à®µà®¿à®¨à®¾à®à®¿à®à®³à¯');
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 45}), true),  'à®à®°à¯ à®¨à®¿à®®à®¿à®à®®à¯',      '45 à®µà®¿à®¨à®¾à®à®¿à®à®³à¯ = à®à®°à¯ à®¨à®¿à®®à®¿à®à®®à¯');
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 89}), true),  'à®à®°à¯ à®¨à®¿à®®à®¿à®à®®à¯',      '89 à®µà®¿à®¨à®¾à®à®¿à®à®³à¯ = à®à®°à¯ à®¨à®¿à®®à®¿à®à®®à¯');
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 90}), true),  'à¯¨ à®¨à®¿à®®à®¿à®à®à¯à®à®³à¯',     '90 à®µà®¿à®¨à®¾à®à®¿à®à®³à¯ = à¯¨ à®¨à®¿à®®à®¿à®à®à¯à®à®³à¯');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 44}), true),  'à¯ªà¯ª à®¨à®¿à®®à®¿à®à®à¯à®à®³à¯',    '44 à®¨à®¿à®®à®¿à®à®à¯à®à®³à¯ = 44 à®¨à®¿à®®à®¿à®à®à¯à®à®³à¯');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 45}), true),  'à®à®°à¯ à®®à®£à®¿ à®¨à¯à®°à®®à¯',       '45 à®¨à®¿à®®à®¿à®à®à¯à®à®³à¯ = à®à®°à¯ à®®à®£à®¿ à®¨à¯à®°à®®à¯');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 89}), true),  'à®à®°à¯ à®®à®£à®¿ à®¨à¯à®°à®®à¯',       '89 à®¨à®¿à®®à®¿à®à®à¯à®à®³à¯ = à®à®°à¯ à®®à®£à®¿ à®¨à¯à®°à®®à¯');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 90}), true),  'à¯¨ à®®à®£à®¿ à®¨à¯à®°à®®à¯',       '90 à®¨à®¿à®®à®¿à®à®à¯à®à®³à¯ = à¯¨ à®®à®£à®¿ à®¨à¯à®°à®®à¯');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 5}), true),   'à¯« à®®à®£à®¿ à®¨à¯à®°à®®à¯',       '5 à®®à®£à®¿ à®¨à¯à®°à®®à¯ = 5 à®®à®£à®¿ à®¨à¯à®°à®®à¯');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 21}), true),  'à¯¨à¯§ à®®à®£à®¿ à®¨à¯à®°à®®à¯',      'à¯¨à¯§ à®®à®£à®¿ à®¨à¯à®°à®®à¯ = à¯¨à¯§ à®®à®£à®¿ à®¨à¯à®°à®®à¯');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 22}), true),  'à®à®°à¯ à®¨à®¾à®³à¯',         'à¯¨à¯¨ à®®à®£à®¿ à®¨à¯à®°à®®à¯ = à®à®°à¯ à®¨à®¾à®³à¯');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 35}), true),  'à®à®°à¯ à®¨à®¾à®³à¯',         'à¯©5 à®®à®£à®¿ à®¨à¯à®°à®®à¯ = à®à®°à¯ à®¨à®¾à®³à¯');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 36}), true),  'à¯¨ à®¨à®¾à®à¯à®à®³à¯',        'à¯©6 à®®à®£à®¿ à®¨à¯à®°à®®à¯ = à¯¨ days');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 1}), true),   'à®à®°à¯ à®¨à®¾à®³à¯',         'à¯§ à®¨à®¾à®³à¯ = à®à®°à¯ à®¨à®¾à®³à¯');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 5}), true),   'à¯« à®¨à®¾à®à¯à®à®³à¯',        '5 à®¨à®¾à®à¯à®à®³à¯ = 5 à®¨à®¾à®à¯à®à®³à¯');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 25}), true),  'à¯¨à¯« à®¨à®¾à®à¯à®à®³à¯',       'à¯¨5 à®¨à®¾à®à¯à®à®³à¯ = à¯¨5 à®¨à®¾à®à¯à®à®³à¯');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 26}), true),  'à®à®°à¯ à®®à®¾à®¤à®®à¯',       'à¯¨6 à®¨à®¾à®à¯à®à®³à¯ = à®à®°à¯ à®®à®¾à®¤à®®à¯');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 30}), true),  'à®à®°à¯ à®®à®¾à®¤à®®à¯',       'à¯©0 à®¨à®¾à®à¯à®à®³à¯ = à®à®°à¯ à®®à®¾à®¤à®®à¯');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 43}), true),  'à®à®°à¯ à®®à®¾à®¤à®®à¯',       '45 à®¨à®¾à®à¯à®à®³à¯ = à®à®°à¯ à®®à®¾à®¤à®®à¯');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 46}), true),  'à¯¨ à®®à®¾à®¤à®à¯à®à®³à¯',      '46 à®¨à®¾à®à¯à®à®³à¯ = à¯¨ à®®à®¾à®¤à®à¯à®à®³à¯');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 74}), true),  'à¯¨ à®®à®¾à®¤à®à¯à®à®³à¯',      '75 à®¨à®¾à®à¯à®à®³à¯ = à¯¨ à®®à®¾à®¤à®à¯à®à®³à¯');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 76}), true),  'à¯© à®®à®¾à®¤à®à¯à®à®³à¯',      '76 à®¨à®¾à®à¯à®à®³à¯ = à¯© à®®à®¾à®¤à®à¯à®à®³à¯');
        assert.equal(start.from(moment([2007, 1, 28]).add({M: 1}), true),   'à®à®°à¯ à®®à®¾à®¤à®®à¯',       'à¯§ à®®à®¾à®¤à®®à¯ = à®à®°à¯ à®®à®¾à®¤à®®à¯');
        assert.equal(start.from(moment([2007, 1, 28]).add({M: 5}), true),   'à¯« à®®à®¾à®¤à®à¯à®à®³à¯',      '5 à®®à®¾à®¤à®à¯à®à®³à¯ = 5 à®®à®¾à®¤à®à¯à®à®³à¯');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 345}), true), 'à®à®°à¯ à®µà®°à¯à®à®®à¯',        'à¯©45 à®¨à®¾à®à¯à®à®³à¯ = à®à®°à¯ à®µà®°à¯à®à®®à¯');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 548}), true), 'à¯¨ à®à®£à¯à®à¯à®à®³à¯',       '548 à®¨à®¾à®à¯à®à®³à¯ = à¯¨ à®à®£à¯à®à¯à®à®³à¯');
        assert.equal(start.from(moment([2007, 1, 28]).add({y: 1}), true),   'à®à®°à¯ à®µà®°à¯à®à®®à¯',        'à¯§ à®µà®°à¯à®à®®à¯ = à®à®°à¯ à®µà®°à¯à®à®®à¯');
        assert.equal(start.from(moment([2007, 1, 28]).add({y: 5}), true),   'à¯« à®à®£à¯à®à¯à®à®³à¯',       '5 à®à®£à¯à®à¯à®à®³à¯ = 5 à®à®£à¯à®à¯à®à®³à¯');
    });

    test('suffix', function (assert) {
        assert.equal(moment(30000).from(0), 'à®à®°à¯ à®à®¿à®² à®µà®¿à®¨à®¾à®à®¿à®à®³à¯ à®à®²à¯',  'prefix');
        assert.equal(moment(0).from(30000), 'à®à®°à¯ à®à®¿à®² à®µà®¿à®¨à®¾à®à®¿à®à®³à¯ à®®à¯à®©à¯', 'suffix');
    });

    test('now from now', function (assert) {
        assert.equal(moment().fromNow(), 'à®à®°à¯ à®à®¿à®² à®µà®¿à®¨à®¾à®à®¿à®à®³à¯ à®®à¯à®©à¯',  'à®à®ªà¯à®ªà¯à®¾à®¤à¯ à®à®°à¯à®¨à¯à®¤à¯ à®à®à®¨à¯à®¤ à®à®¾à®²à®¤à¯à®¤à®¿à®²à¯ à®à®¾à®à¯à® à®µà¯à®£à¯à®à¯à®®à¯');
    });

    test('fromNow', function (assert) {
        assert.equal(moment().add({s: 30}).fromNow(), 'à®à®°à¯ à®à®¿à®² à®µà®¿à®¨à®¾à®à®¿à®à®³à¯ à®à®²à¯', 'à®à®°à¯ à®à®¿à®² à®µà®¿à®¨à®¾à®à®¿à®à®³à¯ à®à®²à¯');
        assert.equal(moment().add({d: 5}).fromNow(), 'à¯« à®¨à®¾à®à¯à®à®³à¯ à®à®²à¯', '5 à®¨à®¾à®à¯à®à®³à¯ à®à®²à¯');
    });

    test('calendar day', function (assert) {
        var a = moment().hours(12).minutes(0).seconds(0);

        assert.equal(moment(a).calendar(),                   'à®à®©à¯à®±à¯ à¯§à¯¨:à¯¦à¯¦',   'à®à®©à¯à®±à¯  12:00');
        assert.equal(moment(a).add({m: 25}).calendar(),      'à®à®©à¯à®±à¯ à¯§à¯¨:à¯¨à¯«',   'à®à®©à¯à®±à¯  12:25');
        assert.equal(moment(a).add({h: 1}).calendar(),       'à®à®©à¯à®±à¯ à¯§à¯©:à¯¦à¯¦',   'à®à®©à¯à®±à¯  13:00');
        assert.equal(moment(a).add({d: 1}).calendar(),       'à®¨à®¾à®³à¯ à¯§à¯¨:à¯¦à¯¦',    'à®¨à®¾à®³à¯  12:00');
        assert.equal(moment(a).subtract({h: 1}).calendar(),  'à®à®©à¯à®±à¯ à¯§à¯§:à¯¦à¯¦',   'à®à®©à¯à®±à¯  11:00');
        assert.equal(moment(a).subtract({d: 1}).calendar(),  'à®¨à¯à®±à¯à®±à¯ à¯§à¯¨:à¯¦à¯¦',  'à®¨à¯à®±à¯à®±à¯  12:00');
    });

    test('calendar next week', function (assert) {
        var i, m;
        for (i = 2; i < 7; i++) {
            m = moment().add({d: i});
            assert.equal(m.calendar(),       m.format('dddd, LT'),  'Today + ' + i + ' days current time');
            m.hours(0).minutes(0).seconds(0).milliseconds(0);
            assert.equal(m.calendar(),       m.format('dddd, LT'),  'Today + ' + i + ' days beginning of day');
            m.hours(23).minutes(59).seconds(59).milliseconds(999);
            assert.equal(m.calendar(),       m.format('dddd, LT'),  'Today + ' + i + ' days end of day');
        }
    });

    test('calendar last week', function (assert) {
        var i, m;

        for (i = 2; i < 7; i++) {
            m = moment().subtract({d: i});
            assert.equal(m.calendar(),       m.format('[à®à®à®¨à¯à®¤ à®µà®¾à®°à®®à¯] dddd, LT'),  'Today - ' + i + ' days current time');
            m.hours(0).minutes(0).seconds(0).milliseconds(0);
            assert.equal(m.calendar(),       m.format('[à®à®à®¨à¯à®¤ à®µà®¾à®°à®®à¯] dddd, LT'),  'Today - ' + i + ' days beginning of day');
            m.hours(23).minutes(59).seconds(59).milliseconds(999);
            assert.equal(m.calendar(),       m.format('[à®à®à®¨à¯à®¤ à®µà®¾à®°à®®à¯] dddd, LT'),  'Today - ' + i + ' days end of day');
        }
    });

    test('calendar all else', function (assert) {
        var weeksAgo = moment().subtract({w: 1}),
            weeksFromNow = moment().add({w: 1});

        assert.equal(weeksAgo.calendar(),       weeksAgo.format('L'),  '1 week ago');
        assert.equal(weeksFromNow.calendar(),   weeksFromNow.format('L'),  'in 1 week');

        weeksAgo = moment().subtract({w: 2});
        weeksFromNow = moment().add({w: 2});

        assert.equal(weeksAgo.calendar(),       weeksAgo.format('L'),  '2 weeks ago');
        assert.equal(weeksFromNow.calendar(),   weeksFromNow.format('L'),  'in 2 weeks');
    });

    test('meridiem', function (assert) {
        assert.equal(moment([2011, 2, 23,  0, 30]).format('a'), ' à®¯à®¾à®®à®®à¯', '(after) midnight');
        assert.equal(moment([2011, 2, 23,  2, 30]).format('a'), ' à®µà¯à®à®±à¯', 'before dawn');
        assert.equal(moment([2011, 2, 23,  9, 30]).format('a'), ' à®à®¾à®²à¯', 'morning');
        assert.equal(moment([2011, 2, 23, 14, 30]).format('a'), ' à®à®±à¯à®ªà®¾à®à¯', 'during day');
        assert.equal(moment([2011, 2, 23, 17, 30]).format('a'), ' à®à®±à¯à®ªà®¾à®à¯', 'evening');
        assert.equal(moment([2011, 2, 23, 19, 30]).format('a'), ' à®®à®¾à®²à¯', 'late evening');
        assert.equal(moment([2011, 2, 23, 23, 30]).format('a'), ' à®¯à®¾à®®à®®à¯', '(before) midnight');
    });

}));

;(function (global, factory) {
   typeof exports === 'object' && typeof module !== 'undefined'
       && typeof require === 'function' ? factory(require('../../moment')) :
   typeof define === 'function' && define.amd ? define(['../../moment'], factory) :
   factory(global.moment)
}(this, function (moment) { 'use strict';

    function each(array, callback) {
        var i;
        for (i = 0; i < array.length; i++) {
            callback(array[i], i, array);
        }
    }

    function objectKeys(obj) {
        if (Object.keys) {
            return Object.keys(obj);
        } else {
            // IE8
            var res = [], i;
            for (i in obj) {
                if (obj.hasOwnProperty(i)) {
                    res.push(i);
                }
            }
            return res;
        }
    }

    // Pick the first defined of two or three arguments.
    function defaults(a, b, c) {
        if (a != null) {
            return a;
        }
        if (b != null) {
            return b;
        }
        return c;
    }

    function defineCommonLocaleTests(locale, options) {
        test('lenient ordinal parsing', function (assert) {
            var i, ordinalStr, testMoment;
            for (i = 1; i <= 31; ++i) {
                ordinalStr = moment([2014, 0, i]).format('YYYY MM Do');
                testMoment = moment(ordinalStr, 'YYYY MM Do');
                assert.equal(testMoment.year(), 2014,
                        'lenient ordinal parsing ' + i + ' year check');
                assert.equal(testMoment.month(), 0,
                        'lenient ordinal parsing ' + i + ' month check');
                assert.equal(testMoment.date(), i,
                        'lenient ordinal parsing ' + i + ' date check');
            }
        });

        test('lenient ordinal parsing of number', function (assert) {
            var i, testMoment;
            for (i = 1; i <= 31; ++i) {
                testMoment = moment('2014 01 ' + i, 'YYYY MM Do');
                assert.equal(testMoment.year(), 2014,
                        'lenient ordinal parsing of number ' + i + ' year check');
                assert.equal(testMoment.month(), 0,
                        'lenient ordinal parsing of number ' + i + ' month check');
                assert.equal(testMoment.date(), i,
                        'lenient ordinal parsing of number ' + i + ' date check');
            }
        });

        test('strict ordinal parsing', function (assert) {
            var i, ordinalStr, testMoment;
            for (i = 1; i <= 31; ++i) {
                ordinalStr = moment([2014, 0, i]).format('YYYY MM Do');
                testMoment = moment(ordinalStr, 'YYYY MM Do', true);
                assert.ok(testMoment.isValid(), 'strict ordinal parsing ' + i);
            }
        });

        test('meridiem invariant', function (assert) {
            var h, m, t1, t2;
            for (h = 0; h < 24; ++h) {
                for (m = 0; m < 60; m += 15) {
                    t1 = moment.utc([2000, 0, 1, h, m]);
                    t2 = moment.utc(t1.format('A h:mm'), 'A h:mm');
                    assert.equal(t2.format('HH:mm'), t1.format('HH:mm'),
                            'meridiem at ' + t1.format('HH:mm'));
                }
            }
        });

        test('date format correctness', function (assert) {
            var data, tokens;
            data = moment.localeData()._longDateFormat;
            tokens = objectKeys(data);
            each(tokens, function (srchToken) {
                // Check each format string to make sure it does not contain any
                // tokens that need to be expanded.
                each(tokens, function (baseToken) {
                    // strip escaped sequences
                    var format = data[baseToken].replace(/(\[[^\]]*\])/g, '');
                    assert.equal(false, !!~format.indexOf(srchToken),
                            'contains ' + srchToken + ' in ' + baseToken);
                });
            });
        });

        test('month parsing correctness', function (assert) {
            var i, m;

            if (locale === 'tr') {
                // I can't fix it :(
                expect(0);
                return;
            }
            function tester(format) {
                var r;
                r = moment(m.format(format), format);
                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format);
                r = moment(m.format(format).toLocaleUpperCase(), format);
                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' upper');
                r = moment(m.format(format).toLocaleLowerCase(), format);
                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' lower');

                r = moment(m.format(format), format, true);
                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' strict');
                r = moment(m.format(format).toLocaleUpperCase(), format, true);
                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' upper strict');
                r = moment(m.format(format).toLocaleLowerCase(), format, true);
                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' lower strict');
            }

            for (i = 0; i < 12; ++i) {
                m = moment([2015, i, 15, 18]);
                tester('MMM');
                tester('MMM.');
                tester('MMMM');
                tester('MMMM.');
            }
        });

        test('weekday parsing correctness', function (assert) {
            var i, m;

            if (locale === 'tr' || locale === 'az') {
                // There is a lower-case letter (Ä±), that converted to upper then
                // lower changes to i
                expect(0);
                return;
            }
            function tester(format) {
                var r, baseMsg = 'weekday ' + m.weekday() + ' fmt ' + format;
                r = moment(m.format(format), format);
                assert.equal(r.weekday(), m.weekday(), baseMsg);
                r = moment(m.format(format).toLocaleUpperCase(), format);
                assert.equal(r.weekday(), m.weekday(), baseMsg + ' upper');
                r = moment(m.format(format).toLocaleLowerCase(), format);
                assert.equal(r.weekday(), m.weekday(), baseMsg + ' lower');

                r = moment(m.format(format), format, true);
                assert.equal(r.weekday(), m.weekday(), baseMsg + ' strict');
                r = moment(m.format(format).toLocaleUpperCase(), format, true);
                assert.equal(r.weekday(), m.weekday(), baseMsg + ' upper strict');
                r = moment(m.format(format).toLocaleLowerCase(), format, true);
                assert.equal(r.weekday(), m.weekday(), baseMsg + ' lower strict');
            }

            for (i = 0; i < 7; ++i) {
                m = moment.utc([2015, i, 15, 18]);
                tester('dd');
                tester('ddd');
                tester('dddd');
            }
        });
    }

    function setupDeprecationHandler(test, moment, scope) {
        test._expectedDeprecations = null;
        test._observedDeprecations = null;
        test._oldSupress = moment.suppressDeprecationWarnings;
        moment.suppressDeprecationWarnings = true;
        test.expectedDeprecations = function () {
            test._expectedDeprecations = arguments;
            test._observedDeprecations = [];
        };
        moment.deprecationHandler = function (name, msg) {
            var deprecationId = matchedDeprecation(name, msg, test._expectedDeprecations);
            if (deprecationId === -1) {
                throw new Error('Unexpected deprecation thrown name=' +
                        name + ' msg=' + msg);
            }
            test._observedDeprecations[deprecationId] = 1;
        };
    }

    function teardownDeprecationHandler(test, moment, scope) {
        moment.suppressDeprecationWarnings = test._oldSupress;

        if (test._expectedDeprecations != null) {
            var missedDeprecations = [];
            each(test._expectedDeprecations, function (deprecationPattern, id) {
                if (test._observedDeprecations[id] !== 1) {
                    missedDeprecations.push(deprecationPattern);
                }
            });
            if (missedDeprecations.length !== 0) {
                throw new Error('Expected deprecation warnings did not happen: ' +
                        missedDeprecations.join(' '));
            }
        }
    }

    function matchedDeprecation(name, msg, deprecations) {
        if (deprecations == null) {
            return -1;
        }
        for (var i = 0; i < deprecations.length; ++i) {
            if (name != null && name === deprecations[i]) {
                return i;
            }
            if (msg != null && msg.substring(0, deprecations[i].length) === deprecations[i]) {
                return i;
            }
        }
        return -1;
    }

    /*global QUnit:false*/

    var test = QUnit.test;

    var expect = QUnit.expect;

    function module (name, lifecycle) {
        QUnit.module(name, {
            setup : function () {
                moment.locale('en');
                moment.createFromInputFallback = function (config) {
                    throw new Error('input not handled by moment: ' + config._i);
                };
                setupDeprecationHandler(test, moment, 'core');
                if (lifecycle && lifecycle.setup) {
                    lifecycle.setup();
                }
            },
            teardown : function () {
                teardownDeprecationHandler(test, moment, 'core');
                if (lifecycle && lifecycle.teardown) {
                    lifecycle.teardown();
                }
            }
        });
    }

    function localeModule (name, lifecycle) {
        QUnit.module('locale:' + name, {
            setup : function () {
                moment.locale(name);
                moment.createFromInputFallback = function (config) {
                    throw new Error('input not handled by moment: ' + config._i);
                };
                setupDeprecationHandler(test, moment, 'locale');
                if (lifecycle && lifecycle.setup) {
                    lifecycle.setup();
                }
            },
            teardown : function () {
                moment.locale('en');
                teardownDeprecationHandler(test, moment, 'locale');
                if (lifecycle && lifecycle.teardown) {
                    lifecycle.teardown();
                }
            }
        });
        defineCommonLocaleTests(name, -1, -1);
    }

    localeModule('te');

    test('parse', function (assert) {
        var tests = 'à°à°¨à°µà°°à°¿ à°à°¨._à°«à°¿à°¬à±à°°à°µà°°à°¿ à°«à°¿à°¬à±à°°._à°®à°¾à°°à±à°à°¿ à°®à°¾à°°à±à°à°¿_à°à°ªà±à°°à°¿à°²à± à°à°ªà±à°°à°¿._à°®à± à°®à±_à°à±à°¨à± à°à±à°¨à±_à°à±à°²à±à± à°à±à°²à±à±_à°à°à°¸à±à°à± à°à°._à°¸à±à°ªà±à°à±à°à°¬à°°à± à°¸à±à°ªà±._à°à°à±à°à±à°¬à°°à± à°à°à±à°à±._à°¨à°µà°à°¬à°°à± à°¨à°µ._à°¡à°¿à°¸à±à°à°¬à°°à± à°¡à°¿à°¸à±.'.split('_'), i;
        function equalTest(input, mmm, i) {
            assert.equal(moment(input, mmm).month(), i, input + ' should be month ' + (i + 1));
        }
        for (i = 0; i < 12; i++) {
            tests[i] = tests[i].split(' ');
            equalTest(tests[i][0], 'MMM', i);
            equalTest(tests[i][1], 'MMM', i);
            equalTest(tests[i][0], 'MMMM', i);
            equalTest(tests[i][1], 'MMMM', i);
            equalTest(tests[i][0].toLocaleLowerCase(), 'MMMM', i);
            equalTest(tests[i][1].toLocaleLowerCase(), 'MMMM', i);
            equalTest(tests[i][0].toLocaleUpperCase(), 'MMMM', i);
            equalTest(tests[i][1].toLocaleUpperCase(), 'MMMM', i);
        }
    });

    test('format', function (assert) {
        var a = [
                ['dddd, Do à°¤à±à°¦à± MMMM YYYY, a h:mm:ss',  'à°à°¦à°¿à°µà°¾à°°à°, 14à°µ à°¤à±à°¦à± à°«à°¿à°¬à±à°°à°µà°°à°¿ 2010, à°®à°§à±à°¯à°¾à°¹à±à°¨à° 3:25:50'],
                ['ddd, a h à°à°à°à°²à±',                 'à°à°¦à°¿, à°®à°§à±à°¯à°¾à°¹à±à°¨à° 3 à°à°à°à°²à±'],
                ['M Mo à°¨à±à°² MM MMMM MMM',                   '2 2à°µ à°¨à±à°² 02 à°«à°¿à°¬à±à°°à°µà°°à°¿ à°«à°¿à°¬à±à°°.'],
                ['YYYY YY',                            '2010 10'],
                ['D Do DD',                            '14 14à°µ 14'],
                ['d do dddd ddd dd',                   '0 0à°µ à°à°¦à°¿à°µà°¾à°°à° à°à°¦à°¿ à°'],
                ['DDD DDDo DDDD',                      '45 45à°µ 045'],
                ['w wo ww',                            '8 8à°µ 08'],
                ['h hh',                               '3 03'],
                ['H HH',                               '15 15'],
                ['m mm',                               '25 25'],
                ['s ss',                               '50 50'],
                ['a A',                                'à°®à°§à±à°¯à°¾à°¹à±à°¨à° à°®à°§à±à°¯à°¾à°¹à±à°¨à°'],
                ['LTS',                                'à°®à°§à±à°¯à°¾à°¹à±à°¨à° 3:25:50'],
                ['L',                                  '14/02/2010'],
                ['LL',                                 '14 à°«à°¿à°¬à±à°°à°µà°°à°¿ 2010'],
                ['LLL',                                '14 à°«à°¿à°¬à±à°°à°µà°°à°¿ 2010, à°®à°§à±à°¯à°¾à°¹à±à°¨à° 3:25'],
                ['LLLL',                               'à°à°¦à°¿à°µà°¾à°°à°, 14 à°«à°¿à°¬à±à°°à°µà°°à°¿ 2010, à°®à°§à±à°¯à°¾à°¹à±à°¨à° 3:25'],
                ['l',                                  '14/2/2010'],
                ['ll',                                 '14 à°«à°¿à°¬à±à°°. 2010'],
                ['lll',                                '14 à°«à°¿à°¬à±à°°. 2010, à°®à°§à±à°¯à°¾à°¹à±à°¨à° 3:25'],
                ['llll',                               'à°à°¦à°¿, 14 à°«à°¿à°¬à±à°°. 2010, à°®à°§à±à°¯à°¾à°¹à±à°¨à° 3:25']
            ],
            b = moment(new Date(2010, 1, 14, 15, 25, 50, 125)),
            i;
        for (i = 0; i < a.length; i++) {
            assert.equal(b.format(a[i][0]), a[i][1], a[i][0] + ' ---> ' + a[i][1]);
        }
    });

    test('format ordinal', function (assert) {
        assert.equal(moment([2011, 0, 1]).format('DDDo'), '1à°µ', '1à°µ');
        assert.equal(moment([2011, 0, 2]).format('DDDo'), '2à°µ', '2à°µ');
        assert.equal(moment([2011, 0, 3]).format('DDDo'), '3à°µ', '3à°µ');
        assert.equal(moment([2011, 0, 4]).format('DDDo'), '4à°µ', '4à°µ');
        assert.equal(moment([2011, 0, 5]).format('DDDo'), '5à°µ', '5à°µ');
        assert.equal(moment([2011, 0, 6]).format('DDDo'), '6à°µ', '6à°µ');
        assert.equal(moment([2011, 0, 7]).format('DDDo'), '7à°µ', '7à°µ');
        assert.equal(moment([2011, 0, 8]).format('DDDo'), '8à°µ', '8à°µ');
        assert.equal(moment([2011, 0, 9]).format('DDDo'), '9à°µ', '9à°µ');
        assert.equal(moment([2011, 0, 10]).format('DDDo'), '10à°µ', '10à°µ');

        assert.equal(moment([2011, 0, 11]).format('DDDo'), '11à°µ', '11à°µ');
        assert.equal(moment([2011, 0, 12]).format('DDDo'), '12à°µ', '12à°µ');
        assert.equal(moment([2011, 0, 13]).format('DDDo'), '13à°µ', '13à°µ');
        assert.equal(moment([2011, 0, 14]).format('DDDo'), '14à°µ', '14à°µ');
        assert.equal(moment([2011, 0, 15]).format('DDDo'), '15à°µ', '15à°µ');
        assert.equal(moment([2011, 0, 16]).format('DDDo'), '16à°µ', '16à°µ');
        assert.equal(moment([2011, 0, 17]).format('DDDo'), '17à°µ', '17à°µ');
        assert.equal(moment([2011, 0, 18]).format('DDDo'), '18à°µ', '18à°µ');
        assert.equal(moment([2011, 0, 19]).format('DDDo'), '19à°µ', '19à°µ');
        assert.equal(moment([2011, 0, 20]).format('DDDo'), '20à°µ', '20à°µ');

        assert.equal(moment([2011, 0, 21]).format('DDDo'), '21à°µ', '21à°µ');
        assert.equal(moment([2011, 0, 22]).format('DDDo'), '22à°µ', '22à°µ');
        assert.equal(moment([2011, 0, 23]).format('DDDo'), '23à°µ', '23à°µ');
        assert.equal(moment([2011, 0, 24]).format('DDDo'), '24à°µ', '24à°µ');
        assert.equal(moment([2011, 0, 25]).format('DDDo'), '25à°µ', '25à°µ');
        assert.equal(moment([2011, 0, 26]).format('DDDo'), '26à°µ', '26à°µ');
        assert.equal(moment([2011, 0, 27]).format('DDDo'), '27à°µ', '27à°µ');
        assert.equal(moment([2011, 0, 28]).format('DDDo'), '28à°µ', '28à°µ');
        assert.equal(moment([2011, 0, 29]).format('DDDo'), '29à°µ', '29à°µ');
        assert.equal(moment([2011, 0, 30]).format('DDDo'), '30à°µ', '30à°µ');

        assert.equal(moment([2011, 0, 31]).format('DDDo'), '31à°µ', '31à°µ');
    });

    test('format month', function (assert) {
        var expected = 'à°à°¨à°µà°°à°¿ à°à°¨._à°«à°¿à°¬à±à°°à°µà°°à°¿ à°«à°¿à°¬à±à°°._à°®à°¾à°°à±à°à°¿ à°®à°¾à°°à±à°à°¿_à°à°ªà±à°°à°¿à°²à± à°à°ªà±à°°à°¿._à°®à± à°®à±_à°à±à°¨à± à°à±à°¨à±_à°à±à°²à±à± à°à±à°²à±à±_à°à°à°¸à±à°à± à°à°._à°¸à±à°ªà±à°à±à°à°¬à°°à± à°¸à±à°ªà±._à°à°à±à°à±à°¬à°°à± à°à°à±à°à±._à°¨à°µà°à°¬à°°à± à°¨à°µ._à°¡à°¿à°¸à±à°à°¬à°°à± à°¡à°¿à°¸à±.'.split('_'), i;
        for (i = 0; i < expected.length; i++) {
            assert.equal(moment([2011, i, 1]).format('MMMM MMM'), expected[i], expected[i]);
        }
    });

    test('format week', function (assert) {
        var expected = 'à°à°¦à°¿à°µà°¾à°°à° à°à°¦à°¿ à°_à°¸à±à°®à°µà°¾à°°à° à°¸à±à°® à°¸à±_à°®à°à°à°³à°µà°¾à°°à° à°®à°à°à°³ à°®à°_à°¬à±à°§à°µà°¾à°°à° à°¬à±à°§ à°¬à±_à°à±à°°à±à°µà°¾à°°à° à°à±à°°à± à°à±_à°¶à±à°à±à°°à°µà°¾à°°à° à°¶à±à°à±à°° à°¶à±_à°¶à°¨à°¿à°µà°¾à°°à° à°¶à°¨à°¿ à°¶'.split('_'), i;
        for (i = 0; i < expected.length; i++) {
            assert.equal(moment([2011, 0, 2 + i]).format('dddd ddd dd'), expected[i], expected[i]);
        }
    });

    test('from', function (assert) {
        var start = moment([2007, 1, 28]);
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 44}), true),  'à°à±à°¨à±à°¨à°¿ à°à±à°·à°£à°¾à°²à±', '44 seconds = a few seconds');
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 45}), true),  'à°à° à°¨à°¿à°®à°¿à°·à°',      '45 seconds = a minute');
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 89}), true),  'à°à° à°¨à°¿à°®à°¿à°·à°',      '89 seconds = a minute');
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 90}), true),  '2 à°¨à°¿à°®à°¿à°·à°¾à°²à±',     '90 seconds = 2 minutes');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 44}), true),  '44 à°¨à°¿à°®à°¿à°·à°¾à°²à±',    '44 minutes = 44 minutes');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 45}), true),  'à°à° à°à°à°',       '45 minutes = an hour');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 89}), true),  'à°à° à°à°à°',       '89 minutes = an hour');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 90}), true),  '2 à°à°à°à°²à±',       '90 minutes = 2 hours');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 5}), true),   '5 à°à°à°à°²à±',       '5 hours = 5 hours');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 21}), true),  '21 à°à°à°à°²à±',      '21 hours = 21 hours');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 22}), true),  'à°à° à°°à±à°à±',         '22 hours = a day');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 35}), true),  'à°à° à°°à±à°à±',         '35 hours = a day');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 36}), true),  '2 à°°à±à°à±à°²à±',        '36 hours = 2 days');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 1}), true),   'à°à° à°°à±à°à±',         '1 day = a day');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 5}), true),   '5 à°°à±à°à±à°²à±',        '5 days = 5 days');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 25}), true),  '25 à°°à±à°à±à°²à±',       '25 days = 25 days');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 26}), true),  'à°à° à°¨à±à°²',       '26 days = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 30}), true),  'à°à° à°¨à±à°²',       '30 days = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 43}), true),  'à°à° à°¨à±à°²',       '43 days = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 46}), true),  '2 à°¨à±à°²à°²à±',      '46 days = 2 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 74}), true),  '2 à°¨à±à°²à°²à±',      '75 days = 2 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 76}), true),  '3 à°¨à±à°²à°²à±',      '76 days = 3 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({M: 1}), true),   'à°à° à°¨à±à°²',       '1 month = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({M: 5}), true),   '5 à°¨à±à°²à°²à±',      '5 months = 5 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 345}), true), 'à°à° à°¸à°à°µà°¤à±à°¸à°°à°',        '345 days = a year');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 548}), true), '2 à°¸à°à°µà°¤à±à°¸à°°à°¾à°²à±',       '548 days = 2 years');
        assert.equal(start.from(moment([2007, 1, 28]).add({y: 1}), true),   'à°à° à°¸à°à°µà°¤à±à°¸à°°à°',        '1 year = a year');
        assert.equal(start.from(moment([2007, 1, 28]).add({y: 5}), true),   '5 à°¸à°à°µà°¤à±à°¸à°°à°¾à°²à±',       '5 years = 5 years');
    });

    test('suffix', function (assert) {
        assert.equal(moment(30000).from(0), 'à°à±à°¨à±à°¨à°¿ à°à±à°·à°£à°¾à°²à± à°²à±',  'prefix');
        assert.equal(moment(0).from(30000), 'à°à±à°¨à±à°¨à°¿ à°à±à°·à°£à°¾à°²à± à°à±à°°à°¿à°¤à°', 'suffix');
    });

    test('now from now', function (assert) {
        assert.equal(moment().fromNow(), 'à°à±à°¨à±à°¨à°¿ à°à±à°·à°£à°¾à°²à± à°à±à°°à°¿à°¤à°',  'now from now should display as in the past');
    });

    test('fromNow', function (assert) {
        assert.equal(moment().add({s: 30}).fromNow(), 'à°à±à°¨à±à°¨à°¿ à°à±à°·à°£à°¾à°²à± à°²à±', 'à°à±à°¨à±à°¨à°¿ à°à±à°·à°£à°¾à°²à± à°²à±');
        assert.equal(moment().add({d: 5}).fromNow(), '5 à°°à±à°à±à°²à± à°²à±', '5 à°°à±à°à±à°²à± à°²à±');
    });

    test('calendar day', function (assert) {
        var a = moment().hours(12).minutes(0).seconds(0);

        assert.equal(moment(a).calendar(),                   'à°¨à±à°¡à± à°®à°§à±à°¯à°¾à°¹à±à°¨à° 12:00',   'today at the same time');
        assert.equal(moment(a).add({m: 25}).calendar(),      'à°¨à±à°¡à± à°®à°§à±à°¯à°¾à°¹à±à°¨à° 12:25',   'Now plus 25 min');
        assert.equal(moment(a).add({h: 3}).calendar(),       'à°¨à±à°¡à± à°®à°§à±à°¯à°¾à°¹à±à°¨à° 3:00',    'Now plus 3 hours');
        assert.equal(moment(a).add({d: 1}).calendar(),       'à°°à±à°ªà± à°®à°§à±à°¯à°¾à°¹à±à°¨à° 12:00',   'tomorrow at the same time');
        assert.equal(moment(a).subtract({h: 1}).calendar(),  'à°¨à±à°¡à± à°®à°§à±à°¯à°¾à°¹à±à°¨à° 11:00',   'Now minus 1 hour');
        assert.equal(moment(a).subtract({d: 1}).calendar(),  'à°¨à°¿à°¨à±à°¨ à°®à°§à±à°¯à°¾à°¹à±à°¨à° 12:00',  'yesterday at the same time');
    });

    test('calendar next week', function (assert) {
        var i, m;
        for (i = 2; i < 7; i++) {
            m = moment().add({d: i});
            assert.equal(m.calendar(),       m.format('dddd[,] LT'),  'Today + ' + i + ' days current time');
            m.hours(0).minutes(0).seconds(0).milliseconds(0);
            assert.equal(m.calendar(),       m.format('dddd[,] LT'),  'Today + ' + i + ' days beginning of day');
            m.hours(23).minutes(59).seconds(59).milliseconds(999);
            assert.equal(m.calendar(),       m.format('dddd[,] LT'),  'Today + ' + i + ' days end of day');
        }
    });

    test('calendar last week', function (assert) {
        var i, m;

        for (i = 2; i < 7; i++) {
            m = moment().subtract({d: i});
            assert.equal(m.calendar(),       m.format('[à°à°¤] dddd[,] LT'),  'Today - ' + i + ' days current time');
            m.hours(0).minutes(0).seconds(0).milliseconds(0);
            assert.equal(m.calendar(),       m.format('[à°à°¤] dddd[,] LT'),  'Today - ' + i + ' days beginning of day');
            m.hours(23).minutes(59).seconds(59).milliseconds(999);
            assert.equal(m.calendar(),       m.format('[à°à°¤] dddd[,] LT'),  'Today - ' + i + ' days end of day');
        }
    });

    test('calendar all else', function (assert) {
        var weeksAgo = moment().subtract({w: 1}),
            weeksFromNow = moment().add({w: 1});

        assert.equal(weeksAgo.calendar(),       weeksAgo.format('L'),  '1 week ago');
        assert.equal(weeksFromNow.calendar(),   weeksFromNow.format('L'),  'in 1 week');

        weeksAgo = moment().subtract({w: 2});
        weeksFromNow = moment().add({w: 2});

        assert.equal(weeksAgo.calendar(),       weeksAgo.format('L'),  '2 weeks ago');
        assert.equal(weeksFromNow.calendar(),   weeksFromNow.format('L'),  'in 2 weeks');
    });

    test('meridiem', function (assert) {
        assert.equal(moment([2011, 2, 23,  2, 30]).format('a'), 'à°°à°¾à°¤à±à°°à°¿', 'before dawn');
        assert.equal(moment([2011, 2, 23,  9, 30]).format('a'), 'à°à°¦à°¯à°', 'morning');
        assert.equal(moment([2011, 2, 23, 14, 30]).format('a'), 'à°®à°§à±à°¯à°¾à°¹à±à°¨à°', 'during day');
        assert.equal(moment([2011, 2, 23, 17, 30]).format('a'), 'à°¸à°¾à°¯à°à°¤à±à°°à°', 'evening');
        assert.equal(moment([2011, 2, 23, 19, 30]).format('a'), 'à°¸à°¾à°¯à°à°¤à±à°°à°', 'late evening');
        assert.equal(moment([2011, 2, 23, 21, 20]).format('a'), 'à°°à°¾à°¤à±à°°à°¿', 'night');

        assert.equal(moment([2011, 2, 23,  2, 30]).format('A'), 'à°°à°¾à°¤à±à°°à°¿', 'before dawn');
        assert.equal(moment([2011, 2, 23,  9, 30]).format('A'), 'à°à°¦à°¯à°', 'morning');
        assert.equal(moment([2011, 2, 23, 14, 30]).format('A'), 'à°®à°§à±à°¯à°¾à°¹à±à°¨à°', ' during day');
        assert.equal(moment([2011, 2, 23, 17, 30]).format('A'), 'à°¸à°¾à°¯à°à°¤à±à°°à°', 'evening');
        assert.equal(moment([2011, 2, 23, 19, 30]).format('A'), 'à°¸à°¾à°¯à°à°¤à±à°°à°', 'late evening');
        assert.equal(moment([2011, 2, 23, 21, 20]).format('A'), 'à°°à°¾à°¤à±à°°à°¿', 'night');
    });

    test('weeks year starting sunday formatted', function (assert) {
        assert.equal(moment([2012, 0,  1]).format('w ww wo'), '1 01 1à°µ', 'Jan  1 2012 should be week 1');
        assert.equal(moment([2012, 0,  7]).format('w ww wo'), '1 01 1à°µ', 'Jan  7 2012 should be week 1');
        assert.equal(moment([2012, 0,  8]).format('w ww wo'), '2 02 2à°µ', 'Jan  8 2012 should be week 2');
        assert.equal(moment([2012, 0, 14]).format('w ww wo'), '2 02 2à°µ', 'Jan 14 2012 should be week 2');
        assert.equal(moment([2012, 0, 15]).format('w ww wo'), '3 03 3à°µ', 'Jan 15 2012 should be week 3');
    });

}));

;(function (global, factory) {
   typeof exports === 'object' && typeof module !== 'undefined'
       && typeof require === 'function' ? factory(require('../../moment')) :
   typeof define === 'function' && define.amd ? define(['../../moment'], factory) :
   factory(global.moment)
}(this, function (moment) { 'use strict';

    function each(array, callback) {
        var i;
        for (i = 0; i < array.length; i++) {
            callback(array[i], i, array);
        }
    }

    function objectKeys(obj) {
        if (Object.keys) {
            return Object.keys(obj);
        } else {
            // IE8
            var res = [], i;
            for (i in obj) {
                if (obj.hasOwnProperty(i)) {
                    res.push(i);
                }
            }
            return res;
        }
    }

    // Pick the first defined of two or three arguments.
    function defaults(a, b, c) {
        if (a != null) {
            return a;
        }
        if (b != null) {
            return b;
        }
        return c;
    }

    function defineCommonLocaleTests(locale, options) {
        test('lenient ordinal parsing', function (assert) {
            var i, ordinalStr, testMoment;
            for (i = 1; i <= 31; ++i) {
                ordinalStr = moment([2014, 0, i]).format('YYYY MM Do');
                testMoment = moment(ordinalStr, 'YYYY MM Do');
                assert.equal(testMoment.year(), 2014,
                        'lenient ordinal parsing ' + i + ' year check');
                assert.equal(testMoment.month(), 0,
                        'lenient ordinal parsing ' + i + ' month check');
                assert.equal(testMoment.date(), i,
                        'lenient ordinal parsing ' + i + ' date check');
            }
        });

        test('lenient ordinal parsing of number', function (assert) {
            var i, testMoment;
            for (i = 1; i <= 31; ++i) {
                testMoment = moment('2014 01 ' + i, 'YYYY MM Do');
                assert.equal(testMoment.year(), 2014,
                        'lenient ordinal parsing of number ' + i + ' year check');
                assert.equal(testMoment.month(), 0,
                        'lenient ordinal parsing of number ' + i + ' month check');
                assert.equal(testMoment.date(), i,
                        'lenient ordinal parsing of number ' + i + ' date check');
            }
        });

        test('strict ordinal parsing', function (assert) {
            var i, ordinalStr, testMoment;
            for (i = 1; i <= 31; ++i) {
                ordinalStr = moment([2014, 0, i]).format('YYYY MM Do');
                testMoment = moment(ordinalStr, 'YYYY MM Do', true);
                assert.ok(testMoment.isValid(), 'strict ordinal parsing ' + i);
            }
        });

        test('meridiem invariant', function (assert) {
            var h, m, t1, t2;
            for (h = 0; h < 24; ++h) {
                for (m = 0; m < 60; m += 15) {
                    t1 = moment.utc([2000, 0, 1, h, m]);
                    t2 = moment.utc(t1.format('A h:mm'), 'A h:mm');
                    assert.equal(t2.format('HH:mm'), t1.format('HH:mm'),
                            'meridiem at ' + t1.format('HH:mm'));
                }
            }
        });

        test('date format correctness', function (assert) {
            var data, tokens;
            data = moment.localeData()._longDateFormat;
            tokens = objectKeys(data);
            each(tokens, function (srchToken) {
                // Check each format string to make sure it does not contain any
                // tokens that need to be expanded.
                each(tokens, function (baseToken) {
                    // strip escaped sequences
                    var format = data[baseToken].replace(/(\[[^\]]*\])/g, '');
                    assert.equal(false, !!~format.indexOf(srchToken),
                            'contains ' + srchToken + ' in ' + baseToken);
                });
            });
        });

        test('month parsing correctness', function (assert) {
            var i, m;

            if (locale === 'tr') {
                // I can't fix it :(
                expect(0);
                return;
            }
            function tester(format) {
                var r;
                r = moment(m.format(format), format);
                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format);
                r = moment(m.format(format).toLocaleUpperCase(), format);
                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' upper');
                r = moment(m.format(format).toLocaleLowerCase(), format);
                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' lower');

                r = moment(m.format(format), format, true);
                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' strict');
                r = moment(m.format(format).toLocaleUpperCase(), format, true);
                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' upper strict');
                r = moment(m.format(format).toLocaleLowerCase(), format, true);
                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' lower strict');
            }

            for (i = 0; i < 12; ++i) {
                m = moment([2015, i, 15, 18]);
                tester('MMM');
                tester('MMM.');
                tester('MMMM');
                tester('MMMM.');
            }
        });

        test('weekday parsing correctness', function (assert) {
            var i, m;

            if (locale === 'tr' || locale === 'az') {
                // There is a lower-case letter (Ä±), that converted to upper then
                // lower changes to i
                expect(0);
                return;
            }
            function tester(format) {
                var r, baseMsg = 'weekday ' + m.weekday() + ' fmt ' + format;
                r = moment(m.format(format), format);
                assert.equal(r.weekday(), m.weekday(), baseMsg);
                r = moment(m.format(format).toLocaleUpperCase(), format);
                assert.equal(r.weekday(), m.weekday(), baseMsg + ' upper');
                r = moment(m.format(format).toLocaleLowerCase(), format);
                assert.equal(r.weekday(), m.weekday(), baseMsg + ' lower');

                r = moment(m.format(format), format, true);
                assert.equal(r.weekday(), m.weekday(), baseMsg + ' strict');
                r = moment(m.format(format).toLocaleUpperCase(), format, true);
                assert.equal(r.weekday(), m.weekday(), baseMsg + ' upper strict');
                r = moment(m.format(format).toLocaleLowerCase(), format, true);
                assert.equal(r.weekday(), m.weekday(), baseMsg + ' lower strict');
            }

            for (i = 0; i < 7; ++i) {
                m = moment.utc([2015, i, 15, 18]);
                tester('dd');
                tester('ddd');
                tester('dddd');
            }
        });
    }

    function setupDeprecationHandler(test, moment, scope) {
        test._expectedDeprecations = null;
        test._observedDeprecations = null;
        test._oldSupress = moment.suppressDeprecationWarnings;
        moment.suppressDeprecationWarnings = true;
        test.expectedDeprecations = function () {
            test._expectedDeprecations = arguments;
            test._observedDeprecations = [];
        };
        moment.deprecationHandler = function (name, msg) {
            var deprecationId = matchedDeprecation(name, msg, test._expectedDeprecations);
            if (deprecationId === -1) {
                throw new Error('Unexpected deprecation thrown name=' +
                        name + ' msg=' + msg);
            }
            test._observedDeprecations[deprecationId] = 1;
        };
    }

    function teardownDeprecationHandler(test, moment, scope) {
        moment.suppressDeprecationWarnings = test._oldSupress;

        if (test._expectedDeprecations != null) {
            var missedDeprecations = [];
            each(test._expectedDeprecations, function (deprecationPattern, id) {
                if (test._observedDeprecations[id] !== 1) {
                    missedDeprecations.push(deprecationPattern);
                }
            });
            if (missedDeprecations.length !== 0) {
                throw new Error('Expected deprecation warnings did not happen: ' +
                        missedDeprecations.join(' '));
            }
        }
    }

    function matchedDeprecation(name, msg, deprecations) {
        if (deprecations == null) {
            return -1;
        }
        for (var i = 0; i < deprecations.length; ++i) {
            if (name != null && name === deprecations[i]) {
                return i;
            }
            if (msg != null && msg.substring(0, deprecations[i].length) === deprecations[i]) {
                return i;
            }
        }
        return -1;
    }

    /*global QUnit:false*/

    var test = QUnit.test;

    var expect = QUnit.expect;

    function module (name, lifecycle) {
        QUnit.module(name, {
            setup : function () {
                moment.locale('en');
                moment.createFromInputFallback = function (config) {
                    throw new Error('input not handled by moment: ' + config._i);
                };
                setupDeprecationHandler(test, moment, 'core');
                if (lifecycle && lifecycle.setup) {
                    lifecycle.setup();
                }
            },
            teardown : function () {
                teardownDeprecationHandler(test, moment, 'core');
                if (lifecycle && lifecycle.teardown) {
                    lifecycle.teardown();
                }
            }
        });
    }

    function localeModule (name, lifecycle) {
        QUnit.module('locale:' + name, {
            setup : function () {
                moment.locale(name);
                moment.createFromInputFallback = function (config) {
                    throw new Error('input not handled by moment: ' + config._i);
                };
                setupDeprecationHandler(test, moment, 'locale');
                if (lifecycle && lifecycle.setup) {
                    lifecycle.setup();
                }
            },
            teardown : function () {
                moment.locale('en');
                teardownDeprecationHandler(test, moment, 'locale');
                if (lifecycle && lifecycle.teardown) {
                    lifecycle.teardown();
                }
            }
        });
        defineCommonLocaleTests(name, -1, -1);
    }

    localeModule('th');

    test('parse', function (assert) {
        var tests = 'à¸¡à¸à¸£à¸²à¸à¸¡ à¸¡à¸à¸£à¸²_à¸à¸¸à¸¡à¸ à¸²à¸à¸±à¸à¸à¹ à¸à¸¸à¸¡à¸ à¸²_à¸¡à¸µà¸à¸²à¸à¸¡ à¸¡à¸µà¸à¸²_à¹à¸¡à¸©à¸²à¸¢à¸ à¹à¸¡à¸©à¸²_à¸à¸¤à¸©à¸ à¸²à¸à¸¡ à¸à¸¤à¸©à¸ à¸²_à¸¡à¸´à¸à¸¸à¸à¸²à¸¢à¸ à¸¡à¸´à¸à¸¸à¸à¸²_à¸à¸£à¸à¸à¸²à¸à¸¡ à¸à¸£à¸à¸à¸²_à¸ªà¸´à¸à¸«à¸²à¸à¸¡ à¸ªà¸´à¸à¸«à¸²_à¸à¸±à¸à¸¢à¸²à¸¢à¸ à¸à¸±à¸à¸¢à¸²_à¸à¸¸à¸¥à¸²à¸à¸¡ à¸à¸¸à¸¥à¸²_à¸à¸¤à¸¨à¸à¸´à¸à¸²à¸¢à¸ à¸à¸¤à¸¨à¸à¸´à¸à¸²_à¸à¸±à¸à¸§à¸²à¸à¸¡ à¸à¸±à¸à¸§à¸²'.split('_'), i;
        function equalTest(input, mmm, i) {
            assert.equal(moment(input, mmm).month(), i, input + ' should be month ' + (i + 1));
        }
        for (i = 0; i < 12; i++) {
            tests[i] = tests[i].split(' ');
            equalTest(tests[i][0], 'MMM', i);
            equalTest(tests[i][1], 'MMM', i);
            equalTest(tests[i][0], 'MMMM', i);
            equalTest(tests[i][1], 'MMMM', i);
            equalTest(tests[i][0].toLocaleLowerCase(), 'MMMM', i);
            equalTest(tests[i][1].toLocaleLowerCase(), 'MMMM', i);
            equalTest(tests[i][0].toLocaleUpperCase(), 'MMMM', i);
            equalTest(tests[i][1].toLocaleUpperCase(), 'MMMM', i);
        }
    });

    test('format', function (assert) {
        var a = [
                ['dddd, Do MMMM YYYY, h:mm:ss a',      'à¸­à¸²à¸à¸´à¸à¸¢à¹, 14 à¸à¸¸à¸¡à¸ à¸²à¸à¸±à¸à¸à¹ 2010, 3:25:50 à¸«à¸¥à¸±à¸à¹à¸à¸µà¹à¸¢à¸'],
                ['ddd, h A',                           'à¸­à¸²à¸à¸´à¸à¸¢à¹, 3 à¸«à¸¥à¸±à¸à¹à¸à¸µà¹à¸¢à¸'],
                ['M Mo MM MMMM MMM',                   '2 2 02 à¸à¸¸à¸¡à¸ à¸²à¸à¸±à¸à¸à¹ à¸à¸¸à¸¡à¸ à¸²'],
                ['YYYY YY',                            '2010 10'],
                ['D Do DD',                            '14 14 14'],
                ['d do dddd ddd dd',                   '0 0 à¸­à¸²à¸à¸´à¸à¸¢à¹ à¸­à¸²à¸à¸´à¸à¸¢à¹ à¸­à¸².'],
                ['DDD DDDo DDDD',                      '45 45 045'],
                ['w wo ww',                            '8 8 08'],
                ['h hh',                               '3 03'],
                ['H HH',                               '15 15'],
                ['m mm',                               '25 25'],
                ['s ss',                               '50 50'],
                ['a A',                                'à¸«à¸¥à¸±à¸à¹à¸à¸µà¹à¸¢à¸ à¸«à¸¥à¸±à¸à¹à¸à¸µà¹à¸¢à¸'],
                ['[the] DDDo [day of the year]',       'the 45 day of the year'],
                ['LTS',                                '15 à¸à¸²à¸¬à¸´à¸à¸² 25 à¸à¸²à¸à¸µ 50 à¸§à¸´à¸à¸²à¸à¸µ'],
                ['L',                                  '2010/02/14'],
                ['LL',                                 '14 à¸à¸¸à¸¡à¸ à¸²à¸à¸±à¸à¸à¹ 2010'],
                ['LLL',                                '14 à¸à¸¸à¸¡à¸ à¸²à¸à¸±à¸à¸à¹ 2010 à¹à¸§à¸¥à¸² 15 à¸à¸²à¸¬à¸´à¸à¸² 25 à¸à¸²à¸à¸µ'],
                ['LLLL',                               'à¸§à¸±à¸à¸­à¸²à¸à¸´à¸à¸¢à¹à¸à¸µà¹ 14 à¸à¸¸à¸¡à¸ à¸²à¸à¸±à¸à¸à¹ 2010 à¹à¸§à¸¥à¸² 15 à¸à¸²à¸¬à¸´à¸à¸² 25 à¸à¸²à¸à¸µ'],
                ['l',                                  '2010/2/14'],
                ['ll',                                 '14 à¸à¸¸à¸¡à¸ à¸² 2010'],
                ['lll',                                '14 à¸à¸¸à¸¡à¸ à¸² 2010 à¹à¸§à¸¥à¸² 15 à¸à¸²à¸¬à¸´à¸à¸² 25 à¸à¸²à¸à¸µ'],
                ['llll',                               'à¸§à¸±à¸à¸­à¸²à¸à¸´à¸à¸¢à¹à¸à¸µà¹ 14 à¸à¸¸à¸¡à¸ à¸² 2010 à¹à¸§à¸¥à¸² 15 à¸à¸²à¸¬à¸´à¸à¸² 25 à¸à¸²à¸à¸µ']
            ],
            b = moment(new Date(2010, 1, 14, 15, 25, 50, 125)),
            i;
        for (i = 0; i < a.length; i++) {
            assert.equal(b.format(a[i][0]), a[i][1], a[i][0] + ' ---> ' + a[i][1]);
        }
    });

    test('format month', function (assert) {
        var expected = 'à¸¡à¸à¸£à¸²à¸à¸¡ à¸¡à¸à¸£à¸²_à¸à¸¸à¸¡à¸ à¸²à¸à¸±à¸à¸à¹ à¸à¸¸à¸¡à¸ à¸²_à¸¡à¸µà¸à¸²à¸à¸¡ à¸¡à¸µà¸à¸²_à¹à¸¡à¸©à¸²à¸¢à¸ à¹à¸¡à¸©à¸²_à¸à¸¤à¸©à¸ à¸²à¸à¸¡ à¸à¸¤à¸©à¸ à¸²_à¸¡à¸´à¸à¸¸à¸à¸²à¸¢à¸ à¸¡à¸´à¸à¸¸à¸à¸²_à¸à¸£à¸à¸à¸²à¸à¸¡ à¸à¸£à¸à¸à¸²_à¸ªà¸´à¸à¸«à¸²à¸à¸¡ à¸ªà¸´à¸à¸«à¸²_à¸à¸±à¸à¸¢à¸²à¸¢à¸ à¸à¸±à¸à¸¢à¸²_à¸à¸¸à¸¥à¸²à¸à¸¡ à¸à¸¸à¸¥à¸²_à¸à¸¤à¸¨à¸à¸´à¸à¸²à¸¢à¸ à¸à¸¤à¸¨à¸à¸´à¸à¸²_à¸à¸±à¸à¸§à¸²à¸à¸¡ à¸à¸±à¸à¸§à¸²'.split('_'), i;
        for (i = 0; i < expected.length; i++) {
            assert.equal(moment([2011, i, 1]).format('MMMM MMM'), expected[i], expected[i]);
        }
    });

    test('format week', function (assert) {
        var expected = 'à¸­à¸²à¸à¸´à¸à¸¢à¹ à¸­à¸²à¸à¸´à¸à¸¢à¹ à¸­à¸²._à¸à¸±à¸à¸à¸£à¹ à¸à¸±à¸à¸à¸£à¹ à¸._à¸­à¸±à¸à¸à¸²à¸£ à¸­à¸±à¸à¸à¸²à¸£ à¸­._à¸à¸¸à¸ à¸à¸¸à¸ à¸._à¸à¸¤à¸«à¸±à¸ªà¸à¸à¸µ à¸à¸¤à¸«à¸±à¸ª à¸à¸¤._à¸¨à¸¸à¸à¸£à¹ à¸¨à¸¸à¸à¸£à¹ à¸¨._à¹à¸ªà¸²à¸£à¹ à¹à¸ªà¸²à¸£à¹ à¸ª.'.split('_'), i;
        for (i = 0; i < expected.length; i++) {
            assert.equal(moment([2011, 0, 2 + i]).format('dddd ddd dd'), expected[i], expected[i]);
        }
    });

    test('from', function (assert) {
        var start = moment([2007, 1, 28]);
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 44}), true),  'à¹à¸¡à¹à¸à¸µà¹à¸§à¸´à¸à¸²à¸à¸µ',   '44 seconds = a few seconds');
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 45}), true),  '1 à¸à¸²à¸à¸µ', '45 seconds = a minute');
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 89}), true),  '1 à¸à¸²à¸à¸µ', '89 seconds = a minute');
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 90}), true),  '2 à¸à¸²à¸à¸µ',  '90 seconds = 2 minutes');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 44}), true),  '44 à¸à¸²à¸à¸µ', '44 minutes = 44 minutes');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 45}), true),  '1 à¸à¸±à¹à¸§à¹à¸¡à¸', '45 minutes = an hour');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 89}), true),  '1 à¸à¸±à¹à¸§à¹à¸¡à¸', '89 minutes = an hour');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 90}), true),  '2 à¸à¸±à¹à¸§à¹à¸¡à¸',  '90 minutes = 2 hours');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 5}), true),   '5 à¸à¸±à¹à¸§à¹à¸¡à¸',  '5 hours = 5 hours');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 21}), true),  '21 à¸à¸±à¹à¸§à¹à¸¡à¸', '21 hours = 21 hours');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 22}), true),  '1 à¸§à¸±à¸',   '22 hours = a day');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 35}), true),  '1 à¸§à¸±à¸',   '35 hours = a day');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 36}), true),  '2 à¸§à¸±à¸',   '36 hours = 2 days');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 1}), true),   '1 à¸§à¸±à¸',   '1 day = a day');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 5}), true),   '5 à¸§à¸±à¸',   '5 days = 5 days');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 25}), true),  '25 à¸§à¸±à¸',  '25 days = 25 days');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 26}), true),  '1 à¹à¸à¸·à¸­à¸', '26 days = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 30}), true),  '1 à¹à¸à¸·à¸­à¸', '30 days = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 43}), true),  '1 à¹à¸à¸·à¸­à¸', '43 days = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 46}), true),  '2 à¹à¸à¸·à¸­à¸',  '46 days = 2 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 74}), true),  '2 à¹à¸à¸·à¸­à¸',  '75 days = 2 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 76}), true),  '3 à¹à¸à¸·à¸­à¸',  '76 days = 3 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({M: 1}), true),   '1 à¹à¸à¸·à¸­à¸', '1 month = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({M: 5}), true),   '5 à¹à¸à¸·à¸­à¸',  '5 months = 5 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 345}), true), '1 à¸à¸µ',   '345 days = a year');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 548}), true), '2 à¸à¸µ',   '548 days = 2 years');
        assert.equal(start.from(moment([2007, 1, 28]).add({y: 1}), true),   '1 à¸à¸µ',   '1 year = a year');
        assert.equal(start.from(moment([2007, 1, 28]).add({y: 5}), true),   '5 à¸à¸µ',   '5 years = 5 years');
    });

    test('suffix', function (assert) {
        assert.equal(moment(30000).from(0), 'à¸­à¸µà¸ à¹à¸¡à¹à¸à¸µà¹à¸§à¸´à¸à¸²à¸à¸µ',  'prefix');
        assert.equal(moment(0).from(30000), 'à¹à¸¡à¹à¸à¸µà¹à¸§à¸´à¸à¸²à¸à¸µà¸à¸µà¹à¹à¸¥à¹à¸§', 'suffix');
    });

    test('now from now', function (assert) {
        assert.equal(moment().fromNow(), 'à¹à¸¡à¹à¸à¸µà¹à¸§à¸´à¸à¸²à¸à¸µà¸à¸µà¹à¹à¸¥à¹à¸§',  'now from now should display as in the past');
    });

    test('fromNow', function (assert) {
        assert.equal(moment().add({s: 30}).fromNow(), 'à¸­à¸µà¸ à¹à¸¡à¹à¸à¸µà¹à¸§à¸´à¸à¸²à¸à¸µ', 'in a few seconds');
        assert.equal(moment().add({d: 5}).fromNow(), 'à¸­à¸µà¸ 5 à¸§à¸±à¸', 'in 5 days');
    });

    test('calendar day', function (assert) {
        var a = moment().hours(12).minutes(0).seconds(0);

        assert.equal(moment(a).calendar(),                   'à¸§à¸±à¸à¸à¸µà¹ à¹à¸§à¸¥à¸² 12 à¸à¸²à¸¬à¸´à¸à¸² 0 à¸à¸²à¸à¸µ',      'today at the same time');
        assert.equal(moment(a).add({m: 25}).calendar(),      'à¸§à¸±à¸à¸à¸µà¹ à¹à¸§à¸¥à¸² 12 à¸à¸²à¸¬à¸´à¸à¸² 25 à¸à¸²à¸à¸µ',     'Now plus 25 min');
        assert.equal(moment(a).add({h: 1}).calendar(),       'à¸§à¸±à¸à¸à¸µà¹ à¹à¸§à¸¥à¸² 13 à¸à¸²à¸¬à¸´à¸à¸² 0 à¸à¸²à¸à¸µ',      'Now plus 1 hour');
        assert.equal(moment(a).add({d: 1}).calendar(),       'à¸à¸£à¸¸à¹à¸à¸à¸µà¹ à¹à¸§à¸¥à¸² 12 à¸à¸²à¸¬à¸´à¸à¸² 0 à¸à¸²à¸à¸µ',    'tomorrow at the same time');
        assert.equal(moment(a).subtract({h: 1}).calendar(),  'à¸§à¸±à¸à¸à¸µà¹ à¹à¸§à¸¥à¸² 11 à¸à¸²à¸¬à¸´à¸à¸² 0 à¸à¸²à¸à¸µ',      'Now minus 1 hour');
        assert.equal(moment(a).subtract({d: 1}).calendar(),  'à¹à¸¡à¸·à¹à¸­à¸§à¸²à¸à¸à¸µà¹ à¹à¸§à¸¥à¸² 12 à¸à¸²à¸¬à¸´à¸à¸² 0 à¸à¸²à¸à¸µ', 'yesterday at the same time');
    });

    test('calendar next week', function (assert) {
        var i, m;
        for (i = 2; i < 7; i++) {
            m = moment().add({d: i});
            assert.equal(m.calendar(),       m.format('dddd[à¸«à¸à¹à¸² à¹à¸§à¸¥à¸²] LT'),  'Today + ' + i + ' days current time');
            m.hours(0).minutes(0).seconds(0).milliseconds(0);
            assert.equal(m.calendar(),       m.format('dddd[à¸«à¸à¹à¸² à¹à¸§à¸¥à¸²] LT'),  'Today + ' + i + ' days beginning of day');
            m.hours(23).minutes(59).seconds(59).milliseconds(999);
            assert.equal(m.calendar(),       m.format('dddd[à¸«à¸à¹à¸² à¹à¸§à¸¥à¸²] LT'),  'Today + ' + i + ' days end of day');
        }
    });

    test('calendar last week', function (assert) {
        var i, m;
        for (i = 2; i < 7; i++) {
            m = moment().subtract({d: i});
            assert.equal(m.calendar(),       m.format('[à¸§à¸±à¸]dddd[à¸à¸µà¹à¹à¸¥à¹à¸§ à¹à¸§à¸¥à¸²] LT'),  'Today - ' + i + ' days current time');
            m.hours(0).minutes(0).seconds(0).milliseconds(0);
            assert.equal(m.calendar(),       m.format('[à¸§à¸±à¸]dddd[à¸à¸µà¹à¹à¸¥à¹à¸§ à¹à¸§à¸¥à¸²] LT'),  'Today - ' + i + ' days beginning of day');
            m.hours(23).minutes(59).seconds(59).milliseconds(999);
            assert.equal(m.calendar(),       m.format('[à¸§à¸±à¸]dddd[à¸à¸µà¹à¹à¸¥à¹à¸§ à¹à¸§à¸¥à¸²] LT'),  'Today - ' + i + ' days end of day');
        }
    });

    test('calendar all else', function (assert) {
        var weeksAgo = moment().subtract({w: 1}),
            weeksFromNow = moment().add({w: 1});

        assert.equal(weeksAgo.calendar(),       weeksAgo.format('L'),      '1 week ago');
        assert.equal(weeksFromNow.calendar(),   weeksFromNow.format('L'),  'in 1 week');

        weeksAgo = moment().subtract({w: 2});
        weeksFromNow = moment().add({w: 2});

        assert.equal(weeksAgo.calendar(),       weeksAgo.format('L'),      '2 weeks ago');
        assert.equal(weeksFromNow.calendar(),   weeksFromNow.format('L'),  'in 2 weeks');
    });

    test('weeks year starting sunday format', function (assert) {
        assert.equal(moment([2012, 0,  1]).format('w ww wo'), '1 01 1', 'Jan  1 2012 should be week 1');
        assert.equal(moment([2012, 0,  7]).format('w ww wo'), '1 01 1', 'Jan  7 2012 should be week 1');
        assert.equal(moment([2012, 0,  8]).format('w ww wo'), '2 02 2', 'Jan  8 2012 should be week 2');
        assert.equal(moment([2012, 0, 14]).format('w ww wo'), '2 02 2', 'Jan 14 2012 should be week 2');
        assert.equal(moment([2012, 0, 15]).format('w ww wo'), '3 03 3', 'Jan 15 2012 should be week 3');
    });

}));

;(function (global, factory) {
   typeof exports === 'object' && typeof module !== 'undefined'
       && typeof require === 'function' ? factory(require('../../moment')) :
   typeof define === 'function' && define.amd ? define(['../../moment'], factory) :
   factory(global.moment)
}(this, function (moment) { 'use strict';

    function each(array, callback) {
        var i;
        for (i = 0; i < array.length; i++) {
            callback(array[i], i, array);
        }
    }

    function objectKeys(obj) {
        if (Object.keys) {
            return Object.keys(obj);
        } else {
            // IE8
            var res = [], i;
            for (i in obj) {
                if (obj.hasOwnProperty(i)) {
                    res.push(i);
                }
            }
            return res;
        }
    }

    // Pick the first defined of two or three arguments.
    function defaults(a, b, c) {
        if (a != null) {
            return a;
        }
        if (b != null) {
            return b;
        }
        return c;
    }

    function defineCommonLocaleTests(locale, options) {
        test('lenient ordinal parsing', function (assert) {
            var i, ordinalStr, testMoment;
            for (i = 1; i <= 31; ++i) {
                ordinalStr = moment([2014, 0, i]).format('YYYY MM Do');
                testMoment = moment(ordinalStr, 'YYYY MM Do');
                assert.equal(testMoment.year(), 2014,
                        'lenient ordinal parsing ' + i + ' year check');
                assert.equal(testMoment.month(), 0,
                        'lenient ordinal parsing ' + i + ' month check');
                assert.equal(testMoment.date(), i,
                        'lenient ordinal parsing ' + i + ' date check');
            }
        });

        test('lenient ordinal parsing of number', function (assert) {
            var i, testMoment;
            for (i = 1; i <= 31; ++i) {
                testMoment = moment('2014 01 ' + i, 'YYYY MM Do');
                assert.equal(testMoment.year(), 2014,
                        'lenient ordinal parsing of number ' + i + ' year check');
                assert.equal(testMoment.month(), 0,
                        'lenient ordinal parsing of number ' + i + ' month check');
                assert.equal(testMoment.date(), i,
                        'lenient ordinal parsing of number ' + i + ' date check');
            }
        });

        test('strict ordinal parsing', function (assert) {
            var i, ordinalStr, testMoment;
            for (i = 1; i <= 31; ++i) {
                ordinalStr = moment([2014, 0, i]).format('YYYY MM Do');
                testMoment = moment(ordinalStr, 'YYYY MM Do', true);
                assert.ok(testMoment.isValid(), 'strict ordinal parsing ' + i);
            }
        });

        test('meridiem invariant', function (assert) {
            var h, m, t1, t2;
            for (h = 0; h < 24; ++h) {
                for (m = 0; m < 60; m += 15) {
                    t1 = moment.utc([2000, 0, 1, h, m]);
                    t2 = moment.utc(t1.format('A h:mm'), 'A h:mm');
                    assert.equal(t2.format('HH:mm'), t1.format('HH:mm'),
                            'meridiem at ' + t1.format('HH:mm'));
                }
            }
        });

        test('date format correctness', function (assert) {
            var data, tokens;
            data = moment.localeData()._longDateFormat;
            tokens = objectKeys(data);
            each(tokens, function (srchToken) {
                // Check each format string to make sure it does not contain any
                // tokens that need to be expanded.
                each(tokens, function (baseToken) {
                    // strip escaped sequences
                    var format = data[baseToken].replace(/(\[[^\]]*\])/g, '');
                    assert.equal(false, !!~format.indexOf(srchToken),
                            'contains ' + srchToken + ' in ' + baseToken);
                });
            });
        });

        test('month parsing correctness', function (assert) {
            var i, m;

            if (locale === 'tr') {
                // I can't fix it :(
                expect(0);
                return;
            }
            function tester(format) {
                var r;
                r = moment(m.format(format), format);
                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format);
                r = moment(m.format(format).toLocaleUpperCase(), format);
                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' upper');
                r = moment(m.format(format).toLocaleLowerCase(), format);
                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' lower');

                r = moment(m.format(format), format, true);
                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' strict');
                r = moment(m.format(format).toLocaleUpperCase(), format, true);
                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' upper strict');
                r = moment(m.format(format).toLocaleLowerCase(), format, true);
                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' lower strict');
            }

            for (i = 0; i < 12; ++i) {
                m = moment([2015, i, 15, 18]);
                tester('MMM');
                tester('MMM.');
                tester('MMMM');
                tester('MMMM.');
            }
        });

        test('weekday parsing correctness', function (assert) {
            var i, m;

            if (locale === 'tr' || locale === 'az') {
                // There is a lower-case letter (Ä±), that converted to upper then
                // lower changes to i
                expect(0);
                return;
            }
            function tester(format) {
                var r, baseMsg = 'weekday ' + m.weekday() + ' fmt ' + format;
                r = moment(m.format(format), format);
                assert.equal(r.weekday(), m.weekday(), baseMsg);
                r = moment(m.format(format).toLocaleUpperCase(), format);
                assert.equal(r.weekday(), m.weekday(), baseMsg + ' upper');
                r = moment(m.format(format).toLocaleLowerCase(), format);
                assert.equal(r.weekday(), m.weekday(), baseMsg + ' lower');

                r = moment(m.format(format), format, true);
                assert.equal(r.weekday(), m.weekday(), baseMsg + ' strict');
                r = moment(m.format(format).toLocaleUpperCase(), format, true);
                assert.equal(r.weekday(), m.weekday(), baseMsg + ' upper strict');
                r = moment(m.format(format).toLocaleLowerCase(), format, true);
                assert.equal(r.weekday(), m.weekday(), baseMsg + ' lower strict');
            }

            for (i = 0; i < 7; ++i) {
                m = moment.utc([2015, i, 15, 18]);
                tester('dd');
                tester('ddd');
                tester('dddd');
            }
        });
    }

    function setupDeprecationHandler(test, moment, scope) {
        test._expectedDeprecations = null;
        test._observedDeprecations = null;
        test._oldSupress = moment.suppressDeprecationWarnings;
        moment.suppressDeprecationWarnings = true;
        test.expectedDeprecations = function () {
            test._expectedDeprecations = arguments;
            test._observedDeprecations = [];
        };
        moment.deprecationHandler = function (name, msg) {
            var deprecationId = matchedDeprecation(name, msg, test._expectedDeprecations);
            if (deprecationId === -1) {
                throw new Error('Unexpected deprecation thrown name=' +
                        name + ' msg=' + msg);
            }
            test._observedDeprecations[deprecationId] = 1;
        };
    }

    function teardownDeprecationHandler(test, moment, scope) {
        moment.suppressDeprecationWarnings = test._oldSupress;

        if (test._expectedDeprecations != null) {
            var missedDeprecations = [];
            each(test._expectedDeprecations, function (deprecationPattern, id) {
                if (test._observedDeprecations[id] !== 1) {
                    missedDeprecations.push(deprecationPattern);
                }
            });
            if (missedDeprecations.length !== 0) {
                throw new Error('Expected deprecation warnings did not happen: ' +
                        missedDeprecations.join(' '));
            }
        }
    }

    function matchedDeprecation(name, msg, deprecations) {
        if (deprecations == null) {
            return -1;
        }
        for (var i = 0; i < deprecations.length; ++i) {
            if (name != null && name === deprecations[i]) {
                return i;
            }
            if (msg != null && msg.substring(0, deprecations[i].length) === deprecations[i]) {
                return i;
            }
        }
        return -1;
    }

    /*global QUnit:false*/

    var test = QUnit.test;

    var expect = QUnit.expect;

    function module (name, lifecycle) {
        QUnit.module(name, {
            setup : function () {
                moment.locale('en');
                moment.createFromInputFallback = function (config) {
                    throw new Error('input not handled by moment: ' + config._i);
                };
                setupDeprecationHandler(test, moment, 'core');
                if (lifecycle && lifecycle.setup) {
                    lifecycle.setup();
                }
            },
            teardown : function () {
                teardownDeprecationHandler(test, moment, 'core');
                if (lifecycle && lifecycle.teardown) {
                    lifecycle.teardown();
                }
            }
        });
    }

    function localeModule (name, lifecycle) {
        QUnit.module('locale:' + name, {
            setup : function () {
                moment.locale(name);
                moment.createFromInputFallback = function (config) {
                    throw new Error('input not handled by moment: ' + config._i);
                };
                setupDeprecationHandler(test, moment, 'locale');
                if (lifecycle && lifecycle.setup) {
                    lifecycle.setup();
                }
            },
            teardown : function () {
                moment.locale('en');
                teardownDeprecationHandler(test, moment, 'locale');
                if (lifecycle && lifecycle.teardown) {
                    lifecycle.teardown();
                }
            }
        });
        defineCommonLocaleTests(name, -1, -1);
    }

    localeModule('tl-ph');

    test('parse', function (assert) {
        var tests = 'Enero Ene_Pebrero Peb_Marso Mar_Abril Abr_Mayo May_Hunyo Hun_Hulyo Hul_Agosto Ago_Setyembre Set_Oktubre Okt_Nobyembre Nob_Disyembre Dis'.split('_'),
            i;
        function equalTest(input, mmm, i) {
            assert.equal(moment(input, mmm).month(), i, input + ' should be month ' + (i + 1));
        }
        for (i = 0; i < 12; i++) {
            tests[i] = tests[i].split(' ');
            equalTest(tests[i][0], 'MMM', i);
            equalTest(tests[i][1], 'MMM', i);
            equalTest(tests[i][0], 'MMMM', i);
            equalTest(tests[i][1], 'MMMM', i);
            equalTest(tests[i][0].toLocaleLowerCase(), 'MMMM', i);
            equalTest(tests[i][1].toLocaleLowerCase(), 'MMMM', i);
            equalTest(tests[i][0].toLocaleUpperCase(), 'MMMM', i);
            equalTest(tests[i][1].toLocaleUpperCase(), 'MMMM', i);
        }
    });

    test('format', function (assert) {
        var a = [
                ['dddd, MMMM Do YYYY, h:mm:ss a',      'Linggo, Pebrero 14 2010, 3:25:50 pm'],
                ['ddd, hA',                            'Lin, 3PM'],
                ['M Mo MM MMMM MMM',                   '2 2 02 Pebrero Peb'],
                ['YYYY YY',                             '2010 10'],
                ['D Do DD',                            '14 14 14'],
                ['d do dddd ddd dd',                   '0 0 Linggo Lin Li'],
                ['DDD DDDo DDDD',                      '45 45 045'],
                ['w wo ww',                            '6 6 06'],
                ['h hh',                               '3 03'],
                ['H HH',                               '15 15'],
                ['m mm',                               '25 25'],
                ['s ss',                               '50 50'],
                ['a A',                                'pm PM'],
                ['[the] DDDo [day of the year]',       'the 45 day of the year'],
                ['LTS',                                '15:25:50'],
                ['L',                                  '02/14/2010'],
                ['LL',                                 'Pebrero 14, 2010'],
                ['LLL',                                'Pebrero 14, 2010 15:25'],
                ['LLLL',                               'Linggo, Pebrero 14, 2010 15:25'],
                ['l',                                  '2/14/2010'],
                ['ll',                                 'Peb 14, 2010'],
                ['lll',                                'Peb 14, 2010 15:25'],
                ['llll',                               'Lin, Peb 14, 2010 15:25']
            ],
            b = moment(new Date(2010, 1, 14, 15, 25, 50, 125)),
            i;
        for (i = 0; i < a.length; i++) {
            assert.equal(b.format(a[i][0]), a[i][1], a[i][0] + ' ---> ' + a[i][1]);
        }
    });

    test('format ordinal', function (assert) {
        assert.equal(moment([2011, 0, 1]).format('DDDo'), '1', '1');
        assert.equal(moment([2011, 0, 2]).format('DDDo'), '2', '2');
        assert.equal(moment([2011, 0, 3]).format('DDDo'), '3', '3');
        assert.equal(moment([2011, 0, 4]).format('DDDo'), '4', '4');
        assert.equal(moment([2011, 0, 5]).format('DDDo'), '5', '5');
        assert.equal(moment([2011, 0, 6]).format('DDDo'), '6', '6');
        assert.equal(moment([2011, 0, 7]).format('DDDo'), '7', '7');
        assert.equal(moment([2011, 0, 8]).format('DDDo'), '8', '8');
        assert.equal(moment([2011, 0, 9]).format('DDDo'), '9', '9');
        assert.equal(moment([2011, 0, 10]).format('DDDo'), '10', '10');

        assert.equal(moment([2011, 0, 11]).format('DDDo'), '11', '11');
        assert.equal(moment([2011, 0, 12]).format('DDDo'), '12', '12');
        assert.equal(moment([2011, 0, 13]).format('DDDo'), '13', '13');
        assert.equal(moment([2011, 0, 14]).format('DDDo'), '14', '14');
        assert.equal(moment([2011, 0, 15]).format('DDDo'), '15', '15');
        assert.equal(moment([2011, 0, 16]).format('DDDo'), '16', '16');
        assert.equal(moment([2011, 0, 17]).format('DDDo'), '17', '17');
        assert.equal(moment([2011, 0, 18]).format('DDDo'), '18', '18');
        assert.equal(moment([2011, 0, 19]).format('DDDo'), '19', '19');
        assert.equal(moment([2011, 0, 20]).format('DDDo'), '20', '20');

        assert.equal(moment([2011, 0, 21]).format('DDDo'), '21', '21');
        assert.equal(moment([2011, 0, 22]).format('DDDo'), '22', '22');
        assert.equal(moment([2011, 0, 23]).format('DDDo'), '23', '23');
        assert.equal(moment([2011, 0, 24]).format('DDDo'), '24', '24');
        assert.equal(moment([2011, 0, 25]).format('DDDo'), '25', '25');
        assert.equal(moment([2011, 0, 26]).format('DDDo'), '26', '26');
        assert.equal(moment([2011, 0, 27]).format('DDDo'), '27', '27');
        assert.equal(moment([2011, 0, 28]).format('DDDo'), '28', '28');
        assert.equal(moment([2011, 0, 29]).format('DDDo'), '29', '29');
        assert.equal(moment([2011, 0, 30]).format('DDDo'), '30', '30');

        assert.equal(moment([2011, 0, 31]).format('DDDo'), '31', '31');
    });

    test('format month', function (assert) {
        var expected = 'Enero Ene_Pebrero Peb_Marso Mar_Abril Abr_Mayo May_Hunyo Hun_Hulyo Hul_Agosto Ago_Setyembre Set_Oktubre Okt_Nobyembre Nob_Disyembre Dis'.split('_'), i;
        for (i = 0; i < expected.length; i++) {
            assert.equal(moment([2011, i, 1]).format('MMMM MMM'), expected[i], expected[i]);
        }
    });

    test('format week', function (assert) {
        var expected = 'Linggo Lin Li_Lunes Lun Lu_Martes Mar Ma_Miyerkules Miy Mi_Huwebes Huw Hu_Biyernes Biy Bi_Sabado Sab Sab'.split('_'), i;
        for (i = 0; i < expected.length; i++) {
            assert.equal(moment([2011, 0, 2 + i]).format('dddd ddd dd'), expected[i], expected[i]);
        }
    });

    test('from', function (assert) {
        var start = moment([2007, 1, 28]);
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 44}), true),  'ilang segundo', '44 seconds = a few seconds');
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 45}), true),  'isang minuto',   '45 seconds = a minute');
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 89}), true),  'isang minuto',   '89 seconds = a minute');
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 90}), true),  '2 minuto',  '90 seconds = 2 minutes');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 44}), true),  '44 minuto', '44 minutes = 44 minutes');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 45}), true),  'isang oras',    '45 minutes = an hour');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 89}), true),  'isang oras',    '89 minutes = an hour');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 90}), true),  '2 oras',    '90 minutes = 2 hours');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 5}), true),   '5 oras',    '5 hours = 5 hours');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 21}), true),  '21 oras',   '21 hours = 21 hours');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 22}), true),  'isang araw',      '22 hours = a day');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 35}), true),  'isang araw',      '35 hours = a day');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 36}), true),  '2 araw',     '36 hours = 2 days');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 1}), true),   'isang araw',      '1 day = a day');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 5}), true),   '5 araw',     '5 days = 5 days');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 25}), true),  '25 araw',    '25 days = 25 days');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 26}), true),  'isang buwan',    '26 days = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 30}), true),  'isang buwan',    '30 days = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 43}), true),  'isang buwan',    '43 days = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 46}), true),  '2 buwan',   '46 days = 2 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 74}), true),  '2 buwan',   '75 days = 2 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 76}), true),  '3 buwan',   '76 days = 3 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({M: 1}), true),   'isang buwan',    '1 month = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({M: 5}), true),   '5 buwan',   '5 months = 5 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 345}), true), 'isang taon',     '345 days = a year');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 548}), true), '2 taon',    '548 days = 2 years');
        assert.equal(start.from(moment([2007, 1, 28]).add({y: 1}), true),   'isang taon',     '1 year = a year');
        assert.equal(start.from(moment([2007, 1, 28]).add({y: 5}), true),   '5 taon',    '5 years = 5 years');
    });

    test('suffix', function (assert) {
        assert.equal(moment(30000).from(0), 'sa loob ng ilang segundo', 'prefix');
        assert.equal(moment(0).from(30000), 'ilang segundo ang nakalipas', 'suffix');
    });

    test('fromNow', function (assert) {
        assert.equal(moment().add({s: 30}).fromNow(), 'sa loob ng ilang segundo', 'in a few seconds');
        assert.equal(moment().add({d: 5}).fromNow(), 'sa loob ng 5 araw', 'in 5 days');
    });

    test('same day', function (assert) {
        var a = moment().hours(12).minutes(0).seconds(0);

        assert.equal(moment(a).calendar(),                   'Ngayon sa 12:00',    'today at the same time');
        assert.equal(moment(a).add({m: 25}).calendar(),      'Ngayon sa 12:25',    'Now plus 25 min');
        assert.equal(moment(a).add({h: 1}).calendar(),       'Ngayon sa 13:00',    'Now plus 1 hour');
        assert.equal(moment(a).add({d: 1}).calendar(),       'Bukas sa 12:00',     'tomorrow at the same time');
        assert.equal(moment(a).subtract({h: 1}).calendar(),  'Ngayon sa 11:00',    'Now minus 1 hour');
        assert.equal(moment(a).subtract({d: 1}).calendar(),  'Kahapon sa 12:00',   'yesterday at the same time');
    });

    test('same next week', function (assert) {
        var i, m;

        for (i = 2; i < 7; i++) {
            m = moment().add({d: i});
            assert.equal(m.calendar(),       m.format('dddd [sa] LT'),  'Today + ' + i + ' days current time');
            m.hours(0).minutes(0).seconds(0).milliseconds(0);
            assert.equal(m.calendar(),       m.format('dddd [sa] LT'),  'Today + ' + i + ' days beginning of day');
            m.hours(23).minutes(59).seconds(59).milliseconds(999);
            assert.equal(m.calendar(),       m.format('dddd [sa] LT'),  'Today + ' + i + ' days end of day');
        }
    });

    test('same last week', function (assert) {
        var i, m;

        for (i = 2; i < 7; i++) {
            m = moment().subtract({d: i});
            assert.equal(m.calendar(),       m.format('dddd [huling linggo] LT'),  'Today - ' + i + ' days current time');
            m.hours(0).minutes(0).seconds(0).milliseconds(0);
            assert.equal(m.calendar(),       m.format('dddd [huling linggo] LT'),  'Today - ' + i + ' days beginning of day');
            m.hours(23).minutes(59).seconds(59).milliseconds(999);
            assert.equal(m.calendar(),       m.format('dddd [huling linggo] LT'),  'Today - ' + i + ' days end of day');
        }
    });

    test('same all else', function (assert) {
        var weeksAgo = moment().subtract({w: 1}),
            weeksFromNow = moment().add({w: 1});

        assert.equal(weeksAgo.calendar(),       weeksAgo.format('L'),  '1 week ago');
        assert.equal(weeksFromNow.calendar(),   weeksFromNow.format('L'),  'in 1 week');

        weeksAgo = moment().subtract({w: 2});
        weeksFromNow = moment().add({w: 2});

        assert.equal(weeksAgo.calendar(),       weeksAgo.format('L'),  '2 weeks ago');
        assert.equal(weeksFromNow.calendar(),   weeksFromNow.format('L'),  'in 2 weeks');
    });

    test('weeks year starting sunday formatted', function (assert) {
        assert.equal(moment([2012, 0,  1]).format('w ww wo'), '52 52 52', 'Jan  1 2012 should be week 52');
        assert.equal(moment([2012, 0,  2]).format('w ww wo'), '1 01 1', 'Jan  2 2012 should be week 1');
        assert.equal(moment([2012, 0,  8]).format('w ww wo'), '1 01 1', 'Jan  8 2012 should be week 1');
        assert.equal(moment([2012, 0,  9]).format('w ww wo'),   '2 02 2', 'Jan  9 2012 should be week 2');
        assert.equal(moment([2012, 0, 15]).format('w ww wo'),   '2 02 2', 'Jan 15 2012 should be week 2');
    });

}));

;(function (global, factory) {
   typeof exports === 'object' && typeof module !== 'undefined'
       && typeof require === 'function' ? factory(require('../../moment')) :
   typeof define === 'function' && define.amd ? define(['../../moment'], factory) :
   factory(global.moment)
}(this, function (moment) { 'use strict';

    function each(array, callback) {
        var i;
        for (i = 0; i < array.length; i++) {
            callback(array[i], i, array);
        }
    }

    function objectKeys(obj) {
        if (Object.keys) {
            return Object.keys(obj);
        } else {
            // IE8
            var res = [], i;
            for (i in obj) {
                if (obj.hasOwnProperty(i)) {
                    res.push(i);
                }
            }
            return res;
        }
    }

    // Pick the first defined of two or three arguments.
    function defaults(a, b, c) {
        if (a != null) {
            return a;
        }
        if (b != null) {
            return b;
        }
        return c;
    }

    function defineCommonLocaleTests(locale, options) {
        test('lenient ordinal parsing', function (assert) {
            var i, ordinalStr, testMoment;
            for (i = 1; i <= 31; ++i) {
                ordinalStr = moment([2014, 0, i]).format('YYYY MM Do');
                testMoment = moment(ordinalStr, 'YYYY MM Do');
                assert.equal(testMoment.year(), 2014,
                        'lenient ordinal parsing ' + i + ' year check');
                assert.equal(testMoment.month(), 0,
                        'lenient ordinal parsing ' + i + ' month check');
                assert.equal(testMoment.date(), i,
                        'lenient ordinal parsing ' + i + ' date check');
            }
        });

        test('lenient ordinal parsing of number', function (assert) {
            var i, testMoment;
            for (i = 1; i <= 31; ++i) {
                testMoment = moment('2014 01 ' + i, 'YYYY MM Do');
                assert.equal(testMoment.year(), 2014,
                        'lenient ordinal parsing of number ' + i + ' year check');
                assert.equal(testMoment.month(), 0,
                        'lenient ordinal parsing of number ' + i + ' month check');
                assert.equal(testMoment.date(), i,
                        'lenient ordinal parsing of number ' + i + ' date check');
            }
        });

        test('strict ordinal parsing', function (assert) {
            var i, ordinalStr, testMoment;
            for (i = 1; i <= 31; ++i) {
                ordinalStr = moment([2014, 0, i]).format('YYYY MM Do');
                testMoment = moment(ordinalStr, 'YYYY MM Do', true);
                assert.ok(testMoment.isValid(), 'strict ordinal parsing ' + i);
            }
        });

        test('meridiem invariant', function (assert) {
            var h, m, t1, t2;
            for (h = 0; h < 24; ++h) {
                for (m = 0; m < 60; m += 15) {
                    t1 = moment.utc([2000, 0, 1, h, m]);
                    t2 = moment.utc(t1.format('A h:mm'), 'A h:mm');
                    assert.equal(t2.format('HH:mm'), t1.format('HH:mm'),
                            'meridiem at ' + t1.format('HH:mm'));
                }
            }
        });

        test('date format correctness', function (assert) {
            var data, tokens;
            data = moment.localeData()._longDateFormat;
            tokens = objectKeys(data);
            each(tokens, function (srchToken) {
                // Check each format string to make sure it does not contain any
                // tokens that need to be expanded.
                each(tokens, function (baseToken) {
                    // strip escaped sequences
                    var format = data[baseToken].replace(/(\[[^\]]*\])/g, '');
                    assert.equal(false, !!~format.indexOf(srchToken),
                            'contains ' + srchToken + ' in ' + baseToken);
                });
            });
        });

        test('month parsing correctness', function (assert) {
            var i, m;

            if (locale === 'tr') {
                // I can't fix it :(
                expect(0);
                return;
            }
            function tester(format) {
                var r;
                r = moment(m.format(format), format);
                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format);
                r = moment(m.format(format).toLocaleUpperCase(), format);
                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' upper');
                r = moment(m.format(format).toLocaleLowerCase(), format);
                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' lower');

                r = moment(m.format(format), format, true);
                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' strict');
                r = moment(m.format(format).toLocaleUpperCase(), format, true);
                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' upper strict');
                r = moment(m.format(format).toLocaleLowerCase(), format, true);
                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' lower strict');
            }

            for (i = 0; i < 12; ++i) {
                m = moment([2015, i, 15, 18]);
                tester('MMM');
                tester('MMM.');
                tester('MMMM');
                tester('MMMM.');
            }
        });

        test('weekday parsing correctness', function (assert) {
            var i, m;

            if (locale === 'tr' || locale === 'az') {
                // There is a lower-case letter (Ä±), that converted to upper then
                // lower changes to i
                expect(0);
                return;
            }
            function tester(format) {
                var r, baseMsg = 'weekday ' + m.weekday() + ' fmt ' + format;
                r = moment(m.format(format), format);
                assert.equal(r.weekday(), m.weekday(), baseMsg);
                r = moment(m.format(format).toLocaleUpperCase(), format);
                assert.equal(r.weekday(), m.weekday(), baseMsg + ' upper');
                r = moment(m.format(format).toLocaleLowerCase(), format);
                assert.equal(r.weekday(), m.weekday(), baseMsg + ' lower');

                r = moment(m.format(format), format, true);
                assert.equal(r.weekday(), m.weekday(), baseMsg + ' strict');
                r = moment(m.format(format).toLocaleUpperCase(), format, true);
                assert.equal(r.weekday(), m.weekday(), baseMsg + ' upper strict');
                r = moment(m.format(format).toLocaleLowerCase(), format, true);
                assert.equal(r.weekday(), m.weekday(), baseMsg + ' lower strict');
            }

            for (i = 0; i < 7; ++i) {
                m = moment.utc([2015, i, 15, 18]);
                tester('dd');
                tester('ddd');
                tester('dddd');
            }
        });
    }

    function setupDeprecationHandler(test, moment, scope) {
        test._expectedDeprecations = null;
        test._observedDeprecations = null;
        test._oldSupress = moment.suppressDeprecationWarnings;
        moment.suppressDeprecationWarnings = true;
        test.expectedDeprecations = function () {
            test._expectedDeprecations = arguments;
            test._observedDeprecations = [];
        };
        moment.deprecationHandler = function (name, msg) {
            var deprecationId = matchedDeprecation(name, msg, test._expectedDeprecations);
            if (deprecationId === -1) {
                throw new Error('Unexpected deprecation thrown name=' +
                        name + ' msg=' + msg);
            }
            test._observedDeprecations[deprecationId] = 1;
        };
    }

    function teardownDeprecationHandler(test, moment, scope) {
        moment.suppressDeprecationWarnings = test._oldSupress;

        if (test._expectedDeprecations != null) {
            var missedDeprecations = [];
            each(test._expectedDeprecations, function (deprecationPattern, id) {
                if (test._observedDeprecations[id] !== 1) {
                    missedDeprecations.push(deprecationPattern);
                }
            });
            if (missedDeprecations.length !== 0) {
                throw new Error('Expected deprecation warnings did not happen: ' +
                        missedDeprecations.join(' '));
            }
        }
    }

    function matchedDeprecation(name, msg, deprecations) {
        if (deprecations == null) {
            return -1;
        }
        for (var i = 0; i < deprecations.length; ++i) {
            if (name != null && name === deprecations[i]) {
                return i;
            }
            if (msg != null && msg.substring(0, deprecations[i].length) === deprecations[i]) {
                return i;
            }
        }
        return -1;
    }

    /*global QUnit:false*/

    var test = QUnit.test;

    var expect = QUnit.expect;

    function module (name, lifecycle) {
        QUnit.module(name, {
            setup : function () {
                moment.locale('en');
                moment.createFromInputFallback = function (config) {
                    throw new Error('input not handled by moment: ' + config._i);
                };
                setupDeprecationHandler(test, moment, 'core');
                if (lifecycle && lifecycle.setup) {
                    lifecycle.setup();
                }
            },
            teardown : function () {
                teardownDeprecationHandler(test, moment, 'core');
                if (lifecycle && lifecycle.teardown) {
                    lifecycle.teardown();
                }
            }
        });
    }

    function localeModule (name, lifecycle) {
        QUnit.module('locale:' + name, {
            setup : function () {
                moment.locale(name);
                moment.createFromInputFallback = function (config) {
                    throw new Error('input not handled by moment: ' + config._i);
                };
                setupDeprecationHandler(test, moment, 'locale');
                if (lifecycle && lifecycle.setup) {
                    lifecycle.setup();
                }
            },
            teardown : function () {
                moment.locale('en');
                teardownDeprecationHandler(test, moment, 'locale');
                if (lifecycle && lifecycle.teardown) {
                    lifecycle.teardown();
                }
            }
        });
        defineCommonLocaleTests(name, -1, -1);
    }

    localeModule('tlh');

    //Current parsing method doesn't allow parsing correctly months 10, 11 and 12.
    /*
     * test('parse', function (assert) {
        var tests = 'teraâ jar waâ.jar waâ_teraâ jar chaâ.jar chaâ_teraâ jar wej.jar wej_teraâ jar loS.jar loS_teraâ jar vagh.jar vagh_teraâ jar jav.jar jav_teraâ jar Soch.jar Soch_teraâ jar chorgh.jar chorgh_teraâ jar Hut.jar Hut_teraâ jar waâmaH.jar waâmaH_teraâ jar waâmaH waâ.jar waâmaH waâ_teraâ jar waâmaH chaâ.jar waâmaH chaâ'.split('_'), i;
        function equalTest(input, mmm, i) {
            assert.equal(moment(input, mmm).month(), i, input + ' should be month ' + (i + 1));
        }
        for (i = 0; i < 12; i++) {
            tests[i] = tests[i].split('.');
            equalTest(tests[i][0], 'MMM', i);
            equalTest(tests[i][1], 'MMM', i);
            equalTest(tests[i][0], 'MMMM', i);
            equalTest(tests[i][1], 'MMMM', i);
            equalTest(tests[i][0].toLocaleLowerCase(), 'MMMM', i);
            equalTest(tests[i][1].toLocaleLowerCase(), 'MMMM', i);
            equalTest(tests[i][0].toLocaleUpperCase(), 'MMMM', i);
            equalTest(tests[i][1].toLocaleUpperCase(), 'MMMM', i);
        }
    });
    */
    test('format', function (assert) {
        var a = [
                ['dddd, MMMM Do YYYY, h:mm:ss a',      'lojmItjaj, teraâ jar chaâ 14. 2010, 3:25:50 pm'],
                ['ddd, hA',                            'lojmItjaj, 3PM'],
                ['M Mo MM MMMM MMM',                   '2 2. 02 teraâ jar chaâ jar chaâ'],
                ['YYYY YY',                            '2010 10'],
                ['D Do DD',                            '14 14. 14'],
                ['d do dddd ddd dd',                   '0 0. lojmItjaj lojmItjaj lojmItjaj'],
                ['DDD DDDo DDDD',                      '45 45. 045'],
                ['w wo ww',                            '6 6. 06'],
                ['h hh',                               '3 03'],
                ['H HH',                               '15 15'],
                ['m mm',                               '25 25'],
                ['s ss',                               '50 50'],
                ['a A',                                'pm PM'],
                ['[DIS jaj] DDDo',                     'DIS jaj 45.'],
                ['LTS',                                '15:25:50'],
                ['L',                                  '14.02.2010'],
                ['LL',                                 '14 teraâ jar chaâ 2010'],
                ['LLL',                                '14 teraâ jar chaâ 2010 15:25'],
                ['LLLL',                               'lojmItjaj, 14 teraâ jar chaâ 2010 15:25'],
                ['l',                                  '14.2.2010'],
                ['ll',                                 '14 jar chaâ 2010'],
                ['lll',                                '14 jar chaâ 2010 15:25'],
                ['llll',                               'lojmItjaj, 14 jar chaâ 2010 15:25']
            ],
            b = moment(new Date(2010, 1, 14, 15, 25, 50, 125)),
            i;
        for (i = 0; i < a.length; i++) {
            assert.equal(b.format(a[i][0]), a[i][1], a[i][0] + ' ---> ' + a[i][1]);
        }
    });

    test('format ordinal', function (assert) {
        assert.equal(moment([2011, 0, 1]).format('DDDo'), '1.', '1.');
        assert.equal(moment([2011, 0, 2]).format('DDDo'), '2.', '2.');
        assert.equal(moment([2011, 0, 3]).format('DDDo'), '3.', '3.');
        assert.equal(moment([2011, 0, 4]).format('DDDo'), '4.', '4.');
        assert.equal(moment([2011, 0, 5]).format('DDDo'), '5.', '5.');
        assert.equal(moment([2011, 0, 6]).format('DDDo'), '6.', '6.');
        assert.equal(moment([2011, 0, 7]).format('DDDo'), '7.', '7.');
        assert.equal(moment([2011, 0, 8]).format('DDDo'), '8.', '8.');
        assert.equal(moment([2011, 0, 9]).format('DDDo'), '9.', '9.');
        assert.equal(moment([2011, 0, 10]).format('DDDo'), '10.', '10.');

        assert.equal(moment([2011, 0, 11]).format('DDDo'), '11.', '11.');
        assert.equal(moment([2011, 0, 12]).format('DDDo'), '12.', '12.');
        assert.equal(moment([2011, 0, 13]).format('DDDo'), '13.', '13.');
        assert.equal(moment([2011, 0, 14]).format('DDDo'), '14.', '14.');
        assert.equal(moment([2011, 0, 15]).format('DDDo'), '15.', '15.');
        assert.equal(moment([2011, 0, 16]).format('DDDo'), '16.', '16.');
        assert.equal(moment([2011, 0, 17]).format('DDDo'), '17.', '17.');
        assert.equal(moment([2011, 0, 18]).format('DDDo'), '18.', '18.');
        assert.equal(moment([2011, 0, 19]).format('DDDo'), '19.', '19.');
        assert.equal(moment([2011, 0, 20]).format('DDDo'), '20.', '20.');

        assert.equal(moment([2011, 0, 21]).format('DDDo'), '21.', '21.');
        assert.equal(moment([2011, 0, 22]).format('DDDo'), '22.', '22.');
        assert.equal(moment([2011, 0, 23]).format('DDDo'), '23.', '23.');
        assert.equal(moment([2011, 0, 24]).format('DDDo'), '24.', '24.');
        assert.equal(moment([2011, 0, 25]).format('DDDo'), '25.', '25.');
        assert.equal(moment([2011, 0, 26]).format('DDDo'), '26.', '26.');
        assert.equal(moment([2011, 0, 27]).format('DDDo'), '27.', '27.');
        assert.equal(moment([2011, 0, 28]).format('DDDo'), '28.', '28.');
        assert.equal(moment([2011, 0, 29]).format('DDDo'), '29.', '29.');
        assert.equal(moment([2011, 0, 30]).format('DDDo'), '30.', '30.');

        assert.equal(moment([2011, 0, 31]).format('DDDo'), '31.', '31.');
    });

    test('format month', function (assert) {
        var expected = 'teraâ jar waâ jar waâ_teraâ jar chaâ jar chaâ_teraâ jar wej jar wej_teraâ jar loS jar loS_teraâ jar vagh jar vagh_teraâ jar jav jar jav_teraâ jar Soch jar Soch_teraâ jar chorgh jar chorgh_teraâ jar Hut jar Hut_teraâ jar waâmaH jar waâmaH_teraâ jar waâmaH waâ jar waâmaH waâ_teraâ jar waâmaH chaâ jar waâmaH chaâ'.split('_'), i;
        for (i = 0; i < expected.length; i++) {
            assert.equal(moment([2011, i, 1]).format('MMMM MMM'), expected[i], expected[i]);
        }
    });

    test('format week', function (assert) {
        var expected = 'lojmItjaj lojmItjaj lojmItjaj_DaSjaj DaSjaj DaSjaj_povjaj povjaj povjaj_ghItlhjaj ghItlhjaj ghItlhjaj_loghjaj loghjaj loghjaj_buqjaj buqjaj buqjaj_ghInjaj ghInjaj ghInjaj'.split('_'), i;
        for (i = 0; i < expected.length; i++) {
            assert.equal(moment([2011, 0, 2 + i]).format('dddd ddd dd'), expected[i], expected[i]);
        }
    });

    test('from', function (assert) {
        var start = moment([2007, 1, 28]);
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 44}), true),  'puS lup',  '44 seconds = a few seconds');
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 45}), true),  'waâ tup',        '45 seconds = a minute');
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 89}), true),  'waâ tup',        '89 seconds = a minute');
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 90}), true),  'chaâ tup',      '90 seconds = 2 minutes');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 44}), true),  'loSmaH loS tup',     '44 minutes = 44 minutes');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 45}), true),  'waâ rep',       '45 minutes = an hour');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 89}), true),  'waâ rep',       '89 minutes = an hour');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 90}), true),  'chaâ rep',     '90 minutes = 2 hours');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 5}), true),   'vagh rep',      '5 hours = 5 hours');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 21}), true),  'chaâmaH waâ rep',     '21 hours = 21 hours');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 22}), true),  'waâ jaj',       '22 hours = a day');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 35}), true),  'waâ jaj',       '35 hours = a day');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 36}), true),  'chaâ jaj',         '36 hours = 2 days');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 1}), true),   'waâ jaj',       '1 day = a day');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 5}), true),   'vagh jaj',         '5 days = 5 days');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 25}), true),  'chaâmaH vagh jaj',        '25 days = 25 days');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 26}), true),  'waâ jar',       '26 days = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 30}), true),  'waâ jar',       '30 days = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 43}), true),  'waâ jar',       '43 days = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 46}), true),  'chaâ jar',    '46 days = 2 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 74}), true),  'chaâ jar',    '75 days = 2 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 76}), true),  'wej jar',    '76 days = 3 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({M: 1}), true),   'waâ jar',       '1 month = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({M: 5}), true),   'vagh jar',    '5 months = 5 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 345}), true), 'waâ DIS',           '345 days = a year');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 548}), true), 'chaâ DIS',        '548 days = 2 years');
        assert.equal(start.from(moment([2007, 1, 28]).add({y: 1}), true),   'waâ DIS',           '1 year = a year');
        assert.equal(start.from(moment([2007, 1, 28]).add({y: 5}), true),   'vagh DIS',         '5 years = 5 years');
        assert.equal(start.from(moment([2007, 1, 28]).add({y: 112}), true), 'waâvatlh waâmaH chaâ DIS',       '112 years = 112 years');
        assert.equal(start.from(moment([2007, 1, 28]).add({y: 122}), true), 'waâvatlh chaâmaH chaâ DIS',      '122 years = 122 years');
        assert.equal(start.from(moment([2007, 1, 28]).add({y: 213}), true), 'chaâvatlh waâmaH wej DIS',       '213 years = 213 years');
        assert.equal(start.from(moment([2007, 1, 28]).add({y: 223}), true), 'chaâvatlh chaâmaH wej DIS',      '223 years = 223 years');
    });

    test('suffix', function (assert) {
        assert.equal(moment(30000).from(0), 'puS lup pIq',  'suffix');
        assert.equal(moment(0).from(30000), 'puS lup ret', 'suffix');
    });

    test('now from now', function (assert) {
        assert.equal(moment().fromNow(), 'puS lup ret',  'now from now should display as in the past');
    });

    test('fromNow', function (assert) {
        assert.equal(moment().add({s: 30}).fromNow(), 'puS lup pIq', 'in a few seconds');
        assert.equal(moment().add({h: 1}).fromNow(), 'waâ rep pIq', 'in an hour');
        assert.equal(moment().add({d: 5}).fromNow(), 'vagh leS', 'in 5 days');
        assert.equal(moment().add({M: 2}).fromNow(), 'chaâ waQ', 'in 2 months');
        assert.equal(moment().add({y: 1}).fromNow(), 'waâ nem', 'in a year');
        assert.equal(moment().add({s: -30}).fromNow(), 'puS lup ret', 'a few seconds ago');
        assert.equal(moment().add({h: -1}).fromNow(), 'waâ rep ret', 'an hour ago');
        assert.equal(moment().add({d: -5}).fromNow(), 'vagh Huâ', '5 days ago');
        assert.equal(moment().add({M: -2}).fromNow(), 'chaâ wen', '2 months ago');
        assert.equal(moment().add({y: -1}).fromNow(), 'waâ ben', 'a year ago');
    });

    test('calendar day', function (assert) {
        var a = moment().hours(12).minutes(0).seconds(0);

        assert.equal(moment(a).calendar(),                   'DaHjaj 12:00',     'today at the same time');
        assert.equal(moment(a).add({m: 25}).calendar(),      'DaHjaj 12:25',     'Now plus 25 min');
        assert.equal(moment(a).add({h: 1}).calendar(),       'DaHjaj 13:00',     'Now plus 1 hour');
        assert.equal(moment(a).add({d: 1}).calendar(),       'waâleS 12:00',     'tomorrow at the same time');
        assert.equal(moment(a).subtract({h: 1}).calendar(),  'DaHjaj 11:00',     'Now minus 1 hour');
        assert.equal(moment(a).subtract({d: 1}).calendar(),  'waâHuâ 12:00',     'yesterday at the same time');
    });

    test('calendar next week', function (assert) {
        var i, m;
        for (i = 2; i < 7; i++) {
            m = moment().add({d: i});
            assert.equal(m.calendar(),       m.format('LLL'),  'Today + ' + i + ' days current time');
            m.hours(0).minutes(0).seconds(0).milliseconds(0);
            assert.equal(m.calendar(),       m.format('LLL'),  'Today + ' + i + ' days beginning of day');
            m.hours(23).minutes(59).seconds(59).milliseconds(999);
            assert.equal(m.calendar(),       m.format('LLL'),  'Today + ' + i + ' days end of day');
        }
    });

    test('calendar last week', function (assert) {
        var i, m;
        for (i = 2; i < 7; i++) {
            m = moment().subtract({d: i});
            assert.equal(m.calendar(), m.format('LLL'), 'Today - ' + i + ' days current time');

            m.hours(0).minutes(0).seconds(0).milliseconds(0);
            assert.equal(m.calendar(), m.format('LLL'), 'Today - ' + i + ' days beginning of day');

            m.hours(23).minutes(59).seconds(59).milliseconds(999);
            assert.equal(m.calendar(), m.format('LLL'), 'Today - ' + i + ' days end of day');
        }
    });

    test('calendar all else', function (assert) {
        var weeksAgo = moment().subtract({w: 1}),
            weeksFromNow = moment().add({w: 1});

        assert.equal(weeksAgo.calendar(),       weeksAgo.format('L'),  '1 week ago');
        assert.equal(weeksFromNow.calendar(),   weeksFromNow.format('L'),  'in 1 week');

        weeksAgo = moment().subtract({w: 2});
        weeksFromNow = moment().add({w: 2});

        assert.equal(weeksAgo.calendar(),       weeksAgo.format('L'),  '2 weeks ago');
        assert.equal(weeksFromNow.calendar(),   weeksFromNow.format('L'),  'in 2 weeks');
    });

    test('weeks year starting sunday formatted', function (assert) {
        assert.equal(moment([2012, 0,  1]).format('w ww wo'), '52 52 52.', 'Jan  1 2012 should be week 52');
        assert.equal(moment([2012, 0,  2]).format('w ww wo'),   '1 01 1.', 'Jan  2 2012 should be week 1');
        assert.equal(moment([2012, 0,  8]).format('w ww wo'),   '1 01 1.', 'Jan  8 2012 should be week 1');
        assert.equal(moment([2012, 0,  9]).format('w ww wo'),   '2 02 2.', 'Jan  9 2012 should be week 2');
        assert.equal(moment([2012, 0, 15]).format('w ww wo'),   '2 02 2.', 'Jan 15 2012 should be week 2');
    });

}));

;(function (global, factory) {
   typeof exports === 'object' && typeof module !== 'undefined'
       && typeof require === 'function' ? factory(require('../../moment')) :
   typeof define === 'function' && define.amd ? define(['../../moment'], factory) :
   factory(global.moment)
}(this, function (moment) { 'use strict';

    function each(array, callback) {
        var i;
        for (i = 0; i < array.length; i++) {
            callback(array[i], i, array);
        }
    }

    function objectKeys(obj) {
        if (Object.keys) {
            return Object.keys(obj);
        } else {
            // IE8
            var res = [], i;
            for (i in obj) {
                if (obj.hasOwnProperty(i)) {
                    res.push(i);
                }
            }
            return res;
        }
    }

    // Pick the first defined of two or three arguments.
    function defaults(a, b, c) {
        if (a != null) {
            return a;
        }
        if (b != null) {
            return b;
        }
        return c;
    }

    function defineCommonLocaleTests(locale, options) {
        test('lenient ordinal parsing', function (assert) {
            var i, ordinalStr, testMoment;
            for (i = 1; i <= 31; ++i) {
                ordinalStr = moment([2014, 0, i]).format('YYYY MM Do');
                testMoment = moment(ordinalStr, 'YYYY MM Do');
                assert.equal(testMoment.year(), 2014,
                        'lenient ordinal parsing ' + i + ' year check');
                assert.equal(testMoment.month(), 0,
                        'lenient ordinal parsing ' + i + ' month check');
                assert.equal(testMoment.date(), i,
                        'lenient ordinal parsing ' + i + ' date check');
            }
        });

        test('lenient ordinal parsing of number', function (assert) {
            var i, testMoment;
            for (i = 1; i <= 31; ++i) {
                testMoment = moment('2014 01 ' + i, 'YYYY MM Do');
                assert.equal(testMoment.year(), 2014,
                        'lenient ordinal parsing of number ' + i + ' year check');
                assert.equal(testMoment.month(), 0,
                        'lenient ordinal parsing of number ' + i + ' month check');
                assert.equal(testMoment.date(), i,
                        'lenient ordinal parsing of number ' + i + ' date check');
            }
        });

        test('strict ordinal parsing', function (assert) {
            var i, ordinalStr, testMoment;
            for (i = 1; i <= 31; ++i) {
                ordinalStr = moment([2014, 0, i]).format('YYYY MM Do');
                testMoment = moment(ordinalStr, 'YYYY MM Do', true);
                assert.ok(testMoment.isValid(), 'strict ordinal parsing ' + i);
            }
        });

        test('meridiem invariant', function (assert) {
            var h, m, t1, t2;
            for (h = 0; h < 24; ++h) {
                for (m = 0; m < 60; m += 15) {
                    t1 = moment.utc([2000, 0, 1, h, m]);
                    t2 = moment.utc(t1.format('A h:mm'), 'A h:mm');
                    assert.equal(t2.format('HH:mm'), t1.format('HH:mm'),
                            'meridiem at ' + t1.format('HH:mm'));
                }
            }
        });

        test('date format correctness', function (assert) {
            var data, tokens;
            data = moment.localeData()._longDateFormat;
            tokens = objectKeys(data);
            each(tokens, function (srchToken) {
                // Check each format string to make sure it does not contain any
                // tokens that need to be expanded.
                each(tokens, function (baseToken) {
                    // strip escaped sequences
                    var format = data[baseToken].replace(/(\[[^\]]*\])/g, '');
                    assert.equal(false, !!~format.indexOf(srchToken),
                            'contains ' + srchToken + ' in ' + baseToken);
                });
            });
        });

        test('month parsing correctness', function (assert) {
            var i, m;

            if (locale === 'tr') {
                // I can't fix it :(
                expect(0);
                return;
            }
            function tester(format) {
                var r;
                r = moment(m.format(format), format);
                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format);
                r = moment(m.format(format).toLocaleUpperCase(), format);
                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' upper');
                r = moment(m.format(format).toLocaleLowerCase(), format);
                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' lower');

                r = moment(m.format(format), format, true);
                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' strict');
                r = moment(m.format(format).toLocaleUpperCase(), format, true);
                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' upper strict');
                r = moment(m.format(format).toLocaleLowerCase(), format, true);
                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' lower strict');
            }

            for (i = 0; i < 12; ++i) {
                m = moment([2015, i, 15, 18]);
                tester('MMM');
                tester('MMM.');
                tester('MMMM');
                tester('MMMM.');
            }
        });

        test('weekday parsing correctness', function (assert) {
            var i, m;

            if (locale === 'tr' || locale === 'az') {
                // There is a lower-case letter (Ä±), that converted to upper then
                // lower changes to i
                expect(0);
                return;
            }
            function tester(format) {
                var r, baseMsg = 'weekday ' + m.weekday() + ' fmt ' + format;
                r = moment(m.format(format), format);
                assert.equal(r.weekday(), m.weekday(), baseMsg);
                r = moment(m.format(format).toLocaleUpperCase(), format);
                assert.equal(r.weekday(), m.weekday(), baseMsg + ' upper');
                r = moment(m.format(format).toLocaleLowerCase(), format);
                assert.equal(r.weekday(), m.weekday(), baseMsg + ' lower');

                r = moment(m.format(format), format, true);
                assert.equal(r.weekday(), m.weekday(), baseMsg + ' strict');
                r = moment(m.format(format).toLocaleUpperCase(), format, true);
                assert.equal(r.weekday(), m.weekday(), baseMsg + ' upper strict');
                r = moment(m.format(format).toLocaleLowerCase(), format, true);
                assert.equal(r.weekday(), m.weekday(), baseMsg + ' lower strict');
            }

            for (i = 0; i < 7; ++i) {
                m = moment.utc([2015, i, 15, 18]);
                tester('dd');
                tester('ddd');
                tester('dddd');
            }
        });
    }

    function setupDeprecationHandler(test, moment, scope) {
        test._expectedDeprecations = null;
        test._observedDeprecations = null;
        test._oldSupress = moment.suppressDeprecationWarnings;
        moment.suppressDeprecationWarnings = true;
        test.expectedDeprecations = function () {
            test._expectedDeprecations = arguments;
            test._observedDeprecations = [];
        };
        moment.deprecationHandler = function (name, msg) {
            var deprecationId = matchedDeprecation(name, msg, test._expectedDeprecations);
            if (deprecationId === -1) {
                throw new Error('Unexpected deprecation thrown name=' +
                        name + ' msg=' + msg);
            }
            test._observedDeprecations[deprecationId] = 1;
        };
    }

    function teardownDeprecationHandler(test, moment, scope) {
        moment.suppressDeprecationWarnings = test._oldSupress;

        if (test._expectedDeprecations != null) {
            var missedDeprecations = [];
            each(test._expectedDeprecations, function (deprecationPattern, id) {
                if (test._observedDeprecations[id] !== 1) {
                    missedDeprecations.push(deprecationPattern);
                }
            });
            if (missedDeprecations.length !== 0) {
                throw new Error('Expected deprecation warnings did not happen: ' +
                        missedDeprecations.join(' '));
            }
        }
    }

    function matchedDeprecation(name, msg, deprecations) {
        if (deprecations == null) {
            return -1;
        }
        for (var i = 0; i < deprecations.length; ++i) {
            if (name != null && name === deprecations[i]) {
                return i;
            }
            if (msg != null && msg.substring(0, deprecations[i].length) === deprecations[i]) {
                return i;
            }
        }
        return -1;
    }

    /*global QUnit:false*/

    var test = QUnit.test;

    var expect = QUnit.expect;

    function module (name, lifecycle) {
        QUnit.module(name, {
            setup : function () {
                moment.locale('en');
                moment.createFromInputFallback = function (config) {
                    throw new Error('input not handled by moment: ' + config._i);
                };
                setupDeprecationHandler(test, moment, 'core');
                if (lifecycle && lifecycle.setup) {
                    lifecycle.setup();
                }
            },
            teardown : function () {
                teardownDeprecationHandler(test, moment, 'core');
                if (lifecycle && lifecycle.teardown) {
                    lifecycle.teardown();
                }
            }
        });
    }

    function localeModule (name, lifecycle) {
        QUnit.module('locale:' + name, {
            setup : function () {
                moment.locale(name);
                moment.createFromInputFallback = function (config) {
                    throw new Error('input not handled by moment: ' + config._i);
                };
                setupDeprecationHandler(test, moment, 'locale');
                if (lifecycle && lifecycle.setup) {
                    lifecycle.setup();
                }
            },
            teardown : function () {
                moment.locale('en');
                teardownDeprecationHandler(test, moment, 'locale');
                if (lifecycle && lifecycle.teardown) {
                    lifecycle.teardown();
                }
            }
        });
        defineCommonLocaleTests(name, -1, -1);
    }

    localeModule('tr');

    test('parse', function (assert) {
        var tests = 'Ocak Oca_Åubat Åub_Mart Mar_Nisan Nis_MayÄ±s May_Haziran Haz_Temmuz Tem_AÄustos AÄu_EylÃ¼l Eyl_Ekim Eki_KasÄ±m Kas_AralÄ±k Ara'.split('_'), i;
        function equalTest(input, mmm, i) {
            assert.equal(moment(input, mmm).month(), i, input + ' should be month ' + (i + 1));
        }
        for (i = 0; i < 12; i++) {
            tests[i] = tests[i].split(' ');
            equalTest(tests[i][0], 'MMM', i);
            equalTest(tests[i][1], 'MMM', i);
            equalTest(tests[i][0], 'MMMM', i);
            equalTest(tests[i][1], 'MMMM', i);
            equalTest(tests[i][0].toLocaleLowerCase(), 'MMMM', i);
            equalTest(tests[i][1].toLocaleLowerCase(), 'MMMM', i);
            equalTest(tests[i][0].toLocaleUpperCase(), 'MMMM', i);
            equalTest(tests[i][1].toLocaleUpperCase(), 'MMMM', i);
        }
    });

    test('format', function (assert) {
        var a = [
                ['dddd, MMMM Do YYYY, h:mm:ss a',      'Pazar, Åubat 14\'Ã¼ncÃ¼ 2010, 3:25:50 pm'],
                ['ddd, hA',                            'Paz, 3PM'],
                ['M Mo MM MMMM MMM',                   '2 2\'nci 02 Åubat Åub'],
                ['YYYY YY',                            '2010 10'],
                ['D Do DD',                            '14 14\'Ã¼ncÃ¼ 14'],
                ['d do dddd ddd dd',                   '0 0\'Ä±ncÄ± Pazar Paz Pz'],
                ['DDD DDDo DDDD',                      '45 45\'inci 045'],
                ['w wo ww',                            '7 7\'nci 07'],
                ['h hh',                               '3 03'],
                ['H HH',                               '15 15'],
                ['m mm',                               '25 25'],
                ['s ss',                               '50 50'],
                ['a A',                                'pm PM'],
                ['[yÄ±lÄ±n] DDDo [gÃ¼nÃ¼]',                'yÄ±lÄ±n 45\'inci gÃ¼nÃ¼'],
                ['LTS',                                '15:25:50'],
                ['L',                                  '14.02.2010'],
                ['LL',                                 '14 Åubat 2010'],
                ['LLL',                                '14 Åubat 2010 15:25'],
                ['LLLL',                               'Pazar, 14 Åubat 2010 15:25'],
                ['l',                                  '14.2.2010'],
                ['ll',                                 '14 Åub 2010'],
                ['lll',                                '14 Åub 2010 15:25'],
                ['llll',                               'Paz, 14 Åub 2010 15:25']
            ],
            DDDo = [
                [359, '360\'Ä±ncÄ±'],
                [199, '200\'Ã¼ncÃ¼'],
                [149, '150\'nci']
            ],
            dt = moment(new Date(2010, 1, 14, 15, 25, 50, 125)),
            DDDoDt,
            i;

        for (i = 0; i < a.length; i++) {
            assert.equal(dt.format(a[i][0]), a[i][1], a[i][0] + ' ---> ' + a[i][1]);
        }
        for (i = 0; i < DDDo.length; i++) {
            DDDoDt = moment([2010]);
            assert.equal(DDDoDt.add(DDDo[i][0], 'days').format('DDDo'), DDDo[i][1], DDDo[i][0] + ' ---> ' + DDDo[i][1]);
        }
    });

    test('format ordinal', function (assert) {
        assert.equal(moment([2011, 0, 1]).format('DDDo'), '1\'inci', '1st');
        assert.equal(moment([2011, 0, 2]).format('DDDo'), '2\'nci', '2nd');
        assert.equal(moment([2011, 0, 3]).format('DDDo'), '3\'Ã¼ncÃ¼', '3rd');
        assert.equal(moment([2011, 0, 4]).format('DDDo'), '4\'Ã¼ncÃ¼', '4th');
        assert.equal(moment([2011, 0, 5]).format('DDDo'), '5\'inci', '5th');
        assert.equal(moment([2011, 0, 6]).format('DDDo'), '6\'ncÄ±', '6th');
        assert.equal(moment([2011, 0, 7]).format('DDDo'), '7\'nci', '7th');
        assert.equal(moment([2011, 0, 8]).format('DDDo'), '8\'inci', '8th');
        assert.equal(moment([2011, 0, 9]).format('DDDo'), '9\'uncu', '9th');
        assert.equal(moment([2011, 0, 10]).format('DDDo'), '10\'uncu', '10th');

        assert.equal(moment([2011, 0, 11]).format('DDDo'), '11\'inci', '11th');
        assert.equal(moment([2011, 0, 12]).format('DDDo'), '12\'nci', '12th');
        assert.equal(moment([2011, 0, 13]).format('DDDo'), '13\'Ã¼ncÃ¼', '13th');
        assert.equal(moment([2011, 0, 14]).format('DDDo'), '14\'Ã¼ncÃ¼', '14th');
        assert.equal(moment([2011, 0, 15]).format('DDDo'), '15\'inci', '15th');
        assert.equal(moment([2011, 0, 16]).format('DDDo'), '16\'ncÄ±', '16th');
        assert.equal(moment([2011, 0, 17]).format('DDDo'), '17\'nci', '17th');
        assert.equal(moment([2011, 0, 18]).format('DDDo'), '18\'inci', '18th');
        assert.equal(moment([2011, 0, 19]).format('DDDo'), '19\'uncu', '19th');
        assert.equal(moment([2011, 0, 20]).format('DDDo'), '20\'nci', '20th');

        assert.equal(moment([2011, 0, 21]).format('DDDo'), '21\'inci', '21th');
        assert.equal(moment([2011, 0, 22]).format('DDDo'), '22\'nci', '22th');
        assert.equal(moment([2011, 0, 23]).format('DDDo'), '23\'Ã¼ncÃ¼', '23th');
        assert.equal(moment([2011, 0, 24]).format('DDDo'), '24\'Ã¼ncÃ¼', '24th');
        assert.equal(moment([2011, 0, 25]).format('DDDo'), '25\'inci', '25th');
        assert.equal(moment([2011, 0, 26]).format('DDDo'), '26\'ncÄ±', '26th');
        assert.equal(moment([2011, 0, 27]).format('DDDo'), '27\'nci', '27th');
        assert.equal(moment([2011, 0, 28]).format('DDDo'), '28\'inci', '28th');
        assert.equal(moment([2011, 0, 29]).format('DDDo'), '29\'uncu', '29th');
        assert.equal(moment([2011, 0, 30]).format('DDDo'), '30\'uncu', '30th');

        assert.equal(moment([2011, 0, 31]).format('DDDo'), '31\'inci', '31st');
    });

    test('format month', function (assert) {
        var expected = 'Ocak Oca_Åubat Åub_Mart Mar_Nisan Nis_MayÄ±s May_Haziran Haz_Temmuz Tem_AÄustos AÄu_EylÃ¼l Eyl_Ekim Eki_KasÄ±m Kas_AralÄ±k Ara'.split('_'), i;
        for (i = 0; i < expected.length; i++) {
            assert.equal(moment([2011, i, 1]).format('MMMM MMM'), expected[i], expected[i]);
        }
    });

    test('format week', function (assert) {
        var expected = 'Pazar Paz Pz_Pazartesi Pts Pt_SalÄ± Sal Sa_ÃarÅamba Ãar Ãa_PerÅembe Per Pe_Cuma Cum Cu_Cumartesi Cts Ct'.split('_'), i;
        for (i = 0; i < expected.length; i++) {
            assert.equal(moment([2011, 0, 2 + i]).format('dddd ddd dd'), expected[i], expected[i]);
        }
    });

    test('from', function (assert) {
        var start = moment([2007, 1, 28]);
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 44}), true),  'birkaÃ§ saniye', '44 seconds = a few seconds');
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 45}), true),  'bir dakika',      '45 seconds = a minute');
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 89}), true),  'bir dakika',      '89 seconds = a minute');
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 90}), true),  '2 dakika',     '90 seconds = 2 minutes');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 44}), true),  '44 dakika',    '44 minutes = 44 minutes');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 45}), true),  'bir saat',       '45 minutes = an hour');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 89}), true),  'bir saat',       '89 minutes = an hour');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 90}), true),  '2 saat',       '90 minutes = 2 hours');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 5}), true),   '5 saat',       '5 hours = 5 hours');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 21}), true),  '21 saat',      '21 hours = 21 hours');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 22}), true),  'bir gÃ¼n',         '22 hours = a day');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 35}), true),  'bir gÃ¼n',         '35 hours = a day');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 36}), true),  '2 gÃ¼n',        '36 hours = 2 days');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 1}), true),   'bir gÃ¼n',         '1 day = a day');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 5}), true),   '5 gÃ¼n',        '5 days = 5 days');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 25}), true),  '25 gÃ¼n',       '25 days = 25 days');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 26}), true),  'bir ay',       '26 days = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 30}), true),  'bir ay',       '30 days = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 43}), true),  'bir ay',       '43 days = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 46}), true),  '2 ay',      '46 days = 2 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 74}), true),  '2 ay',      '75 days = 2 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 76}), true),  '3 ay',      '76 days = 3 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({M: 1}), true),   'bir ay',       '1 month = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({M: 5}), true),   '5 ay',      '5 months = 5 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 345}), true), 'bir yÄ±l',        '345 days = a year');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 548}), true), '2 yÄ±l',       '548 days = 2 years');
        assert.equal(start.from(moment([2007, 1, 28]).add({y: 1}), true),   'bir yÄ±l',        '1 year = a year');
        assert.equal(start.from(moment([2007, 1, 28]).add({y: 5}), true),   '5 yÄ±l',       '5 years = 5 years');
    });

    test('suffix', function (assert) {
        assert.equal(moment(30000).from(0), 'birkaÃ§ saniye sonra',  'prefix');
        assert.equal(moment(0).from(30000), 'birkaÃ§ saniye Ã¶nce', 'suffix');
    });

    test('now from now', function (assert) {
        assert.equal(moment().fromNow(), 'birkaÃ§ saniye Ã¶nce',  'now from now should display as in the past');
    });

    test('fromNow', function (assert) {
        assert.equal(moment().add({s: 30}).fromNow(), 'birkaÃ§ saniye sonra', 'in a few seconds');
        assert.equal(moment().add({d: 5}).fromNow(), '5 gÃ¼n sonra', 'in 5 days');
    });

    test('calendar day', function (assert) {
        var a = moment().hours(12).minutes(0).seconds(0);

        assert.equal(moment(a).calendar(),                   'bugÃ¼n saat 12:00',     'today at the same time');
        assert.equal(moment(a).add({m: 25}).calendar(),      'bugÃ¼n saat 12:25',     'Now plus 25 min');
        assert.equal(moment(a).add({h: 1}).calendar(),       'bugÃ¼n saat 13:00',     'Now plus 1 hour');
        assert.equal(moment(a).add({d: 1}).calendar(),       'yarÄ±n saat 12:00',     'tomorrow at the same time');
        assert.equal(moment(a).subtract({h: 1}).calendar(),  'bugÃ¼n saat 11:00',     'Now minus 1 hour');
        assert.equal(moment(a).subtract({d: 1}).calendar(),  'dÃ¼n 12:00',            'yesterday at the same time');
    });

    test('calendar next week', function (assert) {
        var i, m;
        for (i = 2; i < 7; i++) {
            m = moment().add({d: i});
            assert.equal(m.calendar(),       m.format('[haftaya] dddd [saat] LT'),  'Today + ' + i + ' days current time');
            m.hours(0).minutes(0).seconds(0).milliseconds(0);
            assert.equal(m.calendar(),       m.format('[haftaya] dddd [saat] LT'),  'Today + ' + i + ' days beginning of day');
            m.hours(23).minutes(59).seconds(59).milliseconds(999);
            assert.equal(m.calendar(),       m.format('[haftaya] dddd [saat] LT'),  'Today + ' + i + ' days end of day');
        }
    });

    test('calendar last week', function (assert) {
        var i, m;
        for (i = 2; i < 7; i++) {
            m = moment().subtract({d: i});
            assert.equal(m.calendar(),       m.format('[geÃ§en hafta] dddd [saat] LT'),  'Today - ' + i + ' days current time');
            m.hours(0).minutes(0).seconds(0).milliseconds(0);
            assert.equal(m.calendar(),       m.format('[geÃ§en hafta] dddd [saat] LT'),  'Today - ' + i + ' days beginning of day');
            m.hours(23).minutes(59).seconds(59).milliseconds(999);
            assert.equal(m.calendar(),       m.format('[geÃ§en hafta] dddd [saat] LT'),  'Today - ' + i + ' days end of day');
        }
    });

    test('calendar all else', function (assert) {
        var weeksAgo = moment().subtract({w: 1}),
            weeksFromNow = moment().add({w: 1});

        assert.equal(weeksAgo.calendar(),       weeksAgo.format('L'),  '1 week ago');
        assert.equal(weeksFromNow.calendar(),   weeksFromNow.format('L'),  'in 1 week');

        weeksAgo = moment().subtract({w: 2});
        weeksFromNow = moment().add({w: 2});

        assert.equal(weeksAgo.calendar(),       weeksAgo.format('L'),  '2 weeks ago');
        assert.equal(weeksFromNow.calendar(),   weeksFromNow.format('L'),  'in 2 weeks');
    });

    test('weeks year starting sunday formatted', function (assert) {
        assert.equal(moment([2011, 11, 26]).format('w ww wo'), '1 01 1\'inci', 'Dec 26 2011 should be week 1');
        assert.equal(moment([2012,  0,  1]).format('w ww wo'), '1 01 1\'inci', 'Jan  1 2012 should be week 1');
        assert.equal(moment([2012,  0,  2]).format('w ww wo'), '2 02 2\'nci', 'Jan  2 2012 should be week 2');
        assert.equal(moment([2012,  0,  8]).format('w ww wo'), '2 02 2\'nci', 'Jan  8 2012 should be week 2');
        assert.equal(moment([2012,  0,  9]).format('w ww wo'), '3 03 3\'Ã¼ncÃ¼', 'Jan  9 2012 should be week 3');
    });

}));

;(function (global, factory) {
   typeof exports === 'object' && typeof module !== 'undefined'
       && typeof require === 'function' ? factory(require('../../moment')) :
   typeof define === 'function' && define.amd ? define(['../../moment'], factory) :
   factory(global.moment)
}(this, function (moment) { 'use strict';

    function each(array, callback) {
        var i;
        for (i = 0; i < array.length; i++) {
            callback(array[i], i, array);
        }
    }

    function objectKeys(obj) {
        if (Object.keys) {
            return Object.keys(obj);
        } else {
            // IE8
            var res = [], i;
            for (i in obj) {
                if (obj.hasOwnProperty(i)) {
                    res.push(i);
                }
            }
            return res;
        }
    }

    // Pick the first defined of two or three arguments.
    function defaults(a, b, c) {
        if (a != null) {
            return a;
        }
        if (b != null) {
            return b;
        }
        return c;
    }

    function defineCommonLocaleTests(locale, options) {
        test('lenient ordinal parsing', function (assert) {
            var i, ordinalStr, testMoment;
            for (i = 1; i <= 31; ++i) {
                ordinalStr = moment([2014, 0, i]).format('YYYY MM Do');
                testMoment = moment(ordinalStr, 'YYYY MM Do');
                assert.equal(testMoment.year(), 2014,
                        'lenient ordinal parsing ' + i + ' year check');
                assert.equal(testMoment.month(), 0,
                        'lenient ordinal parsing ' + i + ' month check');
                assert.equal(testMoment.date(), i,
                        'lenient ordinal parsing ' + i + ' date check');
            }
        });

        test('lenient ordinal parsing of number', function (assert) {
            var i, testMoment;
            for (i = 1; i <= 31; ++i) {
                testMoment = moment('2014 01 ' + i, 'YYYY MM Do');
                assert.equal(testMoment.year(), 2014,
                        'lenient ordinal parsing of number ' + i + ' year check');
                assert.equal(testMoment.month(), 0,
                        'lenient ordinal parsing of number ' + i + ' month check');
                assert.equal(testMoment.date(), i,
                        'lenient ordinal parsing of number ' + i + ' date check');
            }
        });

        test('strict ordinal parsing', function (assert) {
            var i, ordinalStr, testMoment;
            for (i = 1; i <= 31; ++i) {
                ordinalStr = moment([2014, 0, i]).format('YYYY MM Do');
                testMoment = moment(ordinalStr, 'YYYY MM Do', true);
                assert.ok(testMoment.isValid(), 'strict ordinal parsing ' + i);
            }
        });

        test('meridiem invariant', function (assert) {
            var h, m, t1, t2;
            for (h = 0; h < 24; ++h) {
                for (m = 0; m < 60; m += 15) {
                    t1 = moment.utc([2000, 0, 1, h, m]);
                    t2 = moment.utc(t1.format('A h:mm'), 'A h:mm');
                    assert.equal(t2.format('HH:mm'), t1.format('HH:mm'),
                            'meridiem at ' + t1.format('HH:mm'));
                }
            }
        });

        test('date format correctness', function (assert) {
            var data, tokens;
            data = moment.localeData()._longDateFormat;
            tokens = objectKeys(data);
            each(tokens, function (srchToken) {
                // Check each format string to make sure it does not contain any
                // tokens that need to be expanded.
                each(tokens, function (baseToken) {
                    // strip escaped sequences
                    var format = data[baseToken].replace(/(\[[^\]]*\])/g, '');
                    assert.equal(false, !!~format.indexOf(srchToken),
                            'contains ' + srchToken + ' in ' + baseToken);
                });
            });
        });

        test('month parsing correctness', function (assert) {
            var i, m;

            if (locale === 'tr') {
                // I can't fix it :(
                expect(0);
                return;
            }
            function tester(format) {
                var r;
                r = moment(m.format(format), format);
                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format);
                r = moment(m.format(format).toLocaleUpperCase(), format);
                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' upper');
                r = moment(m.format(format).toLocaleLowerCase(), format);
                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' lower');

                r = moment(m.format(format), format, true);
                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' strict');
                r = moment(m.format(format).toLocaleUpperCase(), format, true);
                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' upper strict');
                r = moment(m.format(format).toLocaleLowerCase(), format, true);
                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' lower strict');
            }

            for (i = 0; i < 12; ++i) {
                m = moment([2015, i, 15, 18]);
                tester('MMM');
                tester('MMM.');
                tester('MMMM');
                tester('MMMM.');
            }
        });

        test('weekday parsing correctness', function (assert) {
            var i, m;

            if (locale === 'tr' || locale === 'az') {
                // There is a lower-case letter (Ä±), that converted to upper then
                // lower changes to i
                expect(0);
                return;
            }
            function tester(format) {
                var r, baseMsg = 'weekday ' + m.weekday() + ' fmt ' + format;
                r = moment(m.format(format), format);
                assert.equal(r.weekday(), m.weekday(), baseMsg);
                r = moment(m.format(format).toLocaleUpperCase(), format);
                assert.equal(r.weekday(), m.weekday(), baseMsg + ' upper');
                r = moment(m.format(format).toLocaleLowerCase(), format);
                assert.equal(r.weekday(), m.weekday(), baseMsg + ' lower');

                r = moment(m.format(format), format, true);
                assert.equal(r.weekday(), m.weekday(), baseMsg + ' strict');
                r = moment(m.format(format).toLocaleUpperCase(), format, true);
                assert.equal(r.weekday(), m.weekday(), baseMsg + ' upper strict');
                r = moment(m.format(format).toLocaleLowerCase(), format, true);
                assert.equal(r.weekday(), m.weekday(), baseMsg + ' lower strict');
            }

            for (i = 0; i < 7; ++i) {
                m = moment.utc([2015, i, 15, 18]);
                tester('dd');
                tester('ddd');
                tester('dddd');
            }
        });
    }

    function setupDeprecationHandler(test, moment, scope) {
        test._expectedDeprecations = null;
        test._observedDeprecations = null;
        test._oldSupress = moment.suppressDeprecationWarnings;
        moment.suppressDeprecationWarnings = true;
        test.expectedDeprecations = function () {
            test._expectedDeprecations = arguments;
            test._observedDeprecations = [];
        };
        moment.deprecationHandler = function (name, msg) {
            var deprecationId = matchedDeprecation(name, msg, test._expectedDeprecations);
            if (deprecationId === -1) {
                throw new Error('Unexpected deprecation thrown name=' +
                        name + ' msg=' + msg);
            }
            test._observedDeprecations[deprecationId] = 1;
        };
    }

    function teardownDeprecationHandler(test, moment, scope) {
        moment.suppressDeprecationWarnings = test._oldSupress;

        if (test._expectedDeprecations != null) {
            var missedDeprecations = [];
            each(test._expectedDeprecations, function (deprecationPattern, id) {
                if (test._observedDeprecations[id] !== 1) {
                    missedDeprecations.push(deprecationPattern);
                }
            });
            if (missedDeprecations.length !== 0) {
                throw new Error('Expected deprecation warnings did not happen: ' +
                        missedDeprecations.join(' '));
            }
        }
    }

    function matchedDeprecation(name, msg, deprecations) {
        if (deprecations == null) {
            return -1;
        }
        for (var i = 0; i < deprecations.length; ++i) {
            if (name != null && name === deprecations[i]) {
                return i;
            }
            if (msg != null && msg.substring(0, deprecations[i].length) === deprecations[i]) {
                return i;
            }
        }
        return -1;
    }

    /*global QUnit:false*/

    var test = QUnit.test;

    var expect = QUnit.expect;

    function module (name, lifecycle) {
        QUnit.module(name, {
            setup : function () {
                moment.locale('en');
                moment.createFromInputFallback = function (config) {
                    throw new Error('input not handled by moment: ' + config._i);
                };
                setupDeprecationHandler(test, moment, 'core');
                if (lifecycle && lifecycle.setup) {
                    lifecycle.setup();
                }
            },
            teardown : function () {
                teardownDeprecationHandler(test, moment, 'core');
                if (lifecycle && lifecycle.teardown) {
                    lifecycle.teardown();
                }
            }
        });
    }

    function localeModule (name, lifecycle) {
        QUnit.module('locale:' + name, {
            setup : function () {
                moment.locale(name);
                moment.createFromInputFallback = function (config) {
                    throw new Error('input not handled by moment: ' + config._i);
                };
                setupDeprecationHandler(test, moment, 'locale');
                if (lifecycle && lifecycle.setup) {
                    lifecycle.setup();
                }
            },
            teardown : function () {
                moment.locale('en');
                teardownDeprecationHandler(test, moment, 'locale');
                if (lifecycle && lifecycle.teardown) {
                    lifecycle.teardown();
                }
            }
        });
        defineCommonLocaleTests(name, -1, -1);
    }

    localeModule('tzl');

    test('parse', function (assert) {
        var tests = 'Januar Jan_Fevraglh Fev_MarÃ§ Mar_AvrÃ¯u Avr_Mai Mai_GÃ¼n GÃ¼n_Julia Jul_Guscht Gus_Setemvar Set_ListopÃ¤ts Lis_Noemvar Noe_Zecemvar Zec'.split('_'), i;
        function equalTest(input, mmm, i) {
            assert.equal(moment(input, mmm).month(), i, input + ' should be month ' + (i + 1));
        }
        for (i = 0; i < 12; i++) {
            tests[i] = tests[i].split(' ');
            equalTest(tests[i][0], 'MMM', i);
            equalTest(tests[i][1], 'MMM', i);
            equalTest(tests[i][0], 'MMMM', i);
            equalTest(tests[i][1], 'MMMM', i);
            equalTest(tests[i][0].toLocaleLowerCase(), 'MMMM', i);
            equalTest(tests[i][1].toLocaleLowerCase(), 'MMMM', i);
            equalTest(tests[i][0].toLocaleUpperCase(), 'MMMM', i);
            equalTest(tests[i][1].toLocaleUpperCase(), 'MMMM', i);
        }
    });

    test('format', function (assert) {
        var a = [
                ['dddd, MMMM Do YYYY, h.mm.ss a',      'SÃºladi, Fevraglh 14. 2010, 3.25.50 d\'o'],
                ['ddd, hA',                            'SÃºl, 3D\'O'],
                ['M Mo MM MMMM MMM',                   '2 2. 02 Fevraglh Fev'],
                ['YYYY YY',                            '2010 10'],
                ['D Do DD',                            '14 14. 14'],
                ['d do dddd ddd dd',                   '0 0. SÃºladi SÃºl SÃº'],
                ['DDD DDDo DDDD',                      '45 45. 045'],
                ['w wo ww',                            '6 6. 06'],
                ['h hh',                               '3 03'],
                ['H HH',                               '15 15'],
                ['m mm',                               '25 25'],
                ['s ss',                               '50 50'],
                ['a A',                                'd\'o D\'O'],
                ['[the] DDDo [day of the year]',       'the 45. day of the year'],
                ['LTS',                                '15.25.50'],
                ['L',                                  '14.02.2010'],
                ['LL',                                 '14. Fevraglh dallas 2010'],
                ['LLL',                                '14. Fevraglh dallas 2010 15.25'],
                ['LLLL',                               'SÃºladi, li 14. Fevraglh dallas 2010 15.25'],
                ['l',                                  '14.2.2010'],
                ['ll',                                 '14. Fev dallas 2010'],
                ['lll',                                '14. Fev dallas 2010 15.25'],
                ['llll',                               'SÃºl, li 14. Fev dallas 2010 15.25']
            ],
            b = moment(new Date(2010, 1, 14, 15, 25, 50, 125)),
            i;
        for (i = 0; i < a.length; i++) {
            assert.equal(b.format(a[i][0]), a[i][1], a[i][0] + ' ---> ' + a[i][1]);
        }
    });

    test('format ordinal', function (assert) {
        assert.equal(moment([2011, 0, 1]).format('DDDo'), '1.', '1.');
        assert.equal(moment([2011, 0, 2]).format('DDDo'), '2.', '2.');
        assert.equal(moment([2011, 0, 3]).format('DDDo'), '3.', '3.');
        assert.equal(moment([2011, 0, 4]).format('DDDo'), '4.', '4.');
        assert.equal(moment([2011, 0, 5]).format('DDDo'), '5.', '5.');
        assert.equal(moment([2011, 0, 6]).format('DDDo'), '6.', '6.');
        assert.equal(moment([2011, 0, 7]).format('DDDo'), '7.', '7.');
        assert.equal(moment([2011, 0, 8]).format('DDDo'), '8.', '8.');
        assert.equal(moment([2011, 0, 9]).format('DDDo'), '9.', '9.');
        assert.equal(moment([2011, 0, 10]).format('DDDo'), '10.', '10.');

        assert.equal(moment([2011, 0, 11]).format('DDDo'), '11.', '11.');
        assert.equal(moment([2011, 0, 12]).format('DDDo'), '12.', '12.');
        assert.equal(moment([2011, 0, 13]).format('DDDo'), '13.', '13.');
        assert.equal(moment([2011, 0, 14]).format('DDDo'), '14.', '14.');
        assert.equal(moment([2011, 0, 15]).format('DDDo'), '15.', '15.');
        assert.equal(moment([2011, 0, 16]).format('DDDo'), '16.', '16.');
        assert.equal(moment([2011, 0, 17]).format('DDDo'), '17.', '17.');
        assert.equal(moment([2011, 0, 18]).format('DDDo'), '18.', '18.');
        assert.equal(moment([2011, 0, 19]).format('DDDo'), '19.', '19.');
        assert.equal(moment([2011, 0, 20]).format('DDDo'), '20.', '20.');

        assert.equal(moment([2011, 0, 21]).format('DDDo'), '21.', '21.');
        assert.equal(moment([2011, 0, 22]).format('DDDo'), '22.', '22.');
        assert.equal(moment([2011, 0, 23]).format('DDDo'), '23.', '23.');
        assert.equal(moment([2011, 0, 24]).format('DDDo'), '24.', '24.');
        assert.equal(moment([2011, 0, 25]).format('DDDo'), '25.', '25.');
        assert.equal(moment([2011, 0, 26]).format('DDDo'), '26.', '26.');
        assert.equal(moment([2011, 0, 27]).format('DDDo'), '27.', '27.');
        assert.equal(moment([2011, 0, 28]).format('DDDo'), '28.', '28.');
        assert.equal(moment([2011, 0, 29]).format('DDDo'), '29.', '29.');
        assert.equal(moment([2011, 0, 30]).format('DDDo'), '30.', '30.');

        assert.equal(moment([2011, 0, 31]).format('DDDo'), '31.', '31.');
    });

    test('format month', function (assert) {
        var expected = 'Januar Jan_Fevraglh Fev_MarÃ§ Mar_AvrÃ¯u Avr_Mai Mai_GÃ¼n GÃ¼n_Julia Jul_Guscht Gus_Setemvar Set_ListopÃ¤ts Lis_Noemvar Noe_Zecemvar Zec'.split('_'), i;
        for (i = 0; i < expected.length; i++) {
            assert.equal(moment([2011, i, 1]).format('MMMM MMM'), expected[i], expected[i]);
        }
    });

    test('format week', function (assert) {
        var expected = 'SÃºladi SÃºl SÃº_LÃºneÃ§i LÃºn LÃº_Maitzi Mai Ma_MÃ¡rcuri MÃ¡r MÃ¡_XhÃºadi XhÃº Xh_ViÃ©nerÃ§i ViÃ© Vi_SÃ¡turi SÃ¡t SÃ¡'.split('_'), i;
        for (i = 0; i < expected.length; i++) {
            assert.equal(moment([2011, 0, 2 + i]).format('dddd ddd dd'), expected[i], expected[i]);
        }
    });

    test('from', function (assert) {
        var start = moment([2007, 1, 28]);
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 44}), true),  'viensas secunds', '44 seconds = a few seconds');
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 45}), true),  '\'n mÃ­ut',      '45 seconds = a minute');
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 89}), true),  '\'n mÃ­ut',      '89 seconds = a minute');
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 90}), true),  '2 mÃ­uts',     '90 seconds = 2 minutes');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 44}), true),  '44 mÃ­uts',    '44 minutes = 44 minutes');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 45}), true),  '\'n Ã¾ora',       '45 minutes = an hour');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 89}), true),  '\'n Ã¾ora',       '89 minutes = an hour');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 90}), true),  '2 Ã¾oras',       '90 minutes = 2 hours');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 5}), true),   '5 Ã¾oras',       '5 hours = 5 hours');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 21}), true),  '21 Ã¾oras',      '21 hours = 21 hours');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 22}), true),  '\'n ziua',         '22 hours = a day');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 35}), true),  '\'n ziua',         '35 hours = a day');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 36}), true),  '2 ziuas',        '36 hours = 2 days');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 1}), true),   '\'n ziua',         '1 day = a day');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 5}), true),   '5 ziuas',        '5 days = 5 days');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 25}), true),  '25 ziuas',       '25 days = 25 days');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 26}), true),  '\'n mes',       '26 days = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 30}), true),  '\'n mes',       '30 days = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 43}), true),  '\'n mes',       '43 days = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 46}), true),  '2 mesen',      '46 days = 2 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 74}), true),  '2 mesen',      '75 days = 2 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 76}), true),  '3 mesen',      '76 days = 3 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({M: 1}), true),   '\'n mes',       '1 month = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({M: 5}), true),   '5 mesen',      '5 months = 5 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 345}), true), '\'n ar',        '345 days = a year');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 548}), true), '2 ars',       '548 days = 2 years');
        assert.equal(start.from(moment([2007, 1, 28]).add({y: 1}), true),   '\'n ar',        '1 year = a year');
        assert.equal(start.from(moment([2007, 1, 28]).add({y: 5}), true),   '5 ars',       '5 years = 5 years');
    });

    test('suffix', function (assert) {
        assert.equal(moment(30000).from(0), 'osprei viensas secunds',  'prefix');
        assert.equal(moment(0).from(30000), 'ja\'iensas secunds', 'suffix');
    });

    test('now from now', function (assert) {
        assert.equal(moment().fromNow(), 'ja\'iensas secunds',  'now from now should display as in the past');
    });

    test('fromNow', function (assert) {
        assert.equal(moment().add({s: 30}).fromNow(), 'osprei viensas secunds', 'in a few seconds');
        assert.equal(moment().add({d: 5}).fromNow(), 'osprei 5 ziuas', 'in 5 days');
    });

    test('calendar day', function (assert) {
        var a = moment().hours(12).minutes(0).seconds(0);

        assert.equal(moment(a).calendar(),                   'oxhi Ã  12.00',      'today at the same time');
        assert.equal(moment(a).add({m: 25}).calendar(),      'oxhi Ã  12.25',      'Now plus 25 min');
        assert.equal(moment(a).add({h: 1}).calendar(),       'oxhi Ã  13.00',      'Now plus 1 hour');
        assert.equal(moment(a).add({d: 1}).calendar(),       'demÃ  Ã  12.00',      'tomorrow at the same time');
        assert.equal(moment(a).subtract({h: 1}).calendar(),  'oxhi Ã  11.00',      'Now minus 1 hour');
        assert.equal(moment(a).subtract({d: 1}).calendar(),  'ieiri Ã  12.00',     'yesterday at the same time');
    });

    test('calendar next week', function (assert) {
        var i, m;
        for (i = 2; i < 7; i++) {
            m = moment().add({d: i});
            assert.equal(m.calendar(),       m.format('dddd [Ã ] LT'),  'Today + ' + i + ' days current time');
            m.hours(0).minutes(0).seconds(0).milliseconds(0);
            assert.equal(m.calendar(),       m.format('dddd [Ã ] LT'),  'Today + ' + i + ' days beginning of day');
            m.hours(23).minutes(59).seconds(59).milliseconds(999);
            assert.equal(m.calendar(),       m.format('dddd [Ã ] LT'),  'Today + ' + i + ' days end of day');
        }
    });

    test('calendar last week', function (assert) {
        var i, m;

        for (i = 2; i < 7; i++) {
            m = moment().subtract({d: i});
            assert.equal(m.calendar(),       m.format('[sÃ¼r el] dddd [lasteu Ã ] LT'),  'Today - ' + i + ' days current time');
            m.hours(0).minutes(0).seconds(0).milliseconds(0);
            assert.equal(m.calendar(),       m.format('[sÃ¼r el] dddd [lasteu Ã ] LT'),  'Today - ' + i + ' days beginning of day');
            m.hours(23).minutes(59).seconds(59).milliseconds(999);
            assert.equal(m.calendar(),       m.format('[sÃ¼r el] dddd [lasteu Ã ] LT'),  'Today - ' + i + ' days end of day');
        }
    });

    test('calendar all else', function (assert) {
        var weeksAgo = moment().subtract({w: 1}),
            weeksFromNow = moment().add({w: 1});

        assert.equal(weeksAgo.calendar(),       weeksAgo.format('L'),  '1 week ago');
        assert.equal(weeksFromNow.calendar(),   weeksFromNow.format('L'),  'in 1 week');

        weeksAgo = moment().subtract({w: 2});
        weeksFromNow = moment().add({w: 2});

        assert.equal(weeksAgo.calendar(),       weeksAgo.format('L'),  '2 weeks ago');
        assert.equal(weeksFromNow.calendar(),   weeksFromNow.format('L'),  'in 2 weeks');
    });

    // Monday is the first day of the week.
    // The week that contains Jan 4th is the first week of the year.

    test('weeks year starting sunday formatted', function (assert) {
        assert.equal(moment([2012, 0,  1]).format('w ww wo'), '52 52 52.', 'Jan  1 2012 should be week 52');
        assert.equal(moment([2012, 0,  2]).format('w ww wo'),   '1 01 1.', 'Jan  2 2012 should be week 1');
        assert.equal(moment([2012, 0,  8]).format('w ww wo'),   '1 01 1.', 'Jan  8 2012 should be week 1');
        assert.equal(moment([2012, 0,  9]).format('w ww wo'),   '2 02 2.', 'Jan  9 2012 should be week 2');
        assert.equal(moment([2012, 0, 15]).format('w ww wo'),   '2 02 2.', 'Jan 15 2012 should be week 2');
    });

}));

;(function (global, factory) {
   typeof exports === 'object' && typeof module !== 'undefined'
       && typeof require === 'function' ? factory(require('../../moment')) :
   typeof define === 'function' && define.amd ? define(['../../moment'], factory) :
   factory(global.moment)
}(this, function (moment) { 'use strict';

    function each(array, callback) {
        var i;
        for (i = 0; i < array.length; i++) {
            callback(array[i], i, array);
        }
    }

    function objectKeys(obj) {
        if (Object.keys) {
            return Object.keys(obj);
        } else {
            // IE8
            var res = [], i;
            for (i in obj) {
                if (obj.hasOwnProperty(i)) {
                    res.push(i);
                }
            }
            return res;
        }
    }

    // Pick the first defined of two or three arguments.
    function defaults(a, b, c) {
        if (a != null) {
            return a;
        }
        if (b != null) {
            return b;
        }
        return c;
    }

    function defineCommonLocaleTests(locale, options) {
        test('lenient ordinal parsing', function (assert) {
            var i, ordinalStr, testMoment;
            for (i = 1; i <= 31; ++i) {
                ordinalStr = moment([2014, 0, i]).format('YYYY MM Do');
                testMoment = moment(ordinalStr, 'YYYY MM Do');
                assert.equal(testMoment.year(), 2014,
                        'lenient ordinal parsing ' + i + ' year check');
                assert.equal(testMoment.month(), 0,
                        'lenient ordinal parsing ' + i + ' month check');
                assert.equal(testMoment.date(), i,
                        'lenient ordinal parsing ' + i + ' date check');
            }
        });

        test('lenient ordinal parsing of number', function (assert) {
            var i, testMoment;
            for (i = 1; i <= 31; ++i) {
                testMoment = moment('2014 01 ' + i, 'YYYY MM Do');
                assert.equal(testMoment.year(), 2014,
                        'lenient ordinal parsing of number ' + i + ' year check');
                assert.equal(testMoment.month(), 0,
                        'lenient ordinal parsing of number ' + i + ' month check');
                assert.equal(testMoment.date(), i,
                        'lenient ordinal parsing of number ' + i + ' date check');
            }
        });

        test('strict ordinal parsing', function (assert) {
            var i, ordinalStr, testMoment;
            for (i = 1; i <= 31; ++i) {
                ordinalStr = moment([2014, 0, i]).format('YYYY MM Do');
                testMoment = moment(ordinalStr, 'YYYY MM Do', true);
                assert.ok(testMoment.isValid(), 'strict ordinal parsing ' + i);
            }
        });

        test('meridiem invariant', function (assert) {
            var h, m, t1, t2;
            for (h = 0; h < 24; ++h) {
                for (m = 0; m < 60; m += 15) {
                    t1 = moment.utc([2000, 0, 1, h, m]);
                    t2 = moment.utc(t1.format('A h:mm'), 'A h:mm');
                    assert.equal(t2.format('HH:mm'), t1.format('HH:mm'),
                            'meridiem at ' + t1.format('HH:mm'));
                }
            }
        });

        test('date format correctness', function (assert) {
            var data, tokens;
            data = moment.localeData()._longDateFormat;
            tokens = objectKeys(data);
            each(tokens, function (srchToken) {
                // Check each format string to make sure it does not contain any
                // tokens that need to be expanded.
                each(tokens, function (baseToken) {
                    // strip escaped sequences
                    var format = data[baseToken].replace(/(\[[^\]]*\])/g, '');
                    assert.equal(false, !!~format.indexOf(srchToken),
                            'contains ' + srchToken + ' in ' + baseToken);
                });
            });
        });

        test('month parsing correctness', function (assert) {
            var i, m;

            if (locale === 'tr') {
                // I can't fix it :(
                expect(0);
                return;
            }
            function tester(format) {
                var r;
                r = moment(m.format(format), format);
                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format);
                r = moment(m.format(format).toLocaleUpperCase(), format);
                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' upper');
                r = moment(m.format(format).toLocaleLowerCase(), format);
                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' lower');

                r = moment(m.format(format), format, true);
                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' strict');
                r = moment(m.format(format).toLocaleUpperCase(), format, true);
                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' upper strict');
                r = moment(m.format(format).toLocaleLowerCase(), format, true);
                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' lower strict');
            }

            for (i = 0; i < 12; ++i) {
                m = moment([2015, i, 15, 18]);
                tester('MMM');
                tester('MMM.');
                tester('MMMM');
                tester('MMMM.');
            }
        });

        test('weekday parsing correctness', function (assert) {
            var i, m;

            if (locale === 'tr' || locale === 'az') {
                // There is a lower-case letter (Ä±), that converted to upper then
                // lower changes to i
                expect(0);
                return;
            }
            function tester(format) {
                var r, baseMsg = 'weekday ' + m.weekday() + ' fmt ' + format;
                r = moment(m.format(format), format);
                assert.equal(r.weekday(), m.weekday(), baseMsg);
                r = moment(m.format(format).toLocaleUpperCase(), format);
                assert.equal(r.weekday(), m.weekday(), baseMsg + ' upper');
                r = moment(m.format(format).toLocaleLowerCase(), format);
                assert.equal(r.weekday(), m.weekday(), baseMsg + ' lower');

                r = moment(m.format(format), format, true);
                assert.equal(r.weekday(), m.weekday(), baseMsg + ' strict');
                r = moment(m.format(format).toLocaleUpperCase(), format, true);
                assert.equal(r.weekday(), m.weekday(), baseMsg + ' upper strict');
                r = moment(m.format(format).toLocaleLowerCase(), format, true);
                assert.equal(r.weekday(), m.weekday(), baseMsg + ' lower strict');
            }

            for (i = 0; i < 7; ++i) {
                m = moment.utc([2015, i, 15, 18]);
                tester('dd');
                tester('ddd');
                tester('dddd');
            }
        });
    }

    function setupDeprecationHandler(test, moment, scope) {
        test._expectedDeprecations = null;
        test._observedDeprecations = null;
        test._oldSupress = moment.suppressDeprecationWarnings;
        moment.suppressDeprecationWarnings = true;
        test.expectedDeprecations = function () {
            test._expectedDeprecations = arguments;
            test._observedDeprecations = [];
        };
        moment.deprecationHandler = function (name, msg) {
            var deprecationId = matchedDeprecation(name, msg, test._expectedDeprecations);
            if (deprecationId === -1) {
                throw new Error('Unexpected deprecation thrown name=' +
                        name + ' msg=' + msg);
            }
            test._observedDeprecations[deprecationId] = 1;
        };
    }

    function teardownDeprecationHandler(test, moment, scope) {
        moment.suppressDeprecationWarnings = test._oldSupress;

        if (test._expectedDeprecations != null) {
            var missedDeprecations = [];
            each(test._expectedDeprecations, function (deprecationPattern, id) {
                if (test._observedDeprecations[id] !== 1) {
                    missedDeprecations.push(deprecationPattern);
                }
            });
            if (missedDeprecations.length !== 0) {
                throw new Error('Expected deprecation warnings did not happen: ' +
                        missedDeprecations.join(' '));
            }
        }
    }

    function matchedDeprecation(name, msg, deprecations) {
        if (deprecations == null) {
            return -1;
        }
        for (var i = 0; i < deprecations.length; ++i) {
            if (name != null && name === deprecations[i]) {
                return i;
            }
            if (msg != null && msg.substring(0, deprecations[i].length) === deprecations[i]) {
                return i;
            }
        }
        return -1;
    }

    /*global QUnit:false*/

    var test = QUnit.test;

    var expect = QUnit.expect;

    function module (name, lifecycle) {
        QUnit.module(name, {
            setup : function () {
                moment.locale('en');
                moment.createFromInputFallback = function (config) {
                    throw new Error('input not handled by moment: ' + config._i);
                };
                setupDeprecationHandler(test, moment, 'core');
                if (lifecycle && lifecycle.setup) {
                    lifecycle.setup();
                }
            },
            teardown : function () {
                teardownDeprecationHandler(test, moment, 'core');
                if (lifecycle && lifecycle.teardown) {
                    lifecycle.teardown();
                }
            }
        });
    }

    function localeModule (name, lifecycle) {
        QUnit.module('locale:' + name, {
            setup : function () {
                moment.locale(name);
                moment.createFromInputFallback = function (config) {
                    throw new Error('input not handled by moment: ' + config._i);
                };
                setupDeprecationHandler(test, moment, 'locale');
                if (lifecycle && lifecycle.setup) {
                    lifecycle.setup();
                }
            },
            teardown : function () {
                moment.locale('en');
                teardownDeprecationHandler(test, moment, 'locale');
                if (lifecycle && lifecycle.teardown) {
                    lifecycle.teardown();
                }
            }
        });
        defineCommonLocaleTests(name, -1, -1);
    }

    localeModule('tzm-latn');

    test('parse', function (assert) {
        var tests = 'innayr innayr_brË¤ayrË¤ brË¤ayrË¤_marË¤sË¤ marË¤sË¤_ibrir ibrir_mayyw mayyw_ywnyw ywnyw_ywlywz ywlywz_É£wÅ¡t É£wÅ¡t_Å¡wtanbir Å¡wtanbir_ktË¤wbrË¤ ktË¤wbrË¤_nwwanbir nwwanbir_dwjnbir dwjnbir'.split('_'), i;
        function equalTest(input, mmm, i) {
            assert.equal(moment(input, mmm).month(), i, input + ' should be month ' + (i + 1));
        }
        for (i = 0; i < 12; i++) {
            tests[i] = tests[i].split(' ');
            equalTest(tests[i][0], 'MMM', i);
            equalTest(tests[i][1], 'MMM', i);
            equalTest(tests[i][0], 'MMMM', i);
            equalTest(tests[i][1], 'MMMM', i);
            equalTest(tests[i][0].toLocaleLowerCase(), 'MMMM', i);
            equalTest(tests[i][1].toLocaleLowerCase(), 'MMMM', i);
            equalTest(tests[i][0].toLocaleUpperCase(), 'MMMM', i);
            equalTest(tests[i][1].toLocaleUpperCase(), 'MMMM', i);
        }
    });

    test('format', function (assert) {
        var a = [
                ['dddd, MMMM Do YYYY, h:mm:ss a',      'asamas, brË¤ayrË¤ 14 2010, 3:25:50 pm'],
                ['ddd, hA',                            'asamas, 3PM'],
                ['M Mo MM MMMM MMM',                   '2 2 02 brË¤ayrË¤ brË¤ayrË¤'],
                ['YYYY YY',                            '2010 10'],
                ['D Do DD',                            '14 14 14'],
                ['d do dddd ddd dd',                   '0 0 asamas asamas asamas'],
                ['DDD DDDo DDDD',                      '45 45 045'],
                ['w wo ww',                            '8 8 08'],
                ['h hh',                               '3 03'],
                ['H HH',                               '15 15'],
                ['m mm',                               '25 25'],
                ['s ss',                               '50 50'],
                ['a A',                                'pm PM'],
                ['[the] DDDo [day of the year]',       'the 45 day of the year'],
                ['LTS',                                '15:25:50'],
                ['L',                                  '14/02/2010'],
                ['LL',                                 '14 brË¤ayrË¤ 2010'],
                ['LLL',                                '14 brË¤ayrË¤ 2010 15:25'],
                ['LLLL',                               'asamas 14 brË¤ayrË¤ 2010 15:25'],
                ['l',                                  '14/2/2010'],
                ['ll',                                 '14 brË¤ayrË¤ 2010'],
                ['lll',                                '14 brË¤ayrË¤ 2010 15:25'],
                ['llll',                               'asamas 14 brË¤ayrË¤ 2010 15:25']
            ],
            b = moment(new Date(2010, 1, 14, 15, 25, 50, 125)),
            i;
        for (i = 0; i < a.length; i++) {
            assert.equal(b.format(a[i][0]), a[i][1], a[i][0] + ' ---> ' + a[i][1]);
        }
    });

    test('format ordinal', function (assert) {
        assert.equal(moment([2011, 0, 1]).format('DDDo'), '1', '1');
        assert.equal(moment([2011, 0, 2]).format('DDDo'), '2', '2');
        assert.equal(moment([2011, 0, 3]).format('DDDo'), '3', '3');
        assert.equal(moment([2011, 0, 4]).format('DDDo'), '4', '4');
        assert.equal(moment([2011, 0, 5]).format('DDDo'), '5', '5');
        assert.equal(moment([2011, 0, 6]).format('DDDo'), '6', '6');
        assert.equal(moment([2011, 0, 7]).format('DDDo'), '7', '7');
        assert.equal(moment([2011, 0, 8]).format('DDDo'), '8', '8');
        assert.equal(moment([2011, 0, 9]).format('DDDo'), '9', '9');
        assert.equal(moment([2011, 0, 10]).format('DDDo'), '10', '10');

        assert.equal(moment([2011, 0, 11]).format('DDDo'), '11', '11');
        assert.equal(moment([2011, 0, 12]).format('DDDo'), '12', '12');
        assert.equal(moment([2011, 0, 13]).format('DDDo'), '13', '13');
        assert.equal(moment([2011, 0, 14]).format('DDDo'), '14', '14');
        assert.equal(moment([2011, 0, 15]).format('DDDo'), '15', '15');
        assert.equal(moment([2011, 0, 16]).format('DDDo'), '16', '16');
        assert.equal(moment([2011, 0, 17]).format('DDDo'), '17', '17');
        assert.equal(moment([2011, 0, 18]).format('DDDo'), '18', '18');
        assert.equal(moment([2011, 0, 19]).format('DDDo'), '19', '19');
        assert.equal(moment([2011, 0, 20]).format('DDDo'), '20', '20');

        assert.equal(moment([2011, 0, 21]).format('DDDo'), '21', '21');
        assert.equal(moment([2011, 0, 22]).format('DDDo'), '22', '22');
        assert.equal(moment([2011, 0, 23]).format('DDDo'), '23', '23');
        assert.equal(moment([2011, 0, 24]).format('DDDo'), '24', '24');
        assert.equal(moment([2011, 0, 25]).format('DDDo'), '25', '25');
        assert.equal(moment([2011, 0, 26]).format('DDDo'), '26', '26');
        assert.equal(moment([2011, 0, 27]).format('DDDo'), '27', '27');
        assert.equal(moment([2011, 0, 28]).format('DDDo'), '28', '28');
        assert.equal(moment([2011, 0, 29]).format('DDDo'), '29', '29');
        assert.equal(moment([2011, 0, 30]).format('DDDo'), '30', '30');

        assert.equal(moment([2011, 0, 31]).format('DDDo'), '31', '31');
    });

    test('format month', function (assert) {
        var expected = 'innayr innayr_brË¤ayrË¤ brË¤ayrË¤_marË¤sË¤ marË¤sË¤_ibrir ibrir_mayyw mayyw_ywnyw ywnyw_ywlywz ywlywz_É£wÅ¡t É£wÅ¡t_Å¡wtanbir Å¡wtanbir_ktË¤wbrË¤ ktË¤wbrË¤_nwwanbir nwwanbir_dwjnbir dwjnbir'.split('_'), i;
        for (i = 0; i < expected.length; i++) {
            assert.equal(moment([2011, i, 1]).format('MMMM MMM'), expected[i], expected[i]);
        }
    });

    test('format week', function (assert) {
        var expected = 'asamas asamas asamas_aynas aynas aynas_asinas asinas asinas_akras akras akras_akwas akwas akwas_asimwas asimwas asimwas_asiá¸yas asiá¸yas asiá¸yas'.split('_'), i;
        for (i = 0; i < expected.length; i++) {
            assert.equal(moment([2011, 0, 2 + i]).format('dddd ddd dd'), expected[i], expected[i]);
        }
    });

    test('from', function (assert) {
        var start = moment([2007, 1, 28]);
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 44}), true),  'imik', '44 seconds = a few seconds');
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 45}), true),  'minuá¸',      '45 seconds = a minute');
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 89}), true),  'minuá¸',      '89 seconds = a minute');
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 90}), true),  '2 minuá¸',     '90 seconds = 2 minutes');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 44}), true),  '44 minuá¸',    '44 minutes = 44 minutes');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 45}), true),  'saÉa',       '45 minutes = an hour');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 89}), true),  'saÉa',       '89 minutes = an hour');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 90}), true),  '2 tassaÉin',       '90 minutes = 2 hours');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 5}), true),   '5 tassaÉin',       '5 hours = 5 hours');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 21}), true),  '21 tassaÉin',      '21 hours = 21 hours');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 22}), true),  'ass',         '22 hours = a day');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 35}), true),  'ass',         '35 hours = a day');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 36}), true),  '2 ossan',        '36 hours = 2 days');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 1}), true),   'ass',         '1 day = a day');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 5}), true),   '5 ossan',        '5 days = 5 days');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 25}), true),  '25 ossan',       '25 days = 25 days');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 26}), true),  'ayowr',       '26 days = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 30}), true),  'ayowr',       '30 days = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 43}), true),  'ayowr',       '43 days = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 46}), true),  '2 iyyirn',      '46 days = 2 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 74}), true),  '2 iyyirn',      '75 days = 2 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 76}), true),  '3 iyyirn',      '76 days = 3 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({M: 1}), true),   'ayowr',       '1 month = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({M: 5}), true),   '5 iyyirn',      '5 months = 5 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 345}), true), 'asgas',        '345 days = a year');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 548}), true), '2 isgasn',       '548 days = 2 years');
        assert.equal(start.from(moment([2007, 1, 28]).add({y: 1}), true),   'asgas',        '1 year = a year');
        assert.equal(start.from(moment([2007, 1, 28]).add({y: 5}), true),   '5 isgasn',       '5 years = 5 years');
    });

    test('suffix', function (assert) {
        assert.equal(moment(30000).from(0), 'dadkh s yan imik',  'prefix');
        assert.equal(moment(0).from(30000), 'yan imik', 'suffix');
    });

    test('now from now', function (assert) {
        assert.equal(moment().fromNow(), 'yan imik',  'now from now should display as in the past');
    });

    test('fromNow', function (assert) {
        assert.equal(moment().add({s: 30}).fromNow(), 'dadkh s yan imik', 'in a few seconds');
        assert.equal(moment().add({d: 5}).fromNow(), 'dadkh s yan 5 ossan', 'in 5 days');
    });

    test('calendar day', function (assert) {
        var a = moment().hours(12).minutes(0).seconds(0);

        assert.equal(moment(a).calendar(),                   'asdkh g 12:00',   'today at the same time');
        assert.equal(moment(a).add({m: 25}).calendar(),      'asdkh g 12:25',   'Now plus 25 min');
        assert.equal(moment(a).add({h: 1}).calendar(),       'asdkh g 13:00',   'Now plus 1 hour');
        assert.equal(moment(a).add({d: 1}).calendar(),       'aska g 12:00',    'tomorrow at the same time');
        assert.equal(moment(a).subtract({h: 1}).calendar(),  'asdkh g 11:00',   'Now minus 1 hour');
        assert.equal(moment(a).subtract({d: 1}).calendar(),  'assant g 12:00',  'yesterday at the same time');
    });

    test('calendar next week', function (assert) {
        var i, m;
        for (i = 2; i < 7; i++) {
            m = moment().add({d: i});
            assert.equal(m.calendar(),       m.format('dddd [g] LT'),  'Today + ' + i + ' days current time');
            m.hours(0).minutes(0).seconds(0).milliseconds(0);
            assert.equal(m.calendar(),       m.format('dddd [g] LT'),  'Today + ' + i + ' days beginning of day');
            m.hours(23).minutes(59).seconds(59).milliseconds(999);
            assert.equal(m.calendar(),       m.format('dddd [g] LT'),  'Today + ' + i + ' days end of day');
        }
    });

    test('calendar last week', function (assert) {
        var i, m;
        for (i = 2; i < 7; i++) {
            m = moment().subtract({d: i});
            assert.equal(m.calendar(),       m.format('dddd [g] LT'),  'Today - ' + i + ' days current time');
            m.hours(0).minutes(0).seconds(0).milliseconds(0);
            assert.equal(m.calendar(),       m.format('dddd [g] LT'),  'Today - ' + i + ' days beginning of day');
            m.hours(23).minutes(59).seconds(59).milliseconds(999);
            assert.equal(m.calendar(),       m.format('dddd [g] LT'),  'Today - ' + i + ' days end of day');
        }
    });

    test('calendar all else', function (assert) {
        var weeksAgo = moment().subtract({w: 1}),
            weeksFromNow = moment().add({w: 1});

        assert.equal(weeksAgo.calendar(),       weeksAgo.format('L'),  '1 week ago');
        assert.equal(weeksFromNow.calendar(),   weeksFromNow.format('L'),  'in 1 week');

        weeksAgo = moment().subtract({w: 2});
        weeksFromNow = moment().add({w: 2});

        assert.equal(weeksAgo.calendar(),       weeksAgo.format('L'),  '2 weeks ago');
        assert.equal(weeksFromNow.calendar(),   weeksFromNow.format('L'),  'in 2 weeks');
    });

    test('weeks year starting sunday formatted', function (assert) {
        assert.equal(moment([2011, 11, 31]).format('w ww wo'), '1 01 1', 'Dec 31 2011 should be week 1');
        assert.equal(moment([2012,  0,  6]).format('w ww wo'), '1 01 1', 'Jan  6 2012 should be week 1');
        assert.equal(moment([2012,  0,  7]).format('w ww wo'), '2 02 2', 'Jan  7 2012 should be week 2');
        assert.equal(moment([2012,  0, 13]).format('w ww wo'), '2 02 2', 'Jan 13 2012 should be week 2');
        assert.equal(moment([2012,  0, 14]).format('w ww wo'), '3 03 3', 'Jan 14 2012 should be week 3');
    });

}));

;(function (global, factory) {
   typeof exports === 'object' && typeof module !== 'undefined'
       && typeof require === 'function' ? factory(require('../../moment')) :
   typeof define === 'function' && define.amd ? define(['../../moment'], factory) :
   factory(global.moment)
}(this, function (moment) { 'use strict';

    function each(array, callback) {
        var i;
        for (i = 0; i < array.length; i++) {
            callback(array[i], i, array);
        }
    }

    function objectKeys(obj) {
        if (Object.keys) {
            return Object.keys(obj);
        } else {
            // IE8
            var res = [], i;
            for (i in obj) {
                if (obj.hasOwnProperty(i)) {
                    res.push(i);
                }
            }
            return res;
        }
    }

    // Pick the first defined of two or three arguments.
    function defaults(a, b, c) {
        if (a != null) {
            return a;
        }
        if (b != null) {
            return b;
        }
        return c;
    }

    function defineCommonLocaleTests(locale, options) {
        test('lenient ordinal parsing', function (assert) {
            var i, ordinalStr, testMoment;
            for (i = 1; i <= 31; ++i) {
                ordinalStr = moment([2014, 0, i]).format('YYYY MM Do');
                testMoment = moment(ordinalStr, 'YYYY MM Do');
                assert.equal(testMoment.year(), 2014,
                        'lenient ordinal parsing ' + i + ' year check');
                assert.equal(testMoment.month(), 0,
                        'lenient ordinal parsing ' + i + ' month check');
                assert.equal(testMoment.date(), i,
                        'lenient ordinal parsing ' + i + ' date check');
            }
        });

        test('lenient ordinal parsing of number', function (assert) {
            var i, testMoment;
            for (i = 1; i <= 31; ++i) {
                testMoment = moment('2014 01 ' + i, 'YYYY MM Do');
                assert.equal(testMoment.year(), 2014,
                        'lenient ordinal parsing of number ' + i + ' year check');
                assert.equal(testMoment.month(), 0,
                        'lenient ordinal parsing of number ' + i + ' month check');
                assert.equal(testMoment.date(), i,
                        'lenient ordinal parsing of number ' + i + ' date check');
            }
        });

        test('strict ordinal parsing', function (assert) {
            var i, ordinalStr, testMoment;
            for (i = 1; i <= 31; ++i) {
                ordinalStr = moment([2014, 0, i]).format('YYYY MM Do');
                testMoment = moment(ordinalStr, 'YYYY MM Do', true);
                assert.ok(testMoment.isValid(), 'strict ordinal parsing ' + i);
            }
        });

        test('meridiem invariant', function (assert) {
            var h, m, t1, t2;
            for (h = 0; h < 24; ++h) {
                for (m = 0; m < 60; m += 15) {
                    t1 = moment.utc([2000, 0, 1, h, m]);
                    t2 = moment.utc(t1.format('A h:mm'), 'A h:mm');
                    assert.equal(t2.format('HH:mm'), t1.format('HH:mm'),
                            'meridiem at ' + t1.format('HH:mm'));
                }
            }
        });

        test('date format correctness', function (assert) {
            var data, tokens;
            data = moment.localeData()._longDateFormat;
            tokens = objectKeys(data);
            each(tokens, function (srchToken) {
                // Check each format string to make sure it does not contain any
                // tokens that need to be expanded.
                each(tokens, function (baseToken) {
                    // strip escaped sequences
                    var format = data[baseToken].replace(/(\[[^\]]*\])/g, '');
                    assert.equal(false, !!~format.indexOf(srchToken),
                            'contains ' + srchToken + ' in ' + baseToken);
                });
            });
        });

        test('month parsing correctness', function (assert) {
            var i, m;

            if (locale === 'tr') {
                // I can't fix it :(
                expect(0);
                return;
            }
            function tester(format) {
                var r;
                r = moment(m.format(format), format);
                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format);
                r = moment(m.format(format).toLocaleUpperCase(), format);
                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' upper');
                r = moment(m.format(format).toLocaleLowerCase(), format);
                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' lower');

                r = moment(m.format(format), format, true);
                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' strict');
                r = moment(m.format(format).toLocaleUpperCase(), format, true);
                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' upper strict');
                r = moment(m.format(format).toLocaleLowerCase(), format, true);
                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' lower strict');
            }

            for (i = 0; i < 12; ++i) {
                m = moment([2015, i, 15, 18]);
                tester('MMM');
                tester('MMM.');
                tester('MMMM');
                tester('MMMM.');
            }
        });

        test('weekday parsing correctness', function (assert) {
            var i, m;

            if (locale === 'tr' || locale === 'az') {
                // There is a lower-case letter (Ä±), that converted to upper then
                // lower changes to i
                expect(0);
                return;
            }
            function tester(format) {
                var r, baseMsg = 'weekday ' + m.weekday() + ' fmt ' + format;
                r = moment(m.format(format), format);
                assert.equal(r.weekday(), m.weekday(), baseMsg);
                r = moment(m.format(format).toLocaleUpperCase(), format);
                assert.equal(r.weekday(), m.weekday(), baseMsg + ' upper');
                r = moment(m.format(format).toLocaleLowerCase(), format);
                assert.equal(r.weekday(), m.weekday(), baseMsg + ' lower');

                r = moment(m.format(format), format, true);
                assert.equal(r.weekday(), m.weekday(), baseMsg + ' strict');
                r = moment(m.format(format).toLocaleUpperCase(), format, true);
                assert.equal(r.weekday(), m.weekday(), baseMsg + ' upper strict');
                r = moment(m.format(format).toLocaleLowerCase(), format, true);
                assert.equal(r.weekday(), m.weekday(), baseMsg + ' lower strict');
            }

            for (i = 0; i < 7; ++i) {
                m = moment.utc([2015, i, 15, 18]);
                tester('dd');
                tester('ddd');
                tester('dddd');
            }
        });
    }

    function setupDeprecationHandler(test, moment, scope) {
        test._expectedDeprecations = null;
        test._observedDeprecations = null;
        test._oldSupress = moment.suppressDeprecationWarnings;
        moment.suppressDeprecationWarnings = true;
        test.expectedDeprecations = function () {
            test._expectedDeprecations = arguments;
            test._observedDeprecations = [];
        };
        moment.deprecationHandler = function (name, msg) {
            var deprecationId = matchedDeprecation(name, msg, test._expectedDeprecations);
            if (deprecationId === -1) {
                throw new Error('Unexpected deprecation thrown name=' +
                        name + ' msg=' + msg);
            }
            test._observedDeprecations[deprecationId] = 1;
        };
    }

    function teardownDeprecationHandler(test, moment, scope) {
        moment.suppressDeprecationWarnings = test._oldSupress;

        if (test._expectedDeprecations != null) {
            var missedDeprecations = [];
            each(test._expectedDeprecations, function (deprecationPattern, id) {
                if (test._observedDeprecations[id] !== 1) {
                    missedDeprecations.push(deprecationPattern);
                }
            });
            if (missedDeprecations.length !== 0) {
                throw new Error('Expected deprecation warnings did not happen: ' +
                        missedDeprecations.join(' '));
            }
        }
    }

    function matchedDeprecation(name, msg, deprecations) {
        if (deprecations == null) {
            return -1;
        }
        for (var i = 0; i < deprecations.length; ++i) {
            if (name != null && name === deprecations[i]) {
                return i;
            }
            if (msg != null && msg.substring(0, deprecations[i].length) === deprecations[i]) {
                return i;
            }
        }
        return -1;
    }

    /*global QUnit:false*/

    var test = QUnit.test;

    var expect = QUnit.expect;

    function module (name, lifecycle) {
        QUnit.module(name, {
            setup : function () {
                moment.locale('en');
                moment.createFromInputFallback = function (config) {
                    throw new Error('input not handled by moment: ' + config._i);
                };
                setupDeprecationHandler(test, moment, 'core');
                if (lifecycle && lifecycle.setup) {
                    lifecycle.setup();
                }
            },
            teardown : function () {
                teardownDeprecationHandler(test, moment, 'core');
                if (lifecycle && lifecycle.teardown) {
                    lifecycle.teardown();
                }
            }
        });
    }

    function localeModule (name, lifecycle) {
        QUnit.module('locale:' + name, {
            setup : function () {
                moment.locale(name);
                moment.createFromInputFallback = function (config) {
                    throw new Error('input not handled by moment: ' + config._i);
                };
                setupDeprecationHandler(test, moment, 'locale');
                if (lifecycle && lifecycle.setup) {
                    lifecycle.setup();
                }
            },
            teardown : function () {
                moment.locale('en');
                teardownDeprecationHandler(test, moment, 'locale');
                if (lifecycle && lifecycle.teardown) {
                    lifecycle.teardown();
                }
            }
        });
        defineCommonLocaleTests(name, -1, -1);
    }

    localeModule('tzm');

    test('parse', function (assert) {
        var tests = 'âµâµâµâ´°âµ¢âµ âµâµâµâ´°âµ¢âµ_â´±âµâ´°âµ¢âµ â´±âµâ´°âµ¢âµ_âµâ´°âµâµ âµâ´°âµâµ_âµâ´±âµâµâµ âµâ´±âµâµâµ_âµâ´°âµ¢âµ¢âµ âµâ´°âµ¢âµ¢âµ_âµ¢âµâµâµ¢âµ âµ¢âµâµâµ¢âµ_âµ¢âµâµâµ¢âµâµ£ âµ¢âµâµâµ¢âµâµ£_âµâµâµâµ âµâµâµâµ_âµâµâµâ´°âµâ´±âµâµ âµâµâµâ´°âµâ´±âµâµ_â´½âµâµâ´±âµ â´½âµâµâ´±âµ_âµâµâµ¡â´°âµâ´±âµâµ âµâµâµ¡â´°âµâ´±âµâµ_â´·âµâµâµâ´±âµâµ â´·âµâµâµâ´±âµâµ'.split('_'), i;
        function equalTest(input, mmm, i) {
            assert.equal(moment(input, mmm).month(), i, input + ' should be month ' + (i + 1));
        }
        for (i = 0; i < 12; i++) {
            tests[i] = tests[i].split(' ');
            equalTest(tests[i][0], 'MMM', i);
            equalTest(tests[i][1], 'MMM', i);
            equalTest(tests[i][0], 'MMMM', i);
            equalTest(tests[i][1], 'MMMM', i);
            equalTest(tests[i][0].toLocaleLowerCase(), 'MMMM', i);
            equalTest(tests[i][1].toLocaleLowerCase(), 'MMMM', i);
            equalTest(tests[i][0].toLocaleUpperCase(), 'MMMM', i);
            equalTest(tests[i][1].toLocaleUpperCase(), 'MMMM', i);
        }
    });

    test('format', function (assert) {
        var a = [
                ['dddd, MMMM Do YYYY, h:mm:ss a',      'â´°âµâ´°âµâ´°âµ, â´±âµâ´°âµ¢âµ 14 2010, 3:25:50 pm'],
                ['ddd, hA',                            'â´°âµâ´°âµâ´°âµ, 3PM'],
                ['M Mo MM MMMM MMM',                   '2 2 02 â´±âµâ´°âµ¢âµ â´±âµâ´°âµ¢âµ'],
                ['YYYY YY',                            '2010 10'],
                ['D Do DD',                            '14 14 14'],
                ['d do dddd ddd dd',                   '0 0 â´°âµâ´°âµâ´°âµ â´°âµâ´°âµâ´°âµ â´°âµâ´°âµâ´°âµ'],
                ['DDD DDDo DDDD',                      '45 45 045'],
                ['w wo ww',                            '8 8 08'],
                ['h hh',                               '3 03'],
                ['H HH',                               '15 15'],
                ['m mm',                               '25 25'],
                ['s ss',                               '50 50'],
                ['a A',                                'pm PM'],
                ['[the] DDDo [day of the year]',       'the 45 day of the year'],
                ['LTS',                                '15:25:50'],
                ['L',                                  '14/02/2010'],
                ['LL',                                 '14 â´±âµâ´°âµ¢âµ 2010'],
                ['LLL',                                '14 â´±âµâ´°âµ¢âµ 2010 15:25'],
                ['LLLL',                               'â´°âµâ´°âµâ´°âµ 14 â´±âµâ´°âµ¢âµ 2010 15:25'],
                ['l',                                  '14/2/2010'],
                ['ll',                                 '14 â´±âµâ´°âµ¢âµ 2010'],
                ['lll',                                '14 â´±âµâ´°âµ¢âµ 2010 15:25'],
                ['llll',                               'â´°âµâ´°âµâ´°âµ 14 â´±âµâ´°âµ¢âµ 2010 15:25']
            ],
            b = moment(new Date(2010, 1, 14, 15, 25, 50, 125)),
            i;
        for (i = 0; i < a.length; i++) {
            assert.equal(b.format(a[i][0]), a[i][1], a[i][0] + ' ---> ' + a[i][1]);
        }
    });

    test('format ordinal', function (assert) {
        assert.equal(moment([2011, 0, 1]).format('DDDo'), '1', '1');
        assert.equal(moment([2011, 0, 2]).format('DDDo'), '2', '2');
        assert.equal(moment([2011, 0, 3]).format('DDDo'), '3', '3');
        assert.equal(moment([2011, 0, 4]).format('DDDo'), '4', '4');
        assert.equal(moment([2011, 0, 5]).format('DDDo'), '5', '5');
        assert.equal(moment([2011, 0, 6]).format('DDDo'), '6', '6');
        assert.equal(moment([2011, 0, 7]).format('DDDo'), '7', '7');
        assert.equal(moment([2011, 0, 8]).format('DDDo'), '8', '8');
        assert.equal(moment([2011, 0, 9]).format('DDDo'), '9', '9');
        assert.equal(moment([2011, 0, 10]).format('DDDo'), '10', '10');

        assert.equal(moment([2011, 0, 11]).format('DDDo'), '11', '11');
        assert.equal(moment([2011, 0, 12]).format('DDDo'), '12', '12');
        assert.equal(moment([2011, 0, 13]).format('DDDo'), '13', '13');
        assert.equal(moment([2011, 0, 14]).format('DDDo'), '14', '14');
        assert.equal(moment([2011, 0, 15]).format('DDDo'), '15', '15');
        assert.equal(moment([2011, 0, 16]).format('DDDo'), '16', '16');
        assert.equal(moment([2011, 0, 17]).format('DDDo'), '17', '17');
        assert.equal(moment([2011, 0, 18]).format('DDDo'), '18', '18');
        assert.equal(moment([2011, 0, 19]).format('DDDo'), '19', '19');
        assert.equal(moment([2011, 0, 20]).format('DDDo'), '20', '20');

        assert.equal(moment([2011, 0, 21]).format('DDDo'), '21', '21');
        assert.equal(moment([2011, 0, 22]).format('DDDo'), '22', '22');
        assert.equal(moment([2011, 0, 23]).format('DDDo'), '23', '23');
        assert.equal(moment([2011, 0, 24]).format('DDDo'), '24', '24');
        assert.equal(moment([2011, 0, 25]).format('DDDo'), '25', '25');
        assert.equal(moment([2011, 0, 26]).format('DDDo'), '26', '26');
        assert.equal(moment([2011, 0, 27]).format('DDDo'), '27', '27');
        assert.equal(moment([2011, 0, 28]).format('DDDo'), '28', '28');
        assert.equal(moment([2011, 0, 29]).format('DDDo'), '29', '29');
        assert.equal(moment([2011, 0, 30]).format('DDDo'), '30', '30');

        assert.equal(moment([2011, 0, 31]).format('DDDo'), '31', '31');
    });

    test('format month', function (assert) {
        var expected = 'âµâµâµâ´°âµ¢âµ âµâµâµâ´°âµ¢âµ_â´±âµâ´°âµ¢âµ â´±âµâ´°âµ¢âµ_âµâ´°âµâµ âµâ´°âµâµ_âµâ´±âµâµâµ âµâ´±âµâµâµ_âµâ´°âµ¢âµ¢âµ âµâ´°âµ¢âµ¢âµ_âµ¢âµâµâµ¢âµ âµ¢âµâµâµ¢âµ_âµ¢âµâµâµ¢âµâµ£ âµ¢âµâµâµ¢âµâµ£_âµâµâµâµ âµâµâµâµ_âµâµâµâ´°âµâ´±âµâµ âµâµâµâ´°âµâ´±âµâµ_â´½âµâµâ´±âµ â´½âµâµâ´±âµ_âµâµâµ¡â´°âµâ´±âµâµ âµâµâµ¡â´°âµâ´±âµâµ_â´·âµâµâµâ´±âµâµ â´·âµâµâµâ´±âµâµ'.split('_'), i;
        for (i = 0; i < expected.length; i++) {
            assert.equal(moment([2011, i, 1]).format('MMMM MMM'), expected[i], expected[i]);
        }
    });

    test('format week', function (assert) {
        var expected = 'â´°âµâ´°âµâ´°âµ â´°âµâ´°âµâ´°âµ â´°âµâ´°âµâ´°âµ_â´°âµ¢âµâ´°âµ â´°âµ¢âµâ´°âµ â´°âµ¢âµâ´°âµ_â´°âµâµâµâ´°âµ â´°âµâµâµâ´°âµ â´°âµâµâµâ´°âµ_â´°â´½âµâ´°âµ â´°â´½âµâ´°âµ â´°â´½âµâ´°âµ_â´°â´½âµ¡â´°âµ â´°â´½âµ¡â´°âµ â´°â´½âµ¡â´°âµ_â´°âµâµâµâµ¡â´°âµ â´°âµâµâµâµ¡â´°âµ â´°âµâµâµâµ¡â´°âµ_â´°âµâµâ´¹âµ¢â´°âµ â´°âµâµâ´¹âµ¢â´°âµ â´°âµâµâ´¹âµ¢â´°âµ'.split('_'), i;
        for (i = 0; i < expected.length; i++) {
            assert.equal(moment([2011, 0, 2 + i]).format('dddd ddd dd'), expected[i], expected[i]);
        }
    });

    test('from', function (assert) {
        var start = moment([2007, 1, 28]);
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 44}), true),  'âµâµâµâ´½', '44 seconds = a few seconds');
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 45}), true),  'âµâµâµâµâ´º',      '45 seconds = a minute');
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 89}), true),  'âµâµâµâµâ´º',      '89 seconds = a minute');
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 90}), true),  '2 âµâµâµâµâ´º',     '90 seconds = 2 minutes');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 44}), true),  '44 âµâµâµâµâ´º',    '44 minutes = 44 minutes');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 45}), true),  'âµâ´°âµâ´°',       '45 minutes = an hour');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 89}), true),  'âµâ´°âµâ´°',       '89 minutes = an hour');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 90}), true),  '2 âµâ´°âµâµâ´°âµâµâµ',       '90 minutes = 2 hours');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 5}), true),   '5 âµâ´°âµâµâ´°âµâµâµ',       '5 hours = 5 hours');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 21}), true),  '21 âµâ´°âµâµâ´°âµâµâµ',      '21 hours = 21 hours');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 22}), true),  'â´°âµâµ',         '22 hours = a day');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 35}), true),  'â´°âµâµ',         '35 hours = a day');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 36}), true),  '2 oâµâµâ´°âµ',        '36 hours = 2 days');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 1}), true),   'â´°âµâµ',         '1 day = a day');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 5}), true),   '5 oâµâµâ´°âµ',        '5 days = 5 days');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 25}), true),  '25 oâµâµâ´°âµ',       '25 days = 25 days');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 26}), true),  'â´°âµ¢oâµâµ',       '26 days = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 30}), true),  'â´°âµ¢oâµâµ',       '30 days = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 43}), true),  'â´°âµ¢oâµâµ',       '43 days = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 46}), true),  '2 âµâµ¢âµ¢âµâµâµ',      '46 days = 2 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 74}), true),  '2 âµâµ¢âµ¢âµâµâµ',      '75 days = 2 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 76}), true),  '3 âµâµ¢âµ¢âµâµâµ',      '76 days = 3 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({M: 1}), true),   'â´°âµ¢oâµâµ',       '1 month = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({M: 5}), true),   '5 âµâµ¢âµ¢âµâµâµ',      '5 months = 5 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 345}), true), 'â´°âµâ´³â´°âµ',        '345 days = a year');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 548}), true), '2 âµâµâ´³â´°âµâµ',       '548 days = 2 years');
        assert.equal(start.from(moment([2007, 1, 28]).add({y: 1}), true),   'â´°âµâ´³â´°âµ',        '1 year = a year');
        assert.equal(start.from(moment([2007, 1, 28]).add({y: 5}), true),   '5 âµâµâ´³â´°âµâµ',       '5 years = 5 years');
    });

    test('suffix', function (assert) {
        assert.equal(moment(30000).from(0), 'â´·â´°â´·âµ âµ âµ¢â´°âµ âµâµâµâ´½',  'prefix');
        assert.equal(moment(0).from(30000), 'âµ¢â´°âµ âµâµâµâ´½', 'suffix');
    });

    test('now from now', function (assert) {
        assert.equal(moment().fromNow(), 'âµ¢â´°âµ âµâµâµâ´½',  'now from now should display as in the past');
    });

    test('fromNow', function (assert) {
        assert.equal(moment().add({s: 30}).fromNow(), 'â´·â´°â´·âµ âµ âµ¢â´°âµ âµâµâµâ´½', 'in a few seconds');
        assert.equal(moment().add({d: 5}).fromNow(), 'â´·â´°â´·âµ âµ âµ¢â´°âµ 5 oâµâµâ´°âµ', 'in 5 days');
    });

    test('calendar day', function (assert) {
        var a = moment().hours(12).minutes(0).seconds(0);

        assert.equal(moment(a).calendar(),                   'â´°âµâ´·âµ â´´ 12:00',  'today at the same time');
        assert.equal(moment(a).add({m: 25}).calendar(),      'â´°âµâ´·âµ â´´ 12:25',  'Now plus 25 min');
        assert.equal(moment(a).add({h: 1}).calendar(),       'â´°âµâ´·âµ â´´ 13:00',  'Now plus 1 hour');
        assert.equal(moment(a).add({d: 1}).calendar(),       'â´°âµâ´½â´° â´´ 12:00',  'tomorrow at the same time');
        assert.equal(moment(a).subtract({h: 1}).calendar(),  'â´°âµâ´·âµ â´´ 11:00',  'Now minus 1 hour');
        assert.equal(moment(a).subtract({d: 1}).calendar(),  'â´°âµâ´°âµâµ â´´ 12:00',  'yesterday at the same time');
    });

    test('calendar next week', function (assert) {
        var i, m;
        for (i = 2; i < 7; i++) {
            m = moment().add({d: i});
            assert.equal(m.calendar(),       m.format('dddd [â´´] LT'),  'Today + ' + i + ' days current time');
            m.hours(0).minutes(0).seconds(0).milliseconds(0);
            assert.equal(m.calendar(),       m.format('dddd [â´´] LT'),  'Today + ' + i + ' days beginning of day');
            m.hours(23).minutes(59).seconds(59).milliseconds(999);
            assert.equal(m.calendar(),       m.format('dddd [â´´] LT'),  'Today + ' + i + ' days end of day');
        }
    });

    test('calendar last week', function (assert) {
        var i, m;
        for (i = 2; i < 7; i++) {
            m = moment().subtract({d: i});
            assert.equal(m.calendar(),       m.format('dddd [â´´] LT'),  'Today - ' + i + ' days current time');
            m.hours(0).minutes(0).seconds(0).milliseconds(0);
            assert.equal(m.calendar(),       m.format('dddd [â´´] LT'),  'Today - ' + i + ' days beginning of day');
            m.hours(23).minutes(59).seconds(59).milliseconds(999);
            assert.equal(m.calendar(),       m.format('dddd [â´´] LT'),  'Today - ' + i + ' days end of day');
        }
    });

    test('calendar all else', function (assert) {
        var weeksAgo = moment().subtract({w: 1}),
            weeksFromNow = moment().add({w: 1});

        assert.equal(weeksAgo.calendar(),       weeksAgo.format('L'),  '1 week ago');
        assert.equal(weeksFromNow.calendar(),   weeksFromNow.format('L'),  'in 1 week');

        weeksAgo = moment().subtract({w: 2});
        weeksFromNow = moment().add({w: 2});

        assert.equal(weeksAgo.calendar(),       weeksAgo.format('L'),  '2 weeks ago');
        assert.equal(weeksFromNow.calendar(),   weeksFromNow.format('L'),  'in 2 weeks');
    });

    test('weeks year starting sunday formatted', function (assert) {
        assert.equal(moment([2011, 11, 31]).format('w ww wo'), '1 01 1', 'Dec 31 2011 should be week 1');
        assert.equal(moment([2012,  0,  6]).format('w ww wo'), '1 01 1', 'Jan  6 2012 should be week 1');
        assert.equal(moment([2012,  0,  7]).format('w ww wo'), '2 02 2', 'Jan  7 2012 should be week 2');
        assert.equal(moment([2012,  0, 13]).format('w ww wo'), '2 02 2', 'Jan 13 2012 should be week 2');
        assert.equal(moment([2012,  0, 14]).format('w ww wo'), '3 03 3', 'Jan 14 2012 should be week 3');
    });

}));

;(function (global, factory) {
   typeof exports === 'object' && typeof module !== 'undefined'
       && typeof require === 'function' ? factory(require('../../moment')) :
   typeof define === 'function' && define.amd ? define(['../../moment'], factory) :
   factory(global.moment)
}(this, function (moment) { 'use strict';

    function each(array, callback) {
        var i;
        for (i = 0; i < array.length; i++) {
            callback(array[i], i, array);
        }
    }

    function objectKeys(obj) {
        if (Object.keys) {
            return Object.keys(obj);
        } else {
            // IE8
            var res = [], i;
            for (i in obj) {
                if (obj.hasOwnProperty(i)) {
                    res.push(i);
                }
            }
            return res;
        }
    }

    // Pick the first defined of two or three arguments.
    function defaults(a, b, c) {
        if (a != null) {
            return a;
        }
        if (b != null) {
            return b;
        }
        return c;
    }

    function defineCommonLocaleTests(locale, options) {
        test('lenient ordinal parsing', function (assert) {
            var i, ordinalStr, testMoment;
            for (i = 1; i <= 31; ++i) {
                ordinalStr = moment([2014, 0, i]).format('YYYY MM Do');
                testMoment = moment(ordinalStr, 'YYYY MM Do');
                assert.equal(testMoment.year(), 2014,
                        'lenient ordinal parsing ' + i + ' year check');
                assert.equal(testMoment.month(), 0,
                        'lenient ordinal parsing ' + i + ' month check');
                assert.equal(testMoment.date(), i,
                        'lenient ordinal parsing ' + i + ' date check');
            }
        });

        test('lenient ordinal parsing of number', function (assert) {
            var i, testMoment;
            for (i = 1; i <= 31; ++i) {
                testMoment = moment('2014 01 ' + i, 'YYYY MM Do');
                assert.equal(testMoment.year(), 2014,
                        'lenient ordinal parsing of number ' + i + ' year check');
                assert.equal(testMoment.month(), 0,
                        'lenient ordinal parsing of number ' + i + ' month check');
                assert.equal(testMoment.date(), i,
                        'lenient ordinal parsing of number ' + i + ' date check');
            }
        });

        test('strict ordinal parsing', function (assert) {
            var i, ordinalStr, testMoment;
            for (i = 1; i <= 31; ++i) {
                ordinalStr = moment([2014, 0, i]).format('YYYY MM Do');
                testMoment = moment(ordinalStr, 'YYYY MM Do', true);
                assert.ok(testMoment.isValid(), 'strict ordinal parsing ' + i);
            }
        });

        test('meridiem invariant', function (assert) {
            var h, m, t1, t2;
            for (h = 0; h < 24; ++h) {
                for (m = 0; m < 60; m += 15) {
                    t1 = moment.utc([2000, 0, 1, h, m]);
                    t2 = moment.utc(t1.format('A h:mm'), 'A h:mm');
                    assert.equal(t2.format('HH:mm'), t1.format('HH:mm'),
                            'meridiem at ' + t1.format('HH:mm'));
                }
            }
        });

        test('date format correctness', function (assert) {
            var data, tokens;
            data = moment.localeData()._longDateFormat;
            tokens = objectKeys(data);
            each(tokens, function (srchToken) {
                // Check each format string to make sure it does not contain any
                // tokens that need to be expanded.
                each(tokens, function (baseToken) {
                    // strip escaped sequences
                    var format = data[baseToken].replace(/(\[[^\]]*\])/g, '');
                    assert.equal(false, !!~format.indexOf(srchToken),
                            'contains ' + srchToken + ' in ' + baseToken);
                });
            });
        });

        test('month parsing correctness', function (assert) {
            var i, m;

            if (locale === 'tr') {
                // I can't fix it :(
                expect(0);
                return;
            }
            function tester(format) {
                var r;
                r = moment(m.format(format), format);
                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format);
                r = moment(m.format(format).toLocaleUpperCase(), format);
                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' upper');
                r = moment(m.format(format).toLocaleLowerCase(), format);
                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' lower');

                r = moment(m.format(format), format, true);
                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' strict');
                r = moment(m.format(format).toLocaleUpperCase(), format, true);
                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' upper strict');
                r = moment(m.format(format).toLocaleLowerCase(), format, true);
                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' lower strict');
            }

            for (i = 0; i < 12; ++i) {
                m = moment([2015, i, 15, 18]);
                tester('MMM');
                tester('MMM.');
                tester('MMMM');
                tester('MMMM.');
            }
        });

        test('weekday parsing correctness', function (assert) {
            var i, m;

            if (locale === 'tr' || locale === 'az') {
                // There is a lower-case letter (Ä±), that converted to upper then
                // lower changes to i
                expect(0);
                return;
            }
            function tester(format) {
                var r, baseMsg = 'weekday ' + m.weekday() + ' fmt ' + format;
                r = moment(m.format(format), format);
                assert.equal(r.weekday(), m.weekday(), baseMsg);
                r = moment(m.format(format).toLocaleUpperCase(), format);
                assert.equal(r.weekday(), m.weekday(), baseMsg + ' upper');
                r = moment(m.format(format).toLocaleLowerCase(), format);
                assert.equal(r.weekday(), m.weekday(), baseMsg + ' lower');

                r = moment(m.format(format), format, true);
                assert.equal(r.weekday(), m.weekday(), baseMsg + ' strict');
                r = moment(m.format(format).toLocaleUpperCase(), format, true);
                assert.equal(r.weekday(), m.weekday(), baseMsg + ' upper strict');
                r = moment(m.format(format).toLocaleLowerCase(), format, true);
                assert.equal(r.weekday(), m.weekday(), baseMsg + ' lower strict');
            }

            for (i = 0; i < 7; ++i) {
                m = moment.utc([2015, i, 15, 18]);
                tester('dd');
                tester('ddd');
                tester('dddd');
            }
        });
    }

    function setupDeprecationHandler(test, moment, scope) {
        test._expectedDeprecations = null;
        test._observedDeprecations = null;
        test._oldSupress = moment.suppressDeprecationWarnings;
        moment.suppressDeprecationWarnings = true;
        test.expectedDeprecations = function () {
            test._expectedDeprecations = arguments;
            test._observedDeprecations = [];
        };
        moment.deprecationHandler = function (name, msg) {
            var deprecationId = matchedDeprecation(name, msg, test._expectedDeprecations);
            if (deprecationId === -1) {
                throw new Error('Unexpected deprecation thrown name=' +
                        name + ' msg=' + msg);
            }
            test._observedDeprecations[deprecationId] = 1;
        };
    }

    function teardownDeprecationHandler(test, moment, scope) {
        moment.suppressDeprecationWarnings = test._oldSupress;

        if (test._expectedDeprecations != null) {
            var missedDeprecations = [];
            each(test._expectedDeprecations, function (deprecationPattern, id) {
                if (test._observedDeprecations[id] !== 1) {
                    missedDeprecations.push(deprecationPattern);
                }
            });
            if (missedDeprecations.length !== 0) {
                throw new Error('Expected deprecation warnings did not happen: ' +
                        missedDeprecations.join(' '));
            }
        }
    }

    function matchedDeprecation(name, msg, deprecations) {
        if (deprecations == null) {
            return -1;
        }
        for (var i = 0; i < deprecations.length; ++i) {
            if (name != null && name === deprecations[i]) {
                return i;
            }
            if (msg != null && msg.substring(0, deprecations[i].length) === deprecations[i]) {
                return i;
            }
        }
        return -1;
    }

    /*global QUnit:false*/

    var test = QUnit.test;

    var expect = QUnit.expect;

    function module (name, lifecycle) {
        QUnit.module(name, {
            setup : function () {
                moment.locale('en');
                moment.createFromInputFallback = function (config) {
                    throw new Error('input not handled by moment: ' + config._i);
                };
                setupDeprecationHandler(test, moment, 'core');
                if (lifecycle && lifecycle.setup) {
                    lifecycle.setup();
                }
            },
            teardown : function () {
                teardownDeprecationHandler(test, moment, 'core');
                if (lifecycle && lifecycle.teardown) {
                    lifecycle.teardown();
                }
            }
        });
    }

    function localeModule (name, lifecycle) {
        QUnit.module('locale:' + name, {
            setup : function () {
                moment.locale(name);
                moment.createFromInputFallback = function (config) {
                    throw new Error('input not handled by moment: ' + config._i);
                };
                setupDeprecationHandler(test, moment, 'locale');
                if (lifecycle && lifecycle.setup) {
                    lifecycle.setup();
                }
            },
            teardown : function () {
                moment.locale('en');
                teardownDeprecationHandler(test, moment, 'locale');
                if (lifecycle && lifecycle.teardown) {
                    lifecycle.teardown();
                }
            }
        });
        defineCommonLocaleTests(name, -1, -1);
    }

    localeModule('uk');

    test('parse', function (assert) {
        var tests = 'ÑÑÑÐµÐ½Ñ ÑÑÑ_Ð»ÑÑÐ¸Ð¹ Ð»ÑÑ_Ð±ÐµÑÐµÐ·ÐµÐ½Ñ Ð±ÐµÑ_ÐºÐ²ÑÑÐµÐ½Ñ ÐºÐ²ÑÑ_ÑÑÐ°Ð²ÐµÐ½Ñ ÑÑÐ°Ð²_ÑÐµÑÐ²ÐµÐ½Ñ ÑÐµÑÐ²_Ð»Ð¸Ð¿ÐµÐ½Ñ Ð»Ð¸Ð¿_ÑÐµÑÐ¿ÐµÐ½Ñ ÑÐµÑÐ¿_Ð²ÐµÑÐµÑÐµÐ½Ñ Ð²ÐµÑ_Ð¶Ð¾Ð²ÑÐµÐ½Ñ Ð¶Ð¾Ð²Ñ_Ð»Ð¸ÑÑÐ¾Ð¿Ð°Ð´ Ð»Ð¸ÑÑ_Ð³ÑÑÐ´ÐµÐ½Ñ Ð³ÑÑÐ´'.split('_'), i;
        function equalTest(input, mmm, i) {
            assert.equal(moment(input, mmm).month(), i, input + ' should be month ' + (i + 1));
        }
        for (i = 0; i < 12; i++) {
            tests[i] = tests[i].split(' ');
            equalTest(tests[i][0], 'MMM', i);
            equalTest(tests[i][1], 'MMM', i);
            equalTest(tests[i][0], 'MMMM', i);
            equalTest(tests[i][1], 'MMMM', i);
            equalTest(tests[i][0].toLocaleLowerCase(), 'MMMM', i);
            equalTest(tests[i][1].toLocaleLowerCase(), 'MMMM', i);
            equalTest(tests[i][0].toLocaleUpperCase(), 'MMMM', i);
            equalTest(tests[i][1].toLocaleUpperCase(), 'MMMM', i);
        }
    });

    test('format', function (assert) {
        var a = [
                ['dddd, Do MMMM YYYY, HH:mm:ss',       'Ð½ÐµÐ´ÑÐ»Ñ, 14-Ð³Ð¾ Ð»ÑÑÐ¾Ð³Ð¾ 2010, 15:25:50'],
                ['ddd, h A',                           'Ð½Ð´, 3 Ð´Ð½Ñ'],
                ['M Mo MM MMMM MMM',                   '2 2-Ð¹ 02 Ð»ÑÑÐ¸Ð¹ Ð»ÑÑ'],
                ['YYYY YY',                            '2010 10'],
                ['D Do DD',                            '14 14-Ð³Ð¾ 14'],
                ['d do dddd ddd dd',                   '0 0-Ð¹ Ð½ÐµÐ´ÑÐ»Ñ Ð½Ð´ Ð½Ð´'],
                ['DDD DDDo DDDD',                      '45 45-Ð¹ 045'],
                ['w wo ww',                            '7 7-Ð¹ 07'],
                ['h hh',                               '3 03'],
                ['H HH',                               '15 15'],
                ['m mm',                               '25 25'],
                ['s ss',                               '50 50'],
                ['a A',                                'Ð´Ð½Ñ Ð´Ð½Ñ'],
                ['DDDo [Ð´ÐµÐ½Ñ ÑÐ¾ÐºÑ]',                  '45-Ð¹ Ð´ÐµÐ½Ñ ÑÐ¾ÐºÑ'],
                ['LTS',                                '15:25:50'],
                ['L',                                  '14.02.2010'],
                ['LL',                                 '14 Ð»ÑÑÐ¾Ð³Ð¾ 2010 Ñ.'],
                ['LLL',                                '14 Ð»ÑÑÐ¾Ð³Ð¾ 2010 Ñ., 15:25'],
                ['LLLL',                               'Ð½ÐµÐ´ÑÐ»Ñ, 14 Ð»ÑÑÐ¾Ð³Ð¾ 2010 Ñ., 15:25']
            ],
            b = moment(new Date(2010, 1, 14, 15, 25, 50, 125)),
            i;
        for (i = 0; i < a.length; i++) {
            assert.equal(b.format(a[i][0]), a[i][1], a[i][0] + ' ---> ' + a[i][1]);
        }
    });

    test('format meridiem', function (assert) {
        assert.equal(moment([2012, 11, 28, 0, 0]).format('A'), 'Ð½Ð¾ÑÑ', 'night');
        assert.equal(moment([2012, 11, 28, 3, 59]).format('A'), 'Ð½Ð¾ÑÑ', 'night');
        assert.equal(moment([2012, 11, 28, 4, 0]).format('A'), 'ÑÐ°Ð½ÐºÑ', 'morning');
        assert.equal(moment([2012, 11, 28, 11, 59]).format('A'), 'ÑÐ°Ð½ÐºÑ', 'morning');
        assert.equal(moment([2012, 11, 28, 12, 0]).format('A'), 'Ð´Ð½Ñ', 'afternoon');
        assert.equal(moment([2012, 11, 28, 16, 59]).format('A'), 'Ð´Ð½Ñ', 'afternoon');
        assert.equal(moment([2012, 11, 28, 17, 0]).format('A'), 'Ð²ÐµÑÐ¾ÑÐ°', 'evening');
        assert.equal(moment([2012, 11, 28, 23, 59]).format('A'), 'Ð²ÐµÑÐ¾ÑÐ°', 'evening');
    });

    test('format ordinal', function (assert) {
        assert.equal(moment([2011, 0, 1]).format('DDDo'), '1-Ð¹', '1-Ð¹');
        assert.equal(moment([2011, 0, 2]).format('DDDo'), '2-Ð¹', '2-Ð¹');
        assert.equal(moment([2011, 0, 3]).format('DDDo'), '3-Ð¹', '3-Ð¹');
        assert.equal(moment([2011, 0, 4]).format('DDDo'), '4-Ð¹', '4-Ð¹');
        assert.equal(moment([2011, 0, 5]).format('DDDo'), '5-Ð¹', '5-Ð¹');
        assert.equal(moment([2011, 0, 6]).format('DDDo'), '6-Ð¹', '6-Ð¹');
        assert.equal(moment([2011, 0, 7]).format('DDDo'), '7-Ð¹', '7-Ð¹');
        assert.equal(moment([2011, 0, 8]).format('DDDo'), '8-Ð¹', '8-Ð¹');
        assert.equal(moment([2011, 0, 9]).format('DDDo'), '9-Ð¹', '9-Ð¹');
        assert.equal(moment([2011, 0, 10]).format('DDDo'), '10-Ð¹', '10-Ð¹');

        assert.equal(moment([2011, 0, 11]).format('DDDo'), '11-Ð¹', '11-Ð¹');
        assert.equal(moment([2011, 0, 12]).format('DDDo'), '12-Ð¹', '12-Ð¹');
        assert.equal(moment([2011, 0, 13]).format('DDDo'), '13-Ð¹', '13-Ð¹');
        assert.equal(moment([2011, 0, 14]).format('DDDo'), '14-Ð¹', '14-Ð¹');
        assert.equal(moment([2011, 0, 15]).format('DDDo'), '15-Ð¹', '15-Ð¹');
        assert.equal(moment([2011, 0, 16]).format('DDDo'), '16-Ð¹', '16-Ð¹');
        assert.equal(moment([2011, 0, 17]).format('DDDo'), '17-Ð¹', '17-Ð¹');
        assert.equal(moment([2011, 0, 18]).format('DDDo'), '18-Ð¹', '18-Ð¹');
        assert.equal(moment([2011, 0, 19]).format('DDDo'), '19-Ð¹', '19-Ð¹');
        assert.equal(moment([2011, 0, 20]).format('DDDo'), '20-Ð¹', '20-Ð¹');

        assert.equal(moment([2011, 0, 21]).format('DDDo'), '21-Ð¹', '21-Ð¹');
        assert.equal(moment([2011, 0, 22]).format('DDDo'), '22-Ð¹', '22-Ð¹');
        assert.equal(moment([2011, 0, 23]).format('DDDo'), '23-Ð¹', '23-Ð¹');
        assert.equal(moment([2011, 0, 24]).format('DDDo'), '24-Ð¹', '24-Ð¹');
        assert.equal(moment([2011, 0, 25]).format('DDDo'), '25-Ð¹', '25-Ð¹');
        assert.equal(moment([2011, 0, 26]).format('DDDo'), '26-Ð¹', '26-Ð¹');
        assert.equal(moment([2011, 0, 27]).format('DDDo'), '27-Ð¹', '27-Ð¹');
        assert.equal(moment([2011, 0, 28]).format('DDDo'), '28-Ð¹', '28-Ð¹');
        assert.equal(moment([2011, 0, 29]).format('DDDo'), '29-Ð¹', '29-Ð¹');
        assert.equal(moment([2011, 0, 30]).format('DDDo'), '30-Ð¹', '30-Ð¹');

        assert.equal(moment([2011, 0, 31]).format('DDDo'), '31-Ð¹', '31-Ð¹');
    });

    test('format month', function (assert) {
        var expected = 'ÑÑÑÐµÐ½Ñ ÑÑÑ_Ð»ÑÑÐ¸Ð¹ Ð»ÑÑ_Ð±ÐµÑÐµÐ·ÐµÐ½Ñ Ð±ÐµÑ_ÐºÐ²ÑÑÐµÐ½Ñ ÐºÐ²ÑÑ_ÑÑÐ°Ð²ÐµÐ½Ñ ÑÑÐ°Ð²_ÑÐµÑÐ²ÐµÐ½Ñ ÑÐµÑÐ²_Ð»Ð¸Ð¿ÐµÐ½Ñ Ð»Ð¸Ð¿_ÑÐµÑÐ¿ÐµÐ½Ñ ÑÐµÑÐ¿_Ð²ÐµÑÐµÑÐµÐ½Ñ Ð²ÐµÑ_Ð¶Ð¾Ð²ÑÐµÐ½Ñ Ð¶Ð¾Ð²Ñ_Ð»Ð¸ÑÑÐ¾Ð¿Ð°Ð´ Ð»Ð¸ÑÑ_Ð³ÑÑÐ´ÐµÐ½Ñ Ð³ÑÑÐ´'.split('_'), i;
        for (i = 0; i < expected.length; i++) {
            assert.equal(moment([2011, i, 1]).format('MMMM MMM'), expected[i], expected[i]);
        }
    });

    test('format month case', function (assert) {
        var months = {
            'nominative': 'ÑÑÑÐµÐ½Ñ_Ð»ÑÑÐ¸Ð¹_Ð±ÐµÑÐµÐ·ÐµÐ½Ñ_ÐºÐ²ÑÑÐµÐ½Ñ_ÑÑÐ°Ð²ÐµÐ½Ñ_ÑÐµÑÐ²ÐµÐ½Ñ_Ð»Ð¸Ð¿ÐµÐ½Ñ_ÑÐµÑÐ¿ÐµÐ½Ñ_Ð²ÐµÑÐµÑÐµÐ½Ñ_Ð¶Ð¾Ð²ÑÐµÐ½Ñ_Ð»Ð¸ÑÑÐ¾Ð¿Ð°Ð´_Ð³ÑÑÐ´ÐµÐ½Ñ'.split('_'),
            'accusative': 'ÑÑÑÐ½Ñ_Ð»ÑÑÐ¾Ð³Ð¾_Ð±ÐµÑÐµÐ·Ð½Ñ_ÐºÐ²ÑÑÐ½Ñ_ÑÑÐ°Ð²Ð½Ñ_ÑÐµÑÐ²Ð½Ñ_Ð»Ð¸Ð¿Ð½Ñ_ÑÐµÑÐ¿Ð½Ñ_Ð²ÐµÑÐµÑÐ½Ñ_Ð¶Ð¾Ð²ÑÐ½Ñ_Ð»Ð¸ÑÑÐ¾Ð¿Ð°Ð´Ð°_Ð³ÑÑÐ´Ð½Ñ'.split('_')
        }, i;
        for (i = 0; i < 12; i++) {
            assert.equal(moment([2011, i, 1]).format('D MMMM'), '1 ' + months.accusative[i], '1 ' + months.accusative[i]);
            assert.equal(moment([2011, i, 1]).format('MMMM'), months.nominative[i], '1 ' + months.nominative[i]);
        }
    });

    test('format week', function (assert) {
        var expected = 'Ð½ÐµÐ´ÑÐ»Ñ Ð½Ð´ Ð½Ð´_Ð¿Ð¾Ð½ÐµÐ´ÑÐ»Ð¾Ðº Ð¿Ð½ Ð¿Ð½_Ð²ÑÐ²ÑÐ¾ÑÐ¾Ðº Ð²Ñ Ð²Ñ_ÑÐµÑÐµÐ´Ð° ÑÑ ÑÑ_ÑÐµÑÐ²ÐµÑ ÑÑ ÑÑ_Ð¿âÑÑÐ½Ð¸ÑÑ Ð¿Ñ Ð¿Ñ_ÑÑÐ±Ð¾ÑÐ° ÑÐ± ÑÐ±'.split('_'), i;
        for (i = 0; i < expected.length; i++) {
            assert.equal(moment([2011, 0, 2 + i]).format('dddd ddd dd'), expected[i], expected[i]);
        }
    });

    test('from', function (assert) {
        var start = moment([2007, 1, 28]);
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 44}), true),  'Ð´ÐµÐºÑÐ»ÑÐºÐ° ÑÐµÐºÑÐ½Ð´',    '44 seconds = seconds');
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 45}), true),  'ÑÐ²Ð¸Ð»Ð¸Ð½Ð°',   '45 seconds = a minute');
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 89}), true),  'ÑÐ²Ð¸Ð»Ð¸Ð½Ð°',   '89 seconds = a minute');
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 90}), true),  '2 ÑÐ²Ð¸Ð»Ð¸Ð½Ð¸',  '90 seconds = 2 minutes');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 44}), true),  '44 ÑÐ²Ð¸Ð»Ð¸Ð½Ð¸', '44 minutes = 44 minutes');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 45}), true),  'Ð³Ð¾Ð´Ð¸Ð½Ñ',    '45 minutes = an hour');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 89}), true),  'Ð³Ð¾Ð´Ð¸Ð½Ñ',    '89 minutes = an hour');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 90}), true),  '2 Ð³Ð¾Ð´Ð¸Ð½Ð¸',    '90 minutes = 2 hours');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 5}), true),   '5 Ð³Ð¾Ð´Ð¸Ð½',    '5 hours = 5 hours');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 21}), true),  '21 Ð³Ð¾Ð´Ð¸Ð½Ð°',   '21 hours = 21 hours');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 22}), true),  'Ð´ÐµÐ½Ñ',      '22 hours = a day');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 35}), true),  'Ð´ÐµÐ½Ñ',      '35 hours = a day');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 36}), true),  '2 Ð´Ð½Ñ',     '36 hours = 2 days');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 1}), true),   'Ð´ÐµÐ½Ñ',      '1 day = a day');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 5}), true),   '5 Ð´Ð½ÑÐ²',     '5 days = 5 days');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 11}), true),  '11 Ð´Ð½ÑÐ²',     '11 days = 11 days');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 21}), true),  '21 Ð´ÐµÐ½Ñ',     '21 days = 21 days');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 25}), true),  '25 Ð´Ð½ÑÐ²',    '25 days = 25 days');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 26}), true),  'Ð¼ÑÑÑÑÑ',    '26 days = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 30}), true),  'Ð¼ÑÑÑÑÑ',    '30 days = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 43}), true),  'Ð¼ÑÑÑÑÑ',    '43 days = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 46}), true),  '2 Ð¼ÑÑÑÑÑ',   '46 days = 2 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 74}), true),  '2 Ð¼ÑÑÑÑÑ',   '75 days = 2 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 76}), true),  '3 Ð¼ÑÑÑÑÑ',   '76 days = 3 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({M: 1}), true),   'Ð¼ÑÑÑÑÑ',    '1 month = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({M: 5}), true),   '5 Ð¼ÑÑÑÑÑÐ²',   '5 months = 5 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 345}), true), 'ÑÑÐº',     '345 days = a year');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 548}), true), '2 ÑÐ¾ÐºÐ¸',    '548 days = 2 years');
        assert.equal(start.from(moment([2007, 1, 28]).add({y: 1}), true),   'ÑÑÐº',     '1 year = a year');
        assert.equal(start.from(moment([2007, 1, 28]).add({y: 5}), true),   '5 ÑÐ¾ÐºÑÐ²',    '5 years = 5 years');
    });

    test('suffix', function (assert) {
        assert.equal(moment(30000).from(0), 'Ð·Ð° Ð´ÐµÐºÑÐ»ÑÐºÐ° ÑÐµÐºÑÐ½Ð´', 'prefix');
        assert.equal(moment(0).from(30000), 'Ð´ÐµÐºÑÐ»ÑÐºÐ° ÑÐµÐºÑÐ½Ð´ ÑÐ¾Ð¼Ñ', 'suffix');
    });

    test('fromNow', function (assert) {
        assert.equal(moment().add({s: 30}).fromNow(), 'Ð·Ð° Ð´ÐµÐºÑÐ»ÑÐºÐ° ÑÐµÐºÑÐ½Ð´', 'in seconds');
        assert.equal(moment().add({d: 5}).fromNow(), 'Ð·Ð° 5 Ð´Ð½ÑÐ²', 'in 5 days');
    });

    test('calendar day', function (assert) {
        var a = moment().hours(12).minutes(0).seconds(0);

        assert.equal(moment(a).calendar(),                   'Ð¡ÑÐ¾Ð³Ð¾Ð´Ð½Ñ Ð¾ 12:00',   'today at the same time');
        assert.equal(moment(a).add({m: 25}).calendar(),      'Ð¡ÑÐ¾Ð³Ð¾Ð´Ð½Ñ Ð¾ 12:25',   'Now plus 25 min');
        assert.equal(moment(a).add({h: 1}).calendar(),       'Ð¡ÑÐ¾Ð³Ð¾Ð´Ð½Ñ Ð¾ 13:00',   'Now plus 1 hour');
        assert.equal(moment(a).add({d: 1}).calendar(),       'ÐÐ°Ð²ÑÑÐ° Ð¾ 12:00',     'tomorrow at the same time');
        assert.equal(moment(a).subtract({h: 2}).calendar(),  'Ð¡ÑÐ¾Ð³Ð¾Ð´Ð½Ñ Ð¾ 10:00',   'Now minus 2 hours');
        assert.equal(moment(a).subtract({d: 1}).calendar(),  'ÐÑÐ¾ÑÐ° Ð¾ 12:00',      'yesterday at the same time');
        // A special case for Ukrainian since 11 hours have different preposition
        assert.equal(moment(a).subtract({h: 1}).calendar(),  'Ð¡ÑÐ¾Ð³Ð¾Ð´Ð½Ñ Ð¾Ð± 11:00',  'same day at 11 o\'clock');
    });

    test('calendar next week', function (assert) {
        var i, m;
        for (i = 2; i < 7; i++) {
            m = moment().add({d: i});
            assert.equal(m.calendar(),       m.format('[Ð£] dddd [Ð¾' + (m.hours() === 11 ? 'Ð±' : '') + '] LT'),  'Today + ' + i + ' days current time');
            m.hours(0).minutes(0).seconds(0).milliseconds(0);
            assert.equal(m.calendar(),       m.format('[Ð£] dddd [Ð¾] LT'),  'Today + ' + i + ' days beginning of day');
            m.hours(23).minutes(59).seconds(59).milliseconds(999);
            assert.equal(m.calendar(),       m.format('[Ð£] dddd [Ð¾] LT'),  'Today + ' + i + ' days end of day');
        }
    });

    test('calendar last week', function (assert) {
        var i, m;

        function makeFormat(d) {
            switch (d.day()) {
            case 0:
            case 3:
            case 5:
            case 6:
                return '[ÐÐ¸Ð½ÑÐ»Ð¾Ñ] dddd [Ð¾' + (d.hours() === 11 ? 'Ð±' : '') + '] LT';
            case 1:
            case 2:
            case 4:
                return '[ÐÐ¸Ð½ÑÐ»Ð¾Ð³Ð¾] dddd [Ð¾' + (d.hours() === 11 ? 'Ð±' : '') + '] LT';
            }
        }

        for (i = 2; i < 7; i++) {
            m = moment().subtract({d: i});
            assert.equal(m.calendar(),       m.format(makeFormat(m)),  'Today - ' + i + ' days current time');
            m.hours(0).minutes(0).seconds(0).milliseconds(0);
            assert.equal(m.calendar(),       m.format(makeFormat(m)),  'Today - ' + i + ' days beginning of day');
            m.hours(23).minutes(59).seconds(59).milliseconds(999);
            assert.equal(m.calendar(),       m.format(makeFormat(m)),  'Today - ' + i + ' days end of day');
        }
    });

    test('calendar all else', function (assert) {
        var weeksAgo = moment().subtract({w: 1}),
            weeksFromNow = moment().add({w: 1});

        assert.equal(weeksAgo.calendar(),       weeksAgo.format('L'),  '1 week ago');
        assert.equal(weeksFromNow.calendar(),   weeksFromNow.format('L'),  'in 1 week');

        weeksAgo = moment().subtract({w: 2});
        weeksFromNow = moment().add({w: 2});

        assert.equal(weeksAgo.calendar(),       weeksAgo.format('L'),  '2 weeks ago');
        assert.equal(weeksFromNow.calendar(),   weeksFromNow.format('L'),  'in 2 weeks');
    });

    test('weeks year starting sunday formatted', function (assert) {
        assert.equal(moment([2011, 11, 26]).format('w ww wo'), '1 01 1-Ð¹', 'Dec 26 2011 should be week 1');
        assert.equal(moment([2012,  0,  1]).format('w ww wo'), '1 01 1-Ð¹', 'Jan  1 2012 should be week 1');
        assert.equal(moment([2012,  0,  2]).format('w ww wo'), '2 02 2-Ð¹', 'Jan  2 2012 should be week 2');
        assert.equal(moment([2012,  0,  8]).format('w ww wo'), '2 02 2-Ð¹', 'Jan  8 2012 should be week 2');
        assert.equal(moment([2012,  0,  9]).format('w ww wo'), '3 03 3-Ð¹', 'Jan  9 2012 should be week 3');
    });

}));

;(function (global, factory) {
   typeof exports === 'object' && typeof module !== 'undefined'
       && typeof require === 'function' ? factory(require('../../moment')) :
   typeof define === 'function' && define.amd ? define(['../../moment'], factory) :
   factory(global.moment)
}(this, function (moment) { 'use strict';

    function each(array, callback) {
        var i;
        for (i = 0; i < array.length; i++) {
            callback(array[i], i, array);
        }
    }

    function objectKeys(obj) {
        if (Object.keys) {
            return Object.keys(obj);
        } else {
            // IE8
            var res = [], i;
            for (i in obj) {
                if (obj.hasOwnProperty(i)) {
                    res.push(i);
                }
            }
            return res;
        }
    }

    // Pick the first defined of two or three arguments.
    function defaults(a, b, c) {
        if (a != null) {
            return a;
        }
        if (b != null) {
            return b;
        }
        return c;
    }

    function defineCommonLocaleTests(locale, options) {
        test('lenient ordinal parsing', function (assert) {
            var i, ordinalStr, testMoment;
            for (i = 1; i <= 31; ++i) {
                ordinalStr = moment([2014, 0, i]).format('YYYY MM Do');
                testMoment = moment(ordinalStr, 'YYYY MM Do');
                assert.equal(testMoment.year(), 2014,
                        'lenient ordinal parsing ' + i + ' year check');
                assert.equal(testMoment.month(), 0,
                        'lenient ordinal parsing ' + i + ' month check');
                assert.equal(testMoment.date(), i,
                        'lenient ordinal parsing ' + i + ' date check');
            }
        });

        test('lenient ordinal parsing of number', function (assert) {
            var i, testMoment;
            for (i = 1; i <= 31; ++i) {
                testMoment = moment('2014 01 ' + i, 'YYYY MM Do');
                assert.equal(testMoment.year(), 2014,
                        'lenient ordinal parsing of number ' + i + ' year check');
                assert.equal(testMoment.month(), 0,
                        'lenient ordinal parsing of number ' + i + ' month check');
                assert.equal(testMoment.date(), i,
                        'lenient ordinal parsing of number ' + i + ' date check');
            }
        });

        test('strict ordinal parsing', function (assert) {
            var i, ordinalStr, testMoment;
            for (i = 1; i <= 31; ++i) {
                ordinalStr = moment([2014, 0, i]).format('YYYY MM Do');
                testMoment = moment(ordinalStr, 'YYYY MM Do', true);
                assert.ok(testMoment.isValid(), 'strict ordinal parsing ' + i);
            }
        });

        test('meridiem invariant', function (assert) {
            var h, m, t1, t2;
            for (h = 0; h < 24; ++h) {
                for (m = 0; m < 60; m += 15) {
                    t1 = moment.utc([2000, 0, 1, h, m]);
                    t2 = moment.utc(t1.format('A h:mm'), 'A h:mm');
                    assert.equal(t2.format('HH:mm'), t1.format('HH:mm'),
                            'meridiem at ' + t1.format('HH:mm'));
                }
            }
        });

        test('date format correctness', function (assert) {
            var data, tokens;
            data = moment.localeData()._longDateFormat;
            tokens = objectKeys(data);
            each(tokens, function (srchToken) {
                // Check each format string to make sure it does not contain any
                // tokens that need to be expanded.
                each(tokens, function (baseToken) {
                    // strip escaped sequences
                    var format = data[baseToken].replace(/(\[[^\]]*\])/g, '');
                    assert.equal(false, !!~format.indexOf(srchToken),
                            'contains ' + srchToken + ' in ' + baseToken);
                });
            });
        });

        test('month parsing correctness', function (assert) {
            var i, m;

            if (locale === 'tr') {
                // I can't fix it :(
                expect(0);
                return;
            }
            function tester(format) {
                var r;
                r = moment(m.format(format), format);
                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format);
                r = moment(m.format(format).toLocaleUpperCase(), format);
                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' upper');
                r = moment(m.format(format).toLocaleLowerCase(), format);
                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' lower');

                r = moment(m.format(format), format, true);
                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' strict');
                r = moment(m.format(format).toLocaleUpperCase(), format, true);
                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' upper strict');
                r = moment(m.format(format).toLocaleLowerCase(), format, true);
                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' lower strict');
            }

            for (i = 0; i < 12; ++i) {
                m = moment([2015, i, 15, 18]);
                tester('MMM');
                tester('MMM.');
                tester('MMMM');
                tester('MMMM.');
            }
        });

        test('weekday parsing correctness', function (assert) {
            var i, m;

            if (locale === 'tr' || locale === 'az') {
                // There is a lower-case letter (Ä±), that converted to upper then
                // lower changes to i
                expect(0);
                return;
            }
            function tester(format) {
                var r, baseMsg = 'weekday ' + m.weekday() + ' fmt ' + format;
                r = moment(m.format(format), format);
                assert.equal(r.weekday(), m.weekday(), baseMsg);
                r = moment(m.format(format).toLocaleUpperCase(), format);
                assert.equal(r.weekday(), m.weekday(), baseMsg + ' upper');
                r = moment(m.format(format).toLocaleLowerCase(), format);
                assert.equal(r.weekday(), m.weekday(), baseMsg + ' lower');

                r = moment(m.format(format), format, true);
                assert.equal(r.weekday(), m.weekday(), baseMsg + ' strict');
                r = moment(m.format(format).toLocaleUpperCase(), format, true);
                assert.equal(r.weekday(), m.weekday(), baseMsg + ' upper strict');
                r = moment(m.format(format).toLocaleLowerCase(), format, true);
                assert.equal(r.weekday(), m.weekday(), baseMsg + ' lower strict');
            }

            for (i = 0; i < 7; ++i) {
                m = moment.utc([2015, i, 15, 18]);
                tester('dd');
                tester('ddd');
                tester('dddd');
            }
        });
    }

    function setupDeprecationHandler(test, moment, scope) {
        test._expectedDeprecations = null;
        test._observedDeprecations = null;
        test._oldSupress = moment.suppressDeprecationWarnings;
        moment.suppressDeprecationWarnings = true;
        test.expectedDeprecations = function () {
            test._expectedDeprecations = arguments;
            test._observedDeprecations = [];
        };
        moment.deprecationHandler = function (name, msg) {
            var deprecationId = matchedDeprecation(name, msg, test._expectedDeprecations);
            if (deprecationId === -1) {
                throw new Error('Unexpected deprecation thrown name=' +
                        name + ' msg=' + msg);
            }
            test._observedDeprecations[deprecationId] = 1;
        };
    }

    function teardownDeprecationHandler(test, moment, scope) {
        moment.suppressDeprecationWarnings = test._oldSupress;

        if (test._expectedDeprecations != null) {
            var missedDeprecations = [];
            each(test._expectedDeprecations, function (deprecationPattern, id) {
                if (test._observedDeprecations[id] !== 1) {
                    missedDeprecations.push(deprecationPattern);
                }
            });
            if (missedDeprecations.length !== 0) {
                throw new Error('Expected deprecation warnings did not happen: ' +
                        missedDeprecations.join(' '));
            }
        }
    }

    function matchedDeprecation(name, msg, deprecations) {
        if (deprecations == null) {
            return -1;
        }
        for (var i = 0; i < deprecations.length; ++i) {
            if (name != null && name === deprecations[i]) {
                return i;
            }
            if (msg != null && msg.substring(0, deprecations[i].length) === deprecations[i]) {
                return i;
            }
        }
        return -1;
    }

    /*global QUnit:false*/

    var test = QUnit.test;

    var expect = QUnit.expect;

    function module (name, lifecycle) {
        QUnit.module(name, {
            setup : function () {
                moment.locale('en');
                moment.createFromInputFallback = function (config) {
                    throw new Error('input not handled by moment: ' + config._i);
                };
                setupDeprecationHandler(test, moment, 'core');
                if (lifecycle && lifecycle.setup) {
                    lifecycle.setup();
                }
            },
            teardown : function () {
                teardownDeprecationHandler(test, moment, 'core');
                if (lifecycle && lifecycle.teardown) {
                    lifecycle.teardown();
                }
            }
        });
    }

    function localeModule (name, lifecycle) {
        QUnit.module('locale:' + name, {
            setup : function () {
                moment.locale(name);
                moment.createFromInputFallback = function (config) {
                    throw new Error('input not handled by moment: ' + config._i);
                };
                setupDeprecationHandler(test, moment, 'locale');
                if (lifecycle && lifecycle.setup) {
                    lifecycle.setup();
                }
            },
            teardown : function () {
                moment.locale('en');
                teardownDeprecationHandler(test, moment, 'locale');
                if (lifecycle && lifecycle.teardown) {
                    lifecycle.teardown();
                }
            }
        });
        defineCommonLocaleTests(name, -1, -1);
    }

    localeModule('uz');

    test('parse', function (assert) {
        var tests = 'ÑÐ½Ð²Ð°Ñ ÑÐ½Ð²_ÑÐµÐ²ÑÐ°Ð» ÑÐµÐ²_Ð¼Ð°ÑÑ Ð¼Ð°Ñ_Ð°Ð¿ÑÐµÐ» Ð°Ð¿Ñ_Ð¼Ð°Ð¹ Ð¼Ð°Ð¹_Ð¸ÑÐ½ Ð¸ÑÐ½_Ð¸ÑÐ» Ð¸ÑÐ»_Ð°Ð²Ð³ÑÑÑ Ð°Ð²Ð³_ÑÐµÐ½ÑÑÐ±Ñ ÑÐµÐ½_Ð¾ÐºÑÑÐ±Ñ Ð¾ÐºÑ_Ð½Ð¾ÑÐ±Ñ Ð½Ð¾Ñ_Ð´ÐµÐºÐ°Ð±Ñ Ð´ÐµÐº'.split('_'), i;
        function equalTest(input, mmm, i) {
            assert.equal(moment(input, mmm).month(), i, input + ' should be month ' + (i + 1));
        }
        for (i = 0; i < 12; i++) {
            tests[i] = tests[i].split(' ');
            equalTest(tests[i][0], 'MMM', i);
            equalTest(tests[i][1], 'MMM', i);
            equalTest(tests[i][0], 'MMMM', i);
            equalTest(tests[i][1], 'MMMM', i);
            equalTest(tests[i][0].toLocaleLowerCase(), 'MMMM', i);
            equalTest(tests[i][1].toLocaleLowerCase(), 'MMMM', i);
            equalTest(tests[i][0].toLocaleUpperCase(), 'MMMM', i);
            equalTest(tests[i][1].toLocaleUpperCase(), 'MMMM', i);
        }
    });

    test('format', function (assert) {
        var a = [
                ['dddd, Do-MMMM YYYY, h:mm:ss',        'Ð¯ÐºÑÐ°Ð½Ð±Ð°, 14-ÑÐµÐ²ÑÐ°Ð» 2010, 3:25:50'],
                ['ddd, h:mm',                          'Ð¯ÐºÑ, 3:25'],
                ['M Mo MM MMMM MMM',                   '2 2 02 ÑÐµÐ²ÑÐ°Ð» ÑÐµÐ²'],
                ['YYYY YY',                            '2010 10'],
                ['D Do DD',                            '14 14 14'],
                ['d do dddd ddd dd',                   '0 0 Ð¯ÐºÑÐ°Ð½Ð±Ð° Ð¯ÐºÑ Ð¯Ðº'],
                ['DDD DDDo DDDD',                      '45 45 045'],
                ['w wo ww',                            '7 7 07'],
                ['h hh',                               '3 03'],
                ['H HH',                               '15 15'],
                ['m mm',                               '25 25'],
                ['s ss',                               '50 50'],
                ['a A',                                'pm PM'],
                ['[Ð¹Ð¸Ð»Ð½Ð¸Ð½Ð³] DDDo-[ÐºÑÐ½Ð¸]',             'Ð¹Ð¸Ð»Ð½Ð¸Ð½Ð³ 45-ÐºÑÐ½Ð¸'],
                ['LTS',                                '15:25:50'],
                ['L',                                  '14/02/2010'],
                ['LL',                                 '14 ÑÐµÐ²ÑÐ°Ð» 2010'],
                ['LLL',                                '14 ÑÐµÐ²ÑÐ°Ð» 2010 15:25'],
                ['LLLL',                               '14 ÑÐµÐ²ÑÐ°Ð» 2010, Ð¯ÐºÑÐ°Ð½Ð±Ð° 15:25'],
                ['l',                                  '14/2/2010'],
                ['ll',                                 '14 ÑÐµÐ² 2010'],
                ['lll',                                '14 ÑÐµÐ² 2010 15:25'],
                ['llll',                               '14 ÑÐµÐ² 2010, Ð¯ÐºÑ 15:25']
            ],
            b = moment(new Date(2010, 1, 14, 15, 25, 50, 125)),
            i;
        for (i = 0; i < a.length; i++) {
            assert.equal(b.format(a[i][0]), a[i][1], a[i][0] + ' ---> ' + a[i][1]);
        }
    });

    test('format ordinal', function (assert) {
        assert.equal(moment([2011, 0, 1]).format('DDDo'), '1', '1');
        assert.equal(moment([2011, 0, 2]).format('DDDo'), '2', '2');
        assert.equal(moment([2011, 0, 3]).format('DDDo'), '3', '3');
        assert.equal(moment([2011, 0, 4]).format('DDDo'), '4', '4');
        assert.equal(moment([2011, 0, 5]).format('DDDo'), '5', '5');
        assert.equal(moment([2011, 0, 6]).format('DDDo'), '6', '6');
        assert.equal(moment([2011, 0, 7]).format('DDDo'), '7', '7');
        assert.equal(moment([2011, 0, 8]).format('DDDo'), '8', '8');
        assert.equal(moment([2011, 0, 9]).format('DDDo'), '9', '9');
        assert.equal(moment([2011, 0, 10]).format('DDDo'), '10', '10');

        assert.equal(moment([2011, 0, 11]).format('DDDo'), '11', '11');
        assert.equal(moment([2011, 0, 12]).format('DDDo'), '12', '12');
        assert.equal(moment([2011, 0, 13]).format('DDDo'), '13', '13');
        assert.equal(moment([2011, 0, 14]).format('DDDo'), '14', '14');
        assert.equal(moment([2011, 0, 15]).format('DDDo'), '15', '15');
        assert.equal(moment([2011, 0, 16]).format('DDDo'), '16', '16');
        assert.equal(moment([2011, 0, 17]).format('DDDo'), '17', '17');
        assert.equal(moment([2011, 0, 18]).format('DDDo'), '18', '18');
        assert.equal(moment([2011, 0, 19]).format('DDDo'), '19', '19');
        assert.equal(moment([2011, 0, 20]).format('DDDo'), '20', '20');

        assert.equal(moment([2011, 0, 21]).format('DDDo'), '21', '21');
        assert.equal(moment([2011, 0, 22]).format('DDDo'), '22', '22');
        assert.equal(moment([2011, 0, 23]).format('DDDo'), '23', '23');
        assert.equal(moment([2011, 0, 24]).format('DDDo'), '24', '24');
        assert.equal(moment([2011, 0, 25]).format('DDDo'), '25', '25');
        assert.equal(moment([2011, 0, 26]).format('DDDo'), '26', '26');
        assert.equal(moment([2011, 0, 27]).format('DDDo'), '27', '27');
        assert.equal(moment([2011, 0, 28]).format('DDDo'), '28', '28');
        assert.equal(moment([2011, 0, 29]).format('DDDo'), '29', '29');
        assert.equal(moment([2011, 0, 30]).format('DDDo'), '30', '30');

        assert.equal(moment([2011, 0, 31]).format('DDDo'), '31', '31');
    });

    test('format month', function (assert) {
        var expected = 'ÑÐ½Ð²Ð°Ñ ÑÐ½Ð²_ÑÐµÐ²ÑÐ°Ð» ÑÐµÐ²_Ð¼Ð°ÑÑ Ð¼Ð°Ñ_Ð°Ð¿ÑÐµÐ» Ð°Ð¿Ñ_Ð¼Ð°Ð¹ Ð¼Ð°Ð¹_Ð¸ÑÐ½ Ð¸ÑÐ½_Ð¸ÑÐ» Ð¸ÑÐ»_Ð°Ð²Ð³ÑÑÑ Ð°Ð²Ð³_ÑÐµÐ½ÑÑÐ±Ñ ÑÐµÐ½_Ð¾ÐºÑÑÐ±Ñ Ð¾ÐºÑ_Ð½Ð¾ÑÐ±Ñ Ð½Ð¾Ñ_Ð´ÐµÐºÐ°Ð±Ñ Ð´ÐµÐº'.split('_'), i;
        for (i = 0; i < expected.length; i++) {
            assert.equal(moment([2011, i, 1]).format('MMMM MMM'), expected[i], expected[i]);
        }
    });

    test('format week', function (assert) {
        var expected = 'Ð¯ÐºÑÐ°Ð½Ð±Ð° Ð¯ÐºÑ Ð¯Ðº_ÐÑÑÐ°Ð½Ð±Ð° ÐÑÑ ÐÑ_Ð¡ÐµÑÐ°Ð½Ð±Ð° Ð¡ÐµÑ Ð¡Ðµ_Ð§Ð¾ÑÑÐ°Ð½Ð±Ð° Ð§Ð¾Ñ Ð§Ð¾_ÐÐ°Ð¹ÑÐ°Ð½Ð±Ð° ÐÐ°Ð¹ ÐÐ°_ÐÑÐ¼Ð° ÐÑÐ¼ ÐÑ_Ð¨Ð°Ð½Ð±Ð° Ð¨Ð°Ð½ Ð¨Ð°'.split('_'), i;
        for (i = 0; i < expected.length; i++) {
            assert.equal(moment([2011, 0, 2 + i]).format('dddd ddd dd'), expected[i], expected[i]);
        }
    });

    test('from', function (assert) {
        var start = moment([2007, 1, 28]);
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 44}), true),  'ÑÑÑÑÐ°Ñ', '44 ÑÐµÐºÑÐ½Ð´ = ÑÑÑÑÐ°Ñ');
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 45}), true),  'Ð±Ð¸Ñ Ð´Ð°ÐºÐ¸ÐºÐ°',      '45 ÑÐµÐºÑÐ½Ð´ = Ð±Ð¸Ñ Ð´Ð°ÐºÐ¸ÐºÐ°');
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 89}), true),  'Ð±Ð¸Ñ Ð´Ð°ÐºÐ¸ÐºÐ°',      '89 ÑÐµÐºÑÐ½Ð´ = Ð±Ð¸Ñ Ð´Ð°ÐºÐ¸ÐºÐ°');
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 90}), true),  '2 Ð´Ð°ÐºÐ¸ÐºÐ°',     '90 ÑÐµÐºÑÐ½Ð´ = 2 Ð´Ð°ÐºÐ¸ÐºÐ°');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 44}), true),  '44 Ð´Ð°ÐºÐ¸ÐºÐ°',    '44 Ð´Ð°ÐºÐ¸ÐºÐ° = 44 Ð´Ð°ÐºÐ¸ÐºÐ°');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 45}), true),  'Ð±Ð¸Ñ ÑÐ¾Ð°Ñ',       '45 Ð¼Ð¸Ð½ÑÑ = Ð±Ð¸Ñ ÑÐ¾Ð°Ñ');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 89}), true),  'Ð±Ð¸Ñ ÑÐ¾Ð°Ñ',       '89 minutes = an hour');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 90}), true),  '2 ÑÐ¾Ð°Ñ',       '90 Ð¼Ð¸Ð½ÑÑ = 2 ÑÐ¾Ð°Ñ');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 5}), true),   '5 ÑÐ¾Ð°Ñ',       '5 ÑÐ¾Ð°Ñ = 5 ÑÐ¾Ð°Ñ');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 21}), true),  '21 ÑÐ¾Ð°Ñ',      '21 ÑÐ¾Ð°Ñ = 21 ÑÐ¾Ð°Ñ');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 22}), true),  'Ð±Ð¸Ñ ÐºÑÐ½',         '22 ÑÐ¾Ð°Ñ = Ð±Ð¸Ñ ÐºÑÐ½');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 35}), true),  'Ð±Ð¸Ñ ÐºÑÐ½',         '35 ÑÐ¾Ð°Ñ = Ð±Ð¸Ñ ÐºÑÐ½');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 36}), true),  '2 ÐºÑÐ½',        '36 ÑÐ¾Ð°Ñ = 2 ÐºÑÐ½');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 1}), true),   'Ð±Ð¸Ñ ÐºÑÐ½',         '1 ÐºÑÐ½ = 1 ÐºÑÐ½');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 5}), true),   '5 ÐºÑÐ½',        '5 ÐºÑÐ½ = 5 ÐºÑÐ½');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 25}), true),  '25 ÐºÑÐ½',       '25 ÐºÑÐ½ = 25 ÐºÑÐ½');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 26}), true),  'Ð±Ð¸Ñ Ð¾Ð¹',       '26 ÐºÑÐ½ = Ð±Ð¸Ñ Ð¾Ð¹');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 30}), true),  'Ð±Ð¸Ñ Ð¾Ð¹',       '30 ÐºÑÐ½ = Ð±Ð¸Ñ Ð¾Ð¹');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 43}), true),  'Ð±Ð¸Ñ Ð¾Ð¹',       '45 ÐºÑÐ½ = Ð±Ð¸Ñ Ð¾Ð¹');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 46}), true),  '2 Ð¾Ð¹',      '46 ÐºÑÐ½ = 2 Ð¾Ð¹');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 74}), true),  '2 Ð¾Ð¹',      '75 ÐºÑÐ½ = 2 Ð¾Ð¹');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 76}), true),  '3 Ð¾Ð¹',      '76 ÐºÑÐ½ = 3 Ð¾Ð¹');
        assert.equal(start.from(moment([2007, 1, 28]).add({M: 1}), true),   'Ð±Ð¸Ñ Ð¾Ð¹',       'Ð±Ð¸Ñ Ð¾Ð¹ = Ð±Ð¸Ñ Ð¾Ð¹');
        assert.equal(start.from(moment([2007, 1, 28]).add({M: 5}), true),   '5 Ð¾Ð¹',      '5 Ð¾Ð¹ = 5 Ð¾Ð¹');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 345}), true), 'Ð±Ð¸Ñ Ð¹Ð¸Ð»',        '345 ÐºÑÐ½ = Ð±Ð¸Ñ Ð¹Ð¸Ð»');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 548}), true), '2 Ð¹Ð¸Ð»',       '548 ÐºÑÐ½ = 2 Ð¹Ð¸Ð»');
        assert.equal(start.from(moment([2007, 1, 28]).add({y: 1}), true),   'Ð±Ð¸Ñ Ð¹Ð¸Ð»',        '1 Ð¹Ð¸Ð» = Ð±Ð¸Ñ Ð¹Ð¸Ð»');
        assert.equal(start.from(moment([2007, 1, 28]).add({y: 5}), true),   '5 Ð¹Ð¸Ð»',       '5 Ð¹Ð¸Ð» = 5 Ð¹Ð¸Ð»');
    });

    test('suffix', function (assert) {
        assert.equal(moment(30000).from(0), 'Ð¯ÐºÐ¸Ð½ ÑÑÑÑÐ°Ñ Ð¸ÑÐ¸Ð´Ð°',  'prefix');
        assert.equal(moment(0).from(30000), 'ÐÐ¸Ñ Ð½ÐµÑÐ° ÑÑÑÑÐ°Ñ Ð¾Ð»Ð´Ð¸Ð½', 'suffix');
    });

    test('now from now', function (assert) {
        assert.equal(moment().fromNow(), 'ÐÐ¸Ñ Ð½ÐµÑÐ° ÑÑÑÑÐ°Ñ Ð¾Ð»Ð´Ð¸Ð½',  'now from now should display as in the past');
    });

    test('fromNow', function (assert) {
        assert.equal(moment().add({s: 30}).fromNow(), 'Ð¯ÐºÐ¸Ð½ ÑÑÑÑÐ°Ñ Ð¸ÑÐ¸Ð´Ð°', 'in a few seconds');
        assert.equal(moment().add({d: 5}).fromNow(), 'Ð¯ÐºÐ¸Ð½ 5 ÐºÑÐ½ Ð¸ÑÐ¸Ð´Ð°', 'in 5 days');
    });

    test('calendar day', function (assert) {
        var a = moment().hours(12).minutes(0).seconds(0);

        assert.equal(moment(a).calendar(),                   'ÐÑÐ³ÑÐ½ ÑÐ¾Ð°Ñ 12:00 Ð´Ð°',  'today at the same time');
        assert.equal(moment(a).add({m: 25}).calendar(),      'ÐÑÐ³ÑÐ½ ÑÐ¾Ð°Ñ 12:25 Ð´Ð°',  'Now plus 25 min');
        assert.equal(moment(a).add({h: 1}).calendar(),       'ÐÑÐ³ÑÐ½ ÑÐ¾Ð°Ñ 13:00 Ð´Ð°',  'Now plus 1 hour');
        assert.equal(moment(a).add({d: 1}).calendar(),       'Ð­ÑÑÐ°Ð³Ð° 12:00 Ð´Ð°',      'tomorrow at the same time');
        assert.equal(moment(a).subtract({h: 1}).calendar(),  'ÐÑÐ³ÑÐ½ ÑÐ¾Ð°Ñ 11:00 Ð´Ð°',  'Now minus 1 hour');
        assert.equal(moment(a).subtract({d: 1}).calendar(),  'ÐÐµÑÐ° ÑÐ¾Ð°Ñ 12:00 Ð´Ð°',   'yesterday at the same time');
    });

    test('calendar next week', function (assert) {
        var i, m;
        for (i = 2; i < 7; i++) {
            m = moment().add({d: i});
            assert.equal(m.calendar(),       m.format('dddd [ÐºÑÐ½Ð¸ ÑÐ¾Ð°Ñ] LT [Ð´Ð°]'),  'Today + ' + i + ' days current time');
            m.hours(0).minutes(0).seconds(0).milliseconds(0);
            assert.equal(m.calendar(),       m.format('dddd [ÐºÑÐ½Ð¸ ÑÐ¾Ð°Ñ] LT [Ð´Ð°]'),  'Today + ' + i + ' days beginning of day');
            m.hours(23).minutes(59).seconds(59).milliseconds(999);
            assert.equal(m.calendar(),       m.format('dddd [ÐºÑÐ½Ð¸ ÑÐ¾Ð°Ñ] LT [Ð´Ð°]'),  'Today + ' + i + ' days end of day');
        }
    });

    test('calendar last week', function (assert) {
        var i, m;

        for (i = 2; i < 7; i++) {
            m = moment().subtract({d: i});
            assert.equal(m.calendar(),       m.format('[Ð£ÑÐ³Ð°Ð½] dddd [ÐºÑÐ½Ð¸ ÑÐ¾Ð°Ñ] LT [Ð´Ð°]'),  'Today - ' + i + ' days current time');
            m.hours(0).minutes(0).seconds(0).milliseconds(0);
            assert.equal(m.calendar(),       m.format('[Ð£ÑÐ³Ð°Ð½] dddd [ÐºÑÐ½Ð¸ ÑÐ¾Ð°Ñ] LT [Ð´Ð°]'),  'Today - ' + i + ' days beginning of day');
            m.hours(23).minutes(59).seconds(59).milliseconds(999);
            assert.equal(m.calendar(),       m.format('[Ð£ÑÐ³Ð°Ð½] dddd [ÐºÑÐ½Ð¸ ÑÐ¾Ð°Ñ] LT [Ð´Ð°]'),  'Today - ' + i + ' days end of day');
        }
    });

    test('calendar all else', function (assert) {
        var weeksAgo = moment().subtract({w: 1}),
            weeksFromNow = moment().add({w: 1});

        assert.equal(weeksAgo.calendar(),       weeksAgo.format('L'),  '1 week ago');
        assert.equal(weeksFromNow.calendar(),   weeksFromNow.format('L'),  'in 1 week');

        weeksAgo = moment().subtract({w: 2});
        weeksFromNow = moment().add({w: 2});

        assert.equal(weeksAgo.calendar(),       weeksAgo.format('L'),  '2 weeks ago');
        assert.equal(weeksFromNow.calendar(),   weeksFromNow.format('L'),  'in 2 weeks');
    });

    test('weeks year starting sunday formatted', function (assert) {
        assert.equal(moment([2012, 0,  1]).format('w ww wo'), '1 01 1', 'Jan  1 2012 should be week 52');
        assert.equal(moment([2012, 0,  2]).format('w ww wo'),   '2 02 2', 'Jan  2 2012 should be week 1');
        assert.equal(moment([2012, 0,  8]).format('w ww wo'),   '2 02 2', 'Jan  8 2012 should be week 1');
        assert.equal(moment([2012, 0,  9]).format('w ww wo'),   '3 03 3', 'Jan  9 2012 should be week 2');
        assert.equal(moment([2012, 0, 15]).format('w ww wo'),   '3 03 3', 'Jan 15 2012 should be week 2');
    });

}));

;(function (global, factory) {
   typeof exports === 'object' && typeof module !== 'undefined'
       && typeof require === 'function' ? factory(require('../../moment')) :
   typeof define === 'function' && define.amd ? define(['../../moment'], factory) :
   factory(global.moment)
}(this, function (moment) { 'use strict';

    function each(array, callback) {
        var i;
        for (i = 0; i < array.length; i++) {
            callback(array[i], i, array);
        }
    }

    function objectKeys(obj) {
        if (Object.keys) {
            return Object.keys(obj);
        } else {
            // IE8
            var res = [], i;
            for (i in obj) {
                if (obj.hasOwnProperty(i)) {
                    res.push(i);
                }
            }
            return res;
        }
    }

    // Pick the first defined of two or three arguments.
    function defaults(a, b, c) {
        if (a != null) {
            return a;
        }
        if (b != null) {
            return b;
        }
        return c;
    }

    function defineCommonLocaleTests(locale, options) {
        test('lenient ordinal parsing', function (assert) {
            var i, ordinalStr, testMoment;
            for (i = 1; i <= 31; ++i) {
                ordinalStr = moment([2014, 0, i]).format('YYYY MM Do');
                testMoment = moment(ordinalStr, 'YYYY MM Do');
                assert.equal(testMoment.year(), 2014,
                        'lenient ordinal parsing ' + i + ' year check');
                assert.equal(testMoment.month(), 0,
                        'lenient ordinal parsing ' + i + ' month check');
                assert.equal(testMoment.date(), i,
                        'lenient ordinal parsing ' + i + ' date check');
            }
        });

        test('lenient ordinal parsing of number', function (assert) {
            var i, testMoment;
            for (i = 1; i <= 31; ++i) {
                testMoment = moment('2014 01 ' + i, 'YYYY MM Do');
                assert.equal(testMoment.year(), 2014,
                        'lenient ordinal parsing of number ' + i + ' year check');
                assert.equal(testMoment.month(), 0,
                        'lenient ordinal parsing of number ' + i + ' month check');
                assert.equal(testMoment.date(), i,
                        'lenient ordinal parsing of number ' + i + ' date check');
            }
        });

        test('strict ordinal parsing', function (assert) {
            var i, ordinalStr, testMoment;
            for (i = 1; i <= 31; ++i) {
                ordinalStr = moment([2014, 0, i]).format('YYYY MM Do');
                testMoment = moment(ordinalStr, 'YYYY MM Do', true);
                assert.ok(testMoment.isValid(), 'strict ordinal parsing ' + i);
            }
        });

        test('meridiem invariant', function (assert) {
            var h, m, t1, t2;
            for (h = 0; h < 24; ++h) {
                for (m = 0; m < 60; m += 15) {
                    t1 = moment.utc([2000, 0, 1, h, m]);
                    t2 = moment.utc(t1.format('A h:mm'), 'A h:mm');
                    assert.equal(t2.format('HH:mm'), t1.format('HH:mm'),
                            'meridiem at ' + t1.format('HH:mm'));
                }
            }
        });

        test('date format correctness', function (assert) {
            var data, tokens;
            data = moment.localeData()._longDateFormat;
            tokens = objectKeys(data);
            each(tokens, function (srchToken) {
                // Check each format string to make sure it does not contain any
                // tokens that need to be expanded.
                each(tokens, function (baseToken) {
                    // strip escaped sequences
                    var format = data[baseToken].replace(/(\[[^\]]*\])/g, '');
                    assert.equal(false, !!~format.indexOf(srchToken),
                            'contains ' + srchToken + ' in ' + baseToken);
                });
            });
        });

        test('month parsing correctness', function (assert) {
            var i, m;

            if (locale === 'tr') {
                // I can't fix it :(
                expect(0);
                return;
            }
            function tester(format) {
                var r;
                r = moment(m.format(format), format);
                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format);
                r = moment(m.format(format).toLocaleUpperCase(), format);
                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' upper');
                r = moment(m.format(format).toLocaleLowerCase(), format);
                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' lower');

                r = moment(m.format(format), format, true);
                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' strict');
                r = moment(m.format(format).toLocaleUpperCase(), format, true);
                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' upper strict');
                r = moment(m.format(format).toLocaleLowerCase(), format, true);
                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' lower strict');
            }

            for (i = 0; i < 12; ++i) {
                m = moment([2015, i, 15, 18]);
                tester('MMM');
                tester('MMM.');
                tester('MMMM');
                tester('MMMM.');
            }
        });

        test('weekday parsing correctness', function (assert) {
            var i, m;

            if (locale === 'tr' || locale === 'az') {
                // There is a lower-case letter (Ä±), that converted to upper then
                // lower changes to i
                expect(0);
                return;
            }
            function tester(format) {
                var r, baseMsg = 'weekday ' + m.weekday() + ' fmt ' + format;
                r = moment(m.format(format), format);
                assert.equal(r.weekday(), m.weekday(), baseMsg);
                r = moment(m.format(format).toLocaleUpperCase(), format);
                assert.equal(r.weekday(), m.weekday(), baseMsg + ' upper');
                r = moment(m.format(format).toLocaleLowerCase(), format);
                assert.equal(r.weekday(), m.weekday(), baseMsg + ' lower');

                r = moment(m.format(format), format, true);
                assert.equal(r.weekday(), m.weekday(), baseMsg + ' strict');
                r = moment(m.format(format).toLocaleUpperCase(), format, true);
                assert.equal(r.weekday(), m.weekday(), baseMsg + ' upper strict');
                r = moment(m.format(format).toLocaleLowerCase(), format, true);
                assert.equal(r.weekday(), m.weekday(), baseMsg + ' lower strict');
            }

            for (i = 0; i < 7; ++i) {
                m = moment.utc([2015, i, 15, 18]);
                tester('dd');
                tester('ddd');
                tester('dddd');
            }
        });
    }

    function setupDeprecationHandler(test, moment, scope) {
        test._expectedDeprecations = null;
        test._observedDeprecations = null;
        test._oldSupress = moment.suppressDeprecationWarnings;
        moment.suppressDeprecationWarnings = true;
        test.expectedDeprecations = function () {
            test._expectedDeprecations = arguments;
            test._observedDeprecations = [];
        };
        moment.deprecationHandler = function (name, msg) {
            var deprecationId = matchedDeprecation(name, msg, test._expectedDeprecations);
            if (deprecationId === -1) {
                throw new Error('Unexpected deprecation thrown name=' +
                        name + ' msg=' + msg);
            }
            test._observedDeprecations[deprecationId] = 1;
        };
    }

    function teardownDeprecationHandler(test, moment, scope) {
        moment.suppressDeprecationWarnings = test._oldSupress;

        if (test._expectedDeprecations != null) {
            var missedDeprecations = [];
            each(test._expectedDeprecations, function (deprecationPattern, id) {
                if (test._observedDeprecations[id] !== 1) {
                    missedDeprecations.push(deprecationPattern);
                }
            });
            if (missedDeprecations.length !== 0) {
                throw new Error('Expected deprecation warnings did not happen: ' +
                        missedDeprecations.join(' '));
            }
        }
    }

    function matchedDeprecation(name, msg, deprecations) {
        if (deprecations == null) {
            return -1;
        }
        for (var i = 0; i < deprecations.length; ++i) {
            if (name != null && name === deprecations[i]) {
                return i;
            }
            if (msg != null && msg.substring(0, deprecations[i].length) === deprecations[i]) {
                return i;
            }
        }
        return -1;
    }

    /*global QUnit:false*/

    var test = QUnit.test;

    var expect = QUnit.expect;

    function module (name, lifecycle) {
        QUnit.module(name, {
            setup : function () {
                moment.locale('en');
                moment.createFromInputFallback = function (config) {
                    throw new Error('input not handled by moment: ' + config._i);
                };
                setupDeprecationHandler(test, moment, 'core');
                if (lifecycle && lifecycle.setup) {
                    lifecycle.setup();
                }
            },
            teardown : function () {
                teardownDeprecationHandler(test, moment, 'core');
                if (lifecycle && lifecycle.teardown) {
                    lifecycle.teardown();
                }
            }
        });
    }

    function localeModule (name, lifecycle) {
        QUnit.module('locale:' + name, {
            setup : function () {
                moment.locale(name);
                moment.createFromInputFallback = function (config) {
                    throw new Error('input not handled by moment: ' + config._i);
                };
                setupDeprecationHandler(test, moment, 'locale');
                if (lifecycle && lifecycle.setup) {
                    lifecycle.setup();
                }
            },
            teardown : function () {
                moment.locale('en');
                teardownDeprecationHandler(test, moment, 'locale');
                if (lifecycle && lifecycle.teardown) {
                    lifecycle.teardown();
                }
            }
        });
        defineCommonLocaleTests(name, -1, -1);
    }

    localeModule('vi');

    test('parse', function (assert) {
        var i,
            tests = 'thÃ¡ng 1,Th01_thÃ¡ng 2,Th02_thÃ¡ng 3,Th03_thÃ¡ng 4,Th04_thÃ¡ng 5,Th05_thÃ¡ng 6,Th06_thÃ¡ng 7,Th07_thÃ¡ng 8,Th08_thÃ¡ng 9,Th09_thÃ¡ng 10,Th10_thÃ¡ng 11,Th11_thÃ¡ng 12,Th12'.split('_');

        function equalTest(input, mmm, i) {
            assert.equal(moment(input, mmm).month(), i, input + ' should be month ' + i);
        }

        for (i = 0; i < 12; i++) {
            tests[i] = tests[i].split(',');
            equalTest(tests[i][0], '[thÃ¡ng] M', i);
            equalTest(tests[i][1], '[Th]M', i);
            equalTest(tests[i][0], '[thÃ¡ng] MM', i);
            equalTest(tests[i][1], '[Th]MM', i);
            equalTest(tests[i][0].toLocaleLowerCase(), '[THÃNG] M', i);
            equalTest(tests[i][1].toLocaleLowerCase(), '[TH]M', i);
            equalTest(tests[i][0].toLocaleUpperCase(), '[THÃNG] MM', i);
            equalTest(tests[i][1].toLocaleUpperCase(), '[TH]MM', i);
        }
    });

    test('format', function (assert) {
        var a = [
                ['dddd, MMMM Do YYYY, h:mm:ss a',      'chá»§ nháº­t, thÃ¡ng 2 14 2010, 3:25:50 ch'],
                ['ddd, hA',                            'CN, 3CH'],
                ['M Mo MM MMMM MMM',                   '2 2 02 thÃ¡ng 2 Th02'],
                ['YYYY YY',                            '2010 10'],
                ['D Do DD',                            '14 14 14'],
                ['d do dddd ddd dd',                   '0 0 chá»§ nháº­t CN CN'],
                ['DDD DDDo DDDD',                      '45 45 045'],
                ['w wo ww',                            '6 6 06'],
                ['h hh',                               '3 03'],
                ['H HH',                               '15 15'],
                ['m mm',                               '25 25'],
                ['s ss',                               '50 50'],
                ['a A',                                'ch CH'],
                ['[ngÃ y thá»©] DDDo [cá»§a nÄm]',          'ngÃ y thá»© 45 cá»§a nÄm'],
                ['LTS',                                '15:25:50'],
                ['L',                                  '14/02/2010'],
                ['LL',                                 '14 thÃ¡ng 2 nÄm 2010'],
                ['LLL',                                '14 thÃ¡ng 2 nÄm 2010 15:25'],
                ['LLLL',                               'chá»§ nháº­t, 14 thÃ¡ng 2 nÄm 2010 15:25'],
                ['l',                                  '14/2/2010'],
                ['ll',                                 '14 Th02 2010'],
                ['lll',                                '14 Th02 2010 15:25'],
                ['llll',                               'CN, 14 Th02 2010 15:25']
            ],
            b = moment(new Date(2010, 1, 14, 15, 25, 50, 125)),
            i;

        for (i = 0; i < a.length; i++) {
            assert.equal(b.format(a[i][0]), a[i][1], a[i][0] + ' ---> ' + a[i][1]);
        }
    });

    test('format ordinal', function (assert) {
        assert.equal(moment([2011, 0, 1]).format('DDDo'), '1', '1');
        assert.equal(moment([2011, 0, 2]).format('DDDo'), '2', '2');
        assert.equal(moment([2011, 0, 3]).format('DDDo'), '3', '3');
        assert.equal(moment([2011, 0, 4]).format('DDDo'), '4', '4');
        assert.equal(moment([2011, 0, 5]).format('DDDo'), '5', '5');
        assert.equal(moment([2011, 0, 6]).format('DDDo'), '6', '6');
        assert.equal(moment([2011, 0, 7]).format('DDDo'), '7', '7');
        assert.equal(moment([2011, 0, 8]).format('DDDo'), '8', '8');
        assert.equal(moment([2011, 0, 9]).format('DDDo'), '9', '9');
        assert.equal(moment([2011, 0, 10]).format('DDDo'), '10', '10');

        assert.equal(moment([2011, 0, 11]).format('DDDo'), '11', '11');
        assert.equal(moment([2011, 0, 12]).format('DDDo'), '12', '12');
        assert.equal(moment([2011, 0, 13]).format('DDDo'), '13', '13');
        assert.equal(moment([2011, 0, 14]).format('DDDo'), '14', '14');
        assert.equal(moment([2011, 0, 15]).format('DDDo'), '15', '15');
        assert.equal(moment([2011, 0, 16]).format('DDDo'), '16', '16');
        assert.equal(moment([2011, 0, 17]).format('DDDo'), '17', '17');
        assert.equal(moment([2011, 0, 18]).format('DDDo'), '18', '18');
        assert.equal(moment([2011, 0, 19]).format('DDDo'), '19', '19');
        assert.equal(moment([2011, 0, 20]).format('DDDo'), '20', '20');

        assert.equal(moment([2011, 0, 21]).format('DDDo'), '21', '21');
        assert.equal(moment([2011, 0, 22]).format('DDDo'), '22', '22');
        assert.equal(moment([2011, 0, 23]).format('DDDo'), '23', '23');
        assert.equal(moment([2011, 0, 24]).format('DDDo'), '24', '24');
        assert.equal(moment([2011, 0, 25]).format('DDDo'), '25', '25');
        assert.equal(moment([2011, 0, 26]).format('DDDo'), '26', '26');
        assert.equal(moment([2011, 0, 27]).format('DDDo'), '27', '27');
        assert.equal(moment([2011, 0, 28]).format('DDDo'), '28', '28');
        assert.equal(moment([2011, 0, 29]).format('DDDo'), '29', '29');
        assert.equal(moment([2011, 0, 30]).format('DDDo'), '30', '30');

        assert.equal(moment([2011, 0, 31]).format('DDDo'), '31', '31');
    });

    test('format month', function (assert) {
        var i,
            expected = 'thÃ¡ng 1,Th01_thÃ¡ng 2,Th02_thÃ¡ng 3,Th03_thÃ¡ng 4,Th04_thÃ¡ng 5,Th05_thÃ¡ng 6,Th06_thÃ¡ng 7,Th07_thÃ¡ng 8,Th08_thÃ¡ng 9,Th09_thÃ¡ng 10,Th10_thÃ¡ng 11,Th11_thÃ¡ng 12,Th12'.split('_');

        for (i = 0; i < expected.length; i++) {
            assert.equal(moment([2011, i, 1]).format('MMMM,MMM'), expected[i], expected[i]);
        }
    });

    test('format week', function (assert) {
        var i,
            expected = 'chá»§ nháº­t CN CN_thá»© hai T2 T2_thá»© ba T3 T3_thá»© tÆ° T4 T4_thá»© nÄm T5 T5_thá»© sÃ¡u T6 T6_thá»© báº£y T7 T7'.split('_');

        for (i = 0; i < expected.length; i++) {
            assert.equal(moment([2011, 0, 2 + i]).format('dddd ddd dd'), expected[i], expected[i]);
        }
    });

    test('from', function (assert) {
        var start = moment([2007, 1, 28]);

        assert.equal(start.from(moment([2007, 1, 28]).add({s: 44}), true),  'vÃ i giÃ¢y', '44 seconds = a few seconds');
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 45}), true),  'má»t phÃºt',      '45 seconds = a minute');
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 89}), true),  'má»t phÃºt',      '89 seconds = a minute');
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 90}), true),  '2 phÃºt',     '90 seconds = 2 minutes');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 44}), true),  '44 phÃºt',    '44 minutes = 44 minutes');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 45}), true),  'má»t giá»',       '45 minutes = an hour');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 89}), true),  'má»t giá»',       '89 minutes = an hour');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 90}), true),  '2 giá»',       '90 minutes = 2 hours');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 5}), true),   '5 giá»',       '5 hours = 5 hours');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 21}), true),  '21 giá»',      '21 hours = 21 hours');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 22}), true),  'má»t ngÃ y',         '22 hours = a day');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 35}), true),  'má»t ngÃ y',         '35 hours = a day');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 36}), true),  '2 ngÃ y',        '36 hours = 2 days');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 1}), true),   'má»t ngÃ y',         '1 day = a day');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 5}), true),   '5 ngÃ y',        '5 days = 5 days');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 25}), true),  '25 ngÃ y',       '25 days = 25 days');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 26}), true),  'má»t thÃ¡ng',       '26 days = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 30}), true),  'má»t thÃ¡ng',       '30 days = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 43}), true),  'má»t thÃ¡ng',       '43 days = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 46}), true),  '2 thÃ¡ng',      '46 days = 2 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 74}), true),  '2 thÃ¡ng',      '75 days = 2 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 76}), true),  '3 thÃ¡ng',      '76 days = 3 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({M: 1}), true),   'má»t thÃ¡ng',       '1 month = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({M: 5}), true),   '5 thÃ¡ng',      '5 months = 5 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 345}), true), 'má»t nÄm',        '345 days = a year');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 548}), true), '2 nÄm',       '548 days = 2 years');
        assert.equal(start.from(moment([2007, 1, 28]).add({y: 1}), true),   'má»t nÄm',        '1 year = a year');
        assert.equal(start.from(moment([2007, 1, 28]).add({y: 5}), true),   '5 nÄm',       '5 years = 5 years');
    });

    test('suffix', function (assert) {
        assert.equal(moment(30000).from(0), 'vÃ i giÃ¢y tá»i',  'prefix');
        assert.equal(moment(0).from(30000), 'vÃ i giÃ¢y trÆ°á»c', 'suffix');
    });

    test('now from now', function (assert) {
        assert.equal(moment().fromNow(), 'vÃ i giÃ¢y trÆ°á»c',  'now from now should display as in the past');
    });

    test('fromNow', function (assert) {
        assert.equal(moment().add({s: 30}).fromNow(), 'vÃ i giÃ¢y tá»i', 'in a few seconds');
        assert.equal(moment().add({d: 5}).fromNow(), '5 ngÃ y tá»i', 'in 5 days');
    });

    test('calendar day', function (assert) {
        var a = moment().hours(12).minutes(0).seconds(0);

        assert.equal(moment(a).calendar(),                   'HÃ´m nay lÃºc 12:00',   'today at the same time');
        assert.equal(moment(a).add({m: 25}).calendar(),      'HÃ´m nay lÃºc 12:25',   'Now plus 25 min');
        assert.equal(moment(a).add({h: 1}).calendar(),       'HÃ´m nay lÃºc 13:00',   'Now plus 1 hour');
        assert.equal(moment(a).add({d: 1}).calendar(),       'NgÃ y mai lÃºc 12:00',  'tomorrow at the same time');
        assert.equal(moment(a).subtract({h: 1}).calendar(),  'HÃ´m nay lÃºc 11:00',   'Now minus 1 hour');
        assert.equal(moment(a).subtract({d: 1}).calendar(),  'HÃ´m qua lÃºc 12:00',   'yesterday at the same time');
    });

    test('calendar next week', function (assert) {
        var i, m;

        for (i = 2; i < 7; i++) {
            m = moment().add({d: i});
            assert.equal(m.calendar(),       m.format('dddd [tuáº§n tá»i lÃºc] LT'),  'Today + ' + i + ' days current time');
            m.hours(0).minutes(0).seconds(0).milliseconds(0);
            assert.equal(m.calendar(),       m.format('dddd [tuáº§n tá»i lÃºc] LT'),  'Today + ' + i + ' days beginning of day');
            m.hours(23).minutes(59).seconds(59).milliseconds(999);
            assert.equal(m.calendar(),       m.format('dddd [tuáº§n tá»i lÃºc] LT'),  'Today + ' + i + ' days end of day');
        }
    });

    test('calendar last week', function (assert) {
        var i, m;

        for (i = 2; i < 7; i++) {
            m = moment().subtract({d: i});
            assert.equal(m.calendar(),       m.format('dddd [tuáº§n rá»i lÃºc] LT'),  'Today - ' + i + ' days current time');
            m.hours(0).minutes(0).seconds(0).milliseconds(0);
            assert.equal(m.calendar(),       m.format('dddd [tuáº§n rá»i lÃºc] LT'),  'Today - ' + i + ' days beginning of day');
            m.hours(23).minutes(59).seconds(59).milliseconds(999);
            assert.equal(m.calendar(),       m.format('dddd [tuáº§n rá»i lÃºc] LT'),  'Today - ' + i + ' days end of day');
        }
    });

    test('calendar all else', function (assert) {
        var weeksAgo = moment().subtract({w: 1}),
            weeksFromNow = moment().add({w: 1});

        assert.equal(weeksAgo.calendar(),       weeksAgo.format('L'),  '1 week ago');
        assert.equal(weeksFromNow.calendar(),   weeksFromNow.format('L'),  'in 1 week');

        weeksAgo = moment().subtract({w: 2});
        weeksFromNow = moment().add({w: 2});

        assert.equal(weeksAgo.calendar(),       weeksAgo.format('L'),  '2 weeks ago');
        assert.equal(weeksFromNow.calendar(),   weeksFromNow.format('L'),  'in 2 weeks');
    });

    test('weeks year starting sunday formatted', function (assert) {
        assert.equal(moment([2012, 0,  1]).format('w ww wo'), '52 52 52', 'Jan  1 2012 should be week 52');
        assert.equal(moment([2012, 0,  2]).format('w ww wo'),   '1 01 1', 'Jan  2 2012 should be week 1');
        assert.equal(moment([2012, 0,  8]).format('w ww wo'),   '1 01 1', 'Jan  8 2012 should be week 1');
        assert.equal(moment([2012, 0,  9]).format('w ww wo'),   '2 02 2', 'Jan  9 2012 should be week 2');
        assert.equal(moment([2012, 0, 15]).format('w ww wo'),   '2 02 2', 'Jan 15 2012 should be week 2');
    });

}));

;(function (global, factory) {
   typeof exports === 'object' && typeof module !== 'undefined'
       && typeof require === 'function' ? factory(require('../../moment')) :
   typeof define === 'function' && define.amd ? define(['../../moment'], factory) :
   factory(global.moment)
}(this, function (moment) { 'use strict';

    function each(array, callback) {
        var i;
        for (i = 0; i < array.length; i++) {
            callback(array[i], i, array);
        }
    }

    function objectKeys(obj) {
        if (Object.keys) {
            return Object.keys(obj);
        } else {
            // IE8
            var res = [], i;
            for (i in obj) {
                if (obj.hasOwnProperty(i)) {
                    res.push(i);
                }
            }
            return res;
        }
    }

    // Pick the first defined of two or three arguments.
    function defaults(a, b, c) {
        if (a != null) {
            return a;
        }
        if (b != null) {
            return b;
        }
        return c;
    }

    function defineCommonLocaleTests(locale, options) {
        test('lenient ordinal parsing', function (assert) {
            var i, ordinalStr, testMoment;
            for (i = 1; i <= 31; ++i) {
                ordinalStr = moment([2014, 0, i]).format('YYYY MM Do');
                testMoment = moment(ordinalStr, 'YYYY MM Do');
                assert.equal(testMoment.year(), 2014,
                        'lenient ordinal parsing ' + i + ' year check');
                assert.equal(testMoment.month(), 0,
                        'lenient ordinal parsing ' + i + ' month check');
                assert.equal(testMoment.date(), i,
                        'lenient ordinal parsing ' + i + ' date check');
            }
        });

        test('lenient ordinal parsing of number', function (assert) {
            var i, testMoment;
            for (i = 1; i <= 31; ++i) {
                testMoment = moment('2014 01 ' + i, 'YYYY MM Do');
                assert.equal(testMoment.year(), 2014,
                        'lenient ordinal parsing of number ' + i + ' year check');
                assert.equal(testMoment.month(), 0,
                        'lenient ordinal parsing of number ' + i + ' month check');
                assert.equal(testMoment.date(), i,
                        'lenient ordinal parsing of number ' + i + ' date check');
            }
        });

        test('strict ordinal parsing', function (assert) {
            var i, ordinalStr, testMoment;
            for (i = 1; i <= 31; ++i) {
                ordinalStr = moment([2014, 0, i]).format('YYYY MM Do');
                testMoment = moment(ordinalStr, 'YYYY MM Do', true);
                assert.ok(testMoment.isValid(), 'strict ordinal parsing ' + i);
            }
        });

        test('meridiem invariant', function (assert) {
            var h, m, t1, t2;
            for (h = 0; h < 24; ++h) {
                for (m = 0; m < 60; m += 15) {
                    t1 = moment.utc([2000, 0, 1, h, m]);
                    t2 = moment.utc(t1.format('A h:mm'), 'A h:mm');
                    assert.equal(t2.format('HH:mm'), t1.format('HH:mm'),
                            'meridiem at ' + t1.format('HH:mm'));
                }
            }
        });

        test('date format correctness', function (assert) {
            var data, tokens;
            data = moment.localeData()._longDateFormat;
            tokens = objectKeys(data);
            each(tokens, function (srchToken) {
                // Check each format string to make sure it does not contain any
                // tokens that need to be expanded.
                each(tokens, function (baseToken) {
                    // strip escaped sequences
                    var format = data[baseToken].replace(/(\[[^\]]*\])/g, '');
                    assert.equal(false, !!~format.indexOf(srchToken),
                            'contains ' + srchToken + ' in ' + baseToken);
                });
            });
        });

        test('month parsing correctness', function (assert) {
            var i, m;

            if (locale === 'tr') {
                // I can't fix it :(
                expect(0);
                return;
            }
            function tester(format) {
                var r;
                r = moment(m.format(format), format);
                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format);
                r = moment(m.format(format).toLocaleUpperCase(), format);
                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' upper');
                r = moment(m.format(format).toLocaleLowerCase(), format);
                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' lower');

                r = moment(m.format(format), format, true);
                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' strict');
                r = moment(m.format(format).toLocaleUpperCase(), format, true);
                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' upper strict');
                r = moment(m.format(format).toLocaleLowerCase(), format, true);
                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' lower strict');
            }

            for (i = 0; i < 12; ++i) {
                m = moment([2015, i, 15, 18]);
                tester('MMM');
                tester('MMM.');
                tester('MMMM');
                tester('MMMM.');
            }
        });

        test('weekday parsing correctness', function (assert) {
            var i, m;

            if (locale === 'tr' || locale === 'az') {
                // There is a lower-case letter (Ä±), that converted to upper then
                // lower changes to i
                expect(0);
                return;
            }
            function tester(format) {
                var r, baseMsg = 'weekday ' + m.weekday() + ' fmt ' + format;
                r = moment(m.format(format), format);
                assert.equal(r.weekday(), m.weekday(), baseMsg);
                r = moment(m.format(format).toLocaleUpperCase(), format);
                assert.equal(r.weekday(), m.weekday(), baseMsg + ' upper');
                r = moment(m.format(format).toLocaleLowerCase(), format);
                assert.equal(r.weekday(), m.weekday(), baseMsg + ' lower');

                r = moment(m.format(format), format, true);
                assert.equal(r.weekday(), m.weekday(), baseMsg + ' strict');
                r = moment(m.format(format).toLocaleUpperCase(), format, true);
                assert.equal(r.weekday(), m.weekday(), baseMsg + ' upper strict');
                r = moment(m.format(format).toLocaleLowerCase(), format, true);
                assert.equal(r.weekday(), m.weekday(), baseMsg + ' lower strict');
            }

            for (i = 0; i < 7; ++i) {
                m = moment.utc([2015, i, 15, 18]);
                tester('dd');
                tester('ddd');
                tester('dddd');
            }
        });
    }

    function setupDeprecationHandler(test, moment, scope) {
        test._expectedDeprecations = null;
        test._observedDeprecations = null;
        test._oldSupress = moment.suppressDeprecationWarnings;
        moment.suppressDeprecationWarnings = true;
        test.expectedDeprecations = function () {
            test._expectedDeprecations = arguments;
            test._observedDeprecations = [];
        };
        moment.deprecationHandler = function (name, msg) {
            var deprecationId = matchedDeprecation(name, msg, test._expectedDeprecations);
            if (deprecationId === -1) {
                throw new Error('Unexpected deprecation thrown name=' +
                        name + ' msg=' + msg);
            }
            test._observedDeprecations[deprecationId] = 1;
        };
    }

    function teardownDeprecationHandler(test, moment, scope) {
        moment.suppressDeprecationWarnings = test._oldSupress;

        if (test._expectedDeprecations != null) {
            var missedDeprecations = [];
            each(test._expectedDeprecations, function (deprecationPattern, id) {
                if (test._observedDeprecations[id] !== 1) {
                    missedDeprecations.push(deprecationPattern);
                }
            });
            if (missedDeprecations.length !== 0) {
                throw new Error('Expected deprecation warnings did not happen: ' +
                        missedDeprecations.join(' '));
            }
        }
    }

    function matchedDeprecation(name, msg, deprecations) {
        if (deprecations == null) {
            return -1;
        }
        for (var i = 0; i < deprecations.length; ++i) {
            if (name != null && name === deprecations[i]) {
                return i;
            }
            if (msg != null && msg.substring(0, deprecations[i].length) === deprecations[i]) {
                return i;
            }
        }
        return -1;
    }

    /*global QUnit:false*/

    var test = QUnit.test;

    var expect = QUnit.expect;

    function module (name, lifecycle) {
        QUnit.module(name, {
            setup : function () {
                moment.locale('en');
                moment.createFromInputFallback = function (config) {
                    throw new Error('input not handled by moment: ' + config._i);
                };
                setupDeprecationHandler(test, moment, 'core');
                if (lifecycle && lifecycle.setup) {
                    lifecycle.setup();
                }
            },
            teardown : function () {
                teardownDeprecationHandler(test, moment, 'core');
                if (lifecycle && lifecycle.teardown) {
                    lifecycle.teardown();
                }
            }
        });
    }

    function localeModule (name, lifecycle) {
        QUnit.module('locale:' + name, {
            setup : function () {
                moment.locale(name);
                moment.createFromInputFallback = function (config) {
                    throw new Error('input not handled by moment: ' + config._i);
                };
                setupDeprecationHandler(test, moment, 'locale');
                if (lifecycle && lifecycle.setup) {
                    lifecycle.setup();
                }
            },
            teardown : function () {
                moment.locale('en');
                teardownDeprecationHandler(test, moment, 'locale');
                if (lifecycle && lifecycle.teardown) {
                    lifecycle.teardown();
                }
            }
        });
        defineCommonLocaleTests(name, -1, -1);
    }

    localeModule('x-pseudo');

    test('parse', function (assert) {
        var tests = 'J~Ã¡Ã±ÃºÃ¡~rÃ½ J~Ã¡Ã±_F~Ã©brÃº~Ã¡rÃ½ ~FÃ©b_~MÃ¡rc~h ~MÃ¡r_Ãp~rÃ­l ~Ãpr_~MÃ¡Ã½ ~MÃ¡Ã½_~JÃºÃ±Ã©~ ~JÃºÃ±_JÃºl~Ã½ ~JÃºl_ÃÃº~gÃºst~ ~ÃÃºg_SÃ©p~tÃ©mb~Ã©r ~SÃ©p_Ã~ctÃ³b~Ã©r ~Ãct_Ã~Ã³vÃ©m~bÃ©r ~ÃÃ³v_~DÃ©cÃ©~mbÃ©r ~DÃ©c'.split('_'), i;
        function equalTest(input, mmm, i) {
            assert.equal(moment(input, mmm).month(), i, input + ' should be month ' + (i + 1));
        }
        for (i = 0; i < 12; i++) {
            tests[i] = tests[i].split(' ');
            equalTest(tests[i][0], 'MMM', i);
            equalTest(tests[i][1], 'MMM', i);
            equalTest(tests[i][0], 'MMMM', i);
            equalTest(tests[i][1], 'MMMM', i);
            equalTest(tests[i][0].toLocaleLowerCase(), 'MMMM', i);
            equalTest(tests[i][1].toLocaleLowerCase(), 'MMMM', i);
            equalTest(tests[i][0].toLocaleUpperCase(), 'MMMM', i);
            equalTest(tests[i][1].toLocaleUpperCase(), 'MMMM', i);
        }
    });

    test('format', function (assert) {
        var a = [
                ['dddd, MMMM Do YYYY, h:mm:ss a',      'S~ÃºÃ±dÃ¡~Ã½, F~Ã©brÃº~Ã¡rÃ½ 14th 2010, 3:25:50 pm'],
                ['ddd, hA',                            'S~ÃºÃ±, 3PM'],
                ['M Mo MM MMMM MMM',                   '2 2nd 02 F~Ã©brÃº~Ã¡rÃ½ ~FÃ©b'],
                ['YYYY YY',                            '2010 10'],
                ['D Do DD',                            '14 14th 14'],
                ['d do dddd ddd dd',                   '0 0th S~ÃºÃ±dÃ¡~Ã½ S~ÃºÃ± S~Ãº'],
                ['DDD DDDo DDDD',                      '45 45th 045'],
                ['w wo ww',                            '6 6th 06'],
                ['h hh',                               '3 03'],
                ['H HH',                               '15 15'],
                ['m mm',                               '25 25'],
                ['s ss',                               '50 50'],
                ['a A',                                'pm PM'],
                ['[the] DDDo [day of the year]',       'the 45th day of the year'],
                ['LT',                                 '15:25'],
                ['L',                                  '14/02/2010'],
                ['LL',                                 '14 F~Ã©brÃº~Ã¡rÃ½ 2010'],
                ['LLL',                                '14 F~Ã©brÃº~Ã¡rÃ½ 2010 15:25'],
                ['LLLL',                               'S~ÃºÃ±dÃ¡~Ã½, 14 F~Ã©brÃº~Ã¡rÃ½ 2010 15:25'],
                ['l',                                  '14/2/2010'],
                ['ll',                                 '14 ~FÃ©b 2010'],
                ['lll',                                '14 ~FÃ©b 2010 15:25'],
                ['llll',                               'S~ÃºÃ±, 14 ~FÃ©b 2010 15:25']
            ],
            b = moment(new Date(2010, 1, 14, 15, 25, 50, 125)),
            i;
        for (i = 0; i < a.length; i++) {
            assert.equal(b.format(a[i][0]), a[i][1], a[i][0] + ' ---> ' + a[i][1]);
        }
    });

    test('format ordinal', function (assert) {
        assert.equal(moment([2011, 0, 1]).format('DDDo'), '1st', '1st');
        assert.equal(moment([2011, 0, 2]).format('DDDo'), '2nd', '2nd');
        assert.equal(moment([2011, 0, 3]).format('DDDo'), '3rd', '3rd');
        assert.equal(moment([2011, 0, 4]).format('DDDo'), '4th', '4th');
        assert.equal(moment([2011, 0, 5]).format('DDDo'), '5th', '5th');
        assert.equal(moment([2011, 0, 6]).format('DDDo'), '6th', '6th');
        assert.equal(moment([2011, 0, 7]).format('DDDo'), '7th', '7th');
        assert.equal(moment([2011, 0, 8]).format('DDDo'), '8th', '8th');
        assert.equal(moment([2011, 0, 9]).format('DDDo'), '9th', '9th');
        assert.equal(moment([2011, 0, 10]).format('DDDo'), '10th', '10th');

        assert.equal(moment([2011, 0, 11]).format('DDDo'), '11th', '11th');
        assert.equal(moment([2011, 0, 12]).format('DDDo'), '12th', '12th');
        assert.equal(moment([2011, 0, 13]).format('DDDo'), '13th', '13th');
        assert.equal(moment([2011, 0, 14]).format('DDDo'), '14th', '14th');
        assert.equal(moment([2011, 0, 15]).format('DDDo'), '15th', '15th');
        assert.equal(moment([2011, 0, 16]).format('DDDo'), '16th', '16th');
        assert.equal(moment([2011, 0, 17]).format('DDDo'), '17th', '17th');
        assert.equal(moment([2011, 0, 18]).format('DDDo'), '18th', '18th');
        assert.equal(moment([2011, 0, 19]).format('DDDo'), '19th', '19th');
        assert.equal(moment([2011, 0, 20]).format('DDDo'), '20th', '20th');

        assert.equal(moment([2011, 0, 21]).format('DDDo'), '21st', '21st');
        assert.equal(moment([2011, 0, 22]).format('DDDo'), '22nd', '22nd');
        assert.equal(moment([2011, 0, 23]).format('DDDo'), '23rd', '23rd');
        assert.equal(moment([2011, 0, 24]).format('DDDo'), '24th', '24th');
        assert.equal(moment([2011, 0, 25]).format('DDDo'), '25th', '25th');
        assert.equal(moment([2011, 0, 26]).format('DDDo'), '26th', '26th');
        assert.equal(moment([2011, 0, 27]).format('DDDo'), '27th', '27th');
        assert.equal(moment([2011, 0, 28]).format('DDDo'), '28th', '28th');
        assert.equal(moment([2011, 0, 29]).format('DDDo'), '29th', '29th');
        assert.equal(moment([2011, 0, 30]).format('DDDo'), '30th', '30th');

        assert.equal(moment([2011, 0, 31]).format('DDDo'), '31st', '31st');
    });

    test('format month', function (assert) {
        var expected = 'J~Ã¡Ã±ÃºÃ¡~rÃ½ J~Ã¡Ã±_F~Ã©brÃº~Ã¡rÃ½ ~FÃ©b_~MÃ¡rc~h ~MÃ¡r_Ãp~rÃ­l ~Ãpr_~MÃ¡Ã½ ~MÃ¡Ã½_~JÃºÃ±Ã©~ ~JÃºÃ±_JÃºl~Ã½ ~JÃºl_ÃÃº~gÃºst~ ~ÃÃºg_SÃ©p~tÃ©mb~Ã©r ~SÃ©p_Ã~ctÃ³b~Ã©r ~Ãct_Ã~Ã³vÃ©m~bÃ©r ~ÃÃ³v_~DÃ©cÃ©~mbÃ©r ~DÃ©c'.split('_'), i;
        for (i = 0; i < expected.length; i++) {
            assert.equal(moment([2011, i, 1]).format('MMMM MMM'), expected[i], expected[i]);
        }
    });

    test('format week', function (assert) {
        var expected = 'S~ÃºÃ±dÃ¡~Ã½ S~ÃºÃ± S~Ãº_MÃ³~Ã±dÃ¡Ã½~ ~MÃ³Ã± MÃ³~_TÃºÃ©~sdÃ¡Ã½~ ~TÃºÃ© TÃº_WÃ©d~Ã±Ã©sd~Ã¡Ã½ ~WÃ©d ~WÃ©_T~hÃºrs~dÃ¡Ã½ ~ThÃº T~h_~FrÃ­d~Ã¡Ã½ ~FrÃ­ Fr~_S~Ã¡tÃºr~dÃ¡Ã½ ~SÃ¡t SÃ¡'.split('_'), i;
        for (i = 0; i < expected.length; i++) {
            assert.equal(moment([2011, 0, 2 + i]).format('dddd ddd dd'), expected[i], expected[i]);
        }
    });

    test('from', function (assert) {
        var start = moment([2007, 1, 28]);
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 44}), true),  'Ã¡ ~fÃ©w ~sÃ©cÃ³~Ã±ds', '44 seconds = a few seconds');
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 45}), true),  'Ã¡ ~mÃ­Ã±~ÃºtÃ©',      '45 seconds = a minute');
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 89}), true),  'Ã¡ ~mÃ­Ã±~ÃºtÃ©',      '89 seconds = a minute');
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 90}), true),  '2 m~Ã­Ã±Ãº~tÃ©s',     '90 seconds = 2 minutes');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 44}), true),  '44 m~Ã­Ã±Ãº~tÃ©s',    '44 minutes = 44 minutes');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 45}), true),  'Ã¡~Ã± hÃ³~Ãºr',       '45 minutes = an hour');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 89}), true),  'Ã¡~Ã± hÃ³~Ãºr',       '89 minutes = an hour');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 90}), true),  '2 h~Ã³Ãºrs',       '90 minutes = 2 hours');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 5}), true),   '5 h~Ã³Ãºrs',       '5 hours = 5 hours');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 21}), true),  '21 h~Ã³Ãºrs',      '21 hours = 21 hours');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 22}), true),  'Ã¡ ~dÃ¡Ã½',         '22 hours = a day');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 35}), true),  'Ã¡ ~dÃ¡Ã½',         '35 hours = a day');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 36}), true),  '2 d~Ã¡Ã½s',        '36 hours = 2 days');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 1}), true),   'Ã¡ ~dÃ¡Ã½',         '1 day = a day');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 5}), true),   '5 d~Ã¡Ã½s',        '5 days = 5 days');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 25}), true),  '25 d~Ã¡Ã½s',       '25 days = 25 days');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 26}), true),  'Ã¡ ~mÃ³Ã±~th',       '26 days = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 30}), true),  'Ã¡ ~mÃ³Ã±~th',       '30 days = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 43}), true),  'Ã¡ ~mÃ³Ã±~th',       '43 days = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 46}), true),  '2 m~Ã³Ã±t~hs',      '46 days = 2 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 74}), true),  '2 m~Ã³Ã±t~hs',      '75 days = 2 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 76}), true),  '3 m~Ã³Ã±t~hs',      '76 days = 3 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({M: 1}), true),   'Ã¡ ~mÃ³Ã±~th',       '1 month = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({M: 5}), true),   '5 m~Ã³Ã±t~hs',      '5 months = 5 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 345}), true), 'Ã¡ ~Ã½Ã©Ã¡r',        '345 days = a year');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 548}), true), '2 Ã½~Ã©Ã¡rs',       '548 days = 2 years');
        assert.equal(start.from(moment([2007, 1, 28]).add({y: 1}), true),   'Ã¡ ~Ã½Ã©Ã¡r',        '1 year = a year');
        assert.equal(start.from(moment([2007, 1, 28]).add({y: 5}), true),   '5 Ã½~Ã©Ã¡rs',       '5 years = 5 years');
    });

    test('suffix', function (assert) {
        assert.equal(moment(30000).from(0), 'Ã­~Ã± Ã¡ ~fÃ©w ~sÃ©cÃ³~Ã±ds',  'prefix');
        assert.equal(moment(0).from(30000), 'Ã¡ ~fÃ©w ~sÃ©cÃ³~Ã±ds Ã¡~gÃ³', 'suffix');
    });

    test('now from now', function (assert) {
        assert.equal(moment().fromNow(), 'Ã¡ ~fÃ©w ~sÃ©cÃ³~Ã±ds Ã¡~gÃ³',  'now from now should display as in the past');
    });

    test('fromNow', function (assert) {
        assert.equal(moment().add({s: 30}).fromNow(), 'Ã­~Ã± Ã¡ ~fÃ©w ~sÃ©cÃ³~Ã±ds', 'in a few seconds');
        assert.equal(moment().add({d: 5}).fromNow(), 'Ã­~Ã± 5 d~Ã¡Ã½s', 'in 5 days');
    });

    test('calendar day', function (assert) {
        var a = moment().hours(2).minutes(0).seconds(0);

        assert.equal(moment(a).calendar(),                     'T~Ã³dÃ¡~Ã½ Ã¡t 02:00',      'today at the same time');
        assert.equal(moment(a).add({m: 25}).calendar(),      'T~Ã³dÃ¡~Ã½ Ã¡t 02:25',      'Now plus 25 min');
        assert.equal(moment(a).add({h: 1}).calendar(),       'T~Ã³dÃ¡~Ã½ Ã¡t 03:00',      'Now plus 1 hour');
        assert.equal(moment(a).add({d: 1}).calendar(),       'T~Ã³mÃ³~rrÃ³~w Ã¡t 02:00',   'tomorrow at the same time');
        assert.equal(moment(a).subtract({h: 1}).calendar(),  'T~Ã³dÃ¡~Ã½ Ã¡t 01:00',      'Now minus 1 hour');
        assert.equal(moment(a).subtract({d: 1}).calendar(),  'Ã~Ã©st~Ã©rdÃ¡~Ã½ Ã¡t 02:00',  'yesterday at the same time');
    });

    test('calendar next week', function (assert) {
        var i, m;
        for (i = 2; i < 7; i++) {
            m = moment().add({d: i});
            assert.equal(m.calendar(),       m.format('dddd [Ã¡t] LT'),  'Today + ' + i + ' days current time');
            m.hours(0).minutes(0).seconds(0).milliseconds(0);
            assert.equal(m.calendar(),       m.format('dddd [Ã¡t] LT'),  'Today + ' + i + ' days beginning of day');
            m.hours(23).minutes(59).seconds(59).milliseconds(999);
            assert.equal(m.calendar(),       m.format('dddd [Ã¡t] LT'),  'Today + ' + i + ' days end of day');
        }
    });

    test('calendar last week', function (assert) {
        var i, m;

        for (i = 2; i < 7; i++) {
            m = moment().subtract({d: i});
            assert.equal(m.calendar(),       m.format('[L~Ã¡st] dddd [Ã¡t] LT'),  'Today - ' + i + ' days current time');
            m.hours(0).minutes(0).seconds(0).milliseconds(0);
            assert.equal(m.calendar(),       m.format('[L~Ã¡st] dddd [Ã¡t] LT'),  'Today - ' + i + ' days beginning of day');
            m.hours(23).minutes(59).seconds(59).milliseconds(999);
            assert.equal(m.calendar(),       m.format('[L~Ã¡st] dddd [Ã¡t] LT'),  'Today - ' + i + ' days end of day');
        }
    });

    test('calendar all else', function (assert) {
        var weeksAgo = moment().subtract({w: 1}),
            weeksFromNow = moment().add({w: 1});

        assert.equal(weeksAgo.calendar(),       weeksAgo.format('L'),  '1 week ago');
        assert.equal(weeksFromNow.calendar(),   weeksFromNow.format('L'),  'in 1 week');

        weeksAgo = moment().subtract({w: 2});
        weeksFromNow = moment().add({w: 2});

        assert.equal(weeksAgo.calendar(),       weeksAgo.format('L'),  '2 weeks ago');
        assert.equal(weeksFromNow.calendar(),   weeksFromNow.format('L'),  'in 2 weeks');
    });

    test('weeks year starting sunday formatted', function (assert) {
        assert.equal(moment([2012, 0,  1]).format('w ww wo'), '52 52 52nd', 'Jan  1 2012 should be week 52');
        assert.equal(moment([2012, 0,  2]).format('w ww wo'),   '1 01 1st', 'Jan  2 2012 should be week 1');
        assert.equal(moment([2012, 0,  8]).format('w ww wo'),   '1 01 1st', 'Jan  8 2012 should be week 1');
        assert.equal(moment([2012, 0,  9]).format('w ww wo'),   '2 02 2nd', 'Jan  9 2012 should be week 2');
        assert.equal(moment([2012, 0, 15]).format('w ww wo'),   '2 02 2nd', 'Jan 15 2012 should be week 2');
    });

}));

;(function (global, factory) {
   typeof exports === 'object' && typeof module !== 'undefined'
       && typeof require === 'function' ? factory(require('../../moment')) :
   typeof define === 'function' && define.amd ? define(['../../moment'], factory) :
   factory(global.moment)
}(this, function (moment) { 'use strict';

    function each(array, callback) {
        var i;
        for (i = 0; i < array.length; i++) {
            callback(array[i], i, array);
        }
    }

    function objectKeys(obj) {
        if (Object.keys) {
            return Object.keys(obj);
        } else {
            // IE8
            var res = [], i;
            for (i in obj) {
                if (obj.hasOwnProperty(i)) {
                    res.push(i);
                }
            }
            return res;
        }
    }

    // Pick the first defined of two or three arguments.
    function defaults(a, b, c) {
        if (a != null) {
            return a;
        }
        if (b != null) {
            return b;
        }
        return c;
    }

    function defineCommonLocaleTests(locale, options) {
        test('lenient ordinal parsing', function (assert) {
            var i, ordinalStr, testMoment;
            for (i = 1; i <= 31; ++i) {
                ordinalStr = moment([2014, 0, i]).format('YYYY MM Do');
                testMoment = moment(ordinalStr, 'YYYY MM Do');
                assert.equal(testMoment.year(), 2014,
                        'lenient ordinal parsing ' + i + ' year check');
                assert.equal(testMoment.month(), 0,
                        'lenient ordinal parsing ' + i + ' month check');
                assert.equal(testMoment.date(), i,
                        'lenient ordinal parsing ' + i + ' date check');
            }
        });

        test('lenient ordinal parsing of number', function (assert) {
            var i, testMoment;
            for (i = 1; i <= 31; ++i) {
                testMoment = moment('2014 01 ' + i, 'YYYY MM Do');
                assert.equal(testMoment.year(), 2014,
                        'lenient ordinal parsing of number ' + i + ' year check');
                assert.equal(testMoment.month(), 0,
                        'lenient ordinal parsing of number ' + i + ' month check');
                assert.equal(testMoment.date(), i,
                        'lenient ordinal parsing of number ' + i + ' date check');
            }
        });

        test('strict ordinal parsing', function (assert) {
            var i, ordinalStr, testMoment;
            for (i = 1; i <= 31; ++i) {
                ordinalStr = moment([2014, 0, i]).format('YYYY MM Do');
                testMoment = moment(ordinalStr, 'YYYY MM Do', true);
                assert.ok(testMoment.isValid(), 'strict ordinal parsing ' + i);
            }
        });

        test('meridiem invariant', function (assert) {
            var h, m, t1, t2;
            for (h = 0; h < 24; ++h) {
                for (m = 0; m < 60; m += 15) {
                    t1 = moment.utc([2000, 0, 1, h, m]);
                    t2 = moment.utc(t1.format('A h:mm'), 'A h:mm');
                    assert.equal(t2.format('HH:mm'), t1.format('HH:mm'),
                            'meridiem at ' + t1.format('HH:mm'));
                }
            }
        });

        test('date format correctness', function (assert) {
            var data, tokens;
            data = moment.localeData()._longDateFormat;
            tokens = objectKeys(data);
            each(tokens, function (srchToken) {
                // Check each format string to make sure it does not contain any
                // tokens that need to be expanded.
                each(tokens, function (baseToken) {
                    // strip escaped sequences
                    var format = data[baseToken].replace(/(\[[^\]]*\])/g, '');
                    assert.equal(false, !!~format.indexOf(srchToken),
                            'contains ' + srchToken + ' in ' + baseToken);
                });
            });
        });

        test('month parsing correctness', function (assert) {
            var i, m;

            if (locale === 'tr') {
                // I can't fix it :(
                expect(0);
                return;
            }
            function tester(format) {
                var r;
                r = moment(m.format(format), format);
                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format);
                r = moment(m.format(format).toLocaleUpperCase(), format);
                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' upper');
                r = moment(m.format(format).toLocaleLowerCase(), format);
                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' lower');

                r = moment(m.format(format), format, true);
                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' strict');
                r = moment(m.format(format).toLocaleUpperCase(), format, true);
                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' upper strict');
                r = moment(m.format(format).toLocaleLowerCase(), format, true);
                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' lower strict');
            }

            for (i = 0; i < 12; ++i) {
                m = moment([2015, i, 15, 18]);
                tester('MMM');
                tester('MMM.');
                tester('MMMM');
                tester('MMMM.');
            }
        });

        test('weekday parsing correctness', function (assert) {
            var i, m;

            if (locale === 'tr' || locale === 'az') {
                // There is a lower-case letter (Ä±), that converted to upper then
                // lower changes to i
                expect(0);
                return;
            }
            function tester(format) {
                var r, baseMsg = 'weekday ' + m.weekday() + ' fmt ' + format;
                r = moment(m.format(format), format);
                assert.equal(r.weekday(), m.weekday(), baseMsg);
                r = moment(m.format(format).toLocaleUpperCase(), format);
                assert.equal(r.weekday(), m.weekday(), baseMsg + ' upper');
                r = moment(m.format(format).toLocaleLowerCase(), format);
                assert.equal(r.weekday(), m.weekday(), baseMsg + ' lower');

                r = moment(m.format(format), format, true);
                assert.equal(r.weekday(), m.weekday(), baseMsg + ' strict');
                r = moment(m.format(format).toLocaleUpperCase(), format, true);
                assert.equal(r.weekday(), m.weekday(), baseMsg + ' upper strict');
                r = moment(m.format(format).toLocaleLowerCase(), format, true);
                assert.equal(r.weekday(), m.weekday(), baseMsg + ' lower strict');
            }

            for (i = 0; i < 7; ++i) {
                m = moment.utc([2015, i, 15, 18]);
                tester('dd');
                tester('ddd');
                tester('dddd');
            }
        });
    }

    function setupDeprecationHandler(test, moment, scope) {
        test._expectedDeprecations = null;
        test._observedDeprecations = null;
        test._oldSupress = moment.suppressDeprecationWarnings;
        moment.suppressDeprecationWarnings = true;
        test.expectedDeprecations = function () {
            test._expectedDeprecations = arguments;
            test._observedDeprecations = [];
        };
        moment.deprecationHandler = function (name, msg) {
            var deprecationId = matchedDeprecation(name, msg, test._expectedDeprecations);
            if (deprecationId === -1) {
                throw new Error('Unexpected deprecation thrown name=' +
                        name + ' msg=' + msg);
            }
            test._observedDeprecations[deprecationId] = 1;
        };
    }

    function teardownDeprecationHandler(test, moment, scope) {
        moment.suppressDeprecationWarnings = test._oldSupress;

        if (test._expectedDeprecations != null) {
            var missedDeprecations = [];
            each(test._expectedDeprecations, function (deprecationPattern, id) {
                if (test._observedDeprecations[id] !== 1) {
                    missedDeprecations.push(deprecationPattern);
                }
            });
            if (missedDeprecations.length !== 0) {
                throw new Error('Expected deprecation warnings did not happen: ' +
                        missedDeprecations.join(' '));
            }
        }
    }

    function matchedDeprecation(name, msg, deprecations) {
        if (deprecations == null) {
            return -1;
        }
        for (var i = 0; i < deprecations.length; ++i) {
            if (name != null && name === deprecations[i]) {
                return i;
            }
            if (msg != null && msg.substring(0, deprecations[i].length) === deprecations[i]) {
                return i;
            }
        }
        return -1;
    }

    /*global QUnit:false*/

    var test = QUnit.test;

    var expect = QUnit.expect;

    function module (name, lifecycle) {
        QUnit.module(name, {
            setup : function () {
                moment.locale('en');
                moment.createFromInputFallback = function (config) {
                    throw new Error('input not handled by moment: ' + config._i);
                };
                setupDeprecationHandler(test, moment, 'core');
                if (lifecycle && lifecycle.setup) {
                    lifecycle.setup();
                }
            },
            teardown : function () {
                teardownDeprecationHandler(test, moment, 'core');
                if (lifecycle && lifecycle.teardown) {
                    lifecycle.teardown();
                }
            }
        });
    }

    function localeModule (name, lifecycle) {
        QUnit.module('locale:' + name, {
            setup : function () {
                moment.locale(name);
                moment.createFromInputFallback = function (config) {
                    throw new Error('input not handled by moment: ' + config._i);
                };
                setupDeprecationHandler(test, moment, 'locale');
                if (lifecycle && lifecycle.setup) {
                    lifecycle.setup();
                }
            },
            teardown : function () {
                moment.locale('en');
                teardownDeprecationHandler(test, moment, 'locale');
                if (lifecycle && lifecycle.teardown) {
                    lifecycle.teardown();
                }
            }
        });
        defineCommonLocaleTests(name, -1, -1);
    }

    localeModule('zh-cn');

    test('parse', function (assert) {
        var tests = 'ä¸æ 1æ_äºæ 2æ_ä¸æ 3æ_åæ 4æ_äºæ 5æ_å­æ 6æ_ä¸æ 7æ_å«æ 8æ_ä¹æ 9æ_åæ 10æ_åä¸æ 11æ_åäºæ 12æ'.split('_'), i;

        function equalTest(input, mmm, i) {
            assert.equal(moment(input, mmm).month(), i, input + ' should be month ' + (i + 1));
        }

        for (i = 0; i < 12; i++) {
            tests[i] = tests[i].split(' ');
            equalTest(tests[i][0], 'MMM', i);
            equalTest(tests[i][1], 'MMM', i);
            equalTest(tests[i][0], 'MMMM', i);
            equalTest(tests[i][1], 'MMMM', i);
            equalTest(tests[i][0].toLocaleLowerCase(), 'MMMM', i);
            equalTest(tests[i][1].toLocaleLowerCase(), 'MMMM', i);
            equalTest(tests[i][0].toLocaleUpperCase(), 'MMMM', i);
            equalTest(tests[i][1].toLocaleUpperCase(), 'MMMM', i);
        }
    });

    test('format', function (assert) {
        var a = [
                ['dddd, MMMM Do YYYY, a h:mm:ss',      'æææ¥, äºæ 14æ¥ 2010, ä¸å 3:25:50'],
                ['ddd, Ah',                            'å¨æ¥, ä¸å3'],
                ['M Mo MM MMMM MMM',                   '2 2æ 02 äºæ 2æ'],
                ['YYYY YY',                            '2010 10'],
                ['D Do DD',                            '14 14æ¥ 14'],
                ['d do dddd ddd dd',                   '0 0æ¥ æææ¥ å¨æ¥ æ¥'],
                ['DDD DDDo DDDD',                      '45 45æ¥ 045'],
                ['w wo ww',                            '6 6å¨ 06'],
                ['h hh',                               '3 03'],
                ['H HH',                               '15 15'],
                ['m mm',                               '25 25'],
                ['s ss',                               '50 50'],
                ['a A',                                'ä¸å ä¸å'],
                ['[è¿å¹´çç¬¬] DDDo',                    'è¿å¹´çç¬¬ 45æ¥'],
                ['LTS',                                'ä¸å3ç¹25å50ç§'],
                ['L',                                  '2010-02-14'],
                ['LL',                                 '2010å¹´2æ14æ¥'],
                ['LLL',                                '2010å¹´2æ14æ¥ä¸å3ç¹25å'],
                ['LLLL',                               '2010å¹´2æ14æ¥æææ¥ä¸å3ç¹25å'],
                ['l',                                  '2010-02-14'],
                ['ll',                                 '2010å¹´2æ14æ¥'],
                ['lll',                                '2010å¹´2æ14æ¥ä¸å3ç¹25å'],
                ['llll',                               '2010å¹´2æ14æ¥æææ¥ä¸å3ç¹25å']
            ],
            b = moment(new Date(2010, 1, 14, 15, 25, 50, 125)),
            i;

        for (i = 0; i < a.length; i++) {
            assert.equal(b.format(a[i][0]), a[i][1], a[i][0] + ' ---> ' + a[i][1]);
        }
    });

    test('format month', function (assert) {
        var expected = 'ä¸æ 1æ_äºæ 2æ_ä¸æ 3æ_åæ 4æ_äºæ 5æ_å­æ 6æ_ä¸æ 7æ_å«æ 8æ_ä¹æ 9æ_åæ 10æ_åä¸æ 11æ_åäºæ 12æ'.split('_'), i;

        for (i = 0; i < expected.length; i++) {
            assert.equal(moment([2011, i, 1]).format('MMMM MMM'), expected[i], expected[i]);
        }
    });

    test('format week', function (assert) {
        var expected = 'æææ¥ å¨æ¥ æ¥_ææä¸ å¨ä¸ ä¸_ææäº å¨äº äº_ææä¸ å¨ä¸ ä¸_ææå å¨å å_ææäº å¨äº äº_ææå­ å¨å­ å­'.split('_'), i;

        for (i = 0; i < expected.length; i++) {
            assert.equal(moment([2011, 0, 2 + i]).format('dddd ddd dd'), expected[i], expected[i]);
        }
    });

    test('from', function (assert) {
        var start = moment([2007, 1, 28]);
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 44}), true),  'å ç§',   '44 seconds = a few seconds');
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 45}), true),  '1 åé', '45 seconds = a minute');
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 89}), true),  '1 åé', '89 seconds = a minute');
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 90}), true),  '2 åé',  '90 seconds = 2 minutes');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 44}), true),  '44 åé', '44 minutes = 44 minutes');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 45}), true),  '1 å°æ¶', '45 minutes = an hour');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 89}), true),  '1 å°æ¶', '89 minutes = an hour');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 90}), true),  '2 å°æ¶',  '90 minutes = 2 hours');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 5}), true),   '5 å°æ¶',  '5 hours = 5 hours');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 21}), true),  '21 å°æ¶', '21 hours = 21 hours');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 22}), true),  '1 å¤©',   '22 hours = a day');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 35}), true),  '1 å¤©',   '35 hours = a day');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 36}), true),  '2 å¤©',   '36 hours = 2 days');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 1}), true),   '1 å¤©',   '1 day = a day');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 5}), true),   '5 å¤©',   '5 days = 5 days');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 25}), true),  '25 å¤©',  '25 days = 25 days');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 26}), true),  '1 ä¸ªæ', '26 days = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 30}), true),  '1 ä¸ªæ', '30 days = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 43}), true),  '1 ä¸ªæ', '43 days = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 46}), true),  '2 ä¸ªæ',  '46 days = 2 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 74}), true),  '2 ä¸ªæ',  '75 days = 2 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 76}), true),  '3 ä¸ªæ',  '76 days = 3 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({M: 1}), true),   '1 ä¸ªæ', '1 month = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({M: 5}), true),   '5 ä¸ªæ',  '5 months = 5 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 345}), true), '1 å¹´',   '345 days = a year');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 548}), true), '2 å¹´',   '548 days = 2 years');
        assert.equal(start.from(moment([2007, 1, 28]).add({y: 1}), true),   '1 å¹´',   '1 year = a year');
        assert.equal(start.from(moment([2007, 1, 28]).add({y: 5}), true),   '5 å¹´',   '5 years = 5 years');
    });

    test('suffix', function (assert) {
        assert.equal(moment(30000).from(0), 'å ç§å',  'prefix');
        assert.equal(moment(0).from(30000), 'å ç§å', 'suffix');
    });

    test('now from now', function (assert) {
        assert.equal(moment().fromNow(), 'å ç§å',  'now from now should display as in the past');
    });

    test('fromNow', function (assert) {
        assert.equal(moment().add({s: 30}).fromNow(), 'å ç§å', 'in a few seconds');
        assert.equal(moment().add({d: 5}).fromNow(), '5 å¤©å', 'in 5 days');
    });

    test('calendar day', function (assert) {
        var a = moment().hours(12).minutes(0).seconds(0);

        assert.equal(moment(a).calendar(),                   'ä»å¤©ä¸­å12ç¹æ´',     'today at the same time');
        assert.equal(moment(a).add({m: 25}).calendar(),      'ä»å¤©ä¸­å12ç¹25å',   'Now plus 25 min');
        assert.equal(moment(a).add({h: 1}).calendar(),       'ä»å¤©ä¸å1ç¹æ´',      'Now plus 1 hour');
        assert.equal(moment(a).add({d: 1}).calendar(),       'æå¤©ä¸­å12ç¹æ´',     'tomorrow at the same time');
        assert.equal(moment(a).subtract({h: 1}).calendar(),  'ä»å¤©ä¸å11ç¹æ´',     'Now minus 1 hour');
        assert.equal(moment(a).subtract({d: 1}).calendar(),  'æ¨å¤©ä¸­å12ç¹æ´',     'yesterday at the same time');
    });

    test('calendar current week', function (assert) {
        var i, m,
            today = moment().startOf('day');

        for (i = 0; i < 7; i++) {
            m = moment().startOf('week').add({d: i});
            if (Math.abs(m.diff(today, 'days')) <= 1) {
                continue; // skip today, yesterday, tomorrow
            }
            assert.equal(m.calendar(),       m.format('[æ¬]dddåæ¨12ç¹æ´'),  'Monday + ' + i + ' days current time');
        }
    });

    test('calendar next week', function (assert) {
        var i, m,
            today = moment().startOf('day');

        for (i = 7; i < 14; i++) {
            m = moment().startOf('week').add({d: i});
            if (Math.abs(m.diff(today, 'days')) >= 7) {
                continue;
            }
            if (Math.abs(m.diff(today, 'days')) <= 1) {
                continue; // skip today, yesterday, tomorrow
            }
            assert.equal(m.calendar(),  m.format('[ä¸]dddåæ¨12ç¹æ´'), 'Today + ' + i + ' days beginning of day');
        }
        assert.equal(42, 42, 'at least one assert');
    });

    test('calendar last week', function (assert) {
        var i, m,
            today = moment().startOf('day');

        for (i = 1; i < 8; i++) {
            m = moment().startOf('week').subtract({d: i});
            if ((Math.abs(m.diff(today, 'days')) >= 7) || (Math.abs(m.diff(today, 'days')) <= 1)) {
                continue;
            }
            assert.equal(m.calendar(),  m.format('[ä¸]dddåæ¨12ç¹æ´'),  'Monday - ' + i + ' days next week');
        }
        assert.equal(42, 42, 'at least one assert');
    });

    test('calendar all else', function (assert) {
        var weeksAgo = moment().subtract({w: 1}),
            weeksFromNow = moment().add({w: 1});

        assert.equal(weeksAgo.calendar(),       weeksAgo.format('LL'),      '1 week ago');
        assert.equal(weeksFromNow.calendar(),   weeksFromNow.format('LL'),  'in 1 week');

        weeksAgo = moment().subtract({w: 2});
        weeksFromNow = moment().add({w: 2});

        assert.equal(weeksAgo.calendar(),       weeksAgo.format('LL'),      '2 weeks ago');
        assert.equal(weeksFromNow.calendar(),   weeksFromNow.format('LL'),  'in 2 weeks');
    });

    test('meridiem', function (assert) {
        assert.equal(moment([2011, 2, 23,  0, 0]).format('A'), 'åæ¨', 'before dawn');
        assert.equal(moment([2011, 2, 23,  6, 0]).format('A'), 'æ©ä¸', 'morning');
        assert.equal(moment([2011, 2, 23,  9, 0]).format('A'), 'ä¸å', 'before noon');
        assert.equal(moment([2011, 2, 23, 12, 0]).format('A'), 'ä¸­å', 'noon');
        assert.equal(moment([2011, 2, 23, 13, 0]).format('A'), 'ä¸å', 'afternoon');
        assert.equal(moment([2011, 2, 23, 18, 0]).format('A'), 'æä¸', 'night');
    });

    test('weeks year starting sunday format', function (assert) {
        assert.equal(moment([2012, 0,  1]).format('w ww wo'), '52 52 52å¨', 'Jan  1 2012 åºè¯¥æ¯ç¬¬52å¨');
        assert.equal(moment([2012, 0,  7]).format('w ww wo'), '1 01 1å¨', 'Jan  7 2012 åºè¯¥æ¯ç¬¬ 1å¨');
        assert.equal(moment([2012, 0, 14]).format('w ww wo'), '2 02 2å¨', 'Jan 14 2012 åºè¯¥æ¯ç¬¬ 2å¨');
    });

}));

;(function (global, factory) {
   typeof exports === 'object' && typeof module !== 'undefined'
       && typeof require === 'function' ? factory(require('../../moment')) :
   typeof define === 'function' && define.amd ? define(['../../moment'], factory) :
   factory(global.moment)
}(this, function (moment) { 'use strict';

    function each(array, callback) {
        var i;
        for (i = 0; i < array.length; i++) {
            callback(array[i], i, array);
        }
    }

    function objectKeys(obj) {
        if (Object.keys) {
            return Object.keys(obj);
        } else {
            // IE8
            var res = [], i;
            for (i in obj) {
                if (obj.hasOwnProperty(i)) {
                    res.push(i);
                }
            }
            return res;
        }
    }

    // Pick the first defined of two or three arguments.
    function defaults(a, b, c) {
        if (a != null) {
            return a;
        }
        if (b != null) {
            return b;
        }
        return c;
    }

    function defineCommonLocaleTests(locale, options) {
        test('lenient ordinal parsing', function (assert) {
            var i, ordinalStr, testMoment;
            for (i = 1; i <= 31; ++i) {
                ordinalStr = moment([2014, 0, i]).format('YYYY MM Do');
                testMoment = moment(ordinalStr, 'YYYY MM Do');
                assert.equal(testMoment.year(), 2014,
                        'lenient ordinal parsing ' + i + ' year check');
                assert.equal(testMoment.month(), 0,
                        'lenient ordinal parsing ' + i + ' month check');
                assert.equal(testMoment.date(), i,
                        'lenient ordinal parsing ' + i + ' date check');
            }
        });

        test('lenient ordinal parsing of number', function (assert) {
            var i, testMoment;
            for (i = 1; i <= 31; ++i) {
                testMoment = moment('2014 01 ' + i, 'YYYY MM Do');
                assert.equal(testMoment.year(), 2014,
                        'lenient ordinal parsing of number ' + i + ' year check');
                assert.equal(testMoment.month(), 0,
                        'lenient ordinal parsing of number ' + i + ' month check');
                assert.equal(testMoment.date(), i,
                        'lenient ordinal parsing of number ' + i + ' date check');
            }
        });

        test('strict ordinal parsing', function (assert) {
            var i, ordinalStr, testMoment;
            for (i = 1; i <= 31; ++i) {
                ordinalStr = moment([2014, 0, i]).format('YYYY MM Do');
                testMoment = moment(ordinalStr, 'YYYY MM Do', true);
                assert.ok(testMoment.isValid(), 'strict ordinal parsing ' + i);
            }
        });

        test('meridiem invariant', function (assert) {
            var h, m, t1, t2;
            for (h = 0; h < 24; ++h) {
                for (m = 0; m < 60; m += 15) {
                    t1 = moment.utc([2000, 0, 1, h, m]);
                    t2 = moment.utc(t1.format('A h:mm'), 'A h:mm');
                    assert.equal(t2.format('HH:mm'), t1.format('HH:mm'),
                            'meridiem at ' + t1.format('HH:mm'));
                }
            }
        });

        test('date format correctness', function (assert) {
            var data, tokens;
            data = moment.localeData()._longDateFormat;
            tokens = objectKeys(data);
            each(tokens, function (srchToken) {
                // Check each format string to make sure it does not contain any
                // tokens that need to be expanded.
                each(tokens, function (baseToken) {
                    // strip escaped sequences
                    var format = data[baseToken].replace(/(\[[^\]]*\])/g, '');
                    assert.equal(false, !!~format.indexOf(srchToken),
                            'contains ' + srchToken + ' in ' + baseToken);
                });
            });
        });

        test('month parsing correctness', function (assert) {
            var i, m;

            if (locale === 'tr') {
                // I can't fix it :(
                expect(0);
                return;
            }
            function tester(format) {
                var r;
                r = moment(m.format(format), format);
                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format);
                r = moment(m.format(format).toLocaleUpperCase(), format);
                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' upper');
                r = moment(m.format(format).toLocaleLowerCase(), format);
                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' lower');

                r = moment(m.format(format), format, true);
                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' strict');
                r = moment(m.format(format).toLocaleUpperCase(), format, true);
                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' upper strict');
                r = moment(m.format(format).toLocaleLowerCase(), format, true);
                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' lower strict');
            }

            for (i = 0; i < 12; ++i) {
                m = moment([2015, i, 15, 18]);
                tester('MMM');
                tester('MMM.');
                tester('MMMM');
                tester('MMMM.');
            }
        });

        test('weekday parsing correctness', function (assert) {
            var i, m;

            if (locale === 'tr' || locale === 'az') {
                // There is a lower-case letter (Ä±), that converted to upper then
                // lower changes to i
                expect(0);
                return;
            }
            function tester(format) {
                var r, baseMsg = 'weekday ' + m.weekday() + ' fmt ' + format;
                r = moment(m.format(format), format);
                assert.equal(r.weekday(), m.weekday(), baseMsg);
                r = moment(m.format(format).toLocaleUpperCase(), format);
                assert.equal(r.weekday(), m.weekday(), baseMsg + ' upper');
                r = moment(m.format(format).toLocaleLowerCase(), format);
                assert.equal(r.weekday(), m.weekday(), baseMsg + ' lower');

                r = moment(m.format(format), format, true);
                assert.equal(r.weekday(), m.weekday(), baseMsg + ' strict');
                r = moment(m.format(format).toLocaleUpperCase(), format, true);
                assert.equal(r.weekday(), m.weekday(), baseMsg + ' upper strict');
                r = moment(m.format(format).toLocaleLowerCase(), format, true);
                assert.equal(r.weekday(), m.weekday(), baseMsg + ' lower strict');
            }

            for (i = 0; i < 7; ++i) {
                m = moment.utc([2015, i, 15, 18]);
                tester('dd');
                tester('ddd');
                tester('dddd');
            }
        });
    }

    function setupDeprecationHandler(test, moment, scope) {
        test._expectedDeprecations = null;
        test._observedDeprecations = null;
        test._oldSupress = moment.suppressDeprecationWarnings;
        moment.suppressDeprecationWarnings = true;
        test.expectedDeprecations = function () {
            test._expectedDeprecations = arguments;
            test._observedDeprecations = [];
        };
        moment.deprecationHandler = function (name, msg) {
            var deprecationId = matchedDeprecation(name, msg, test._expectedDeprecations);
            if (deprecationId === -1) {
                throw new Error('Unexpected deprecation thrown name=' +
                        name + ' msg=' + msg);
            }
            test._observedDeprecations[deprecationId] = 1;
        };
    }

    function teardownDeprecationHandler(test, moment, scope) {
        moment.suppressDeprecationWarnings = test._oldSupress;

        if (test._expectedDeprecations != null) {
            var missedDeprecations = [];
            each(test._expectedDeprecations, function (deprecationPattern, id) {
                if (test._observedDeprecations[id] !== 1) {
                    missedDeprecations.push(deprecationPattern);
                }
            });
            if (missedDeprecations.length !== 0) {
                throw new Error('Expected deprecation warnings did not happen: ' +
                        missedDeprecations.join(' '));
            }
        }
    }

    function matchedDeprecation(name, msg, deprecations) {
        if (deprecations == null) {
            return -1;
        }
        for (var i = 0; i < deprecations.length; ++i) {
            if (name != null && name === deprecations[i]) {
                return i;
            }
            if (msg != null && msg.substring(0, deprecations[i].length) === deprecations[i]) {
                return i;
            }
        }
        return -1;
    }

    /*global QUnit:false*/

    var test = QUnit.test;

    var expect = QUnit.expect;

    function module (name, lifecycle) {
        QUnit.module(name, {
            setup : function () {
                moment.locale('en');
                moment.createFromInputFallback = function (config) {
                    throw new Error('input not handled by moment: ' + config._i);
                };
                setupDeprecationHandler(test, moment, 'core');
                if (lifecycle && lifecycle.setup) {
                    lifecycle.setup();
                }
            },
            teardown : function () {
                teardownDeprecationHandler(test, moment, 'core');
                if (lifecycle && lifecycle.teardown) {
                    lifecycle.teardown();
                }
            }
        });
    }

    function localeModule (name, lifecycle) {
        QUnit.module('locale:' + name, {
            setup : function () {
                moment.locale(name);
                moment.createFromInputFallback = function (config) {
                    throw new Error('input not handled by moment: ' + config._i);
                };
                setupDeprecationHandler(test, moment, 'locale');
                if (lifecycle && lifecycle.setup) {
                    lifecycle.setup();
                }
            },
            teardown : function () {
                moment.locale('en');
                teardownDeprecationHandler(test, moment, 'locale');
                if (lifecycle && lifecycle.teardown) {
                    lifecycle.teardown();
                }
            }
        });
        defineCommonLocaleTests(name, -1, -1);
    }

    localeModule('zh-tw');

    test('parse', function (assert) {
        var tests = 'ä¸æ 1æ_äºæ 2æ_ä¸æ 3æ_åæ 4æ_äºæ 5æ_å­æ 6æ_ä¸æ 7æ_å«æ 8æ_ä¹æ 9æ_åæ 10æ_åä¸æ 11æ_åäºæ 12æ'.split('_'), i;
        function equalTest(input, mmm, i) {
            assert.equal(moment(input, mmm).month(), i, input + ' should be month ' + (i + 1));
        }
        for (i = 0; i < 12; i++) {
            tests[i] = tests[i].split(' ');
            equalTest(tests[i][0], 'MMM', i);
            equalTest(tests[i][1], 'MMM', i);
            equalTest(tests[i][0], 'MMMM', i);
            equalTest(tests[i][1], 'MMMM', i);
            equalTest(tests[i][0].toLocaleLowerCase(), 'MMMM', i);
            equalTest(tests[i][1].toLocaleLowerCase(), 'MMMM', i);
            equalTest(tests[i][0].toLocaleUpperCase(), 'MMMM', i);
            equalTest(tests[i][1].toLocaleUpperCase(), 'MMMM', i);
        }
    });

    test('format', function (assert) {
        var a = [
                ['dddd, MMMM Do YYYY, a h:mm:ss',      'æææ¥, äºæ 14æ¥ 2010, ä¸å 3:25:50'],
                ['ddd, Ah',                            'é±æ¥, ä¸å3'],
                ['M Mo MM MMMM MMM',                   '2 2æ 02 äºæ 2æ'],
                ['YYYY YY',                            '2010 10'],
                ['D Do DD',                            '14 14æ¥ 14'],
                ['d do dddd ddd dd',                   '0 0æ¥ æææ¥ é±æ¥ æ¥'],
                ['DDD DDDo DDDD',                      '45 45æ¥ 045'],
                ['w wo ww',                            '8 8é± 08'],
                ['h hh',                               '3 03'],
                ['H HH',                               '15 15'],
                ['m mm',                               '25 25'],
                ['s ss',                               '50 50'],
                ['a A',                                'ä¸å ä¸å'],
                ['[éå¹´çç¬¬] DDDo',                    'éå¹´çç¬¬ 45æ¥'],
                ['LTS',                                'ä¸å3é»25å50ç§'],
                ['L',                                  '2010å¹´2æ14æ¥'],
                ['LL',                                 '2010å¹´2æ14æ¥'],
                ['LLL',                                '2010å¹´2æ14æ¥ä¸å3é»25å'],
                ['LLLL',                               '2010å¹´2æ14æ¥æææ¥ä¸å3é»25å'],
                ['l',                                  '2010å¹´2æ14æ¥'],
                ['ll',                                 '2010å¹´2æ14æ¥'],
                ['lll',                                '2010å¹´2æ14æ¥ä¸å3é»25å'],
                ['llll',                               '2010å¹´2æ14æ¥æææ¥ä¸å3é»25å']
            ],
            b = moment(new Date(2010, 1, 14, 15, 25, 50, 125)),
            i;

        for (i = 0; i < a.length; i++) {
            assert.equal(b.format(a[i][0]), a[i][1], a[i][0] + ' ---> ' + a[i][1]);
        }
    });

    test('format month', function (assert) {
        var expected = 'ä¸æ 1æ_äºæ 2æ_ä¸æ 3æ_åæ 4æ_äºæ 5æ_å­æ 6æ_ä¸æ 7æ_å«æ 8æ_ä¹æ 9æ_åæ 10æ_åä¸æ 11æ_åäºæ 12æ'.split('_'), i;

        for (i = 0; i < expected.length; i++) {
            assert.equal(moment([2011, i, 1]).format('MMMM MMM'), expected[i], expected[i]);
        }
    });

    test('format week', function (assert) {
        var expected = 'æææ¥ é±æ¥ æ¥_ææä¸ é±ä¸ ä¸_ææäº é±äº äº_ææä¸ é±ä¸ ä¸_ææå é±å å_ææäº é±äº äº_ææå­ é±å­ å­'.split('_'), i;

        for (i = 0; i < expected.length; i++) {
            assert.equal(moment([2011, 0, 2 + i]).format('dddd ddd dd'), expected[i], expected[i]);
        }
    });

    test('from', function (assert) {
        var start = moment([2007, 1, 28]);
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 44}), true),  'å¹¾ç§',   '44 seconds = a few seconds');
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 45}), true),  '1åé', '45 seconds = a minute');
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 89}), true),  '1åé', '89 seconds = a minute');
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 90}), true),  '2åé',  '90 seconds = 2 minutes');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 44}), true),  '44åé', '44 minutes = 44 minutes');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 45}), true),  '1å°æ', '45 minutes = an hour');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 89}), true),  '1å°æ', '89 minutes = an hour');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 90}), true),  '2å°æ',  '90 minutes = 2 hours');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 5}), true),   '5å°æ',  '5 hours = 5 hours');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 21}), true),  '21å°æ', '21 hours = 21 hours');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 22}), true),  '1å¤©',   '22 hours = a day');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 35}), true),  '1å¤©',   '35 hours = a day');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 36}), true),  '2å¤©',   '36 hours = 2 days');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 1}), true),   '1å¤©',   '1 day = a day');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 5}), true),   '5å¤©',   '5 days = 5 days');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 25}), true),  '25å¤©',  '25 days = 25 days');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 26}), true),  '1åæ', '26 days = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 30}), true),  '1åæ', '30 days = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 43}), true),  '1åæ', '43 days = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 46}), true),  '2åæ',  '46 days = 2 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 74}), true),  '2åæ',  '75 days = 2 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 76}), true),  '3åæ',  '76 days = 3 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({M: 1}), true),   '1åæ', '1 month = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({M: 5}), true),   '5åæ',  '5 months = 5 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 345}), true), '1å¹´',   '345 days = a year');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 548}), true), '2å¹´',   '548 days = 2 years');
        assert.equal(start.from(moment([2007, 1, 28]).add({y: 1}), true),   '1å¹´',   '1 year = a year');
        assert.equal(start.from(moment([2007, 1, 28]).add({y: 5}), true),   '5å¹´',   '5 years = 5 years');
    });

    test('suffix', function (assert) {
        assert.equal(moment(30000).from(0), 'å¹¾ç§å§',  'prefix');
        assert.equal(moment(0).from(30000), 'å¹¾ç§å', 'suffix');
    });

    test('now from now', function (assert) {
        assert.equal(moment().fromNow(), 'å¹¾ç§å',  'now from now should display as in the past');
    });

    test('fromNow', function (assert) {
        assert.equal(moment().add({s: 30}).fromNow(), 'å¹¾ç§å§', 'in a few seconds');
        assert.equal(moment().add({d: 5}).fromNow(), '5å¤©å§', 'in 5 days');
    });

    test('calendar day', function (assert) {
        var a = moment().hours(12).minutes(0).seconds(0);

        assert.equal(moment(a).calendar(),                   'ä»å¤©ä¸­å12é»00å',     'today at the same time');
        assert.equal(moment(a).add({m: 25}).calendar(),      'ä»å¤©ä¸­å12é»25å',     'Now plus 25 min');
        assert.equal(moment(a).add({h: 1}).calendar(),       'ä»å¤©ä¸å1é»00å',     'Now plus 1 hour');
        assert.equal(moment(a).add({d: 1}).calendar(),       'æå¤©ä¸­å12é»00å',     'tomorrow at the same time');
        assert.equal(moment(a).subtract({h: 1}).calendar(),  'ä»å¤©ä¸å11é»00å',     'Now minus 1 hour');
        assert.equal(moment(a).subtract({d: 1}).calendar(),  'æ¨å¤©ä¸­å12é»00å',     'yesterday at the same time');
    });

    test('calendar next week', function (assert) {
        var i, m;
        for (i = 2; i < 7; i++) {
            m = moment().add({d: i});
            assert.equal(m.calendar(),       m.format('[ä¸]ddddLT'),  'Today + ' + i + ' days current time');
            m.hours(0).minutes(0).seconds(0).milliseconds(0);
            assert.equal(m.calendar(),       m.format('[ä¸]ddddLT'),  'Today + ' + i + ' days beginning of day');
            m.hours(23).minutes(59).seconds(59).milliseconds(999);
            assert.equal(m.calendar(),       m.format('[ä¸]ddddLT'),  'Today + ' + i + ' days end of day');
        }
    });

    test('calendar last week', function (assert) {
        var i, m;
        for (i = 2; i < 7; i++) {
            m = moment().subtract({d: i});
            assert.equal(m.calendar(),       m.format('[ä¸]ddddLT'),  'Today - ' + i + ' days current time');
            m.hours(0).minutes(0).seconds(0).milliseconds(0);
            assert.equal(m.calendar(),       m.format('[ä¸]ddddLT'),  'Today - ' + i + ' days beginning of day');
            m.hours(23).minutes(59).seconds(59).milliseconds(999);
            assert.equal(m.calendar(),       m.format('[ä¸]ddddLT'),  'Today - ' + i + ' days end of day');
        }
    });

    test('calendar all else', function (assert) {
        var weeksAgo = moment().subtract({w: 1}),
            weeksFromNow = moment().add({w: 1});

        assert.equal(weeksAgo.calendar(),       weeksAgo.format('L'),      '1 week ago');
        assert.equal(weeksFromNow.calendar(),   weeksFromNow.format('L'),  'in 1 week');

        weeksAgo = moment().subtract({w: 2});
        weeksFromNow = moment().add({w: 2});

        assert.equal(weeksAgo.calendar(),       weeksAgo.format('L'),      '2 weeks ago');
        assert.equal(weeksFromNow.calendar(),   weeksFromNow.format('L'),  'in 2 weeks');
    });

    test('meridiem', function (assert) {
        assert.equal(moment([2011, 2, 23,  0, 0]).format('a'), 'æ©ä¸', 'morning');
        assert.equal(moment([2011, 2, 23,  9, 0]).format('a'), 'ä¸å', 'before noon');
        assert.equal(moment([2011, 2, 23, 12, 0]).format('a'), 'ä¸­å', 'noon');
        assert.equal(moment([2011, 2, 23, 13, 0]).format('a'), 'ä¸å', 'after noon');
        assert.equal(moment([2011, 2, 23, 18, 0]).format('a'), 'æä¸', 'night');

        assert.equal(moment([2011, 2, 23,  0, 0]).format('A'), 'æ©ä¸', 'morning');
        assert.equal(moment([2011, 2, 23,  9, 0]).format('A'), 'ä¸å', 'before noon');
        assert.equal(moment([2011, 2, 23, 12, 0]).format('A'), 'ä¸­å', 'noon');
        assert.equal(moment([2011, 2, 23, 13, 0]).format('A'), 'ä¸å', 'afternoon');
        assert.equal(moment([2011, 2, 23, 18, 0]).format('A'), 'æä¸', 'night');
    });

    test('weeks year starting sunday format', function (assert) {
        assert.equal(moment([2012, 0,  1]).format('w ww wo'), '1 01 1é±', 'Jan  1 2012 æè©²æ¯ç¬¬ 1é±');
        assert.equal(moment([2012, 0,  7]).format('w ww wo'), '1 01 1é±', 'Jan  7 2012 æè©²æ¯ç¬¬ 1é±');
        assert.equal(moment([2012, 0,  8]).format('w ww wo'), '2 02 2é±', 'Jan  8 2012 æè©²æ¯ç¬¬ 2é±');
        assert.equal(moment([2012, 0, 14]).format('w ww wo'), '2 02 2é±', 'Jan 14 2012 æè©²æ¯ç¬¬ 2é±');
        assert.equal(moment([2012, 0, 15]).format('w ww wo'), '3 03 3é±', 'Jan 15 2012 æè©²æ¯ç¬¬ 3é±');
    });

}));

;(function (global, factory) {
   typeof exports === 'object' && typeof module !== 'undefined'
       && typeof require === 'function' ? factory(require('../../moment')) :
   typeof define === 'function' && define.amd ? define(['../../moment'], factory) :
   factory(global.moment)
}(this, function (moment) { 'use strict';

    function each(array, callback) {
        var i;
        for (i = 0; i < array.length; i++) {
            callback(array[i], i, array);
        }
    }

    function objectKeys(obj) {
        if (Object.keys) {
            return Object.keys(obj);
        } else {
            // IE8
            var res = [], i;
            for (i in obj) {
                if (obj.hasOwnProperty(i)) {
                    res.push(i);
                }
            }
            return res;
        }
    }

    // Pick the first defined of two or three arguments.
    function defaults(a, b, c) {
        if (a != null) {
            return a;
        }
        if (b != null) {
            return b;
        }
        return c;
    }

    function defineCommonLocaleTests(locale, options) {
        test('lenient ordinal parsing', function (assert) {
            var i, ordinalStr, testMoment;
            for (i = 1; i <= 31; ++i) {
                ordinalStr = moment([2014, 0, i]).format('YYYY MM Do');
                testMoment = moment(ordinalStr, 'YYYY MM Do');
                assert.equal(testMoment.year(), 2014,
                        'lenient ordinal parsing ' + i + ' year check');
                assert.equal(testMoment.month(), 0,
                        'lenient ordinal parsing ' + i + ' month check');
                assert.equal(testMoment.date(), i,
                        'lenient ordinal parsing ' + i + ' date check');
            }
        });

        test('lenient ordinal parsing of number', function (assert) {
            var i, testMoment;
            for (i = 1; i <= 31; ++i) {
                testMoment = moment('2014 01 ' + i, 'YYYY MM Do');
                assert.equal(testMoment.year(), 2014,
                        'lenient ordinal parsing of number ' + i + ' year check');
                assert.equal(testMoment.month(), 0,
                        'lenient ordinal parsing of number ' + i + ' month check');
                assert.equal(testMoment.date(), i,
                        'lenient ordinal parsing of number ' + i + ' date check');
            }
        });

        test('strict ordinal parsing', function (assert) {
            var i, ordinalStr, testMoment;
            for (i = 1; i <= 31; ++i) {
                ordinalStr = moment([2014, 0, i]).format('YYYY MM Do');
                testMoment = moment(ordinalStr, 'YYYY MM Do', true);
                assert.ok(testMoment.isValid(), 'strict ordinal parsing ' + i);
            }
        });

        test('meridiem invariant', function (assert) {
            var h, m, t1, t2;
            for (h = 0; h < 24; ++h) {
                for (m = 0; m < 60; m += 15) {
                    t1 = moment.utc([2000, 0, 1, h, m]);
                    t2 = moment.utc(t1.format('A h:mm'), 'A h:mm');
                    assert.equal(t2.format('HH:mm'), t1.format('HH:mm'),
                            'meridiem at ' + t1.format('HH:mm'));
                }
            }
        });

        test('date format correctness', function (assert) {
            var data, tokens;
            data = moment.localeData()._longDateFormat;
            tokens = objectKeys(data);
            each(tokens, function (srchToken) {
                // Check each format string to make sure it does not contain any
                // tokens that need to be expanded.
                each(tokens, function (baseToken) {
                    // strip escaped sequences
                    var format = data[baseToken].replace(/(\[[^\]]*\])/g, '');
                    assert.equal(false, !!~format.indexOf(srchToken),
                            'contains ' + srchToken + ' in ' + baseToken);
                });
            });
        });

        test('month parsing correctness', function (assert) {
            var i, m;

            if (locale === 'tr') {
                // I can't fix it :(
                expect(0);
                return;
            }
            function tester(format) {
                var r;
                r = moment(m.format(format), format);
                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format);
                r = moment(m.format(format).toLocaleUpperCase(), format);
                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' upper');
                r = moment(m.format(format).toLocaleLowerCase(), format);
                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' lower');

                r = moment(m.format(format), format, true);
                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' strict');
                r = moment(m.format(format).toLocaleUpperCase(), format, true);
                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' upper strict');
                r = moment(m.format(format).toLocaleLowerCase(), format, true);
                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' lower strict');
            }

            for (i = 0; i < 12; ++i) {
                m = moment([2015, i, 15, 18]);
                tester('MMM');
                tester('MMM.');
                tester('MMMM');
                tester('MMMM.');
            }
        });

        test('weekday parsing correctness', function (assert) {
            var i, m;

            if (locale === 'tr' || locale === 'az') {
                // There is a lower-case letter (Ä±), that converted to upper then
                // lower changes to i
                expect(0);
                return;
            }
            function tester(format) {
                var r, baseMsg = 'weekday ' + m.weekday() + ' fmt ' + format;
                r = moment(m.format(format), format);
                assert.equal(r.weekday(), m.weekday(), baseMsg);
                r = moment(m.format(format).toLocaleUpperCase(), format);
                assert.equal(r.weekday(), m.weekday(), baseMsg + ' upper');
                r = moment(m.format(format).toLocaleLowerCase(), format);
                assert.equal(r.weekday(), m.weekday(), baseMsg + ' lower');

                r = moment(m.format(format), format, true);
                assert.equal(r.weekday(), m.weekday(), baseMsg + ' strict');
                r = moment(m.format(format).toLocaleUpperCase(), format, true);
                assert.equal(r.weekday(), m.weekday(), baseMsg + ' upper strict');
                r = moment(m.format(format).toLocaleLowerCase(), format, true);
                assert.equal(r.weekday(), m.weekday(), baseMsg + ' lower strict');
            }

            for (i = 0; i < 7; ++i) {
                m = moment.utc([2015, i, 15, 18]);
                tester('dd');
                tester('ddd');
                tester('dddd');
            }
        });
    }

    function setupDeprecationHandler(test, moment, scope) {
        test._expectedDeprecations = null;
        test._observedDeprecations = null;
        test._oldSupress = moment.suppressDeprecationWarnings;
        moment.suppressDeprecationWarnings = true;
        test.expectedDeprecations = function () {
            test._expectedDeprecations = arguments;
            test._observedDeprecations = [];
        };
        moment.deprecationHandler = function (name, msg) {
            var deprecationId = matchedDeprecation(name, msg, test._expectedDeprecations);
            if (deprecationId === -1) {
                throw new Error('Unexpected deprecation thrown name=' +
                        name + ' msg=' + msg);
            }
            test._observedDeprecations[deprecationId] = 1;
        };
    }

    function teardownDeprecationHandler(test, moment, scope) {
        moment.suppressDeprecationWarnings = test._oldSupress;

        if (test._expectedDeprecations != null) {
            var missedDeprecations = [];
            each(test._expectedDeprecations, function (deprecationPattern, id) {
                if (test._observedDeprecations[id] !== 1) {
                    missedDeprecations.push(deprecationPattern);
                }
            });
            if (missedDeprecations.length !== 0) {
                throw new Error('Expected deprecation warnings did not happen: ' +
                        missedDeprecations.join(' '));
            }
        }
    }

    function matchedDeprecation(name, msg, deprecations) {
        if (deprecations == null) {
            return -1;
        }
        for (var i = 0; i < deprecations.length; ++i) {
            if (name != null && name === deprecations[i]) {
                return i;
            }
            if (msg != null && msg.substring(0, deprecations[i].length) === deprecations[i]) {
                return i;
            }
        }
        return -1;
    }

    /*global QUnit:false*/

    var test = QUnit.test;

    var expect = QUnit.expect;

    function module (name, lifecycle) {
        QUnit.module(name, {
            setup : function () {
                moment.locale('en');
                moment.createFromInputFallback = function (config) {
                    throw new Error('input not handled by moment: ' + config._i);
                };
                setupDeprecationHandler(test, moment, 'core');
                if (lifecycle && lifecycle.setup) {
                    lifecycle.setup();
                }
            },
            teardown : function () {
                teardownDeprecationHandler(test, moment, 'core');
                if (lifecycle && lifecycle.teardown) {
                    lifecycle.teardown();
                }
            }
        });
    }

    function localeModule (name, lifecycle) {
        QUnit.module('locale:' + name, {
            setup : function () {
                moment.locale(name);
                moment.createFromInputFallback = function (config) {
                    throw new Error('input not handled by moment: ' + config._i);
                };
                setupDeprecationHandler(test, moment, 'locale');
                if (lifecycle && lifecycle.setup) {
                    lifecycle.setup();
                }
            },
            teardown : function () {
                moment.locale('en');
                teardownDeprecationHandler(test, moment, 'locale');
                if (lifecycle && lifecycle.teardown) {
                    lifecycle.teardown();
                }
            }
        });
        defineCommonLocaleTests(name, -1, -1);
    }

    module('add and subtract');

    test('add short reverse args', function (assert) {
        var a = moment(), b, c, d;
        a.year(2011);
        a.month(9);
        a.date(12);
        a.hours(6);
        a.minutes(7);
        a.seconds(8);
        a.milliseconds(500);

        assert.equal(a.add({ms: 50}).milliseconds(), 550, 'Add milliseconds');
        assert.equal(a.add({s: 1}).seconds(), 9, 'Add seconds');
        assert.equal(a.add({m: 1}).minutes(), 8, 'Add minutes');
        assert.equal(a.add({h: 1}).hours(), 7, 'Add hours');
        assert.equal(a.add({d: 1}).date(), 13, 'Add date');
        assert.equal(a.add({w: 1}).date(), 20, 'Add week');
        assert.equal(a.add({M: 1}).month(), 10, 'Add month');
        assert.equal(a.add({y: 1}).year(), 2012, 'Add year');
        assert.equal(a.add({Q: 1}).month(), 1, 'Add quarter');

        b = moment([2010, 0, 31]).add({M: 1});
        c = moment([2010, 1, 28]).subtract({M: 1});
        d = moment([2010, 1, 28]).subtract({Q: 1});

        assert.equal(b.month(), 1, 'add month, jan 31st to feb 28th');
        assert.equal(b.date(), 28, 'add month, jan 31st to feb 28th');
        assert.equal(c.month(), 0, 'subtract month, feb 28th to jan 28th');
        assert.equal(c.date(), 28, 'subtract month, feb 28th to jan 28th');
        assert.equal(d.month(), 10, 'subtract quarter, feb 28th 2010 to nov 28th 2009');
        assert.equal(d.date(), 28, 'subtract quarter, feb 28th 2010 to nov 28th 2009');
        assert.equal(d.year(), 2009, 'subtract quarter, feb 28th 2010 to nov 28th 2009');
    });

    test('add long reverse args', function (assert) {
        var a = moment();
        a.year(2011);
        a.month(9);
        a.date(12);
        a.hours(6);
        a.minutes(7);
        a.seconds(8);
        a.milliseconds(500);

        assert.equal(a.add({milliseconds: 50}).milliseconds(), 550, 'Add milliseconds');
        assert.equal(a.add({seconds: 1}).seconds(), 9, 'Add seconds');
        assert.equal(a.add({minutes: 1}).minutes(), 8, 'Add minutes');
        assert.equal(a.add({hours: 1}).hours(), 7, 'Add hours');
        assert.equal(a.add({days: 1}).date(), 13, 'Add date');
        assert.equal(a.add({weeks: 1}).date(), 20, 'Add week');
        assert.equal(a.add({months: 1}).month(), 10, 'Add month');
        assert.equal(a.add({years: 1}).year(), 2012, 'Add year');
        assert.equal(a.add({quarters: 1}).month(), 1, 'Add quarter');
    });

    test('add long singular reverse args', function (assert) {
        var a = moment();
        a.year(2011);
        a.month(9);
        a.date(12);
        a.hours(6);
        a.minutes(7);
        a.seconds(8);
        a.milliseconds(500);

        assert.equal(a.add({millisecond: 50}).milliseconds(), 550, 'Add milliseconds');
        assert.equal(a.add({second: 1}).seconds(), 9, 'Add seconds');
        assert.equal(a.add({minute: 1}).minutes(), 8, 'Add minutes');
        assert.equal(a.add({hour: 1}).hours(), 7, 'Add hours');
        assert.equal(a.add({day: 1}).date(), 13, 'Add date');
        assert.equal(a.add({week: 1}).date(), 20, 'Add week');
        assert.equal(a.add({month: 1}).month(), 10, 'Add month');
        assert.equal(a.add({year: 1}).year(), 2012, 'Add year');
        assert.equal(a.add({quarter: 1}).month(), 1, 'Add quarter');
    });

    test('add string long reverse args', function (assert) {
        var a = moment(), b;

        test.expectedDeprecations('moment().add(period, number)');

        a.year(2011);
        a.month(9);
        a.date(12);
        a.hours(6);
        a.minutes(7);
        a.seconds(8);
        a.milliseconds(500);

        b = a.clone();

        assert.equal(a.add('millisecond', 50).milliseconds(), 550, 'Add milliseconds');
        assert.equal(a.add('second', 1).seconds(), 9, 'Add seconds');
        assert.equal(a.add('minute', 1).minutes(), 8, 'Add minutes');
        assert.equal(a.add('hour', 1).hours(), 7, 'Add hours');
        assert.equal(a.add('day', 1).date(), 13, 'Add date');
        assert.equal(a.add('week', 1).date(), 20, 'Add week');
        assert.equal(a.add('month', 1).month(), 10, 'Add month');
        assert.equal(a.add('year', 1).year(), 2012, 'Add year');
        assert.equal(b.add('day', '01').date(), 13, 'Add date');
        assert.equal(a.add('quarter', 1).month(), 1, 'Add quarter');
    });

    test('add string long singular reverse args', function (assert) {
        var a = moment(), b;

        test.expectedDeprecations('moment().add(period, number)');

        a.year(2011);
        a.month(9);
        a.date(12);
        a.hours(6);
        a.minutes(7);
        a.seconds(8);
        a.milliseconds(500);

        b = a.clone();

        assert.equal(a.add('milliseconds', 50).milliseconds(), 550, 'Add milliseconds');
        assert.equal(a.add('seconds', 1).seconds(), 9, 'Add seconds');
        assert.equal(a.add('minutes', 1).minutes(), 8, 'Add minutes');
        assert.equal(a.add('hours', 1).hours(), 7, 'Add hours');
        assert.equal(a.add('days', 1).date(), 13, 'Add date');
        assert.equal(a.add('weeks', 1).date(), 20, 'Add week');
        assert.equal(a.add('months', 1).month(), 10, 'Add month');
        assert.equal(a.add('years', 1).year(), 2012, 'Add year');
        assert.equal(b.add('days', '01').date(), 13, 'Add date');
        assert.equal(a.add('quarters', 1).month(), 1, 'Add quarter');
    });

    test('add string short reverse args', function (assert) {
        var a = moment();
        test.expectedDeprecations('moment().add(period, number)');

        a.year(2011);
        a.month(9);
        a.date(12);
        a.hours(6);
        a.minutes(7);
        a.seconds(8);
        a.milliseconds(500);

        assert.equal(a.add('ms', 50).milliseconds(), 550, 'Add milliseconds');
        assert.equal(a.add('s', 1).seconds(), 9, 'Add seconds');
        assert.equal(a.add('m', 1).minutes(), 8, 'Add minutes');
        assert.equal(a.add('h', 1).hours(), 7, 'Add hours');
        assert.equal(a.add('d', 1).date(), 13, 'Add date');
        assert.equal(a.add('w', 1).date(), 20, 'Add week');
        assert.equal(a.add('M', 1).month(), 10, 'Add month');
        assert.equal(a.add('y', 1).year(), 2012, 'Add year');
        assert.equal(a.add('Q', 1).month(), 1, 'Add quarter');
    });

    test('add string long', function (assert) {
        var a = moment();
        a.year(2011);
        a.month(9);
        a.date(12);
        a.hours(6);
        a.minutes(7);
        a.seconds(8);
        a.milliseconds(500);

        assert.equal(a.add(50, 'millisecond').milliseconds(), 550, 'Add milliseconds');
        assert.equal(a.add(1, 'second').seconds(), 9, 'Add seconds');
        assert.equal(a.add(1, 'minute').minutes(), 8, 'Add minutes');
        assert.equal(a.add(1, 'hour').hours(), 7, 'Add hours');
        assert.equal(a.add(1, 'day').date(), 13, 'Add date');
        assert.equal(a.add(1, 'week').date(), 20, 'Add week');
        assert.equal(a.add(1, 'month').month(), 10, 'Add month');
        assert.equal(a.add(1, 'year').year(), 2012, 'Add year');
        assert.equal(a.add(1, 'quarter').month(), 1, 'Add quarter');
    });

    test('add string long singular', function (assert) {
        var a = moment();
        a.year(2011);
        a.month(9);
        a.date(12);
        a.hours(6);
        a.minutes(7);
        a.seconds(8);
        a.milliseconds(500);

        assert.equal(a.add(50, 'milliseconds').milliseconds(), 550, 'Add milliseconds');
        assert.equal(a.add(1, 'seconds').seconds(), 9, 'Add seconds');
        assert.equal(a.add(1, 'minutes').minutes(), 8, 'Add minutes');
        assert.equal(a.add(1, 'hours').hours(), 7, 'Add hours');
        assert.equal(a.add(1, 'days').date(), 13, 'Add date');
        assert.equal(a.add(1, 'weeks').date(), 20, 'Add week');
        assert.equal(a.add(1, 'months').month(), 10, 'Add month');
        assert.equal(a.add(1, 'years').year(), 2012, 'Add year');
        assert.equal(a.add(1, 'quarters').month(), 1, 'Add quarter');
    });

    test('add string short', function (assert) {
        var a = moment();
        a.year(2011);
        a.month(9);
        a.date(12);
        a.hours(6);
        a.minutes(7);
        a.seconds(8);
        a.milliseconds(500);

        assert.equal(a.add(50, 'ms').milliseconds(), 550, 'Add milliseconds');
        assert.equal(a.add(1, 's').seconds(), 9, 'Add seconds');
        assert.equal(a.add(1, 'm').minutes(), 8, 'Add minutes');
        assert.equal(a.add(1, 'h').hours(), 7, 'Add hours');
        assert.equal(a.add(1, 'd').date(), 13, 'Add date');
        assert.equal(a.add(1, 'w').date(), 20, 'Add week');
        assert.equal(a.add(1, 'M').month(), 10, 'Add month');
        assert.equal(a.add(1, 'y').year(), 2012, 'Add year');
        assert.equal(a.add(1, 'Q').month(), 1, 'Add quarter');
    });

    test('add strings string short reversed', function (assert) {
        var a = moment();
        test.expectedDeprecations('moment().add(period, number)');

        a.year(2011);
        a.month(9);
        a.date(12);
        a.hours(6);
        a.minutes(7);
        a.seconds(8);
        a.milliseconds(500);

        assert.equal(a.add('ms', '50').milliseconds(), 550, 'Add milliseconds');
        assert.equal(a.add('s', '1').seconds(), 9, 'Add seconds');
        assert.equal(a.add('m', '1').minutes(), 8, 'Add minutes');
        assert.equal(a.add('h', '1').hours(), 7, 'Add hours');
        assert.equal(a.add('d', '1').date(), 13, 'Add date');
        assert.equal(a.add('w', '1').date(), 20, 'Add week');
        assert.equal(a.add('M', '1').month(), 10, 'Add month');
        assert.equal(a.add('y', '1').year(), 2012, 'Add year');
        assert.equal(a.add('Q', '1').month(), 1, 'Add quarter');
    });

    test('subtract strings string short reversed', function (assert) {
        var a = moment();
        test.expectedDeprecations('moment().subtract(period, number)');

        a.year(2011);
        a.month(9);
        a.date(12);
        a.hours(6);
        a.minutes(7);
        a.seconds(8);
        a.milliseconds(500);

        assert.equal(a.subtract('ms', '50').milliseconds(), 450, 'Subtract milliseconds');
        assert.equal(a.subtract('s', '1').seconds(), 7, 'Subtract seconds');
        assert.equal(a.subtract('m', '1').minutes(), 6, 'Subtract minutes');
        assert.equal(a.subtract('h', '1').hours(), 5, 'Subtract hours');
        assert.equal(a.subtract('d', '1').date(), 11, 'Subtract date');
        assert.equal(a.subtract('w', '1').date(), 4, 'Subtract week');
        assert.equal(a.subtract('M', '1').month(), 8, 'Subtract month');
        assert.equal(a.subtract('y', '1').year(), 2010, 'Subtract year');
        assert.equal(a.subtract('Q', '1').month(), 5, 'Subtract quarter');
    });

    test('add strings string short', function (assert) {
        var a = moment();
        a.year(2011);
        a.month(9);
        a.date(12);
        a.hours(6);
        a.minutes(7);
        a.seconds(8);
        a.milliseconds(500);

        assert.equal(a.add('50', 'ms').milliseconds(), 550, 'Add milliseconds');
        assert.equal(a.add('1', 's').seconds(), 9, 'Add seconds');
        assert.equal(a.add('1', 'm').minutes(), 8, 'Add minutes');
        assert.equal(a.add('1', 'h').hours(), 7, 'Add hours');
        assert.equal(a.add('1', 'd').date(), 13, 'Add date');
        assert.equal(a.add('1', 'w').date(), 20, 'Add week');
        assert.equal(a.add('1', 'M').month(), 10, 'Add month');
        assert.equal(a.add('1', 'y').year(), 2012, 'Add year');
        assert.equal(a.add('1', 'Q').month(), 1, 'Add quarter');
    });

    test('subtract strings string short', function (assert) {
        var a = moment();
        a.year(2011);
        a.month(9);
        a.date(12);
        a.hours(6);
        a.minutes(7);
        a.seconds(8);
        a.milliseconds(500);

        assert.equal(a.subtract('50', 'ms').milliseconds(), 450, 'Subtract milliseconds');
        assert.equal(a.subtract('1', 's').seconds(), 7, 'Subtract seconds');
        assert.equal(a.subtract('1', 'm').minutes(), 6, 'Subtract minutes');
        assert.equal(a.subtract('1', 'h').hours(), 5, 'Subtract hours');
        assert.equal(a.subtract('1', 'd').date(), 11, 'Subtract date');
        assert.equal(a.subtract('1', 'w').date(), 4, 'Subtract week');
        assert.equal(a.subtract('1', 'M').month(), 8, 'Subtract month');
        assert.equal(a.subtract('1', 'y').year(), 2010, 'Subtract year');
        assert.equal(a.subtract('1', 'Q').month(), 5, 'Subtract quarter');
    });

    test('add across DST', function (assert) {
        // Detect Safari bug and bail. Hours on 13th March 2011 are shifted
        // with 1 ahead.
        if (new Date(2011, 2, 13, 5, 0, 0).getHours() !== 5) {
            expect(0);
            return;
        }

        var a = moment(new Date(2011, 2, 12, 5, 0, 0)),
            b = moment(new Date(2011, 2, 12, 5, 0, 0)),
            c = moment(new Date(2011, 2, 12, 5, 0, 0)),
            d = moment(new Date(2011, 2, 12, 5, 0, 0)),
            e = moment(new Date(2011, 2, 12, 5, 0, 0));
        a.add(1, 'days');
        b.add(24, 'hours');
        c.add(1, 'months');
        e.add(1, 'quarter');

        assert.equal(a.hours(), 5, 'adding days over DST difference should result in the same hour');
        if (b.isDST() && !d.isDST()) {
            assert.equal(b.hours(), 6, 'adding hours over DST difference should result in a different hour');
        } else if (!b.isDST() && d.isDST()) {
            assert.equal(b.hours(), 4, 'adding hours over DST difference should result in a different hour');
        } else {
            assert.equal(b.hours(), 5, 'adding hours over DST difference should result in a same hour if the timezone does not have daylight savings time');
        }
        assert.equal(c.hours(), 5, 'adding months over DST difference should result in the same hour');
        assert.equal(e.hours(), 5, 'adding quarters over DST difference should result in the same hour');
    });

    test('add decimal values of days and months', function (assert) {
        assert.equal(moment([2016,3,3]).add(1.5, 'days').date(), 5, 'adding 1.5 days is rounded to adding 2 day');
        assert.equal(moment([2016,3,3]).add(-1.5, 'days').date(), 1, 'adding -1.5 days is rounded to adding -2 day');
        assert.equal(moment([2016,3,1]).add(-1.5, 'days').date(), 30, 'adding -1.5 days on first of month wraps around');
        assert.equal(moment([2016,3,3]).add(1.5, 'months').month(), 5, 'adding 1.5 months adds 2 months');
        assert.equal(moment([2016,3,3]).add(-1.5, 'months').month(), 1, 'adding -1.5 months adds -2 months');
        assert.equal(moment([2016,0,3]).add(-1.5, 'months').month(), 10, 'adding -1.5 months at start of year wraps back');
        assert.equal(moment([2016,3,3]).subtract(1.5, 'days').date(),1, 'subtract 1.5 days is rounded to subtract 2 day');
        assert.equal(moment([2016,3,2]).subtract(1.5, 'days').date(), 31, 'subtract 1.5 days subtracts 2 days');
        assert.equal(moment([2016,1,1]).subtract(1.1, 'days').date(), 31, 'subtract 1.1 days wraps to previous month');
        assert.equal(moment([2016,3,3]).subtract(-1.5, 'days').date(), 5, 'subtract -1.5 days is rounded to subtract -2 day');
        assert.equal(moment([2016,3,30]).subtract(-1.5, 'days').date(), 2, 'subtract -1.5 days on last of month wraps around');
        assert.equal(moment([2016,3,3]).subtract(1.5, 'months').month(), 1, 'subtract 1.5 months subtract 2 months');
        assert.equal(moment([2016,3,3]).subtract(-1.5, 'months').month(), 5, 'subtract -1.5 months subtract -2 month');
        assert.equal(moment([2016,11,31]).subtract(-1.5, 'months').month(),1, 'subtract -1.5 months at end of year wraps back');
        assert.equal(moment([2016, 0,1]).add(1.5, 'years').format('YYYY-MM-DD'), '2017-07-01', 'add 1.5 years adds 1 year six months');
        assert.equal(moment([2016, 0,1]).add(1.6, 'years').format('YYYY-MM-DD'), '2017-08-01', 'add 1.6 years becomes 1.6*12 = 19.2, round, 19 months');
        assert.equal(moment([2016,0,1]).add(1.1, 'quarters').format('YYYY-MM-DD'), '2016-04-01', 'add 1.1 quarters 1.1*3=3.3, round, 3 months');
    });

}));

;(function (global, factory) {
   typeof exports === 'object' && typeof module !== 'undefined'
       && typeof require === 'function' ? factory(require('../../moment')) :
   typeof define === 'function' && define.amd ? define(['../../moment'], factory) :
   factory(global.moment)
}(this, function (moment) { 'use strict';

    function each(array, callback) {
        var i;
        for (i = 0; i < array.length; i++) {
            callback(array[i], i, array);
        }
    }

    function objectKeys(obj) {
        if (Object.keys) {
            return Object.keys(obj);
        } else {
            // IE8
            var res = [], i;
            for (i in obj) {
                if (obj.hasOwnProperty(i)) {
                    res.push(i);
                }
            }
            return res;
        }
    }

    // Pick the first defined of two or three arguments.
    function defaults(a, b, c) {
        if (a != null) {
            return a;
        }
        if (b != null) {
            return b;
        }
        return c;
    }

    function defineCommonLocaleTests(locale, options) {
        test('lenient ordinal parsing', function (assert) {
            var i, ordinalStr, testMoment;
            for (i = 1; i <= 31; ++i) {
                ordinalStr = moment([2014, 0, i]).format('YYYY MM Do');
                testMoment = moment(ordinalStr, 'YYYY MM Do');
                assert.equal(testMoment.year(), 2014,
                        'lenient ordinal parsing ' + i + ' year check');
                assert.equal(testMoment.month(), 0,
                        'lenient ordinal parsing ' + i + ' month check');
                assert.equal(testMoment.date(), i,
                        'lenient ordinal parsing ' + i + ' date check');
            }
        });

        test('lenient ordinal parsing of number', function (assert) {
            var i, testMoment;
            for (i = 1; i <= 31; ++i) {
                testMoment = moment('2014 01 ' + i, 'YYYY MM Do');
                assert.equal(testMoment.year(), 2014,
                        'lenient ordinal parsing of number ' + i + ' year check');
                assert.equal(testMoment.month(), 0,
                        'lenient ordinal parsing of number ' + i + ' month check');
                assert.equal(testMoment.date(), i,
                        'lenient ordinal parsing of number ' + i + ' date check');
            }
        });

        test('strict ordinal parsing', function (assert) {
            var i, ordinalStr, testMoment;
            for (i = 1; i <= 31; ++i) {
                ordinalStr = moment([2014, 0, i]).format('YYYY MM Do');
                testMoment = moment(ordinalStr, 'YYYY MM Do', true);
                assert.ok(testMoment.isValid(), 'strict ordinal parsing ' + i);
            }
        });

        test('meridiem invariant', function (assert) {
            var h, m, t1, t2;
            for (h = 0; h < 24; ++h) {
                for (m = 0; m < 60; m += 15) {
                    t1 = moment.utc([2000, 0, 1, h, m]);
                    t2 = moment.utc(t1.format('A h:mm'), 'A h:mm');
                    assert.equal(t2.format('HH:mm'), t1.format('HH:mm'),
                            'meridiem at ' + t1.format('HH:mm'));
                }
            }
        });

        test('date format correctness', function (assert) {
            var data, tokens;
            data = moment.localeData()._longDateFormat;
            tokens = objectKeys(data);
            each(tokens, function (srchToken) {
                // Check each format string to make sure it does not contain any
                // tokens that need to be expanded.
                each(tokens, function (baseToken) {
                    // strip escaped sequences
                    var format = data[baseToken].replace(/(\[[^\]]*\])/g, '');
                    assert.equal(false, !!~format.indexOf(srchToken),
                            'contains ' + srchToken + ' in ' + baseToken);
                });
            });
        });

        test('month parsing correctness', function (assert) {
            var i, m;

            if (locale === 'tr') {
                // I can't fix it :(
                expect(0);
                return;
            }
            function tester(format) {
                var r;
                r = moment(m.format(format), format);
                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format);
                r = moment(m.format(format).toLocaleUpperCase(), format);
                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' upper');
                r = moment(m.format(format).toLocaleLowerCase(), format);
                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' lower');

                r = moment(m.format(format), format, true);
                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' strict');
                r = moment(m.format(format).toLocaleUpperCase(), format, true);
                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' upper strict');
                r = moment(m.format(format).toLocaleLowerCase(), format, true);
                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' lower strict');
            }

            for (i = 0; i < 12; ++i) {
                m = moment([2015, i, 15, 18]);
                tester('MMM');
                tester('MMM.');
                tester('MMMM');
                tester('MMMM.');
            }
        });

        test('weekday parsing correctness', function (assert) {
            var i, m;

            if (locale === 'tr' || locale === 'az') {
                // There is a lower-case letter (Ä±), that converted to upper then
                // lower changes to i
                expect(0);
                return;
            }
            function tester(format) {
                var r, baseMsg = 'weekday ' + m.weekday() + ' fmt ' + format;
                r = moment(m.format(format), format);
                assert.equal(r.weekday(), m.weekday(), baseMsg);
                r = moment(m.format(format).toLocaleUpperCase(), format);
                assert.equal(r.weekday(), m.weekday(), baseMsg + ' upper');
                r = moment(m.format(format).toLocaleLowerCase(), format);
                assert.equal(r.weekday(), m.weekday(), baseMsg + ' lower');

                r = moment(m.format(format), format, true);
                assert.equal(r.weekday(), m.weekday(), baseMsg + ' strict');
                r = moment(m.format(format).toLocaleUpperCase(), format, true);
                assert.equal(r.weekday(), m.weekday(), baseMsg + ' upper strict');
                r = moment(m.format(format).toLocaleLowerCase(), format, true);
                assert.equal(r.weekday(), m.weekday(), baseMsg + ' lower strict');
            }

            for (i = 0; i < 7; ++i) {
                m = moment.utc([2015, i, 15, 18]);
                tester('dd');
                tester('ddd');
                tester('dddd');
            }
        });
    }

    function setupDeprecationHandler(test, moment, scope) {
        test._expectedDeprecations = null;
        test._observedDeprecations = null;
        test._oldSupress = moment.suppressDeprecationWarnings;
        moment.suppressDeprecationWarnings = true;
        test.expectedDeprecations = function () {
            test._expectedDeprecations = arguments;
            test._observedDeprecations = [];
        };
        moment.deprecationHandler = function (name, msg) {
            var deprecationId = matchedDeprecation(name, msg, test._expectedDeprecations);
            if (deprecationId === -1) {
                throw new Error('Unexpected deprecation thrown name=' +
                        name + ' msg=' + msg);
            }
            test._observedDeprecations[deprecationId] = 1;
        };
    }

    function teardownDeprecationHandler(test, moment, scope) {
        moment.suppressDeprecationWarnings = test._oldSupress;

        if (test._expectedDeprecations != null) {
            var missedDeprecations = [];
            each(test._expectedDeprecations, function (deprecationPattern, id) {
                if (test._observedDeprecations[id] !== 1) {
                    missedDeprecations.push(deprecationPattern);
                }
            });
            if (missedDeprecations.length !== 0) {
                throw new Error('Expected deprecation warnings did not happen: ' +
                        missedDeprecations.join(' '));
            }
        }
    }

    function matchedDeprecation(name, msg, deprecations) {
        if (deprecations == null) {
            return -1;
        }
        for (var i = 0; i < deprecations.length; ++i) {
            if (name != null && name === deprecations[i]) {
                return i;
            }
            if (msg != null && msg.substring(0, deprecations[i].length) === deprecations[i]) {
                return i;
            }
        }
        return -1;
    }

    /*global QUnit:false*/

    var test = QUnit.test;

    var expect = QUnit.expect;

    function module (name, lifecycle) {
        QUnit.module(name, {
            setup : function () {
                moment.locale('en');
                moment.createFromInputFallback = function (config) {
                    throw new Error('input not handled by moment: ' + config._i);
                };
                setupDeprecationHandler(test, moment, 'core');
                if (lifecycle && lifecycle.setup) {
                    lifecycle.setup();
                }
            },
            teardown : function () {
                teardownDeprecationHandler(test, moment, 'core');
                if (lifecycle && lifecycle.teardown) {
                    lifecycle.teardown();
                }
            }
        });
    }

    function localeModule (name, lifecycle) {
        QUnit.module('locale:' + name, {
            setup : function () {
                moment.locale(name);
                moment.createFromInputFallback = function (config) {
                    throw new Error('input not handled by moment: ' + config._i);
                };
                setupDeprecationHandler(test, moment, 'locale');
                if (lifecycle && lifecycle.setup) {
                    lifecycle.setup();
                }
            },
            teardown : function () {
                moment.locale('en');
                teardownDeprecationHandler(test, moment, 'locale');
                if (lifecycle && lifecycle.teardown) {
                    lifecycle.teardown();
                }
            }
        });
        defineCommonLocaleTests(name, -1, -1);
    }

    // These tests are for locale independent features
    // locale dependent tests would be in locale test folder
    module('calendar');

    test('passing a function', function (assert) {
        var a  = moment().hours(13).minutes(0).seconds(0);
        assert.equal(moment(a).calendar(null, {
            'sameDay': function () {
                return 'h:mmA';
            }
        }), '1:00PM', 'should equate');
    });

}));

;(function (global, factory) {
   typeof exports === 'object' && typeof module !== 'undefined'
       && typeof require === 'function' ? factory(require('../../moment')) :
   typeof define === 'function' && define.amd ? define(['../../moment'], factory) :
   factory(global.moment)
}(this, function (moment) { 'use strict';

    function each(array, callback) {
        var i;
        for (i = 0; i < array.length; i++) {
            callback(array[i], i, array);
        }
    }

    function objectKeys(obj) {
        if (Object.keys) {
            return Object.keys(obj);
        } else {
            // IE8
            var res = [], i;
            for (i in obj) {
                if (obj.hasOwnProperty(i)) {
                    res.push(i);
                }
            }
            return res;
        }
    }

    // Pick the first defined of two or three arguments.
    function defaults(a, b, c) {
        if (a != null) {
            return a;
        }
        if (b != null) {
            return b;
        }
        return c;
    }

    function defineCommonLocaleTests(locale, options) {
        test('lenient ordinal parsing', function (assert) {
            var i, ordinalStr, testMoment;
            for (i = 1; i <= 31; ++i) {
                ordinalStr = moment([2014, 0, i]).format('YYYY MM Do');
                testMoment = moment(ordinalStr, 'YYYY MM Do');
                assert.equal(testMoment.year(), 2014,
                        'lenient ordinal parsing ' + i + ' year check');
                assert.equal(testMoment.month(), 0,
                        'lenient ordinal parsing ' + i + ' month check');
                assert.equal(testMoment.date(), i,
                        'lenient ordinal parsing ' + i + ' date check');
            }
        });

        test('lenient ordinal parsing of number', function (assert) {
            var i, testMoment;
            for (i = 1; i <= 31; ++i) {
                testMoment = moment('2014 01 ' + i, 'YYYY MM Do');
                assert.equal(testMoment.year(), 2014,
                        'lenient ordinal parsing of number ' + i + ' year check');
                assert.equal(testMoment.month(), 0,
                        'lenient ordinal parsing of number ' + i + ' month check');
                assert.equal(testMoment.date(), i,
                        'lenient ordinal parsing of number ' + i + ' date check');
            }
        });

        test('strict ordinal parsing', function (assert) {
            var i, ordinalStr, testMoment;
            for (i = 1; i <= 31; ++i) {
                ordinalStr = moment([2014, 0, i]).format('YYYY MM Do');
                testMoment = moment(ordinalStr, 'YYYY MM Do', true);
                assert.ok(testMoment.isValid(), 'strict ordinal parsing ' + i);
            }
        });

        test('meridiem invariant', function (assert) {
            var h, m, t1, t2;
            for (h = 0; h < 24; ++h) {
                for (m = 0; m < 60; m += 15) {
                    t1 = moment.utc([2000, 0, 1, h, m]);
                    t2 = moment.utc(t1.format('A h:mm'), 'A h:mm');
                    assert.equal(t2.format('HH:mm'), t1.format('HH:mm'),
                            'meridiem at ' + t1.format('HH:mm'));
                }
            }
        });

        test('date format correctness', function (assert) {
            var data, tokens;
            data = moment.localeData()._longDateFormat;
            tokens = objectKeys(data);
            each(tokens, function (srchToken) {
                // Check each format string to make sure it does not contain any
                // tokens that need to be expanded.
                each(tokens, function (baseToken) {
                    // strip escaped sequences
                    var format = data[baseToken].replace(/(\[[^\]]*\])/g, '');
                    assert.equal(false, !!~format.indexOf(srchToken),
                            'contains ' + srchToken + ' in ' + baseToken);
                });
            });
        });

        test('month parsing correctness', function (assert) {
            var i, m;

            if (locale === 'tr') {
                // I can't fix it :(
                expect(0);
                return;
            }
            function tester(format) {
                var r;
                r = moment(m.format(format), format);
                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format);
                r = moment(m.format(format).toLocaleUpperCase(), format);
                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' upper');
                r = moment(m.format(format).toLocaleLowerCase(), format);
                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' lower');

                r = moment(m.format(format), format, true);
                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' strict');
                r = moment(m.format(format).toLocaleUpperCase(), format, true);
                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' upper strict');
                r = moment(m.format(format).toLocaleLowerCase(), format, true);
                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' lower strict');
            }

            for (i = 0; i < 12; ++i) {
                m = moment([2015, i, 15, 18]);
                tester('MMM');
                tester('MMM.');
                tester('MMMM');
                tester('MMMM.');
            }
        });

        test('weekday parsing correctness', function (assert) {
            var i, m;

            if (locale === 'tr' || locale === 'az') {
                // There is a lower-case letter (Ä±), that converted to upper then
                // lower changes to i
                expect(0);
                return;
            }
            function tester(format) {
                var r, baseMsg = 'weekday ' + m.weekday() + ' fmt ' + format;
                r = moment(m.format(format), format);
                assert.equal(r.weekday(), m.weekday(), baseMsg);
                r = moment(m.format(format).toLocaleUpperCase(), format);
                assert.equal(r.weekday(), m.weekday(), baseMsg + ' upper');
                r = moment(m.format(format).toLocaleLowerCase(), format);
                assert.equal(r.weekday(), m.weekday(), baseMsg + ' lower');

                r = moment(m.format(format), format, true);
                assert.equal(r.weekday(), m.weekday(), baseMsg + ' strict');
                r = moment(m.format(format).toLocaleUpperCase(), format, true);
                assert.equal(r.weekday(), m.weekday(), baseMsg + ' upper strict');
                r = moment(m.format(format).toLocaleLowerCase(), format, true);
                assert.equal(r.weekday(), m.weekday(), baseMsg + ' lower strict');
            }

            for (i = 0; i < 7; ++i) {
                m = moment.utc([2015, i, 15, 18]);
                tester('dd');
                tester('ddd');
                tester('dddd');
            }
        });
    }

    function setupDeprecationHandler(test, moment, scope) {
        test._expectedDeprecations = null;
        test._observedDeprecations = null;
        test._oldSupress = moment.suppressDeprecationWarnings;
        moment.suppressDeprecationWarnings = true;
        test.expectedDeprecations = function () {
            test._expectedDeprecations = arguments;
            test._observedDeprecations = [];
        };
        moment.deprecationHandler = function (name, msg) {
            var deprecationId = matchedDeprecation(name, msg, test._expectedDeprecations);
            if (deprecationId === -1) {
                throw new Error('Unexpected deprecation thrown name=' +
                        name + ' msg=' + msg);
            }
            test._observedDeprecations[deprecationId] = 1;
        };
    }

    function teardownDeprecationHandler(test, moment, scope) {
        moment.suppressDeprecationWarnings = test._oldSupress;

        if (test._expectedDeprecations != null) {
            var missedDeprecations = [];
            each(test._expectedDeprecations, function (deprecationPattern, id) {
                if (test._observedDeprecations[id] !== 1) {
                    missedDeprecations.push(deprecationPattern);
                }
            });
            if (missedDeprecations.length !== 0) {
                throw new Error('Expected deprecation warnings did not happen: ' +
                        missedDeprecations.join(' '));
            }
        }
    }

    function matchedDeprecation(name, msg, deprecations) {
        if (deprecations == null) {
            return -1;
        }
        for (var i = 0; i < deprecations.length; ++i) {
            if (name != null && name === deprecations[i]) {
                return i;
            }
            if (msg != null && msg.substring(0, deprecations[i].length) === deprecations[i]) {
                return i;
            }
        }
        return -1;
    }

    /*global QUnit:false*/

    var test = QUnit.test;

    var expect = QUnit.expect;

    function module (name, lifecycle) {
        QUnit.module(name, {
            setup : function () {
                moment.locale('en');
                moment.createFromInputFallback = function (config) {
                    throw new Error('input not handled by moment: ' + config._i);
                };
                setupDeprecationHandler(test, moment, 'core');
                if (lifecycle && lifecycle.setup) {
                    lifecycle.setup();
                }
            },
            teardown : function () {
                teardownDeprecationHandler(test, moment, 'core');
                if (lifecycle && lifecycle.teardown) {
                    lifecycle.teardown();
                }
            }
        });
    }

    function localeModule (name, lifecycle) {
        QUnit.module('locale:' + name, {
            setup : function () {
                moment.locale(name);
                moment.createFromInputFallback = function (config) {
                    throw new Error('input not handled by moment: ' + config._i);
                };
                setupDeprecationHandler(test, moment, 'locale');
                if (lifecycle && lifecycle.setup) {
                    lifecycle.setup();
                }
            },
            teardown : function () {
                moment.locale('en');
                teardownDeprecationHandler(test, moment, 'locale');
                if (lifecycle && lifecycle.teardown) {
                    lifecycle.teardown();
                }
            }
        });
        defineCommonLocaleTests(name, -1, -1);
    }

    module('create');

    test('array', function (assert) {
        assert.ok(moment([2010]).toDate() instanceof Date, '[2010]');
        assert.ok(moment([2010, 1]).toDate() instanceof Date, '[2010, 1]');
        assert.ok(moment([2010, 1, 12]).toDate() instanceof Date, '[2010, 1, 12]');
        assert.ok(moment([2010, 1, 12, 1]).toDate() instanceof Date, '[2010, 1, 12, 1]');
        assert.ok(moment([2010, 1, 12, 1, 1]).toDate() instanceof Date, '[2010, 1, 12, 1, 1]');
        assert.ok(moment([2010, 1, 12, 1, 1, 1]).toDate() instanceof Date, '[2010, 1, 12, 1, 1, 1]');
        assert.ok(moment([2010, 1, 12, 1, 1, 1, 1]).toDate() instanceof Date, '[2010, 1, 12, 1, 1, 1, 1]');
        assert.equal(+moment(new Date(2010, 1, 14, 15, 25, 50, 125)), +moment([2010, 1, 14, 15, 25, 50, 125]), 'constructing with array === constructing with new Date()');
    });

    test('array with invalid arguments', function (assert) {
        assert.ok(!moment([2010, null, null]).isValid(), '[2010, null, null]');
        assert.ok(!moment([1945, null, null]).isValid(), '[1945, null, null] (pre-1970)');
    });

    test('array copying', function (assert) {
        var importantArray = [2009, 11];
        moment(importantArray);
        assert.deepEqual(importantArray, [2009, 11], 'initializer should not mutate the original array');
    });

    test('object', function (assert) {
        var fmt = 'YYYY-MM-DD HH:mm:ss.SSS',
            tests = [
                [{year: 2010}, '2010-01-01 00:00:00.000'],
                [{year: 2010, month: 1}, '2010-02-01 00:00:00.000'],
                [{year: 2010, month: 1, day: 12}, '2010-02-12 00:00:00.000'],
                [{year: 2010, month: 1, date: 12}, '2010-02-12 00:00:00.000'],
                [{year: 2010, month: 1, day: 12, hours: 1}, '2010-02-12 01:00:00.000'],
                [{year: 2010, month: 1, date: 12, hours: 1}, '2010-02-12 01:00:00.000'],
                [{year: 2010, month: 1, day: 12, hours: 1, minutes: 1}, '2010-02-12 01:01:00.000'],
                [{year: 2010, month: 1, date: 12, hours: 1, minutes: 1}, '2010-02-12 01:01:00.000'],
                [{year: 2010, month: 1, day: 12, hours: 1, minutes: 1, seconds: 1}, '2010-02-12 01:01:01.000'],
                [{year: 2010, month: 1, day: 12, hours: 1, minutes: 1, seconds: 1, milliseconds: 1}, '2010-02-12 01:01:01.001'],
                [{years: 2010, months: 1, days: 14, hours: 15, minutes: 25, seconds: 50, milliseconds: 125}, '2010-02-14 15:25:50.125'],
                [{year: 2010, month: 1, day: 14, hour: 15, minute: 25, second: 50, millisecond: 125}, '2010-02-14 15:25:50.125'],
                [{y: 2010, M: 1, d: 14, h: 15, m: 25, s: 50, ms: 125}, '2010-02-14 15:25:50.125']
            ], i;
        for (i = 0; i < tests.length; ++i) {
            assert.equal(moment(tests[i][0]).format(fmt), tests[i][1]);
        }
    });

    test('multi format array copying', function (assert) {
        var importantArray = ['MM/DD/YYYY', 'YYYY-MM-DD', 'MM-DD-YYYY'];
        moment('1999-02-13', importantArray);
        assert.deepEqual(importantArray, ['MM/DD/YYYY', 'YYYY-MM-DD', 'MM-DD-YYYY'], 'initializer should not mutate the original array');
    });

    test('number', function (assert) {
        assert.ok(moment(1000).toDate() instanceof Date, '1000');
        assert.equal(moment(1000).valueOf(), 1000, 'asserting valueOf');
        assert.equal(moment.utc(1000).valueOf(), 1000, 'asserting valueOf');
    });

    test('unix', function (assert) {
        assert.equal(moment.unix(1).valueOf(), 1000, '1 unix timestamp == 1000 Date.valueOf');
        assert.equal(moment(1000).unix(), 1, '1000 Date.valueOf == 1 unix timestamp');
        assert.equal(moment.unix(1000).valueOf(), 1000000, '1000 unix timestamp == 1000000 Date.valueOf');
        assert.equal(moment(1500).unix(), 1, '1500 Date.valueOf == 1 unix timestamp');
        assert.equal(moment(1900).unix(), 1, '1900 Date.valueOf == 1 unix timestamp');
        assert.equal(moment(2100).unix(), 2, '2100 Date.valueOf == 2 unix timestamp');
        assert.equal(moment(1333129333524).unix(), 1333129333, '1333129333524 Date.valueOf == 1333129333 unix timestamp');
        assert.equal(moment(1333129333524000).unix(), 1333129333524, '1333129333524000 Date.valueOf == 1333129333524 unix timestamp');
    });

    test('date', function (assert) {
        assert.ok(moment(new Date()).toDate() instanceof Date, 'new Date()');
    });

    test('date mutation', function (assert) {
        var a = new Date();
        assert.ok(moment(a).toDate() !== a, 'the date moment uses should not be the date passed in');
    });

    test('moment', function (assert) {
        assert.ok(moment(moment()).toDate() instanceof Date, 'moment(moment())');
        assert.ok(moment(moment(moment())).toDate() instanceof Date, 'moment(moment(moment()))');
    });

    test('cloning moment should only copy own properties', function (assert) {
        assert.ok(!moment().clone().hasOwnProperty('month'), 'Should not clone prototype methods');
    });

    test('cloning moment works with weird clones', function (assert) {
        var extend = function (a, b) {
            var i;
            for (i in b) {
                a[i] = b[i];
            }
            return a;
        },
        now = moment(),
        nowu = moment.utc();

        assert.equal(+extend({}, now).clone(), +now, 'cloning extend-ed now is now');
        assert.equal(+extend({}, nowu).clone(), +nowu, 'cloning extend-ed utc now is utc now');
    });

    test('cloning respects moment.momentProperties', function (assert) {
        var m = moment();

        assert.equal(m.clone()._special, undefined, 'cloning ignores extra properties');
        m._special = 'bacon';
        moment.momentProperties.push('_special');
        assert.equal(m.clone()._special, 'bacon', 'cloning respects momentProperties');
        moment.momentProperties.pop();
    });

    test('undefined', function (assert) {
        assert.ok(moment().toDate() instanceof Date, 'undefined');
    });

    test('iso with bad input', function (assert) {
        assert.ok(!moment('a', moment.ISO_8601).isValid(), 'iso parsing with invalid string');
        assert.ok(!moment('a', moment.ISO_8601, true).isValid(), 'iso parsing with invalid string, strict');
    });

    test('iso format 24hrs', function (assert) {
        assert.equal(moment('2014-01-01T24:00:00.000').format('YYYY-MM-DD[T]HH:mm:ss.SSS'),
                '2014-01-02T00:00:00.000', 'iso format with 24:00 localtime');
        assert.equal(moment.utc('2014-01-01T24:00:00.000').format('YYYY-MM-DD[T]HH:mm:ss.SSS'),
                '2014-01-02T00:00:00.000', 'iso format with 24:00 utc');
    });

    test('string without format - json', function (assert) {
        assert.equal(moment('Date(1325132654000)').valueOf(), 1325132654000, 'Date(1325132654000)');
        assert.equal(moment('Date(-1325132654000)').valueOf(), -1325132654000, 'Date(-1325132654000)');
        assert.equal(moment('/Date(1325132654000)/').valueOf(), 1325132654000, '/Date(1325132654000)/');
        assert.equal(moment('/Date(1325132654000+0700)/').valueOf(), 1325132654000, '/Date(1325132654000+0700)/');
        assert.equal(moment('/Date(1325132654000-0700)/').valueOf(), 1325132654000, '/Date(1325132654000-0700)/');
    });

    test('string with format dropped am/pm bug', function (assert) {
        moment.locale('en');

        assert.equal(moment('05/1/2012 12:25:00', 'MM/DD/YYYY h:m:s a').format('MM/DD/YYYY'), '05/01/2012', 'should not break if am/pm is left off from the parsing tokens');
        assert.equal(moment('05/1/2012 12:25:00 am', 'MM/DD/YYYY h:m:s a').format('MM/DD/YYYY'), '05/01/2012', 'should not break if am/pm is left off from the parsing tokens');
        assert.equal(moment('05/1/2012 12:25:00 pm', 'MM/DD/YYYY h:m:s a').format('MM/DD/YYYY'), '05/01/2012', 'should not break if am/pm is left off from the parsing tokens');

        assert.ok(moment('05/1/2012 12:25:00', 'MM/DD/YYYY h:m:s a').isValid());
        assert.ok(moment('05/1/2012 12:25:00 am', 'MM/DD/YYYY h:m:s a').isValid());
        assert.ok(moment('05/1/2012 12:25:00 pm', 'MM/DD/YYYY h:m:s a').isValid());
    });

    test('empty string with formats', function (assert) {
        assert.equal(moment('', 'MM').format('YYYY-MM-DD HH:mm:ss'), 'Invalid date');
        assert.equal(moment(' ', 'MM').format('YYYY-MM-DD HH:mm:ss'), 'Invalid date');
        assert.equal(moment(' ', 'DD').format('YYYY-MM-DD HH:mm:ss'), 'Invalid date');
        assert.equal(moment(' ', ['MM', 'DD']).format('YYYY-MM-DD HH:mm:ss'), 'Invalid date');

        assert.ok(!moment('', 'MM').isValid());
        assert.ok(!moment(' ', 'MM').isValid());
        assert.ok(!moment(' ', 'DD').isValid());
        assert.ok(!moment(' ', ['MM', 'DD']).isValid());
    });

    test('defaulting to current date', function (assert) {
        var now = moment();
        assert.equal(moment('12:13:14', 'hh:mm:ss').format('YYYY-MM-DD hh:mm:ss'),
                     now.clone().hour(12).minute(13).second(14).format('YYYY-MM-DD hh:mm:ss'),
                     'given only time default to current date');
        assert.equal(moment('05', 'DD').format('YYYY-MM-DD'),
                     now.clone().date(5).format('YYYY-MM-DD'),
                     'given day of month default to current month, year');
        assert.equal(moment('05', 'MM').format('YYYY-MM-DD'),
                     now.clone().month(4).date(1).format('YYYY-MM-DD'),
                     'given month default to current year');
        assert.equal(moment('1996', 'YYYY').format('YYYY-MM-DD'),
                     now.clone().year(1996).month(0).date(1).format('YYYY-MM-DD'),
                     'given year do not default');
    });

    test('matching am/pm', function (assert) {
        assert.equal(moment('2012-09-03T03:00PM',   'YYYY-MM-DDThh:mmA').format('YYYY-MM-DDThh:mmA'), '2012-09-03T03:00PM', 'am/pm should parse correctly for PM');
        assert.equal(moment('2012-09-03T03:00P.M.', 'YYYY-MM-DDThh:mmA').format('YYYY-MM-DDThh:mmA'), '2012-09-03T03:00PM', 'am/pm should parse correctly for P.M.');
        assert.equal(moment('2012-09-03T03:00P',    'YYYY-MM-DDThh:mmA').format('YYYY-MM-DDThh:mmA'), '2012-09-03T03:00PM', 'am/pm should parse correctly for P');
        assert.equal(moment('2012-09-03T03:00pm',   'YYYY-MM-DDThh:mmA').format('YYYY-MM-DDThh:mmA'), '2012-09-03T03:00PM', 'am/pm should parse correctly for pm');
        assert.equal(moment('2012-09-03T03:00p.m.', 'YYYY-MM-DDThh:mmA').format('YYYY-MM-DDThh:mmA'), '2012-09-03T03:00PM', 'am/pm should parse correctly for p.m.');
        assert.equal(moment('2012-09-03T03:00p',    'YYYY-MM-DDThh:mmA').format('YYYY-MM-DDThh:mmA'), '2012-09-03T03:00PM', 'am/pm should parse correctly for p');

        assert.equal(moment('2012-09-03T03:00AM',   'YYYY-MM-DDThh:mmA').format('YYYY-MM-DDThh:mmA'), '2012-09-03T03:00AM', 'am/pm should parse correctly for AM');
        assert.equal(moment('2012-09-03T03:00A.M.', 'YYYY-MM-DDThh:mmA').format('YYYY-MM-DDThh:mmA'), '2012-09-03T03:00AM', 'am/pm should parse correctly for A.M.');
        assert.equal(moment('2012-09-03T03:00A',    'YYYY-MM-DDThh:mmA').format('YYYY-MM-DDThh:mmA'), '2012-09-03T03:00AM', 'am/pm should parse correctly for A');
        assert.equal(moment('2012-09-03T03:00am',   'YYYY-MM-DDThh:mmA').format('YYYY-MM-DDThh:mmA'), '2012-09-03T03:00AM', 'am/pm should parse correctly for am');
        assert.equal(moment('2012-09-03T03:00a.m.', 'YYYY-MM-DDThh:mmA').format('YYYY-MM-DDThh:mmA'), '2012-09-03T03:00AM', 'am/pm should parse correctly for a.m.');
        assert.equal(moment('2012-09-03T03:00a',    'YYYY-MM-DDThh:mmA').format('YYYY-MM-DDThh:mmA'), '2012-09-03T03:00AM', 'am/pm should parse correctly for a');

        assert.equal(moment('5:00p.m.March 4 2012', 'h:mmAMMMM D YYYY').format('YYYY-MM-DDThh:mmA'), '2012-03-04T05:00PM', 'am/pm should parse correctly before month names');
    });

    test('string with format', function (assert) {
        moment.locale('en');
        var a = [
            ['YYYY-Q',              '2014-4'],
            ['MM-DD-YYYY',          '12-02-1999'],
            ['DD-MM-YYYY',          '12-02-1999'],
            ['DD/MM/YYYY',          '12/02/1999'],
            ['DD_MM_YYYY',          '12_02_1999'],
            ['DD:MM:YYYY',          '12:02:1999'],
            ['D-M-YY',              '2-2-99'],
            ['YY',                  '99'],
            ['DDD-YYYY',            '300-1999'],
            ['DD-MM-YYYY h:m:s',    '12-02-1999 2:45:10'],
            ['DD-MM-YYYY h:m:s a',  '12-02-1999 2:45:10 am'],
            ['DD-MM-YYYY h:m:s a',  '12-02-1999 2:45:10 pm'],
            ['h:mm a',              '12:00 pm'],
            ['h:mm a',              '12:30 pm'],
            ['h:mm a',              '12:00 am'],
            ['h:mm a',              '12:30 am'],
            ['HH:mm',               '12:00'],
            ['YYYY-MM-DDTHH:mm:ss', '2011-11-11T11:11:11'],
            ['MM-DD-YYYY [M]',      '12-02-1999 M'],
            ['ddd MMM DD HH:mm:ss YYYY', 'Tue Apr 07 22:52:51 2009'],
            ['HH:mm:ss',            '12:00:00'],
            ['HH:mm:ss',            '12:30:00'],
            ['HH:mm:ss',            '00:00:00'],
            ['HH:mm:ss S',          '00:30:00 1'],
            ['HH:mm:ss SS',         '00:30:00 12'],
            ['HH:mm:ss SSS',        '00:30:00 123'],
            ['HH:mm:ss S',          '00:30:00 7'],
            ['HH:mm:ss SS',         '00:30:00 78'],
            ['HH:mm:ss SSS',        '00:30:00 789'],
            ['X',                   '1234567890'],
            ['x',                   '1234567890123'],
            ['LT',                  '12:30 AM'],
            ['LTS',                 '12:30:29 AM'],
            ['L',                   '09/02/1999'],
            ['l',                   '9/2/1999'],
            ['LL',                  'September 2, 1999'],
            ['ll',                  'Sep 2, 1999'],
            ['LLL',                 'September 2, 1999 12:30 AM'],
            ['lll',                 'Sep 2, 1999 12:30 AM'],
            ['LLLL',                'Thursday, September 2, 1999 12:30 AM'],
            ['llll',                'Thu, Sep 2, 1999 12:30 AM']
        ],
        m,
        i;

        for (i = 0; i < a.length; i++) {
            m = moment(a[i][1], a[i][0]);
            assert.ok(m.isValid());
            assert.equal(m.format(a[i][0]), a[i][1], a[i][0] + ' ---> ' + a[i][1]);
        }
    });

    test('2 digit year with YYYY format', function (assert) {
        assert.equal(moment('9/2/99', 'D/M/YYYY').format('DD/MM/YYYY'), '09/02/1999', 'D/M/YYYY ---> 9/2/99');
        assert.equal(moment('9/2/1999', 'D/M/YYYY').format('DD/MM/YYYY'), '09/02/1999', 'D/M/YYYY ---> 9/2/1999');
        assert.equal(moment('9/2/68', 'D/M/YYYY').format('DD/MM/YYYY'), '09/02/2068', 'D/M/YYYY ---> 9/2/68');
        assert.equal(moment('9/2/69', 'D/M/YYYY').format('DD/MM/YYYY'), '09/02/1969', 'D/M/YYYY ---> 9/2/69');
    });

    test('unix timestamp format', function (assert) {
        var formats = ['X', 'X.S', 'X.SS', 'X.SSS'], i, format;

        for (i = 0; i < formats.length; i++) {
            format = formats[i];
            assert.equal(moment('1234567890',     format).valueOf(), 1234567890 * 1000,       format + ' matches timestamp without milliseconds');
            assert.equal(moment('1234567890.1',   format).valueOf(), 1234567890 * 1000 + 100, format + ' matches timestamp with deciseconds');
            assert.equal(moment('1234567890.12',  format).valueOf(), 1234567890 * 1000 + 120, format + ' matches timestamp with centiseconds');
            assert.equal(moment('1234567890.123', format).valueOf(), 1234567890 * 1000 + 123, format + ' matches timestamp with milliseconds');
        }
    });

    test('unix offset milliseconds', function (assert) {
        assert.equal(moment('1234567890123', 'x').valueOf(), 1234567890123, 'x matches unix offset in milliseconds');
    });

    test('milliseconds format', function (assert) {
        assert.equal(moment('1', 'S').get('ms'), 100, 'deciseconds');
        // assert.equal(moment('10', 'S', true).isValid(), false, 'deciseconds with two digits');
        // assert.equal(moment('1', 'SS', true).isValid(), false, 'centiseconds with one digits');
        assert.equal(moment('12', 'SS').get('ms'), 120, 'centiseconds');
        // assert.equal(moment('123', 'SS', true).isValid(), false, 'centiseconds with three digits');
        assert.equal(moment('123', 'SSS').get('ms'), 123, 'milliseconds');
        assert.equal(moment('1234', 'SSSS').get('ms'), 123, 'milliseconds with SSSS');
        assert.equal(moment('123456789101112', 'SSSS').get('ms'), 123, 'milliseconds with SSSS');
    });

    test('string with format no separators', function (assert) {
        moment.locale('en');
        var a = [
            ['MMDDYYYY',          '12021999'],
            ['DDMMYYYY',          '12021999'],
            ['YYYYMMDD',          '19991202'],
            ['DDMMMYYYY',         '10Sep2001']
        ], i;

        for (i = 0; i < a.length; i++) {
            assert.equal(moment(a[i][1], a[i][0]).format(a[i][0]), a[i][1], a[i][0] + ' ---> ' + a[i][1]);
        }
    });

    test('string with format (timezone)', function (assert) {
        assert.equal(moment('5 -0700', 'H ZZ').toDate().getUTCHours(), 12, 'parse hours \'5 -0700\' ---> \'H ZZ\'');
        assert.equal(moment('5 -07:00', 'H Z').toDate().getUTCHours(), 12, 'parse hours \'5 -07:00\' ---> \'H Z\'');
        assert.equal(moment('5 -0730', 'H ZZ').toDate().getUTCMinutes(), 30, 'parse hours \'5 -0730\' ---> \'H ZZ\'');
        assert.equal(moment('5 -07:30', 'H Z').toDate().getUTCMinutes(), 30, 'parse hours \'5 -07:0\' ---> \'H Z\'');
        assert.equal(moment('5 +0100', 'H ZZ').toDate().getUTCHours(), 4, 'parse hours \'5 +0100\' ---> \'H ZZ\'');
        assert.equal(moment('5 +01:00', 'H Z').toDate().getUTCHours(), 4, 'parse hours \'5 +01:00\' ---> \'H Z\'');
        assert.equal(moment('5 +0130', 'H ZZ').toDate().getUTCMinutes(), 30, 'parse hours \'5 +0130\' ---> \'H ZZ\'');
        assert.equal(moment('5 +01:30', 'H Z').toDate().getUTCMinutes(), 30, 'parse hours \'5 +01:30\' ---> \'H Z\'');
    });

    test('string with format (timezone offset)', function (assert) {
        var a, b, c, d, e, f;
        a = new Date(Date.UTC(2011, 0, 1, 1));
        b = moment('2011 1 1 0 -01:00', 'YYYY MM DD HH Z');
        assert.equal(a.getHours(), b.hours(), 'date created with utc == parsed string with timezone offset');
        assert.equal(+a, +b, 'date created with utc == parsed string with timezone offset');
        c = moment('2011 2 1 10 -05:00', 'YYYY MM DD HH Z');
        d = moment('2011 2 1 8 -07:00', 'YYYY MM DD HH Z');
        assert.equal(c.hours(), d.hours(), '10 am central time == 8 am pacific time');
        e = moment.utc('Fri, 20 Jul 2012 17:15:00', 'ddd, DD MMM YYYY HH:mm:ss');
        f = moment.utc('Fri, 20 Jul 2012 10:15:00 -0700', 'ddd, DD MMM YYYY HH:mm:ss ZZ');
        assert.equal(e.hours(), f.hours(), 'parse timezone offset in utc');
    });

    test('string with timezone around start of year', function (assert) {
        assert.equal(moment('2000-01-01T00:00:00.000+01:00').toISOString(), '1999-12-31T23:00:00.000Z', '+1:00 around 2000');
        assert.equal(moment('2000-01-01T00:00:00.000-01:00').toISOString(), '2000-01-01T01:00:00.000Z', '-1:00 around 2000');
        assert.equal(moment('1970-01-01T00:00:00.000+01:00').toISOString(), '1969-12-31T23:00:00.000Z', '+1:00 around 1970');
        assert.equal(moment('1970-01-01T00:00:00.000-01:00').toISOString(), '1970-01-01T01:00:00.000Z', '-1:00 around 1970');
        assert.equal(moment('1200-01-01T00:00:00.000+01:00').toISOString(), '1199-12-31T23:00:00.000Z', '+1:00 around 1200');
        assert.equal(moment('1200-01-01T00:00:00.000-01:00').toISOString(), '1200-01-01T01:00:00.000Z', '-1:00 around 1200');
    });

    test('string with array of formats', function (assert) {
        assert.equal(moment('11-02-1999', ['MM-DD-YYYY', 'DD-MM-YYYY']).format('MM DD YYYY'), '11 02 1999', 'switching month and day');
        assert.equal(moment('02-11-1999', ['MM/DD/YYYY', 'YYYY MM DD', 'MM-DD-YYYY']).format('MM DD YYYY'), '02 11 1999', 'year last');
        assert.equal(moment('1999-02-11', ['MM/DD/YYYY', 'YYYY MM DD', 'MM-DD-YYYY']).format('MM DD YYYY'), '02 11 1999', 'year first');

        assert.equal(moment('02-11-1999', ['MM/DD/YYYY', 'YYYY MM DD']).format('MM DD YYYY'), '02 11 1999', 'year last');
        assert.equal(moment('1999-02-11', ['MM/DD/YYYY', 'YYYY MM DD']).format('MM DD YYYY'), '02 11 1999', 'year first');
        assert.equal(moment('02-11-1999', ['YYYY MM DD', 'MM/DD/YYYY']).format('MM DD YYYY'), '02 11 1999', 'year last');
        assert.equal(moment('1999-02-11', ['YYYY MM DD', 'MM/DD/YYYY']).format('MM DD YYYY'), '02 11 1999', 'year first');

        assert.equal(moment('13-11-1999', ['MM/DD/YYYY', 'DD/MM/YYYY']).format('MM DD YYYY'), '11 13 1999', 'second must be month');
        assert.equal(moment('11-13-1999', ['MM/DD/YYYY', 'DD/MM/YYYY']).format('MM DD YYYY'), '11 13 1999', 'first must be month');
        assert.equal(moment('01-02-2000', ['MM/DD/YYYY', 'DD/MM/YYYY']).format('MM DD YYYY'), '01 02 2000', 'either can be a month, month first format');
        assert.equal(moment('02-01-2000', ['DD/MM/YYYY', 'MM/DD/YYYY']).format('MM DD YYYY'), '01 02 2000', 'either can be a month, day first format');

        assert.equal(moment('11-02-10', ['MM/DD/YY', 'YY MM DD', 'DD-MM-YY']).format('MM DD YYYY'), '02 11 2010', 'all unparsed substrings have influence on format penalty');
        assert.equal(moment('11-02-10', ['MM-DD-YY HH:mm', 'YY MM DD']).format('MM DD YYYY'), '02 10 2011', 'prefer formats without extra tokens');
        assert.equal(moment('11-02-10 junk', ['MM-DD-YY', 'YY.MM.DD junk']).format('MM DD YYYY'), '02 10 2011', 'prefer formats that dont result in extra characters');
        assert.equal(moment('11-22-10', ['YY-MM-DD', 'YY-DD-MM']).format('MM DD YYYY'), '10 22 2011', 'prefer valid results');

        assert.equal(moment('gibberish', ['YY-MM-DD', 'YY-DD-MM']).format('MM DD YYYY'), 'Invalid date', 'doest throw for invalid strings');
        assert.equal(moment('gibberish', []).format('MM DD YYYY'), 'Invalid date', 'doest throw for an empty array');

        //https://github.com/moment/moment/issues/1143
        assert.equal(moment(
            'System Administrator and Database Assistant (7/1/2011), System Administrator and Database Assistant (7/1/2011), Database Coordinator (7/1/2011), Vice President (7/1/2011), System Administrator and Database Assistant (5/31/2012), Database Coordinator (7/1/2012), System Administrator and Database Assistant (7/1/2013)',
            ['MM/DD/YYYY', 'MM-DD-YYYY', 'YYYY-MM-DD', 'YYYY-MM-DDTHH:mm:ssZ'])
            .format('YYYY-MM-DD'), '2011-07-01', 'Works for long strings');

        assert.equal(moment('11-02-10', ['MM.DD.YY', 'DD-MM-YY']).format('MM DD YYYY'), '02 11 2010', 'escape RegExp special characters on comparing');

        assert.equal(moment('13-10-98', ['DD MM YY', 'DD MM YYYY'])._f, 'DD MM YY', 'use two digit year');
        assert.equal(moment('13-10-1998', ['DD MM YY', 'DD MM YYYY'])._f, 'DD MM YYYY', 'use four digit year');

        assert.equal(moment('01', ['MM', 'DD'])._f, 'MM', 'Should use first valid format');
    });

    test('string with array of formats + ISO', function (assert) {
        assert.equal(moment('1994', [moment.ISO_8601, 'MM', 'HH:mm', 'YYYY']).year(), 1994, 'iso: assert parse YYYY');
        assert.equal(moment('17:15', [moment.ISO_8601, 'MM', 'HH:mm', 'YYYY']).hour(), 17, 'iso: assert parse HH:mm (1)');
        assert.equal(moment('17:15', [moment.ISO_8601, 'MM', 'HH:mm', 'YYYY']).minutes(), 15, 'iso: assert parse HH:mm (2)');
        assert.equal(moment('06', [moment.ISO_8601, 'MM', 'HH:mm', 'YYYY']).month(), 6 - 1, 'iso: assert parse MM');
        assert.equal(moment('2012-06-01', [moment.ISO_8601, 'MM', 'HH:mm', 'YYYY']).parsingFlags().iso, true, 'iso: assert parse iso');
        assert.equal(moment('2014-05-05', [moment.ISO_8601, 'YYYY-MM-DD']).parsingFlags().iso, true, 'iso: edge case array precedence iso');
        assert.equal(moment('2014-05-05', ['YYYY-MM-DD', moment.ISO_8601]).parsingFlags().iso, false, 'iso: edge case array precedence not iso');
    });

    test('string with format - years', function (assert) {
        assert.equal(moment('67', 'YY').format('YYYY'), '2067', '67 > 2067');
        assert.equal(moment('68', 'YY').format('YYYY'), '2068', '68 > 2068');
        assert.equal(moment('69', 'YY').format('YYYY'), '1969', '69 > 1969');
        assert.equal(moment('70', 'YY').format('YYYY'), '1970', '70 > 1970');
    });

    test('implicit cloning', function (assert) {
        var momentA = moment([2011, 10, 10]),
        momentB = moment(momentA);
        momentA.month(5);
        assert.equal(momentB.month(), 10, 'Calling moment() on a moment will create a clone');
        assert.equal(momentA.month(), 5, 'Calling moment() on a moment will create a clone');
    });

    test('explicit cloning', function (assert) {
        var momentA = moment([2011, 10, 10]),
        momentB = momentA.clone();
        momentA.month(5);
        assert.equal(momentB.month(), 10, 'Calling moment() on a moment will create a clone');
        assert.equal(momentA.month(), 5, 'Calling moment() on a moment will create a clone');
    });

    test('cloning carrying over utc mode', function (assert) {
        assert.equal(moment().local().clone()._isUTC, false, 'An explicit cloned local moment should have _isUTC == false');
        assert.equal(moment().utc().clone()._isUTC, true, 'An cloned utc moment should have _isUTC == true');
        assert.equal(moment().clone()._isUTC, false, 'An explicit cloned local moment should have _isUTC == false');
        assert.equal(moment.utc().clone()._isUTC, true, 'An explicit cloned utc moment should have _isUTC == true');
        assert.equal(moment(moment().local())._isUTC, false, 'An implicit cloned local moment should have _isUTC == false');
        assert.equal(moment(moment().utc())._isUTC, true, 'An implicit cloned utc moment should have _isUTC == true');
        assert.equal(moment(moment())._isUTC, false, 'An implicit cloned local moment should have _isUTC == false');
        assert.equal(moment(moment.utc())._isUTC, true, 'An implicit cloned utc moment should have _isUTC == true');
    });

    test('parsing iso', function (assert) {
        var offset = moment([2011, 9, 8]).utcOffset(),
        pad = function (input) {
            if (input < 10) {
                return '0' + input;
            }
            return '' + input;
        },
        hourOffset = (offset > 0 ? Math.floor(offset / 60) : Math.ceil(offset / 60)),
        minOffset = offset - (hourOffset * 60),
        tz = (offset >= 0) ?
            '+' + pad(hourOffset) + ':' + pad(minOffset) :
            '-' + pad(-hourOffset) + ':' + pad(-minOffset),
        tz2 = tz.replace(':', ''),
        tz3 = tz2.slice(0, 3),
        //Tz3 removes minutes digit so will break the tests when parsed if they all use the same minutes digit
        minutesForTz3 = pad((4 + minOffset) % 60),
        minute = pad(4 + minOffset),

        formats = [
            ['2011-10-08',                    '2011-10-08T00:00:00.000' + tz],
            ['2011-10-08T18',                 '2011-10-08T18:00:00.000' + tz],
            ['2011-10-08T18:04',              '2011-10-08T18:04:00.000' + tz],
            ['2011-10-08T18:04:20',           '2011-10-08T18:04:20.000' + tz],
            ['2011-10-08T18:04' + tz,         '2011-10-08T18:04:00.000' + tz],
            ['2011-10-08T18:04:20' + tz,      '2011-10-08T18:04:20.000' + tz],
            ['2011-10-08T18:04' + tz2,        '2011-10-08T18:04:00.000' + tz],
            ['2011-10-08T18:04:20' + tz2,     '2011-10-08T18:04:20.000' + tz],
            ['2011-10-08T18:04' + tz3,        '2011-10-08T18:' + minutesForTz3 + ':00.000' + tz],
            ['2011-10-08T18:04:20' + tz3,     '2011-10-08T18:' + minutesForTz3 + ':20.000' + tz],
            ['2011-10-08T18:04:20.1' + tz2,   '2011-10-08T18:04:20.100' + tz],
            ['2011-10-08T18:04:20.11' + tz2,  '2011-10-08T18:04:20.110' + tz],
            ['2011-10-08T18:04:20.111' + tz2, '2011-10-08T18:04:20.111' + tz],
            ['2011-10-08 18',                 '2011-10-08T18:00:00.000' + tz],
            ['2011-10-08 18:04',              '2011-10-08T18:04:00.000' + tz],
            ['2011-10-08 18:04:20',           '2011-10-08T18:04:20.000' + tz],
            ['2011-10-08 18:04' + tz,         '2011-10-08T18:04:00.000' + tz],
            ['2011-10-08 18:04:20' + tz,      '2011-10-08T18:04:20.000' + tz],
            ['2011-10-08 18:04' + tz2,        '2011-10-08T18:04:00.000' + tz],
            ['2011-10-08 18:04:20' + tz2,     '2011-10-08T18:04:20.000' + tz],
            ['2011-10-08 18:04' + tz3,        '2011-10-08T18:' + minutesForTz3 + ':00.000' + tz],
            ['2011-10-08 18:04:20' + tz3,     '2011-10-08T18:' + minutesForTz3 + ':20.000' + tz],
            ['2011-10-08 18:04:20.1' + tz2,   '2011-10-08T18:04:20.100' + tz],
            ['2011-10-08 18:04:20.11' + tz2,  '2011-10-08T18:04:20.110' + tz],
            ['2011-10-08 18:04:20.111' + tz2, '2011-10-08T18:04:20.111' + tz],
            ['2011-W40',                      '2011-10-03T00:00:00.000' + tz],
            ['2011-W40-6',                    '2011-10-08T00:00:00.000' + tz],
            ['2011-W40-6T18',                 '2011-10-08T18:00:00.000' + tz],
            ['2011-W40-6T18:04',              '2011-10-08T18:04:00.000' + tz],
            ['2011-W40-6T18:04:20',           '2011-10-08T18:04:20.000' + tz],
            ['2011-W40-6T18:04' + tz,         '2011-10-08T18:04:00.000' + tz],
            ['2011-W40-6T18:04:20' + tz,      '2011-10-08T18:04:20.000' + tz],
            ['2011-W40-6T18:04' + tz2,        '2011-10-08T18:04:00.000' + tz],
            ['2011-W40-6T18:04:20' + tz2,     '2011-10-08T18:04:20.000' + tz],
            ['2011-W40-6T18:04' + tz3,        '2011-10-08T18:' + minutesForTz3 + ':00.000' + tz],
            ['2011-W40-6T18:04:20' + tz3,     '2011-10-08T18:' + minutesForTz3 + ':20.000' + tz],
            ['2011-W40-6T18:04:20.1' + tz2,   '2011-10-08T18:04:20.100' + tz],
            ['2011-W40-6T18:04:20.11' + tz2,  '2011-10-08T18:04:20.110' + tz],
            ['2011-W40-6T18:04:20.111' + tz2, '2011-10-08T18:04:20.111' + tz],
            ['2011-W40-6 18',                 '2011-10-08T18:00:00.000' + tz],
            ['2011-W40-6 18:04',              '2011-10-08T18:04:00.000' + tz],
            ['2011-W40-6 18:04:20',           '2011-10-08T18:04:20.000' + tz],
            ['2011-W40-6 18:04' + tz,         '2011-10-08T18:04:00.000' + tz],
            ['2011-W40-6 18:04:20' + tz,      '2011-10-08T18:04:20.000' + tz],
            ['2011-W40-6 18:04' + tz2,        '2011-10-08T18:04:00.000' + tz],
            ['2011-W40-6 18:04:20' + tz2,     '2011-10-08T18:04:20.000' + tz],
            ['2011-W40-6 18:04' + tz3,        '2011-10-08T18:' + minutesForTz3 + ':00.000' + tz],
            ['2011-W40-6 18:04:20' + tz3,     '2011-10-08T18:' + minutesForTz3 + ':20.000' + tz],
            ['2011-W40-6 18:04:20.1' + tz2,   '2011-10-08T18:04:20.100' + tz],
            ['2011-W40-6 18:04:20.11' + tz2,  '2011-10-08T18:04:20.110' + tz],
            ['2011-W40-6 18:04:20.111' + tz2, '2011-10-08T18:04:20.111' + tz],
            ['2011-281',                      '2011-10-08T00:00:00.000' + tz],
            ['2011-281T18',                   '2011-10-08T18:00:00.000' + tz],
            ['2011-281T18:04',                '2011-10-08T18:04:00.000' + tz],
            ['2011-281T18:04:20',             '2011-10-08T18:04:20.000' + tz],
            ['2011-281T18:04' + tz,           '2011-10-08T18:04:00.000' + tz],
            ['2011-281T18:04:20' + tz,        '2011-10-08T18:04:20.000' + tz],
            ['2011-281T18:04' + tz2,          '2011-10-08T18:04:00.000' + tz],
            ['2011-281T18:04:20' + tz2,       '2011-10-08T18:04:20.000' + tz],
            ['2011-281T18:04' + tz3,          '2011-10-08T18:' + minutesForTz3 + ':00.000' + tz],
            ['2011-281T18:04:20' + tz3,       '2011-10-08T18:' + minutesForTz3 + ':20.000' + tz],
            ['2011-281T18:04:20.1' + tz2,     '2011-10-08T18:04:20.100' + tz],
            ['2011-281T18:04:20.11' + tz2,    '2011-10-08T18:04:20.110' + tz],
            ['2011-281T18:04:20.111' + tz2,   '2011-10-08T18:04:20.111' + tz],
            ['2011-281 18',                   '2011-10-08T18:00:00.000' + tz],
            ['2011-281 18:04',                '2011-10-08T18:04:00.000' + tz],
            ['2011-281 18:04:20',             '2011-10-08T18:04:20.000' + tz],
            ['2011-281 18:04' + tz,           '2011-10-08T18:04:00.000' + tz],
            ['2011-281 18:04:20' + tz,        '2011-10-08T18:04:20.000' + tz],
            ['2011-281 18:04' + tz2,          '2011-10-08T18:04:00.000' + tz],
            ['2011-281 18:04:20' + tz2,       '2011-10-08T18:04:20.000' + tz],
            ['2011-281 18:04' + tz3,          '2011-10-08T18:' + minutesForTz3 + ':00.000' + tz],
            ['2011-281 18:04:20' + tz3,       '2011-10-08T18:' + minutesForTz3 + ':20.000' + tz],
            ['2011-281 18:04:20.1' + tz2,     '2011-10-08T18:04:20.100' + tz],
            ['2011-281 18:04:20.11' + tz2,    '2011-10-08T18:04:20.110' + tz],
            ['2011-281 18:04:20.111' + tz2,   '2011-10-08T18:04:20.111' + tz],
            ['20111008T18',                   '2011-10-08T18:00:00.000' + tz],
            ['20111008T1804',                 '2011-10-08T18:04:00.000' + tz],
            ['20111008T180420',               '2011-10-08T18:04:20.000' + tz],
            ['20111008T1804' + tz,            '2011-10-08T18:04:00.000' + tz],
            ['20111008T180420' + tz,          '2011-10-08T18:04:20.000' + tz],
            ['20111008T1804' + tz2,           '2011-10-08T18:04:00.000' + tz],
            ['20111008T180420' + tz2,         '2011-10-08T18:04:20.000' + tz],
            ['20111008T1804' + tz3,           '2011-10-08T18:' + minutesForTz3 + ':00.000' + tz],
            ['20111008T180420' + tz3,         '2011-10-08T18:' + minutesForTz3 + ':20.000' + tz],
            ['20111008T180420,1' + tz2,       '2011-10-08T18:04:20.100' + tz],
            ['20111008T180420,11' + tz2,      '2011-10-08T18:04:20.110' + tz],
            ['20111008T180420,111' + tz2,     '2011-10-08T18:04:20.111' + tz],
            ['20111008 18',                   '2011-10-08T18:00:00.000' + tz],
            ['20111008 1804',                 '2011-10-08T18:04:00.000' + tz],
            ['20111008 180420',               '2011-10-08T18:04:20.000' + tz],
            ['20111008 1804' + tz,            '2011-10-08T18:04:00.000' + tz],
            ['20111008 180420' + tz,          '2011-10-08T18:04:20.000' + tz],
            ['20111008 1804' + tz2,           '2011-10-08T18:04:00.000' + tz],
            ['20111008 180420' + tz2,         '2011-10-08T18:04:20.000' + tz],
            ['20111008 1804' + tz3,           '2011-10-08T18:' + minutesForTz3 + ':00.000' + tz],
            ['20111008 180420' + tz3,         '2011-10-08T18:' + minutesForTz3 + ':20.000' + tz],
            ['20111008 180420,1' + tz2,       '2011-10-08T18:04:20.100' + tz],
            ['20111008 180420,11' + tz2,      '2011-10-08T18:04:20.110' + tz],
            ['20111008 180420,111' + tz2,     '2011-10-08T18:04:20.111' + tz],
            ['2011W40',                       '2011-10-03T00:00:00.000' + tz],
            ['2011W406',                      '2011-10-08T00:00:00.000' + tz],
            ['2011W406T18',                   '2011-10-08T18:00:00.000' + tz],
            ['2011W406T1804',                 '2011-10-08T18:04:00.000' + tz],
            ['2011W406T180420',               '2011-10-08T18:04:20.000' + tz],
            ['2011W406 1804' + tz2,           '2011-10-08T18:04:00.000' + tz],
            ['2011W406T1804' + tz,            '2011-10-08T18:04:00.000' + tz],
            ['2011W406T180420' + tz,          '2011-10-08T18:04:20.000' + tz],
            ['2011W406T1804' + tz2,           '2011-10-08T18:04:00.000' + tz],
            ['2011W406T180420' + tz2,         '2011-10-08T18:04:20.000' + tz],
            ['2011W406T1804' + tz3,           '2011-10-08T18:' + minutesForTz3 + ':00.000' + tz],
            ['2011W406T180420' + tz3,         '2011-10-08T18:' + minutesForTz3 + ':20.000' + tz],
            ['2011W406T180420,1' + tz2,       '2011-10-08T18:04:20.100' + tz],
            ['2011W406T180420,11' + tz2,      '2011-10-08T18:04:20.110' + tz],
            ['2011W406T180420,111' + tz2,     '2011-10-08T18:04:20.111' + tz],
            ['2011W406 18',                   '2011-10-08T18:00:00.000' + tz],
            ['2011W406 1804',                 '2011-10-08T18:04:00.000' + tz],
            ['2011W406 180420',               '2011-10-08T18:04:20.000' + tz],
            ['2011W406 1804' + tz,            '2011-10-08T18:04:00.000' + tz],
            ['2011W406 180420' + tz,          '2011-10-08T18:04:20.000' + tz],
            ['2011W406 180420' + tz2,         '2011-10-08T18:04:20.000' + tz],
            ['2011W406 1804' + tz3,           '2011-10-08T18:' + minutesForTz3 + ':00.000' + tz],
            ['2011W406 180420' + tz3,         '2011-10-08T18:' + minutesForTz3 + ':20.000' + tz],
            ['2011W406 180420,1' + tz2,       '2011-10-08T18:04:20.100' + tz],
            ['2011W406 180420,11' + tz2,      '2011-10-08T18:04:20.110' + tz],
            ['2011W406 180420,111' + tz2,     '2011-10-08T18:04:20.111' + tz],
            ['2011281',                       '2011-10-08T00:00:00.000' + tz],
            ['2011281T18',                    '2011-10-08T18:00:00.000' + tz],
            ['2011281T1804',                  '2011-10-08T18:04:00.000' + tz],
            ['2011281T180420',                '2011-10-08T18:04:20.000' + tz],
            ['2011281T1804' + tz,             '2011-10-08T18:04:00.000' + tz],
            ['2011281T180420' + tz,           '2011-10-08T18:04:20.000' + tz],
            ['2011281T1804' + tz2,            '2011-10-08T18:04:00.000' + tz],
            ['2011281T180420' + tz2,          '2011-10-08T18:04:20.000' + tz],
            ['2011281T1804' + tz3,            '2011-10-08T18:' + minutesForTz3 + ':00.000' + tz],
            ['2011281T180420' + tz3,          '2011-10-08T18:' + minutesForTz3 + ':20.000' + tz],
            ['2011281T180420,1' + tz2,        '2011-10-08T18:04:20.100' + tz],
            ['2011281T180420,11' + tz2,       '2011-10-08T18:04:20.110' + tz],
            ['2011281T180420,111' + tz2,      '2011-10-08T18:04:20.111' + tz],
            ['2011281 18',                    '2011-10-08T18:00:00.000' + tz],
            ['2011281 1804',                  '2011-10-08T18:04:00.000' + tz],
            ['2011281 180420',                '2011-10-08T18:04:20.000' + tz],
            ['2011281 1804' + tz,             '2011-10-08T18:04:00.000' + tz],
            ['2011281 180420' + tz,           '2011-10-08T18:04:20.000' + tz],
            ['2011281 1804' + tz2,            '2011-10-08T18:04:00.000' + tz],
            ['2011281 180420' + tz2,          '2011-10-08T18:04:20.000' + tz],
            ['2011281 1804' + tz3,            '2011-10-08T18:' + minutesForTz3 + ':00.000' + tz],
            ['2011281 180420' + tz3,          '2011-10-08T18:' + minutesForTz3 + ':20.000' + tz],
            ['2011281 180420,1' + tz2,        '2011-10-08T18:04:20.100' + tz],
            ['2011281 180420,11' + tz2,       '2011-10-08T18:04:20.110' + tz],
            ['2011281 180420,111' + tz2,      '2011-10-08T18:04:20.111' + tz]
        ], i;
        for (i = 0; i < formats.length; i++) {
            assert.equal(moment(formats[i][0]).format('YYYY-MM-DDTHH:mm:ss.SSSZ'),
                    formats[i][1], 'moment should be able to parse ISO ' + formats[i][0]);
            assert.equal(moment(formats[i][0], moment.ISO_8601).format('YYYY-MM-DDTHH:mm:ss.SSSZ'),
                    formats[i][1], 'moment should be able to parse specified ISO ' + formats[i][0]);
            assert.equal(moment(formats[i][0], moment.ISO_8601, true).format('YYYY-MM-DDTHH:mm:ss.SSSZ'),
                    formats[i][1], 'moment should be able to parse specified strict ISO ' + formats[i][0]);
        }
    });

    test('non iso 8601 strings', function (assert) {
        assert.ok(!moment('2015-10T10:15', moment.ISO_8601, true).isValid(), 'incomplete date with time');
        assert.ok(!moment('2015-W10T10:15', moment.ISO_8601, true).isValid(), 'incomplete week date with time');
        assert.ok(!moment('201510', moment.ISO_8601, true).isValid(), 'basic YYYYMM is not allowed');
        assert.ok(!moment('2015W10T1015', moment.ISO_8601, true).isValid(), 'incomplete week date with time (basic)');
        assert.ok(!moment('2015-10-08T1015', moment.ISO_8601, true).isValid(), 'mixing extended and basic format');
        assert.ok(!moment('20151008T10:15', moment.ISO_8601, true).isValid(), 'mixing basic and extended format');
    });

    test('parsing iso week year/week/weekday', function (assert) {
        assert.equal(moment.utc('2007-W01').format(), '2007-01-01T00:00:00Z', '2008 week 1 (1st Jan Mon)');
        assert.equal(moment.utc('2008-W01').format(), '2007-12-31T00:00:00Z', '2008 week 1 (1st Jan Tue)');
        assert.equal(moment.utc('2003-W01').format(), '2002-12-30T00:00:00Z', '2008 week 1 (1st Jan Wed)');
        assert.equal(moment.utc('2009-W01').format(), '2008-12-29T00:00:00Z', '2009 week 1 (1st Jan Thu)');
        assert.equal(moment.utc('2010-W01').format(), '2010-01-04T00:00:00Z', '2010 week 1 (1st Jan Fri)');
        assert.equal(moment.utc('2011-W01').format(), '2011-01-03T00:00:00Z', '2011 week 1 (1st Jan Sat)');
        assert.equal(moment.utc('2012-W01').format(), '2012-01-02T00:00:00Z', '2012 week 1 (1st Jan Sun)');
    });

    test('parsing week year/week/weekday (dow 1, doy 4)', function (assert) {
        moment.locale('dow:1,doy:4', {week: {dow: 1, doy: 4}});

        assert.equal(moment.utc('2007-01', 'gggg-ww').format(), '2007-01-01T00:00:00Z', '2007 week 1 (1st Jan Mon)');
        assert.equal(moment.utc('2008-01', 'gggg-ww').format(), '2007-12-31T00:00:00Z', '2008 week 1 (1st Jan Tue)');
        assert.equal(moment.utc('2003-01', 'gggg-ww').format(), '2002-12-30T00:00:00Z', '2003 week 1 (1st Jan Wed)');
        assert.equal(moment.utc('2009-01', 'gggg-ww').format(), '2008-12-29T00:00:00Z', '2009 week 1 (1st Jan Thu)');
        assert.equal(moment.utc('2010-01', 'gggg-ww').format(), '2010-01-04T00:00:00Z', '2010 week 1 (1st Jan Fri)');
        assert.equal(moment.utc('2011-01', 'gggg-ww').format(), '2011-01-03T00:00:00Z', '2011 week 1 (1st Jan Sat)');
        assert.equal(moment.utc('2012-01', 'gggg-ww').format(), '2012-01-02T00:00:00Z', '2012 week 1 (1st Jan Sun)');

        moment.defineLocale('dow:1,doy:4', null);
    });

    test('parsing week year/week/weekday (dow 1, doy 7)', function (assert) {
        moment.locale('dow:1,doy:7', {week: {dow: 1, doy: 7}});

        assert.equal(moment.utc('2007-01', 'gggg-ww').format(), '2007-01-01T00:00:00Z', '2007 week 1 (1st Jan Mon)');
        assert.equal(moment.utc('2008-01', 'gggg-ww').format(), '2007-12-31T00:00:00Z', '2008 week 1 (1st Jan Tue)');
        assert.equal(moment.utc('2003-01', 'gggg-ww').format(), '2002-12-30T00:00:00Z', '2003 week 1 (1st Jan Wed)');
        assert.equal(moment.utc('2009-01', 'gggg-ww').format(), '2008-12-29T00:00:00Z', '2009 week 1 (1st Jan Thu)');
        assert.equal(moment.utc('2010-01', 'gggg-ww').format(), '2009-12-28T00:00:00Z', '2010 week 1 (1st Jan Fri)');
        assert.equal(moment.utc('2011-01', 'gggg-ww').format(), '2010-12-27T00:00:00Z', '2011 week 1 (1st Jan Sat)');
        assert.equal(moment.utc('2012-01', 'gggg-ww').format(), '2011-12-26T00:00:00Z', '2012 week 1 (1st Jan Sun)');
        moment.defineLocale('dow:1,doy:7', null);
    });

    test('parsing week year/week/weekday (dow 0, doy 6)', function (assert) {
        moment.locale('dow:0,doy:6', {week: {dow: 0, doy: 6}});

        assert.equal(moment.utc('2007-01', 'gggg-ww').format(), '2006-12-31T00:00:00Z', '2007 week 1 (1st Jan Mon)');
        assert.equal(moment.utc('2008-01', 'gggg-ww').format(), '2007-12-30T00:00:00Z', '2008 week 1 (1st Jan Tue)');
        assert.equal(moment.utc('2003-01', 'gggg-ww').format(), '2002-12-29T00:00:00Z', '2003 week 1 (1st Jan Wed)');
        assert.equal(moment.utc('2009-01', 'gggg-ww').format(), '2008-12-28T00:00:00Z', '2009 week 1 (1st Jan Thu)');
        assert.equal(moment.utc('2010-01', 'gggg-ww').format(), '2009-12-27T00:00:00Z', '2010 week 1 (1st Jan Fri)');
        assert.equal(moment.utc('2011-01', 'gggg-ww').format(), '2010-12-26T00:00:00Z', '2011 week 1 (1st Jan Sat)');
        assert.equal(moment.utc('2012-01', 'gggg-ww').format(), '2012-01-01T00:00:00Z', '2012 week 1 (1st Jan Sun)');
        moment.defineLocale('dow:0,doy:6', null);
    });

    test('parsing week year/week/weekday (dow 6, doy 12)', function (assert) {
        moment.locale('dow:6,doy:12', {week: {dow: 6, doy: 12}});

        assert.equal(moment.utc('2007-01', 'gggg-ww').format(), '2006-12-30T00:00:00Z', '2007 week 1 (1st Jan Mon)');
        assert.equal(moment.utc('2008-01', 'gggg-ww').format(), '2007-12-29T00:00:00Z', '2008 week 1 (1st Jan Tue)');
        assert.equal(moment.utc('2003-01', 'gggg-ww').format(), '2002-12-28T00:00:00Z', '2003 week 1 (1st Jan Wed)');
        assert.equal(moment.utc('2009-01', 'gggg-ww').format(), '2008-12-27T00:00:00Z', '2009 week 1 (1st Jan Thu)');
        assert.equal(moment.utc('2010-01', 'gggg-ww').format(), '2009-12-26T00:00:00Z', '2010 week 1 (1st Jan Fri)');
        assert.equal(moment.utc('2011-01', 'gggg-ww').format(), '2011-01-01T00:00:00Z', '2011 week 1 (1st Jan Sat)');
        assert.equal(moment.utc('2012-01', 'gggg-ww').format(), '2011-12-31T00:00:00Z', '2012 week 1 (1st Jan Sun)');
        moment.defineLocale('dow:6,doy:12', null);
    });

    test('parsing ISO with Z', function (assert) {
        var i, mom, formats = [
            ['2011-10-08T18:04',             '2011-10-08T18:04:00.000'],
            ['2011-10-08T18:04:20',          '2011-10-08T18:04:20.000'],
            ['2011-10-08T18:04:20.1',        '2011-10-08T18:04:20.100'],
            ['2011-10-08T18:04:20.11',       '2011-10-08T18:04:20.110'],
            ['2011-10-08T18:04:20.111',      '2011-10-08T18:04:20.111'],
            ['2011-W40-6T18',                '2011-10-08T18:00:00.000'],
            ['2011-W40-6T18:04',             '2011-10-08T18:04:00.000'],
            ['2011-W40-6T18:04:20',          '2011-10-08T18:04:20.000'],
            ['2011-W40-6T18:04:20.1',        '2011-10-08T18:04:20.100'],
            ['2011-W40-6T18:04:20.11',       '2011-10-08T18:04:20.110'],
            ['2011-W40-6T18:04:20.111',      '2011-10-08T18:04:20.111'],
            ['2011-281T18',                  '2011-10-08T18:00:00.000'],
            ['2011-281T18:04',               '2011-10-08T18:04:00.000'],
            ['2011-281T18:04:20',            '2011-10-08T18:04:20.000'],
            ['2011-281T18:04:20',            '2011-10-08T18:04:20.000'],
            ['2011-281T18:04:20.1',          '2011-10-08T18:04:20.100'],
            ['2011-281T18:04:20.11',         '2011-10-08T18:04:20.110'],
            ['2011-281T18:04:20.111',        '2011-10-08T18:04:20.111']
        ];

        for (i = 0; i < formats.length; i++) {
            mom = moment(formats[i][0] + 'Z').utc();
            assert.equal(mom.format('YYYY-MM-DDTHH:mm:ss.SSS'), formats[i][1], 'moment should be able to parse ISO in UTC ' + formats[i][0] + 'Z');

            mom = moment(formats[i][0] + ' Z').utc();
            assert.equal(mom.format('YYYY-MM-DDTHH:mm:ss.SSS'), formats[i][1], 'moment should be able to parse ISO in UTC ' + formats[i][0] + ' Z');
        }
    });

    test('parsing iso with T', function (assert) {
        assert.equal(moment('2011-10-08T18')._f, 'YYYY-MM-DDTHH', 'should include \'T\' in the format');
        assert.equal(moment('2011-10-08T18:20')._f, 'YYYY-MM-DDTHH:mm', 'should include \'T\' in the format');
        assert.equal(moment('2011-10-08T18:20:13')._f, 'YYYY-MM-DDTHH:mm:ss', 'should include \'T\' in the format');
        assert.equal(moment('2011-10-08T18:20:13.321')._f, 'YYYY-MM-DDTHH:mm:ss.SSSS', 'should include \'T\' in the format');

        assert.equal(moment('2011-10-08 18')._f, 'YYYY-MM-DD HH', 'should not include \'T\' in the format');
        assert.equal(moment('2011-10-08 18:20')._f, 'YYYY-MM-DD HH:mm', 'should not include \'T\' in the format');
        assert.equal(moment('2011-10-08 18:20:13')._f, 'YYYY-MM-DD HH:mm:ss', 'should not include \'T\' in the format');
        assert.equal(moment('2011-10-08 18:20:13.321')._f, 'YYYY-MM-DD HH:mm:ss.SSSS', 'should not include \'T\' in the format');
    });

    test('parsing iso Z timezone', function (assert) {
        var i,
        formats = [
            ['2011-10-08T18:04Z',             '2011-10-08T18:04:00.000+00:00'],
            ['2011-10-08T18:04:20Z',          '2011-10-08T18:04:20.000+00:00'],
            ['2011-10-08T18:04:20.111Z',      '2011-10-08T18:04:20.111+00:00']
        ];
        for (i = 0; i < formats.length; i++) {
            assert.equal(moment.utc(formats[i][0]).format('YYYY-MM-DDTHH:mm:ss.SSSZ'), formats[i][1], 'moment should be able to parse ISO ' + formats[i][0]);
        }
    });

    test('parsing iso Z timezone into local', function (assert) {
        var m = moment('2011-10-08T18:04:20.111Z');

        assert.equal(m.utc().format('YYYY-MM-DDTHH:mm:ss.SSS'), '2011-10-08T18:04:20.111', 'moment should be able to parse ISO 2011-10-08T18:04:20.111Z');
    });

    test('parsing iso with more subsecond precision digits', function (assert) {
        assert.equal(moment.utc('2013-07-31T22:00:00.0000000Z').format(), '2013-07-31T22:00:00Z', 'more than 3 subsecond digits');
    });

    test('null or empty', function (assert) {
        assert.equal(moment('').isValid(), false, 'moment(\'\') is not valid');
        assert.equal(moment(null).isValid(), false, 'moment(null) is not valid');
        assert.equal(moment(null, 'YYYY-MM-DD').isValid(), false, 'moment(\'\', \'format\') is not valid');
        assert.equal(moment('', 'YYYY-MM-DD').isValid(), false, 'moment(\'\', \'format\') is not valid');
        assert.equal(moment.utc('').isValid(), false, 'moment.utc(\'\') is not valid');
        assert.equal(moment.utc(null).isValid(), false, 'moment.utc(null) is not valid');
        assert.equal(moment.utc(null, 'YYYY-MM-DD').isValid(), false, 'moment.utc(null) is not valid');
        assert.equal(moment.utc('', 'YYYY-MM-DD').isValid(), false, 'moment.utc(\'\', \'YYYY-MM-DD\') is not valid');
    });

    test('first century', function (assert) {
        assert.equal(moment([0, 0, 1]).format('YYYY-MM-DD'), '0000-01-01', 'Year AD 0');
        assert.equal(moment([99, 0, 1]).format('YYYY-MM-DD'), '0099-01-01', 'Year AD 99');
        assert.equal(moment([999, 0, 1]).format('YYYY-MM-DD'), '0999-01-01', 'Year AD 999');
        assert.equal(moment('0 1 1', 'YYYY MM DD').format('YYYY-MM-DD'), '0000-01-01', 'Year AD 0');
        assert.equal(moment('999 1 1', 'YYYY MM DD').format('YYYY-MM-DD'), '0999-01-01', 'Year AD 999');
        assert.equal(moment('0 1 1', 'YYYYY MM DD').format('YYYYY-MM-DD'), '00000-01-01', 'Year AD 0');
        assert.equal(moment('99 1 1', 'YYYYY MM DD').format('YYYYY-MM-DD'), '00099-01-01', 'Year AD 99');
        assert.equal(moment('999 1 1', 'YYYYY MM DD').format('YYYYY-MM-DD'), '00999-01-01', 'Year AD 999');
    });

    test('six digit years', function (assert) {
        assert.equal(moment([-270000, 0, 1]).format('YYYYY-MM-DD'), '-270000-01-01', 'format BC 270,001');
        assert.equal(moment([270000, 0, 1]).format('YYYYY-MM-DD'), '270000-01-01', 'format AD 270,000');
        assert.equal(moment('-270000-01-01', 'YYYYY-MM-DD').toDate().getFullYear(), -270000, 'parse BC 270,001');
        assert.equal(moment('270000-01-01',  'YYYYY-MM-DD').toDate().getFullYear(), 270000, 'parse AD 270,000');
        assert.equal(moment('+270000-01-01', 'YYYYY-MM-DD').toDate().getFullYear(), 270000, 'parse AD +270,000');
        assert.equal(moment.utc('-270000-01-01', 'YYYYY-MM-DD').toDate().getUTCFullYear(), -270000, 'parse utc BC 270,001');
        assert.equal(moment.utc('270000-01-01',  'YYYYY-MM-DD').toDate().getUTCFullYear(), 270000, 'parse utc AD 270,000');
        assert.equal(moment.utc('+270000-01-01', 'YYYYY-MM-DD').toDate().getUTCFullYear(), 270000, 'parse utc AD +270,000');
    });

    test('negative four digit years', function (assert) {
        assert.equal(moment('-1000-01-01', 'YYYYY-MM-DD').toDate().getFullYear(), -1000, 'parse BC 1,001');
        assert.equal(moment.utc('-1000-01-01', 'YYYYY-MM-DD').toDate().getUTCFullYear(), -1000, 'parse utc BC 1,001');
    });

    test('strict parsing', function (assert) {
        assert.equal(moment('2014-', 'YYYY-Q', true).isValid(), false, 'fail missing quarter');

        assert.equal(moment('2012-05', 'YYYY-MM', true).format('YYYY-MM'), '2012-05', 'parse correct string');
        assert.equal(moment(' 2012-05', 'YYYY-MM', true).isValid(), false, 'fail on extra whitespace');
        assert.equal(moment('foo 2012-05', '[foo] YYYY-MM', true).format('YYYY-MM'), '2012-05', 'handle fixed text');
        assert.equal(moment('2012 05', 'YYYY-MM', true).isValid(), false, 'fail on different separator');
        assert.equal(moment('2012 05', 'YYYY MM DD', true).isValid(), false, 'fail on too many tokens');

        assert.equal(moment('05 30 2010', ['DD MM YYYY', 'MM DD YYYY'], true).format('MM DD YYYY'), '05 30 2010', 'array with bad date');
        assert.equal(moment('05 30 2010', ['', 'MM DD YYYY'], true).format('MM DD YYYY'), '05 30 2010', 'array with invalid format');
        assert.equal(moment('05 30 2010', [' DD MM YYYY', 'MM DD YYYY'], true).format('MM DD YYYY'), '05 30 2010', 'array with non-matching format');

        assert.equal(moment('2010.*...', 'YYYY.*', true).isValid(), false, 'invalid format with regex chars');
        assert.equal(moment('2010.*', 'YYYY.*', true).year(), 2010, 'valid format with regex chars');
        assert.equal(moment('.*2010.*', '.*YYYY.*', true).year(), 2010, 'valid format with regex chars on both sides');

        //strict tokens
        assert.equal(moment('-5-05-25', 'YYYY-MM-DD', true).isValid(), false, 'invalid negative year');
        assert.equal(moment('2-05-25', 'YYYY-MM-DD', true).isValid(), false, 'invalid one-digit year');
        assert.equal(moment('20-05-25', 'YYYY-MM-DD', true).isValid(), false, 'invalid two-digit year');
        assert.equal(moment('201-05-25', 'YYYY-MM-DD', true).isValid(), false, 'invalid three-digit year');
        assert.equal(moment('2010-05-25', 'YYYY-MM-DD', true).isValid(), true, 'valid four-digit year');
        assert.equal(moment('22010-05-25', 'YYYY-MM-DD', true).isValid(), false, 'invalid five-digit year');

        assert.equal(moment('12-05-25', 'YY-MM-DD', true).isValid(), true, 'valid two-digit year');
        assert.equal(moment('2012-05-25', 'YY-MM-DD', true).isValid(), false, 'invalid four-digit year');

        assert.equal(moment('-5-05-25', 'Y-MM-DD', true).isValid(), true, 'valid negative year');
        assert.equal(moment('2-05-25', 'Y-MM-DD', true).isValid(), true, 'valid one-digit year');
        assert.equal(moment('20-05-25', 'Y-MM-DD', true).isValid(), true, 'valid two-digit year');
        assert.equal(moment('201-05-25', 'Y-MM-DD', true).isValid(), true, 'valid three-digit year');

        assert.equal(moment('2012-5-25', 'YYYY-M-DD', true).isValid(), true, 'valid one-digit month');
        assert.equal(moment('2012-5-25', 'YYYY-MM-DD', true).isValid(), false, 'invalid one-digit month');
        assert.equal(moment('2012-05-25', 'YYYY-M-DD', true).isValid(), true, 'valid one-digit month');
        assert.equal(moment('2012-05-25', 'YYYY-MM-DD', true).isValid(), true, 'valid one-digit month');

        assert.equal(moment('2012-05-2', 'YYYY-MM-D', true).isValid(), true, 'valid one-digit day');
        assert.equal(moment('2012-05-2', 'YYYY-MM-DD', true).isValid(), false, 'invalid one-digit day');
        assert.equal(moment('2012-05-02', 'YYYY-MM-D', true).isValid(), true, 'valid two-digit day');
        assert.equal(moment('2012-05-02', 'YYYY-MM-DD', true).isValid(), true, 'valid two-digit day');

        assert.equal(moment('+002012-05-25', 'YYYYY-MM-DD', true).isValid(), true, 'valid six-digit year');
        assert.equal(moment('+2012-05-25', 'YYYYY-MM-DD', true).isValid(), false, 'invalid four-digit year');

        //thse are kinda pointless, but they should work as expected
        assert.equal(moment('1', 'S', true).isValid(), true, 'valid one-digit milisecond');
        assert.equal(moment('12', 'S', true).isValid(), false, 'invalid two-digit milisecond');
        assert.equal(moment('123', 'S', true).isValid(), false, 'invalid three-digit milisecond');

        assert.equal(moment('1', 'SS', true).isValid(), false, 'invalid one-digit milisecond');
        assert.equal(moment('12', 'SS', true).isValid(), true, 'valid two-digit milisecond');
        assert.equal(moment('123', 'SS', true).isValid(), false, 'invalid three-digit milisecond');

        assert.equal(moment('1', 'SSS', true).isValid(), false, 'invalid one-digit milisecond');
        assert.equal(moment('12', 'SSS', true).isValid(), false, 'invalid two-digit milisecond');
        assert.equal(moment('123', 'SSS', true).isValid(), true, 'valid three-digit milisecond');

        // strict parsing respects month length
        assert.ok(moment('1 January 2000', 'D MMMM YYYY', true).isValid(), 'capital long-month + MMMM');
        assert.ok(!moment('1 January 2000', 'D MMM YYYY', true).isValid(), 'capital long-month + MMM');
        assert.ok(!moment('1 Jan 2000', 'D MMMM YYYY', true).isValid(), 'capital short-month + MMMM');
        assert.ok(moment('1 Jan 2000', 'D MMM YYYY', true).isValid(), 'capital short-month + MMM');
        assert.ok(moment('1 january 2000', 'D MMMM YYYY', true).isValid(), 'lower long-month + MMMM');
        assert.ok(!moment('1 january 2000', 'D MMM YYYY', true).isValid(), 'lower long-month + MMM');
        assert.ok(!moment('1 jan 2000', 'D MMMM YYYY', true).isValid(), 'lower short-month + MMMM');
        assert.ok(moment('1 jan 2000', 'D MMM YYYY', true).isValid(), 'lower short-month + MMM');
    });

    test('parsing into a locale', function (assert) {
        moment.defineLocale('parselocale', {
            months : 'one_two_three_four_five_six_seven_eight_nine_ten_eleven_twelve'.split('_'),
            monthsShort : 'one_two_three_four_five_six_seven_eight_nine_ten_eleven_twelve'.split('_')
        });

        moment.locale('en');

        assert.equal(moment('2012 seven', 'YYYY MMM', 'parselocale').month(), 6, 'should be able to parse in a specific locale');

        moment.locale('parselocale');

        assert.equal(moment('2012 july', 'YYYY MMM', 'en').month(), 6, 'should be able to parse in a specific locale');

        moment.defineLocale('parselocale', null);
    });

    function getVerifier(test) {
        return function (input, format, expected, description, asymetrical) {
            var m = moment(input, format);
            test.equal(m.format('YYYY MM DD'), expected, 'compare: ' + description);

            //test round trip
            if (!asymetrical) {
                test.equal(m.format(format), input, 'round trip: ' + description);
            }
        };
    }

    test('parsing week and weekday information', function (assert) {
        var ver = getVerifier(assert);

        // year
        ver('12', 'gg', '2012 01 01', 'week-year two digits');
        ver('2012', 'gggg', '2012 01 01', 'week-year four digits');

        ver('99', 'gg', '1998 12 27', 'week-year two digits previous year');
        ver('1999', 'gggg', '1998 12 27', 'week-year four digits previous year');

        ver('99', 'GG', '1999 01 04', 'iso week-year two digits');
        ver('1999', 'GGGG', '1999 01 04', 'iso week-year four digits');

        ver('13', 'GG', '2012 12 31', 'iso week-year two digits previous year');
        ver('2013', 'GGGG', '2012 12 31', 'iso week-year four digits previous year');

        // year + week
        ver('1999 37', 'gggg w', '1999 09 05', 'week');
        ver('1999 37', 'gggg ww', '1999 09 05', 'week double');
        ver('1999 37', 'GGGG W', '1999 09 13', 'iso week');
        ver('1999 37', 'GGGG WW', '1999 09 13', 'iso week double');

        ver('1999 37 4', 'GGGG WW E', '1999 09 16', 'iso day');
        ver('1999 37 04', 'GGGG WW E', '1999 09 16', 'iso day wide', true);

        ver('1999 37 4', 'gggg ww e', '1999 09 09', 'day');
        ver('1999 37 04', 'gggg ww e', '1999 09 09', 'day wide', true);

        // year + week + day
        ver('1999 37 4', 'gggg ww d', '1999 09 09', 'd');
        ver('1999 37 Th', 'gggg ww dd', '1999 09 09', 'dd');
        ver('1999 37 Thu', 'gggg ww ddd', '1999 09 09', 'ddd');
        ver('1999 37 Thursday', 'gggg ww dddd', '1999 09 09', 'dddd');

        // lower-order only
        assert.equal(moment('22', 'ww').week(), 22, 'week sets the week by itself');
        assert.equal(moment('22', 'ww').weekYear(), moment().weekYear(), 'week keeps this year');
        assert.equal(moment('2012 22', 'YYYY ww').weekYear(), 2012, 'week keeps parsed year');

        assert.equal(moment('22', 'WW').isoWeek(), 22, 'iso week sets the week by itself');
        assert.equal(moment('2012 22', 'YYYY WW').weekYear(), 2012, 'iso week keeps parsed year');
        assert.equal(moment('22', 'WW').isoWeekYear(), moment().isoWeekYear(), 'iso week keeps this year');

        // order
        ver('6 2013 2', 'e gggg w', '2013 01 12', 'order doesn\'t matter');
        ver('6 2013 2', 'E GGGG W', '2013 01 12', 'iso order doesn\'t matter');

        //can parse other stuff too
        assert.equal(moment('1999-W37-4 3:30', 'GGGG-[W]WW-E HH:mm').format('YYYY MM DD HH:mm'), '1999 09 16 03:30', 'parsing weeks and hours');

        // In safari, all years before 1300 are shifted back with one day.
        // http://stackoverflow.com/questions/20768975/safari-subtracts-1-day-from-dates-before-1300
        if (new Date('1300-01-01').getUTCFullYear() === 1300) {
            // Years less than 100
            ver('0098-06', 'GGGG-WW', '0098 02 03', 'small years work', true);
        }
    });

    test('parsing localized weekdays', function (assert) {
        var ver = getVerifier(assert);
        try {
            moment.locale('dow:1,doy:4', {
                weekdays : 'dimanche_lundi_mardi_mercredi_jeudi_vendredi_samedi'.split('_'),
                weekdaysShort : 'dim._lun._mar._mer._jeu._ven._sam.'.split('_'),
                weekdaysMin : 'Di_Lu_Ma_Me_Je_Ve_Sa'.split('_'),
                week: {dow: 1, doy: 4}
            });
            ver('1999 37 4', 'GGGG WW E', '1999 09 16', 'iso ignores locale');
            ver('1999 37 7', 'GGGG WW E', '1999 09 19', 'iso ignores locale');

            ver('1999 37 0', 'gggg ww e', '1999 09 13', 'localized e uses local doy and dow: 0 = monday');
            ver('1999 37 4', 'gggg ww e', '1999 09 17', 'localized e uses local doy and dow: 4 = friday');

            ver('1999 37 1', 'gggg ww d', '1999 09 13', 'localized d uses 0-indexed days: 1 = monday');
            ver('1999 37 Lu', 'gggg ww dd', '1999 09 13', 'localized d uses 0-indexed days: Mo');
            ver('1999 37 lun.', 'gggg ww ddd', '1999 09 13', 'localized d uses 0-indexed days: Mon');
            ver('1999 37 lundi', 'gggg ww dddd', '1999 09 13', 'localized d uses 0-indexed days: Monday');
            ver('1999 37 4', 'gggg ww d', '1999 09 16', 'localized d uses 0-indexed days: 4');

            //sunday goes at the end of the week
            ver('1999 37 0', 'gggg ww d', '1999 09 19', 'localized d uses 0-indexed days: 0 = sund');
            ver('1999 37 Di', 'gggg ww dd', '1999 09 19', 'localized d uses 0-indexed days: 0 = sund');
        }
        finally {
            moment.defineLocale('dow:1,doy:4', null);
            moment.locale('en');
        }
    });

    test('parsing with customized two-digit year', function (assert) {
        var original = moment.parseTwoDigitYear;
        try {
            assert.equal(moment('68', 'YY').year(), 2068);
            assert.equal(moment('69', 'YY').year(), 1969);
            moment.parseTwoDigitYear = function (input) {
                return +input + (+input > 30 ? 1900 : 2000);
            };
            assert.equal(moment('68', 'YY').year(), 1968);
            assert.equal(moment('67', 'YY').year(), 1967);
            assert.equal(moment('31', 'YY').year(), 1931);
            assert.equal(moment('30', 'YY').year(), 2030);
        }
        finally {
            moment.parseTwoDigitYear = original;
        }
    });

    test('array with strings', function (assert) {
        assert.equal(moment(['2014', '7', '31']).isValid(), true, 'string array + isValid');
    });

    test('object with strings', function (assert) {
        assert.equal(moment({year: '2014', month: '7', day: '31'}).isValid(), true, 'string object + isValid');
    });

    test('utc with array of formats', function (assert) {
        assert.equal(moment.utc('2014-01-01', ['YYYY-MM-DD', 'YYYY-MM']).format(), '2014-01-01T00:00:00Z', 'moment.utc works with array of formats');
    });

    test('parsing invalid string weekdays', function (assert) {
        assert.equal(false, moment('a', 'dd').isValid(),
                'dd with invalid weekday, non-strict');
        assert.equal(false, moment('a', 'dd', true).isValid(),
                'dd with invalid weekday, strict');
        assert.equal(false, moment('a', 'ddd').isValid(),
                'ddd with invalid weekday, non-strict');
        assert.equal(false, moment('a', 'ddd', true).isValid(),
                'ddd with invalid weekday, strict');
        assert.equal(false, moment('a', 'dddd').isValid(),
                'dddd with invalid weekday, non-strict');
        assert.equal(false, moment('a', 'dddd', true).isValid(),
                'dddd with invalid weekday, strict');
    });

    test('milliseconds', function (assert) {
        assert.equal(moment('1', 'S').millisecond(), 100);
        assert.equal(moment('12', 'SS').millisecond(), 120);
        assert.equal(moment('123', 'SSS').millisecond(), 123);
        assert.equal(moment('1234', 'SSSS').millisecond(), 123);
        assert.equal(moment('12345', 'SSSSS').millisecond(), 123);
        assert.equal(moment('123456', 'SSSSSS').millisecond(), 123);
        assert.equal(moment('1234567', 'SSSSSSS').millisecond(), 123);
        assert.equal(moment('12345678', 'SSSSSSSS').millisecond(), 123);
        assert.equal(moment('123456789', 'SSSSSSSSS').millisecond(), 123);
    });

    test('hmm', function (assert) {
        assert.equal(moment('123', 'hmm', true).format('HH:mm:ss'), '01:23:00', '123 with hmm');
        assert.equal(moment('123a', 'hmmA', true).format('HH:mm:ss'), '01:23:00', '123a with hmmA');
        assert.equal(moment('123p', 'hmmA', true).format('HH:mm:ss'), '13:23:00', '123p with hmmA');

        assert.equal(moment('1234', 'hmm', true).format('HH:mm:ss'), '12:34:00', '1234 with hmm');
        assert.equal(moment('1234a', 'hmmA', true).format('HH:mm:ss'), '00:34:00', '1234a with hmmA');
        assert.equal(moment('1234p', 'hmmA', true).format('HH:mm:ss'), '12:34:00', '1234p with hmmA');

        assert.equal(moment('12345', 'hmmss', true).format('HH:mm:ss'), '01:23:45', '12345 with hmmss');
        assert.equal(moment('12345a', 'hmmssA', true).format('HH:mm:ss'), '01:23:45', '12345a with hmmssA');
        assert.equal(moment('12345p', 'hmmssA', true).format('HH:mm:ss'), '13:23:45', '12345p with hmmssA');
        assert.equal(moment('112345', 'hmmss', true).format('HH:mm:ss'), '11:23:45', '112345 with hmmss');
        assert.equal(moment('112345a', 'hmmssA', true).format('HH:mm:ss'), '11:23:45', '112345a with hmmssA');
        assert.equal(moment('112345p', 'hmmssA', true).format('HH:mm:ss'), '23:23:45', '112345p with hmmssA');

        assert.equal(moment('023', 'Hmm', true).format('HH:mm:ss'), '00:23:00', '023 with Hmm');
        assert.equal(moment('123', 'Hmm', true).format('HH:mm:ss'), '01:23:00', '123 with Hmm');
        assert.equal(moment('1234', 'Hmm', true).format('HH:mm:ss'), '12:34:00', '1234 with Hmm');
        assert.equal(moment('1534', 'Hmm', true).format('HH:mm:ss'), '15:34:00', '1234 with Hmm');
        assert.equal(moment('12345', 'Hmmss', true).format('HH:mm:ss'), '01:23:45', '12345 with Hmmss');
        assert.equal(moment('112345', 'Hmmss', true).format('HH:mm:ss'), '11:23:45', '112345 with Hmmss');
        assert.equal(moment('172345', 'Hmmss', true).format('HH:mm:ss'), '17:23:45', '112345 with Hmmss');
    });

    test('Y token', function (assert) {
        assert.equal(moment('1-1-2010', 'M-D-Y', true).year(), 2010, 'parsing Y');
    });

    test('parsing flags retain parsed date parts', function (assert) {
        var a = moment('10 p', 'hh:mm a');
        assert.equal(a.parsingFlags().parsedDateParts[3], 10, 'parsed 10 as the hour');
        assert.equal(a.parsingFlags().parsedDateParts[0], undefined, 'year was not parsed');
        assert.equal(a.parsingFlags().meridiem, 'p', 'meridiem flag was added');
        var b = moment('10:30', ['MMDDYY', 'HH:mm']);
        assert.equal(b.parsingFlags().parsedDateParts[3], 10, 'multiple format parshing matched hour');
        assert.equal(b.parsingFlags().parsedDateParts[0], undefined, 'array is properly copied, no residual data from first token parse');
    });

    test('parsing only meridiem results in invalid date', function (assert) {
        assert.ok(!moment('alkj', 'hh:mm a').isValid(), 'because an a token is used, a meridiem will be parsed but nothing else was so invalid');
        assert.ok(moment('02:30 p more extra stuff', 'hh:mm a').isValid(), 'because other tokens were parsed, date is valid');
        assert.ok(moment('1/1/2016 extra data', ['a', 'M/D/YYYY']).isValid(), 'took second format, does not pick up on meridiem parsed from first format (good copy)');
    });

}));

;(function (global, factory) {
   typeof exports === 'object' && typeof module !== 'undefined'
       && typeof require === 'function' ? factory(require('../../moment')) :
   typeof define === 'function' && define.amd ? define(['../../moment'], factory) :
   factory(global.moment)
}(this, function (moment) { 'use strict';

    function each(array, callback) {
        var i;
        for (i = 0; i < array.length; i++) {
            callback(array[i], i, array);
        }
    }

    function objectKeys(obj) {
        if (Object.keys) {
            return Object.keys(obj);
        } else {
            // IE8
            var res = [], i;
            for (i in obj) {
                if (obj.hasOwnProperty(i)) {
                    res.push(i);
                }
            }
            return res;
        }
    }

    // Pick the first defined of two or three arguments.
    function defaults(a, b, c) {
        if (a != null) {
            return a;
        }
        if (b != null) {
            return b;
        }
        return c;
    }

    function defineCommonLocaleTests(locale, options) {
        test('lenient ordinal parsing', function (assert) {
            var i, ordinalStr, testMoment;
            for (i = 1; i <= 31; ++i) {
                ordinalStr = moment([2014, 0, i]).format('YYYY MM Do');
                testMoment = moment(ordinalStr, 'YYYY MM Do');
                assert.equal(testMoment.year(), 2014,
                        'lenient ordinal parsing ' + i + ' year check');
                assert.equal(testMoment.month(), 0,
                        'lenient ordinal parsing ' + i + ' month check');
                assert.equal(testMoment.date(), i,
                        'lenient ordinal parsing ' + i + ' date check');
            }
        });

        test('lenient ordinal parsing of number', function (assert) {
            var i, testMoment;
            for (i = 1; i <= 31; ++i) {
                testMoment = moment('2014 01 ' + i, 'YYYY MM Do');
                assert.equal(testMoment.year(), 2014,
                        'lenient ordinal parsing of number ' + i + ' year check');
                assert.equal(testMoment.month(), 0,
                        'lenient ordinal parsing of number ' + i + ' month check');
                assert.equal(testMoment.date(), i,
                        'lenient ordinal parsing of number ' + i + ' date check');
            }
        });

        test('strict ordinal parsing', function (assert) {
            var i, ordinalStr, testMoment;
            for (i = 1; i <= 31; ++i) {
                ordinalStr = moment([2014, 0, i]).format('YYYY MM Do');
                testMoment = moment(ordinalStr, 'YYYY MM Do', true);
                assert.ok(testMoment.isValid(), 'strict ordinal parsing ' + i);
            }
        });

        test('meridiem invariant', function (assert) {
            var h, m, t1, t2;
            for (h = 0; h < 24; ++h) {
                for (m = 0; m < 60; m += 15) {
                    t1 = moment.utc([2000, 0, 1, h, m]);
                    t2 = moment.utc(t1.format('A h:mm'), 'A h:mm');
                    assert.equal(t2.format('HH:mm'), t1.format('HH:mm'),
                            'meridiem at ' + t1.format('HH:mm'));
                }
            }
        });

        test('date format correctness', function (assert) {
            var data, tokens;
            data = moment.localeData()._longDateFormat;
            tokens = objectKeys(data);
            each(tokens, function (srchToken) {
                // Check each format string to make sure it does not contain any
                // tokens that need to be expanded.
                each(tokens, function (baseToken) {
                    // strip escaped sequences
                    var format = data[baseToken].replace(/(\[[^\]]*\])/g, '');
                    assert.equal(false, !!~format.indexOf(srchToken),
                            'contains ' + srchToken + ' in ' + baseToken);
                });
            });
        });

        test('month parsing correctness', function (assert) {
            var i, m;

            if (locale === 'tr') {
                // I can't fix it :(
                expect(0);
                return;
            }
            function tester(format) {
                var r;
                r = moment(m.format(format), format);
                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format);
                r = moment(m.format(format).toLocaleUpperCase(), format);
                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' upper');
                r = moment(m.format(format).toLocaleLowerCase(), format);
                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' lower');

                r = moment(m.format(format), format, true);
                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' strict');
                r = moment(m.format(format).toLocaleUpperCase(), format, true);
                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' upper strict');
                r = moment(m.format(format).toLocaleLowerCase(), format, true);
                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' lower strict');
            }

            for (i = 0; i < 12; ++i) {
                m = moment([2015, i, 15, 18]);
                tester('MMM');
                tester('MMM.');
                tester('MMMM');
                tester('MMMM.');
            }
        });

        test('weekday parsing correctness', function (assert) {
            var i, m;

            if (locale === 'tr' || locale === 'az') {
                // There is a lower-case letter (Ä±), that converted to upper then
                // lower changes to i
                expect(0);
                return;
            }
            function tester(format) {
                var r, baseMsg = 'weekday ' + m.weekday() + ' fmt ' + format;
                r = moment(m.format(format), format);
                assert.equal(r.weekday(), m.weekday(), baseMsg);
                r = moment(m.format(format).toLocaleUpperCase(), format);
                assert.equal(r.weekday(), m.weekday(), baseMsg + ' upper');
                r = moment(m.format(format).toLocaleLowerCase(), format);
                assert.equal(r.weekday(), m.weekday(), baseMsg + ' lower');

                r = moment(m.format(format), format, true);
                assert.equal(r.weekday(), m.weekday(), baseMsg + ' strict');
                r = moment(m.format(format).toLocaleUpperCase(), format, true);
                assert.equal(r.weekday(), m.weekday(), baseMsg + ' upper strict');
                r = moment(m.format(format).toLocaleLowerCase(), format, true);
                assert.equal(r.weekday(), m.weekday(), baseMsg + ' lower strict');
            }

            for (i = 0; i < 7; ++i) {
                m = moment.utc([2015, i, 15, 18]);
                tester('dd');
                tester('ddd');
                tester('dddd');
            }
        });
    }

    function setupDeprecationHandler(test, moment, scope) {
        test._expectedDeprecations = null;
        test._observedDeprecations = null;
        test._oldSupress = moment.suppressDeprecationWarnings;
        moment.suppressDeprecationWarnings = true;
        test.expectedDeprecations = function () {
            test._expectedDeprecations = arguments;
            test._observedDeprecations = [];
        };
        moment.deprecationHandler = function (name, msg) {
            var deprecationId = matchedDeprecation(name, msg, test._expectedDeprecations);
            if (deprecationId === -1) {
                throw new Error('Unexpected deprecation thrown name=' +
                        name + ' msg=' + msg);
            }
            test._observedDeprecations[deprecationId] = 1;
        };
    }

    function teardownDeprecationHandler(test, moment, scope) {
        moment.suppressDeprecationWarnings = test._oldSupress;

        if (test._expectedDeprecations != null) {
            var missedDeprecations = [];
            each(test._expectedDeprecations, function (deprecationPattern, id) {
                if (test._observedDeprecations[id] !== 1) {
                    missedDeprecations.push(deprecationPattern);
                }
            });
            if (missedDeprecations.length !== 0) {
                throw new Error('Expected deprecation warnings did not happen: ' +
                        missedDeprecations.join(' '));
            }
        }
    }

    function matchedDeprecation(name, msg, deprecations) {
        if (deprecations == null) {
            return -1;
        }
        for (var i = 0; i < deprecations.length; ++i) {
            if (name != null && name === deprecations[i]) {
                return i;
            }
            if (msg != null && msg.substring(0, deprecations[i].length) === deprecations[i]) {
                return i;
            }
        }
        return -1;
    }

    /*global QUnit:false*/

    var test = QUnit.test;

    var expect = QUnit.expect;

    function module (name, lifecycle) {
        QUnit.module(name, {
            setup : function () {
                moment.locale('en');
                moment.createFromInputFallback = function (config) {
                    throw new Error('input not handled by moment: ' + config._i);
                };
                setupDeprecationHandler(test, moment, 'core');
                if (lifecycle && lifecycle.setup) {
                    lifecycle.setup();
                }
            },
            teardown : function () {
                teardownDeprecationHandler(test, moment, 'core');
                if (lifecycle && lifecycle.teardown) {
                    lifecycle.teardown();
                }
            }
        });
    }

    function localeModule (name, lifecycle) {
        QUnit.module('locale:' + name, {
            setup : function () {
                moment.locale(name);
                moment.createFromInputFallback = function (config) {
                    throw new Error('input not handled by moment: ' + config._i);
                };
                setupDeprecationHandler(test, moment, 'locale');
                if (lifecycle && lifecycle.setup) {
                    lifecycle.setup();
                }
            },
            teardown : function () {
                moment.locale('en');
                teardownDeprecationHandler(test, moment, 'locale');
                if (lifecycle && lifecycle.teardown) {
                    lifecycle.teardown();
                }
            }
        });
        defineCommonLocaleTests(name, -1, -1);
    }

    module('creation data');

    test('valid date', function (assert) {
        var dat = moment('1992-10-22');
        var orig = dat.creationData();

        assert.equal(dat.isValid(), true, '1992-10-22 is valid');
        assert.equal(orig.input, '1992-10-22', 'original input is not correct.');
        assert.equal(orig.format, 'YYYY-MM-DD', 'original format is defined.');
        assert.equal(orig.locale._abbr, 'en', 'default locale is en');
        assert.equal(orig.isUTC, false, 'not a UTC date');
    });

    test('valid date at fr locale', function (assert) {
        var dat = moment('1992-10-22', 'YYYY-MM-DD', 'fr');
        var orig = dat.creationData();

        assert.equal(orig.locale._abbr, 'fr', 'locale is fr');
    });

    test('valid date with formats', function (assert) {
        var dat = moment('29-06-1995', ['MM-DD-YYYY', 'DD-MM', 'DD-MM-YYYY']);
        var orig = dat.creationData();

        assert.equal(orig.format, 'DD-MM-YYYY', 'DD-MM-YYYY format is defined.');
    });

    test('strict', function (assert) {
        assert.ok(moment('2015-01-02', 'YYYY-MM-DD', true).creationData().strict, 'strict is true');
        assert.ok(!moment('2015-01-02', 'YYYY-MM-DD').creationData().strict, 'strict is true');
    });

}));

;(function (global, factory) {
   typeof exports === 'object' && typeof module !== 'undefined'
       && typeof require === 'function' ? factory(require('../../moment')) :
   typeof define === 'function' && define.amd ? define(['../../moment'], factory) :
   factory(global.moment)
}(this, function (moment) { 'use strict';

    function each(array, callback) {
        var i;
        for (i = 0; i < array.length; i++) {
            callback(array[i], i, array);
        }
    }

    function objectKeys(obj) {
        if (Object.keys) {
            return Object.keys(obj);
        } else {
            // IE8
            var res = [], i;
            for (i in obj) {
                if (obj.hasOwnProperty(i)) {
                    res.push(i);
                }
            }
            return res;
        }
    }

    // Pick the first defined of two or three arguments.
    function defaults(a, b, c) {
        if (a != null) {
            return a;
        }
        if (b != null) {
            return b;
        }
        return c;
    }

    function defineCommonLocaleTests(locale, options) {
        test('lenient ordinal parsing', function (assert) {
            var i, ordinalStr, testMoment;
            for (i = 1; i <= 31; ++i) {
                ordinalStr = moment([2014, 0, i]).format('YYYY MM Do');
                testMoment = moment(ordinalStr, 'YYYY MM Do');
                assert.equal(testMoment.year(), 2014,
                        'lenient ordinal parsing ' + i + ' year check');
                assert.equal(testMoment.month(), 0,
                        'lenient ordinal parsing ' + i + ' month check');
                assert.equal(testMoment.date(), i,
                        'lenient ordinal parsing ' + i + ' date check');
            }
        });

        test('lenient ordinal parsing of number', function (assert) {
            var i, testMoment;
            for (i = 1; i <= 31; ++i) {
                testMoment = moment('2014 01 ' + i, 'YYYY MM Do');
                assert.equal(testMoment.year(), 2014,
                        'lenient ordinal parsing of number ' + i + ' year check');
                assert.equal(testMoment.month(), 0,
                        'lenient ordinal parsing of number ' + i + ' month check');
                assert.equal(testMoment.date(), i,
                        'lenient ordinal parsing of number ' + i + ' date check');
            }
        });

        test('strict ordinal parsing', function (assert) {
            var i, ordinalStr, testMoment;
            for (i = 1; i <= 31; ++i) {
                ordinalStr = moment([2014, 0, i]).format('YYYY MM Do');
                testMoment = moment(ordinalStr, 'YYYY MM Do', true);
                assert.ok(testMoment.isValid(), 'strict ordinal parsing ' + i);
            }
        });

        test('meridiem invariant', function (assert) {
            var h, m, t1, t2;
            for (h = 0; h < 24; ++h) {
                for (m = 0; m < 60; m += 15) {
                    t1 = moment.utc([2000, 0, 1, h, m]);
                    t2 = moment.utc(t1.format('A h:mm'), 'A h:mm');
                    assert.equal(t2.format('HH:mm'), t1.format('HH:mm'),
                            'meridiem at ' + t1.format('HH:mm'));
                }
            }
        });

        test('date format correctness', function (assert) {
            var data, tokens;
            data = moment.localeData()._longDateFormat;
            tokens = objectKeys(data);
            each(tokens, function (srchToken) {
                // Check each format string to make sure it does not contain any
                // tokens that need to be expanded.
                each(tokens, function (baseToken) {
                    // strip escaped sequences
                    var format = data[baseToken].replace(/(\[[^\]]*\])/g, '');
                    assert.equal(false, !!~format.indexOf(srchToken),
                            'contains ' + srchToken + ' in ' + baseToken);
                });
            });
        });

        test('month parsing correctness', function (assert) {
            var i, m;

            if (locale === 'tr') {
                // I can't fix it :(
                expect(0);
                return;
            }
            function tester(format) {
                var r;
                r = moment(m.format(format), format);
                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format);
                r = moment(m.format(format).toLocaleUpperCase(), format);
                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' upper');
                r = moment(m.format(format).toLocaleLowerCase(), format);
                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' lower');

                r = moment(m.format(format), format, true);
                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' strict');
                r = moment(m.format(format).toLocaleUpperCase(), format, true);
                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' upper strict');
                r = moment(m.format(format).toLocaleLowerCase(), format, true);
                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' lower strict');
            }

            for (i = 0; i < 12; ++i) {
                m = moment([2015, i, 15, 18]);
                tester('MMM');
                tester('MMM.');
                tester('MMMM');
                tester('MMMM.');
            }
        });

        test('weekday parsing correctness', function (assert) {
            var i, m;

            if (locale === 'tr' || locale === 'az') {
                // There is a lower-case letter (Ä±), that converted to upper then
                // lower changes to i
                expect(0);
                return;
            }
            function tester(format) {
                var r, baseMsg = 'weekday ' + m.weekday() + ' fmt ' + format;
                r = moment(m.format(format), format);
                assert.equal(r.weekday(), m.weekday(), baseMsg);
                r = moment(m.format(format).toLocaleUpperCase(), format);
                assert.equal(r.weekday(), m.weekday(), baseMsg + ' upper');
                r = moment(m.format(format).toLocaleLowerCase(), format);
                assert.equal(r.weekday(), m.weekday(), baseMsg + ' lower');

                r = moment(m.format(format), format, true);
                assert.equal(r.weekday(), m.weekday(), baseMsg + ' strict');
                r = moment(m.format(format).toLocaleUpperCase(), format, true);
                assert.equal(r.weekday(), m.weekday(), baseMsg + ' upper strict');
                r = moment(m.format(format).toLocaleLowerCase(), format, true);
                assert.equal(r.weekday(), m.weekday(), baseMsg + ' lower strict');
            }

            for (i = 0; i < 7; ++i) {
                m = moment.utc([2015, i, 15, 18]);
                tester('dd');
                tester('ddd');
                tester('dddd');
            }
        });
    }

    function setupDeprecationHandler(test, moment, scope) {
        test._expectedDeprecations = null;
        test._observedDeprecations = null;
        test._oldSupress = moment.suppressDeprecationWarnings;
        moment.suppressDeprecationWarnings = true;
        test.expectedDeprecations = function () {
            test._expectedDeprecations = arguments;
            test._observedDeprecations = [];
        };
        moment.deprecationHandler = function (name, msg) {
            var deprecationId = matchedDeprecation(name, msg, test._expectedDeprecations);
            if (deprecationId === -1) {
                throw new Error('Unexpected deprecation thrown name=' +
                        name + ' msg=' + msg);
            }
            test._observedDeprecations[deprecationId] = 1;
        };
    }

    function teardownDeprecationHandler(test, moment, scope) {
        moment.suppressDeprecationWarnings = test._oldSupress;

        if (test._expectedDeprecations != null) {
            var missedDeprecations = [];
            each(test._expectedDeprecations, function (deprecationPattern, id) {
                if (test._observedDeprecations[id] !== 1) {
                    missedDeprecations.push(deprecationPattern);
                }
            });
            if (missedDeprecations.length !== 0) {
                throw new Error('Expected deprecation warnings did not happen: ' +
                        missedDeprecations.join(' '));
            }
        }
    }

    function matchedDeprecation(name, msg, deprecations) {
        if (deprecations == null) {
            return -1;
        }
        for (var i = 0; i < deprecations.length; ++i) {
            if (name != null && name === deprecations[i]) {
                return i;
            }
            if (msg != null && msg.substring(0, deprecations[i].length) === deprecations[i]) {
                return i;
            }
        }
        return -1;
    }

    /*global QUnit:false*/

    var test = QUnit.test;

    var expect = QUnit.expect;

    function module (name, lifecycle) {
        QUnit.module(name, {
            setup : function () {
                moment.locale('en');
                moment.createFromInputFallback = function (config) {
                    throw new Error('input not handled by moment: ' + config._i);
                };
                setupDeprecationHandler(test, moment, 'core');
                if (lifecycle && lifecycle.setup) {
                    lifecycle.setup();
                }
            },
            teardown : function () {
                teardownDeprecationHandler(test, moment, 'core');
                if (lifecycle && lifecycle.teardown) {
                    lifecycle.teardown();
                }
            }
        });
    }

    function localeModule (name, lifecycle) {
        QUnit.module('locale:' + name, {
            setup : function () {
                moment.locale(name);
                moment.createFromInputFallback = function (config) {
                    throw new Error('input not handled by moment: ' + config._i);
                };
                setupDeprecationHandler(test, moment, 'locale');
                if (lifecycle && lifecycle.setup) {
                    lifecycle.setup();
                }
            },
            teardown : function () {
                moment.locale('en');
                teardownDeprecationHandler(test, moment, 'locale');
                if (lifecycle && lifecycle.teardown) {
                    lifecycle.teardown();
                }
            }
        });
        defineCommonLocaleTests(name, -1, -1);
    }

    module('days in month');

    test('days in month', function (assert) {
        each([31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31], function (days, i) {
            var firstDay = moment([2012, i]),
                lastDay  = moment([2012, i, days]);
            assert.equal(firstDay.daysInMonth(), days, firstDay.format('L') + ' should have ' + days + ' days.');
            assert.equal(lastDay.daysInMonth(), days, lastDay.format('L') + ' should have ' + days + ' days.');
        });
    });

    test('days in month leap years', function (assert) {
        assert.equal(moment([2010, 1]).daysInMonth(), 28, 'Feb 2010 should have 28 days');
        assert.equal(moment([2100, 1]).daysInMonth(), 28, 'Feb 2100 should have 28 days');
        assert.equal(moment([2008, 1]).daysInMonth(), 29, 'Feb 2008 should have 29 days');
        assert.equal(moment([2000, 1]).daysInMonth(), 29, 'Feb 2000 should have 29 days');
    });

}));

;(function (global, factory) {
   typeof exports === 'object' && typeof module !== 'undefined'
       && typeof require === 'function' ? factory(require('../../moment')) :
   typeof define === 'function' && define.amd ? define(['../../moment'], factory) :
   factory(global.moment)
}(this, function (moment) { 'use strict';

    function each(array, callback) {
        var i;
        for (i = 0; i < array.length; i++) {
            callback(array[i], i, array);
        }
    }

    function objectKeys(obj) {
        if (Object.keys) {
            return Object.keys(obj);
        } else {
            // IE8
            var res = [], i;
            for (i in obj) {
                if (obj.hasOwnProperty(i)) {
                    res.push(i);
                }
            }
            return res;
        }
    }

    // Pick the first defined of two or three arguments.
    function defaults(a, b, c) {
        if (a != null) {
            return a;
        }
        if (b != null) {
            return b;
        }
        return c;
    }

    function defineCommonLocaleTests(locale, options) {
        test('lenient ordinal parsing', function (assert) {
            var i, ordinalStr, testMoment;
            for (i = 1; i <= 31; ++i) {
                ordinalStr = moment([2014, 0, i]).format('YYYY MM Do');
                testMoment = moment(ordinalStr, 'YYYY MM Do');
                assert.equal(testMoment.year(), 2014,
                        'lenient ordinal parsing ' + i + ' year check');
                assert.equal(testMoment.month(), 0,
                        'lenient ordinal parsing ' + i + ' month check');
                assert.equal(testMoment.date(), i,
                        'lenient ordinal parsing ' + i + ' date check');
            }
        });

        test('lenient ordinal parsing of number', function (assert) {
            var i, testMoment;
            for (i = 1; i <= 31; ++i) {
                testMoment = moment('2014 01 ' + i, 'YYYY MM Do');
                assert.equal(testMoment.year(), 2014,
                        'lenient ordinal parsing of number ' + i + ' year check');
                assert.equal(testMoment.month(), 0,
                        'lenient ordinal parsing of number ' + i + ' month check');
                assert.equal(testMoment.date(), i,
                        'lenient ordinal parsing of number ' + i + ' date check');
            }
        });

        test('strict ordinal parsing', function (assert) {
            var i, ordinalStr, testMoment;
            for (i = 1; i <= 31; ++i) {
                ordinalStr = moment([2014, 0, i]).format('YYYY MM Do');
                testMoment = moment(ordinalStr, 'YYYY MM Do', true);
                assert.ok(testMoment.isValid(), 'strict ordinal parsing ' + i);
            }
        });

        test('meridiem invariant', function (assert) {
            var h, m, t1, t2;
            for (h = 0; h < 24; ++h) {
                for (m = 0; m < 60; m += 15) {
                    t1 = moment.utc([2000, 0, 1, h, m]);
                    t2 = moment.utc(t1.format('A h:mm'), 'A h:mm');
                    assert.equal(t2.format('HH:mm'), t1.format('HH:mm'),
                            'meridiem at ' + t1.format('HH:mm'));
                }
            }
        });

        test('date format correctness', function (assert) {
            var data, tokens;
            data = moment.localeData()._longDateFormat;
            tokens = objectKeys(data);
            each(tokens, function (srchToken) {
                // Check each format string to make sure it does not contain any
                // tokens that need to be expanded.
                each(tokens, function (baseToken) {
                    // strip escaped sequences
                    var format = data[baseToken].replace(/(\[[^\]]*\])/g, '');
                    assert.equal(false, !!~format.indexOf(srchToken),
                            'contains ' + srchToken + ' in ' + baseToken);
                });
            });
        });

        test('month parsing correctness', function (assert) {
            var i, m;

            if (locale === 'tr') {
                // I can't fix it :(
                expect(0);
                return;
            }
            function tester(format) {
                var r;
                r = moment(m.format(format), format);
                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format);
                r = moment(m.format(format).toLocaleUpperCase(), format);
                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' upper');
                r = moment(m.format(format).toLocaleLowerCase(), format);
                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' lower');

                r = moment(m.format(format), format, true);
                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' strict');
                r = moment(m.format(format).toLocaleUpperCase(), format, true);
                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' upper strict');
                r = moment(m.format(format).toLocaleLowerCase(), format, true);
                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' lower strict');
            }

            for (i = 0; i < 12; ++i) {
                m = moment([2015, i, 15, 18]);
                tester('MMM');
                tester('MMM.');
                tester('MMMM');
                tester('MMMM.');
            }
        });

        test('weekday parsing correctness', function (assert) {
            var i, m;

            if (locale === 'tr' || locale === 'az') {
                // There is a lower-case letter (Ä±), that converted to upper then
                // lower changes to i
                expect(0);
                return;
            }
            function tester(format) {
                var r, baseMsg = 'weekday ' + m.weekday() + ' fmt ' + format;
                r = moment(m.format(format), format);
                assert.equal(r.weekday(), m.weekday(), baseMsg);
                r = moment(m.format(format).toLocaleUpperCase(), format);
                assert.equal(r.weekday(), m.weekday(), baseMsg + ' upper');
                r = moment(m.format(format).toLocaleLowerCase(), format);
                assert.equal(r.weekday(), m.weekday(), baseMsg + ' lower');

                r = moment(m.format(format), format, true);
                assert.equal(r.weekday(), m.weekday(), baseMsg + ' strict');
                r = moment(m.format(format).toLocaleUpperCase(), format, true);
                assert.equal(r.weekday(), m.weekday(), baseMsg + ' upper strict');
                r = moment(m.format(format).toLocaleLowerCase(), format, true);
                assert.equal(r.weekday(), m.weekday(), baseMsg + ' lower strict');
            }

            for (i = 0; i < 7; ++i) {
                m = moment.utc([2015, i, 15, 18]);
                tester('dd');
                tester('ddd');
                tester('dddd');
            }
        });
    }

    function setupDeprecationHandler(test, moment, scope) {
        test._expectedDeprecations = null;
        test._observedDeprecations = null;
        test._oldSupress = moment.suppressDeprecationWarnings;
        moment.suppressDeprecationWarnings = true;
        test.expectedDeprecations = function () {
            test._expectedDeprecations = arguments;
            test._observedDeprecations = [];
        };
        moment.deprecationHandler = function (name, msg) {
            var deprecationId = matchedDeprecation(name, msg, test._expectedDeprecations);
            if (deprecationId === -1) {
                throw new Error('Unexpected deprecation thrown name=' +
                        name + ' msg=' + msg);
            }
            test._observedDeprecations[deprecationId] = 1;
        };
    }

    function teardownDeprecationHandler(test, moment, scope) {
        moment.suppressDeprecationWarnings = test._oldSupress;

        if (test._expectedDeprecations != null) {
            var missedDeprecations = [];
            each(test._expectedDeprecations, function (deprecationPattern, id) {
                if (test._observedDeprecations[id] !== 1) {
                    missedDeprecations.push(deprecationPattern);
                }
            });
            if (missedDeprecations.length !== 0) {
                throw new Error('Expected deprecation warnings did not happen: ' +
                        missedDeprecations.join(' '));
            }
        }
    }

    function matchedDeprecation(name, msg, deprecations) {
        if (deprecations == null) {
            return -1;
        }
        for (var i = 0; i < deprecations.length; ++i) {
            if (name != null && name === deprecations[i]) {
                return i;
            }
            if (msg != null && msg.substring(0, deprecations[i].length) === deprecations[i]) {
                return i;
            }
        }
        return -1;
    }

    /*global QUnit:false*/

    var test = QUnit.test;

    var expect = QUnit.expect;

    function module (name, lifecycle) {
        QUnit.module(name, {
            setup : function () {
                moment.locale('en');
                moment.createFromInputFallback = function (config) {
                    throw new Error('input not handled by moment: ' + config._i);
                };
                setupDeprecationHandler(test, moment, 'core');
                if (lifecycle && lifecycle.setup) {
                    lifecycle.setup();
                }
            },
            teardown : function () {
                teardownDeprecationHandler(test, moment, 'core');
                if (lifecycle && lifecycle.teardown) {
                    lifecycle.teardown();
                }
            }
        });
    }

    function localeModule (name, lifecycle) {
        QUnit.module('locale:' + name, {
            setup : function () {
                moment.locale(name);
                moment.createFromInputFallback = function (config) {
                    throw new Error('input not handled by moment: ' + config._i);
                };
                setupDeprecationHandler(test, moment, 'locale');
                if (lifecycle && lifecycle.setup) {
                    lifecycle.setup();
                }
            },
            teardown : function () {
                moment.locale('en');
                teardownDeprecationHandler(test, moment, 'locale');
                if (lifecycle && lifecycle.teardown) {
                    lifecycle.teardown();
                }
            }
        });
        defineCommonLocaleTests(name, -1, -1);
    }

    function hasOwnProp(a, b) {
        return Object.prototype.hasOwnProperty.call(a, b);
    }

    function extend(a, b) {
        for (var i in b) {
            if (hasOwnProp(b, i)) {
                a[i] = b[i];
            }
        }

        if (hasOwnProp(b, 'toString')) {
            a.toString = b.toString;
        }

        if (hasOwnProp(b, 'valueOf')) {
            a.valueOf = b.valueOf;
        }

        return a;
    }

    var hookCallback;

    function hooks () {
        return hookCallback.apply(null, arguments);
    }

    // This is done to register the method called with moment()
    // without creating circular dependencies.
    function setHookCallback (callback) {
        hookCallback = callback;
    }

    function isUndefined(input) {
        return input === void 0;
    }

    function warn(msg) {
        if (hooks.suppressDeprecationWarnings === false &&
                (typeof console !==  'undefined') && console.warn) {
            console.warn('Deprecation warning: ' + msg);
        }
    }

    function deprecate(msg, fn) {
        var firstTime = true;

        return extend(function () {
            if (hooks.deprecationHandler != null) {
                hooks.deprecationHandler(null, msg);
            }
            if (firstTime) {
                warn(msg + '\nArguments: ' + Array.prototype.slice.call(arguments).join(', ') + '\n' + (new Error()).stack);
                firstTime = false;
            }
            return fn.apply(this, arguments);
        }, fn);
    }

    var deprecations = {};

    function deprecateSimple(name, msg) {
        if (hooks.deprecationHandler != null) {
            hooks.deprecationHandler(name, msg);
        }
        if (!deprecations[name]) {
            warn(msg);
            deprecations[name] = true;
        }
    }

    hooks.suppressDeprecationWarnings = false;
    hooks.deprecationHandler = null;

    module('deprecate');

    test('deprecate', function (assert) {
        // NOTE: hooks inside deprecate.js and moment are different, so this is can
        // not be test.expectedDeprecations(...)
        var fn = function () {};
        var deprecatedFn = deprecate('testing deprecation', fn);
        deprecatedFn();

        expect(0);
    });

}));

;(function (global, factory) {
   typeof exports === 'object' && typeof module !== 'undefined'
       && typeof require === 'function' ? factory(require('../../moment')) :
   typeof define === 'function' && define.amd ? define(['../../moment'], factory) :
   factory(global.moment)
}(this, function (moment) { 'use strict';

    function each(array, callback) {
        var i;
        for (i = 0; i < array.length; i++) {
            callback(array[i], i, array);
        }
    }

    function objectKeys(obj) {
        if (Object.keys) {
            return Object.keys(obj);
        } else {
            // IE8
            var res = [], i;
            for (i in obj) {
                if (obj.hasOwnProperty(i)) {
                    res.push(i);
                }
            }
            return res;
        }
    }

    // Pick the first defined of two or three arguments.
    function defaults(a, b, c) {
        if (a != null) {
            return a;
        }
        if (b != null) {
            return b;
        }
        return c;
    }

    function defineCommonLocaleTests(locale, options) {
        test('lenient ordinal parsing', function (assert) {
            var i, ordinalStr, testMoment;
            for (i = 1; i <= 31; ++i) {
                ordinalStr = moment([2014, 0, i]).format('YYYY MM Do');
                testMoment = moment(ordinalStr, 'YYYY MM Do');
                assert.equal(testMoment.year(), 2014,
                        'lenient ordinal parsing ' + i + ' year check');
                assert.equal(testMoment.month(), 0,
                        'lenient ordinal parsing ' + i + ' month check');
                assert.equal(testMoment.date(), i,
                        'lenient ordinal parsing ' + i + ' date check');
            }
        });

        test('lenient ordinal parsing of number', function (assert) {
            var i, testMoment;
            for (i = 1; i <= 31; ++i) {
                testMoment = moment('2014 01 ' + i, 'YYYY MM Do');
                assert.equal(testMoment.year(), 2014,
                        'lenient ordinal parsing of number ' + i + ' year check');
                assert.equal(testMoment.month(), 0,
                        'lenient ordinal parsing of number ' + i + ' month check');
                assert.equal(testMoment.date(), i,
                        'lenient ordinal parsing of number ' + i + ' date check');
            }
        });

        test('strict ordinal parsing', function (assert) {
            var i, ordinalStr, testMoment;
            for (i = 1; i <= 31; ++i) {
                ordinalStr = moment([2014, 0, i]).format('YYYY MM Do');
                testMoment = moment(ordinalStr, 'YYYY MM Do', true);
                assert.ok(testMoment.isValid(), 'strict ordinal parsing ' + i);
            }
        });

        test('meridiem invariant', function (assert) {
            var h, m, t1, t2;
            for (h = 0; h < 24; ++h) {
                for (m = 0; m < 60; m += 15) {
                    t1 = moment.utc([2000, 0, 1, h, m]);
                    t2 = moment.utc(t1.format('A h:mm'), 'A h:mm');
                    assert.equal(t2.format('HH:mm'), t1.format('HH:mm'),
                            'meridiem at ' + t1.format('HH:mm'));
                }
            }
        });

        test('date format correctness', function (assert) {
            var data, tokens;
            data = moment.localeData()._longDateFormat;
            tokens = objectKeys(data);
            each(tokens, function (srchToken) {
                // Check each format string to make sure it does not contain any
                // tokens that need to be expanded.
                each(tokens, function (baseToken) {
                    // strip escaped sequences
                    var format = data[baseToken].replace(/(\[[^\]]*\])/g, '');
                    assert.equal(false, !!~format.indexOf(srchToken),
                            'contains ' + srchToken + ' in ' + baseToken);
                });
            });
        });

        test('month parsing correctness', function (assert) {
            var i, m;

            if (locale === 'tr') {
                // I can't fix it :(
                expect(0);
                return;
            }
            function tester(format) {
                var r;
                r = moment(m.format(format), format);
                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format);
                r = moment(m.format(format).toLocaleUpperCase(), format);
                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' upper');
                r = moment(m.format(format).toLocaleLowerCase(), format);
                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' lower');

                r = moment(m.format(format), format, true);
                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' strict');
                r = moment(m.format(format).toLocaleUpperCase(), format, true);
                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' upper strict');
                r = moment(m.format(format).toLocaleLowerCase(), format, true);
                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' lower strict');
            }

            for (i = 0; i < 12; ++i) {
                m = moment([2015, i, 15, 18]);
                tester('MMM');
                tester('MMM.');
                tester('MMMM');
                tester('MMMM.');
            }
        });

        test('weekday parsing correctness', function (assert) {
            var i, m;

            if (locale === 'tr' || locale === 'az') {
                // There is a lower-case letter (Ä±), that converted to upper then
                // lower changes to i
                expect(0);
                return;
            }
            function tester(format) {
                var r, baseMsg = 'weekday ' + m.weekday() + ' fmt ' + format;
                r = moment(m.format(format), format);
                assert.equal(r.weekday(), m.weekday(), baseMsg);
                r = moment(m.format(format).toLocaleUpperCase(), format);
                assert.equal(r.weekday(), m.weekday(), baseMsg + ' upper');
                r = moment(m.format(format).toLocaleLowerCase(), format);
                assert.equal(r.weekday(), m.weekday(), baseMsg + ' lower');

                r = moment(m.format(format), format, true);
                assert.equal(r.weekday(), m.weekday(), baseMsg + ' strict');
                r = moment(m.format(format).toLocaleUpperCase(), format, true);
                assert.equal(r.weekday(), m.weekday(), baseMsg + ' upper strict');
                r = moment(m.format(format).toLocaleLowerCase(), format, true);
                assert.equal(r.weekday(), m.weekday(), baseMsg + ' lower strict');
            }

            for (i = 0; i < 7; ++i) {
                m = moment.utc([2015, i, 15, 18]);
                tester('dd');
                tester('ddd');
                tester('dddd');
            }
        });
    }

    function setupDeprecationHandler(test, moment, scope) {
        test._expectedDeprecations = null;
        test._observedDeprecations = null;
        test._oldSupress = moment.suppressDeprecationWarnings;
        moment.suppressDeprecationWarnings = true;
        test.expectedDeprecations = function () {
            test._expectedDeprecations = arguments;
            test._observedDeprecations = [];
        };
        moment.deprecationHandler = function (name, msg) {
            var deprecationId = matchedDeprecation(name, msg, test._expectedDeprecations);
            if (deprecationId === -1) {
                throw new Error('Unexpected deprecation thrown name=' +
                        name + ' msg=' + msg);
            }
            test._observedDeprecations[deprecationId] = 1;
        };
    }

    function teardownDeprecationHandler(test, moment, scope) {
        moment.suppressDeprecationWarnings = test._oldSupress;

        if (test._expectedDeprecations != null) {
            var missedDeprecations = [];
            each(test._expectedDeprecations, function (deprecationPattern, id) {
                if (test._observedDeprecations[id] !== 1) {
                    missedDeprecations.push(deprecationPattern);
                }
            });
            if (missedDeprecations.length !== 0) {
                throw new Error('Expected deprecation warnings did not happen: ' +
                        missedDeprecations.join(' '));
            }
        }
    }

    function matchedDeprecation(name, msg, deprecations) {
        if (deprecations == null) {
            return -1;
        }
        for (var i = 0; i < deprecations.length; ++i) {
            if (name != null && name === deprecations[i]) {
                return i;
            }
            if (msg != null && msg.substring(0, deprecations[i].length) === deprecations[i]) {
                return i;
            }
        }
        return -1;
    }

    /*global QUnit:false*/

    var test = QUnit.test;

    var expect = QUnit.expect;

    function module (name, lifecycle) {
        QUnit.module(name, {
            setup : function () {
                moment.locale('en');
                moment.createFromInputFallback = function (config) {
                    throw new Error('input not handled by moment: ' + config._i);
                };
                setupDeprecationHandler(test, moment, 'core');
                if (lifecycle && lifecycle.setup) {
                    lifecycle.setup();
                }
            },
            teardown : function () {
                teardownDeprecationHandler(test, moment, 'core');
                if (lifecycle && lifecycle.teardown) {
                    lifecycle.teardown();
                }
            }
        });
    }

    function localeModule (name, lifecycle) {
        QUnit.module('locale:' + name, {
            setup : function () {
                moment.locale(name);
                moment.createFromInputFallback = function (config) {
                    throw new Error('input not handled by moment: ' + config._i);
                };
                setupDeprecationHandler(test, moment, 'locale');
                if (lifecycle && lifecycle.setup) {
                    lifecycle.setup();
                }
            },
            teardown : function () {
                moment.locale('en');
                teardownDeprecationHandler(test, moment, 'locale');
                if (lifecycle && lifecycle.teardown) {
                    lifecycle.teardown();
                }
            }
        });
        defineCommonLocaleTests(name, -1, -1);
    }

    function equal(assert, a, b, message) {
        assert.ok(Math.abs(a - b) < 0.00000001, '(' + a + ' === ' + b + ') ' + message);
    }

    function dstForYear(year) {
        var start = moment([year]),
            end = moment([year + 1]),
            current = start.clone(),
            last;

        while (current < end) {
            last = current.clone();
            current.add(24, 'hour');
            if (last.utcOffset() !== current.utcOffset()) {
                end = current.clone();
                current = last.clone();
                break;
            }
        }

        while (current < end) {
            last = current.clone();
            current.add(1, 'hour');
            if (last.utcOffset() !== current.utcOffset()) {
                return {
                    moment : last,
                    diff : -(current.utcOffset() - last.utcOffset()) / 60
                };
            }
        }
    }

    module('diff');

    test('diff', function (assert) {
        assert.equal(moment(1000).diff(0), 1000, '1 second - 0 = 1000');
        assert.equal(moment(1000).diff(500), 500, '1 second - 0.5 seconds = 500');
        assert.equal(moment(0).diff(1000), -1000, '0 - 1 second = -1000');
        assert.equal(moment(new Date(1000)).diff(1000), 0, '1 second - 1 second = 0');
        var oneHourDate = new Date(2015, 5, 21),
        nowDate = new Date(+oneHourDate);
        oneHourDate.setHours(oneHourDate.getHours() + 1);
        assert.equal(moment(oneHourDate).diff(nowDate), 60 * 60 * 1000, '1 hour from now = 3600000');
    });

    test('diff key after', function (assert) {
        assert.equal(moment([2010]).diff([2011], 'years'), -1, 'year diff');
        assert.equal(moment([2010]).diff([2010, 2], 'months'), -2, 'month diff');
        assert.equal(moment([2010]).diff([2010, 0, 7], 'weeks'), 0, 'week diff');
        assert.equal(moment([2010]).diff([2010, 0, 8], 'weeks'), -1, 'week diff');
        assert.equal(moment([2010]).diff([2010, 0, 21], 'weeks'), -2, 'week diff');
        assert.equal(moment([2010]).diff([2010, 0, 22], 'weeks'), -3, 'week diff');
        assert.equal(moment([2010]).diff([2010, 0, 4], 'days'), -3, 'day diff');
        assert.equal(moment([2010]).diff([2010, 0, 1, 4], 'hours'), -4, 'hour diff');
        assert.equal(moment([2010]).diff([2010, 0, 1, 0, 5], 'minutes'), -5, 'minute diff');
        assert.equal(moment([2010]).diff([2010, 0, 1, 0, 0, 6], 'seconds'), -6, 'second diff');
    });

    test('diff key before', function (assert) {
        assert.equal(moment([2011]).diff([2010], 'years'), 1, 'year diff');
        assert.equal(moment([2010, 2]).diff([2010], 'months'), 2, 'month diff');
        assert.equal(moment([2010, 0, 4]).diff([2010], 'days'), 3, 'day diff');
        assert.equal(moment([2010, 0, 7]).diff([2010], 'weeks'), 0, 'week diff');
        assert.equal(moment([2010, 0, 8]).diff([2010], 'weeks'), 1, 'week diff');
        assert.equal(moment([2010, 0, 21]).diff([2010], 'weeks'), 2, 'week diff');
        assert.equal(moment([2010, 0, 22]).diff([2010], 'weeks'), 3, 'week diff');
        assert.equal(moment([2010, 0, 1, 4]).diff([2010], 'hours'), 4, 'hour diff');
        assert.equal(moment([2010, 0, 1, 0, 5]).diff([2010], 'minutes'), 5, 'minute diff');
        assert.equal(moment([2010, 0, 1, 0, 0, 6]).diff([2010], 'seconds'), 6, 'second diff');
    });

    test('diff key before singular', function (assert) {
        assert.equal(moment([2011]).diff([2010], 'year'), 1, 'year diff singular');
        assert.equal(moment([2010, 2]).diff([2010], 'month'), 2, 'month diff singular');
        assert.equal(moment([2010, 0, 4]).diff([2010], 'day'), 3, 'day diff singular');
        assert.equal(moment([2010, 0, 7]).diff([2010], 'week'), 0, 'week diff singular');
        assert.equal(moment([2010, 0, 8]).diff([2010], 'week'), 1, 'week diff singular');
        assert.equal(moment([2010, 0, 21]).diff([2010], 'week'), 2, 'week diff singular');
        assert.equal(moment([2010, 0, 22]).diff([2010], 'week'), 3, 'week diff singular');
        assert.equal(moment([2010, 0, 1, 4]).diff([2010], 'hour'), 4, 'hour diff singular');
        assert.equal(moment([2010, 0, 1, 0, 5]).diff([2010], 'minute'), 5, 'minute diff singular');
        assert.equal(moment([2010, 0, 1, 0, 0, 6]).diff([2010], 'second'), 6, 'second diff singular');
    });

    test('diff key before abbreviated', function (assert) {
        assert.equal(moment([2011]).diff([2010], 'y'), 1, 'year diff abbreviated');
        assert.equal(moment([2010, 2]).diff([2010], 'M'), 2, 'month diff abbreviated');
        assert.equal(moment([2010, 0, 4]).diff([2010], 'd'), 3, 'day diff abbreviated');
        assert.equal(moment([2010, 0, 7]).diff([2010], 'w'), 0, 'week diff abbreviated');
        assert.equal(moment([2010, 0, 8]).diff([2010], 'w'), 1, 'week diff abbreviated');
        assert.equal(moment([2010, 0, 21]).diff([2010], 'w'), 2, 'week diff abbreviated');
        assert.equal(moment([2010, 0, 22]).diff([2010], 'w'), 3, 'week diff abbreviated');
        assert.equal(moment([2010, 0, 1, 4]).diff([2010], 'h'), 4, 'hour diff abbreviated');
        assert.equal(moment([2010, 0, 1, 0, 5]).diff([2010], 'm'), 5, 'minute diff abbreviated');
        assert.equal(moment([2010, 0, 1, 0, 0, 6]).diff([2010], 's'), 6, 'second diff abbreviated');
    });

    test('diff month', function (assert) {
        assert.equal(moment([2011, 0, 31]).diff([2011, 2, 1], 'months'), -1, 'month diff');
    });

    test('diff across DST', function (assert) {
        var dst = dstForYear(2012), a, b, daysInMonth;
        if (!dst) {
            assert.equal(42, 42, 'at least one assertion');
            return;
        }

        a = dst.moment;
        b = a.clone().utc().add(12, 'hours').local();
        daysInMonth = (a.daysInMonth() + b.daysInMonth()) / 2;
        assert.equal(b.diff(a, 'milliseconds', true), 12 * 60 * 60 * 1000,
                'ms diff across DST');
        assert.equal(b.diff(a, 'seconds', true), 12 * 60 * 60,
                'second diff across DST');
        assert.equal(b.diff(a, 'minutes', true), 12 * 60,
                'minute diff across DST');
        assert.equal(b.diff(a, 'hours', true), 12,
                'hour diff across DST');
        assert.equal(b.diff(a, 'days', true), (12 - dst.diff) / 24,
                'day diff across DST');
        equal(assert, b.diff(a, 'weeks', true),  (12 - dst.diff) / 24 / 7,
                'week diff across DST');
        assert.ok(0.95 / (2 * 31) < b.diff(a, 'months', true),
                'month diff across DST, lower bound');
        assert.ok(b.diff(a, 'month', true) < 1.05 / (2 * 28),
                'month diff across DST, upper bound');
        assert.ok(0.95 / (2 * 31 * 12) < b.diff(a, 'years', true),
                'year diff across DST, lower bound');
        assert.ok(b.diff(a, 'year', true) < 1.05 / (2 * 28 * 12),
                'year diff across DST, upper bound');

        a = dst.moment;
        b = a.clone().utc().add(12 + dst.diff, 'hours').local();
        daysInMonth = (a.daysInMonth() + b.daysInMonth()) / 2;

        assert.equal(b.diff(a, 'milliseconds', true),
                (12 + dst.diff) * 60 * 60 * 1000,
                'ms diff across DST');
        assert.equal(b.diff(a, 'seconds', true),  (12 + dst.diff) * 60 * 60,
                'second diff across DST');
        assert.equal(b.diff(a, 'minutes', true),  (12 + dst.diff) * 60,
                'minute diff across DST');
        assert.equal(b.diff(a, 'hours', true),  (12 + dst.diff),
                'hour diff across DST');
        assert.equal(b.diff(a, 'days', true),  12 / 24, 'day diff across DST');
        equal(assert, b.diff(a, 'weeks', true),  12 / 24 / 7,
                'week diff across DST');
        assert.ok(0.95 / (2 * 31) < b.diff(a, 'months', true),
                'month diff across DST, lower bound');
        assert.ok(b.diff(a, 'month', true) < 1.05 / (2 * 28),
                'month diff across DST, upper bound');
        assert.ok(0.95 / (2 * 31 * 12) < b.diff(a, 'years', true),
                'year diff across DST, lower bound');
        assert.ok(b.diff(a, 'year', true) < 1.05 / (2 * 28 * 12),
                'year diff across DST, upper bound');
    });

    test('diff overflow', function (assert) {
        assert.equal(moment([2011]).diff([2010], 'months'), 12, 'month diff');
        assert.equal(moment([2010, 0, 2]).diff([2010], 'hours'), 24, 'hour diff');
        assert.equal(moment([2010, 0, 1, 2]).diff([2010], 'minutes'), 120, 'minute diff');
        assert.equal(moment([2010, 0, 1, 0, 4]).diff([2010], 'seconds'), 240, 'second diff');
    });

    test('diff between utc and local', function (assert) {
        if (moment([2012]).utcOffset() === moment([2011]).utcOffset()) {
            // Russia's utc offset on 1st of Jan 2012 vs 2011 is different
            assert.equal(moment([2012]).utc().diff([2011], 'years'), 1, 'year diff');
        }
        assert.equal(moment([2010, 2, 2]).utc().diff([2010, 0, 2], 'months'), 2, 'month diff');
        assert.equal(moment([2010, 0, 4]).utc().diff([2010], 'days'), 3, 'day diff');
        assert.equal(moment([2010, 0, 22]).utc().diff([2010], 'weeks'), 3, 'week diff');
        assert.equal(moment([2010, 0, 1, 4]).utc().diff([2010], 'hours'), 4, 'hour diff');
        assert.equal(moment([2010, 0, 1, 0, 5]).utc().diff([2010], 'minutes'), 5, 'minute diff');
        assert.equal(moment([2010, 0, 1, 0, 0, 6]).utc().diff([2010], 'seconds'), 6, 'second diff');
    });

    test('diff floored', function (assert) {
        assert.equal(moment([2010, 0, 1, 23]).diff([2010], 'day'), 0, '23 hours = 0 days');
        assert.equal(moment([2010, 0, 1, 23, 59]).diff([2010], 'day'), 0, '23:59 hours = 0 days');
        assert.equal(moment([2010, 0, 1, 24]).diff([2010], 'day'), 1, '24 hours = 1 day');
        assert.equal(moment([2010, 0, 2]).diff([2011, 0, 1], 'year'), 0, 'year rounded down');
        assert.equal(moment([2011, 0, 1]).diff([2010, 0, 2], 'year'), 0, 'year rounded down');
        assert.equal(moment([2010, 0, 2]).diff([2011, 0, 2], 'year'), -1, 'year rounded down');
        assert.equal(moment([2011, 0, 2]).diff([2010, 0, 2], 'year'), 1, 'year rounded down');
    });

    test('year diffs include dates', function (assert) {
        assert.ok(moment([2012, 1, 19]).diff(moment([2002, 1, 20]), 'years', true) < 10, 'year diff should include date of month');
    });

    test('month diffs', function (assert) {
        // due to floating point math errors, these tests just need to be accurate within 0.00000001
        assert.equal(moment([2012, 0, 1]).diff([2012, 1, 1], 'months', true), -1, 'Jan 1 to Feb 1 should be 1 month');
        equal(assert, moment([2012, 0, 1]).diff([2012, 0, 1, 12], 'months', true), -0.5 / 31, 'Jan 1 to Jan 1 noon should be 0.5 / 31 months');
        assert.equal(moment([2012, 0, 15]).diff([2012, 1, 15], 'months', true), -1, 'Jan 15 to Feb 15 should be 1 month');
        assert.equal(moment([2012, 0, 28]).diff([2012, 1, 28], 'months', true), -1, 'Jan 28 to Feb 28 should be 1 month');
        assert.ok(moment([2012, 0, 31]).diff([2012, 1, 29], 'months', true), -1, 'Jan 31 to Feb 29 should be 1 month');
        assert.ok(-1 > moment([2012, 0, 31]).diff([2012, 2, 1], 'months', true), 'Jan 31 to Mar 1 should be more than 1 month');
        assert.ok(-30 / 28 < moment([2012, 0, 31]).diff([2012, 2, 1], 'months', true), 'Jan 31 to Mar 1 should be less than 1 month and 1 day');
        equal(assert, moment([2012, 0, 1]).diff([2012, 0, 31], 'months', true), -(30 / 31), 'Jan 1 to Jan 31 should be 30 / 31 months');
        assert.ok(0 < moment('2014-02-01').diff(moment('2014-01-31'), 'months', true), 'jan-31 to feb-1 diff is positive');
    });

    test('exact month diffs', function (assert) {
        // generate all pairs of months and compute month diff, with fixed day
        // of month = 15.

        var m1, m2;
        for (m1 = 0; m1 < 12; ++m1) {
            for (m2 = m1; m2 < 12; ++m2) {
                assert.equal(moment([2013, m2, 15]).diff(moment([2013, m1, 15]), 'months', true), m2 - m1,
                             'month diff from 2013-' + m1 + '-15 to 2013-' + m2 + '-15');
            }
        }
    });

    test('year diffs', function (assert) {
        // due to floating point math errors, these tests just need to be accurate within 0.00000001
        equal(assert, moment([2012, 0, 1]).diff([2013, 0, 1], 'years', true), -1, 'Jan 1 2012 to Jan 1 2013 should be 1 year');
        equal(assert, moment([2012, 1, 28]).diff([2013, 1, 28], 'years', true), -1, 'Feb 28 2012 to Feb 28 2013 should be 1 year');
        equal(assert, moment([2012, 2, 1]).diff([2013, 2, 1], 'years', true), -1, 'Mar 1 2012 to Mar 1 2013 should be 1 year');
        equal(assert, moment([2012, 11, 1]).diff([2013, 11, 1], 'years', true), -1, 'Dec 1 2012 to Dec 1 2013 should be 1 year');
        equal(assert, moment([2012, 11, 31]).diff([2013, 11, 31], 'years', true), -1, 'Dec 31 2012 to Dec 31 2013 should be 1 year');
        equal(assert, moment([2012, 0, 1]).diff([2013, 6, 1], 'years', true), -1.5, 'Jan 1 2012 to Jul 1 2013 should be 1.5 years');
        equal(assert, moment([2012, 0, 31]).diff([2013, 6, 31], 'years', true), -1.5, 'Jan 31 2012 to Jul 31 2013 should be 1.5 years');
        equal(assert, moment([2012, 0, 1]).diff([2013, 0, 1, 12], 'years', true), -1 - (0.5 / 31) / 12, 'Jan 1 2012 to Jan 1 2013 noon should be 1+(0.5 / 31) / 12 years');
        equal(assert, moment([2012, 0, 1]).diff([2013, 6, 1, 12], 'years', true), -1.5 - (0.5 / 31) / 12, 'Jan 1 2012 to Jul 1 2013 noon should be 1.5+(0.5 / 31) / 12 years');
        equal(assert, moment([2012, 1, 29]).diff([2013, 1, 28], 'years', true), -1, 'Feb 29 2012 to Feb 28 2013 should be 1-(1 / 28.5) / 12 years');
    });

    test('negative zero', function (assert) {
        function isNegative (n) {
                return (1 / n) < 0;
            }
        assert.ok(!isNegative(moment([2012, 0, 1]).diff(moment([2012, 0, 1]), 'months')), 'month diff on same date is zero, not -0');
        assert.ok(!isNegative(moment([2012, 0, 1]).diff(moment([2012, 0, 1]), 'years')), 'year diff on same date is zero, not -0');
        assert.ok(!isNegative(moment([2012, 0, 1]).diff(moment([2012, 0, 1]), 'quarters')), 'quarter diff on same date is zero, not -0');
    });

}));

;(function (global, factory) {
   typeof exports === 'object' && typeof module !== 'undefined'
       && typeof require === 'function' ? factory(require('../../moment')) :
   typeof define === 'function' && define.amd ? define(['../../moment'], factory) :
   factory(global.moment)
}(this, function (moment) { 'use strict';

    function each(array, callback) {
        var i;
        for (i = 0; i < array.length; i++) {
            callback(array[i], i, array);
        }
    }

    function objectKeys(obj) {
        if (Object.keys) {
            return Object.keys(obj);
        } else {
            // IE8
            var res = [], i;
            for (i in obj) {
                if (obj.hasOwnProperty(i)) {
                    res.push(i);
                }
            }
            return res;
        }
    }

    // Pick the first defined of two or three arguments.
    function defaults(a, b, c) {
        if (a != null) {
            return a;
        }
        if (b != null) {
            return b;
        }
        return c;
    }

    function defineCommonLocaleTests(locale, options) {
        test('lenient ordinal parsing', function (assert) {
            var i, ordinalStr, testMoment;
            for (i = 1; i <= 31; ++i) {
                ordinalStr = moment([2014, 0, i]).format('YYYY MM Do');
                testMoment = moment(ordinalStr, 'YYYY MM Do');
                assert.equal(testMoment.year(), 2014,
                        'lenient ordinal parsing ' + i + ' year check');
                assert.equal(testMoment.month(), 0,
                        'lenient ordinal parsing ' + i + ' month check');
                assert.equal(testMoment.date(), i,
                        'lenient ordinal parsing ' + i + ' date check');
            }
        });

        test('lenient ordinal parsing of number', function (assert) {
            var i, testMoment;
            for (i = 1; i <= 31; ++i) {
                testMoment = moment('2014 01 ' + i, 'YYYY MM Do');
                assert.equal(testMoment.year(), 2014,
                        'lenient ordinal parsing of number ' + i + ' year check');
                assert.equal(testMoment.month(), 0,
                        'lenient ordinal parsing of number ' + i + ' month check');
                assert.equal(testMoment.date(), i,
                        'lenient ordinal parsing of number ' + i + ' date check');
            }
        });

        test('strict ordinal parsing', function (assert) {
            var i, ordinalStr, testMoment;
            for (i = 1; i <= 31; ++i) {
                ordinalStr = moment([2014, 0, i]).format('YYYY MM Do');
                testMoment = moment(ordinalStr, 'YYYY MM Do', true);
                assert.ok(testMoment.isValid(), 'strict ordinal parsing ' + i);
            }
        });

        test('meridiem invariant', function (assert) {
            var h, m, t1, t2;
            for (h = 0; h < 24; ++h) {
                for (m = 0; m < 60; m += 15) {
                    t1 = moment.utc([2000, 0, 1, h, m]);
                    t2 = moment.utc(t1.format('A h:mm'), 'A h:mm');
                    assert.equal(t2.format('HH:mm'), t1.format('HH:mm'),
                            'meridiem at ' + t1.format('HH:mm'));
                }
            }
        });

        test('date format correctness', function (assert) {
            var data, tokens;
            data = moment.localeData()._longDateFormat;
            tokens = objectKeys(data);
            each(tokens, function (srchToken) {
                // Check each format string to make sure it does not contain any
                // tokens that need to be expanded.
                each(tokens, function (baseToken) {
                    // strip escaped sequences
                    var format = data[baseToken].replace(/(\[[^\]]*\])/g, '');
                    assert.equal(false, !!~format.indexOf(srchToken),
                            'contains ' + srchToken + ' in ' + baseToken);
                });
            });
        });

        test('month parsing correctness', function (assert) {
            var i, m;

            if (locale === 'tr') {
                // I can't fix it :(
                expect(0);
                return;
            }
            function tester(format) {
                var r;
                r = moment(m.format(format), format);
                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format);
                r = moment(m.format(format).toLocaleUpperCase(), format);
                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' upper');
                r = moment(m.format(format).toLocaleLowerCase(), format);
                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' lower');

                r = moment(m.format(format), format, true);
                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' strict');
                r = moment(m.format(format).toLocaleUpperCase(), format, true);
                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' upper strict');
                r = moment(m.format(format).toLocaleLowerCase(), format, true);
                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' lower strict');
            }

            for (i = 0; i < 12; ++i) {
                m = moment([2015, i, 15, 18]);
                tester('MMM');
                tester('MMM.');
                tester('MMMM');
                tester('MMMM.');
            }
        });

        test('weekday parsing correctness', function (assert) {
            var i, m;

            if (locale === 'tr' || locale === 'az') {
                // There is a lower-case letter (Ä±), that converted to upper then
                // lower changes to i
                expect(0);
                return;
            }
            function tester(format) {
                var r, baseMsg = 'weekday ' + m.weekday() + ' fmt ' + format;
                r = moment(m.format(format), format);
                assert.equal(r.weekday(), m.weekday(), baseMsg);
                r = moment(m.format(format).toLocaleUpperCase(), format);
                assert.equal(r.weekday(), m.weekday(), baseMsg + ' upper');
                r = moment(m.format(format).toLocaleLowerCase(), format);
                assert.equal(r.weekday(), m.weekday(), baseMsg + ' lower');

                r = moment(m.format(format), format, true);
                assert.equal(r.weekday(), m.weekday(), baseMsg + ' strict');
                r = moment(m.format(format).toLocaleUpperCase(), format, true);
                assert.equal(r.weekday(), m.weekday(), baseMsg + ' upper strict');
                r = moment(m.format(format).toLocaleLowerCase(), format, true);
                assert.equal(r.weekday(), m.weekday(), baseMsg + ' lower strict');
            }

            for (i = 0; i < 7; ++i) {
                m = moment.utc([2015, i, 15, 18]);
                tester('dd');
                tester('ddd');
                tester('dddd');
            }
        });
    }

    function setupDeprecationHandler(test, moment, scope) {
        test._expectedDeprecations = null;
        test._observedDeprecations = null;
        test._oldSupress = moment.suppressDeprecationWarnings;
        moment.suppressDeprecationWarnings = true;
        test.expectedDeprecations = function () {
            test._expectedDeprecations = arguments;
            test._observedDeprecations = [];
        };
        moment.deprecationHandler = function (name, msg) {
            var deprecationId = matchedDeprecation(name, msg, test._expectedDeprecations);
            if (deprecationId === -1) {
                throw new Error('Unexpected deprecation thrown name=' +
                        name + ' msg=' + msg);
            }
            test._observedDeprecations[deprecationId] = 1;
        };
    }

    function teardownDeprecationHandler(test, moment, scope) {
        moment.suppressDeprecationWarnings = test._oldSupress;

        if (test._expectedDeprecations != null) {
            var missedDeprecations = [];
            each(test._expectedDeprecations, function (deprecationPattern, id) {
                if (test._observedDeprecations[id] !== 1) {
                    missedDeprecations.push(deprecationPattern);
                }
            });
            if (missedDeprecations.length !== 0) {
                throw new Error('Expected deprecation warnings did not happen: ' +
                        missedDeprecations.join(' '));
            }
        }
    }

    function matchedDeprecation(name, msg, deprecations) {
        if (deprecations == null) {
            return -1;
        }
        for (var i = 0; i < deprecations.length; ++i) {
            if (name != null && name === deprecations[i]) {
                return i;
            }
            if (msg != null && msg.substring(0, deprecations[i].length) === deprecations[i]) {
                return i;
            }
        }
        return -1;
    }

    /*global QUnit:false*/

    var test = QUnit.test;

    var expect = QUnit.expect;

    function module (name, lifecycle) {
        QUnit.module(name, {
            setup : function () {
                moment.locale('en');
                moment.createFromInputFallback = function (config) {
                    throw new Error('input not handled by moment: ' + config._i);
                };
                setupDeprecationHandler(test, moment, 'core');
                if (lifecycle && lifecycle.setup) {
                    lifecycle.setup();
                }
            },
            teardown : function () {
                teardownDeprecationHandler(test, moment, 'core');
                if (lifecycle && lifecycle.teardown) {
                    lifecycle.teardown();
                }
            }
        });
    }

    function localeModule (name, lifecycle) {
        QUnit.module('locale:' + name, {
            setup : function () {
                moment.locale(name);
                moment.createFromInputFallback = function (config) {
                    throw new Error('input not handled by moment: ' + config._i);
                };
                setupDeprecationHandler(test, moment, 'locale');
                if (lifecycle && lifecycle.setup) {
                    lifecycle.setup();
                }
            },
            teardown : function () {
                moment.locale('en');
                teardownDeprecationHandler(test, moment, 'locale');
                if (lifecycle && lifecycle.teardown) {
                    lifecycle.teardown();
                }
            }
        });
        defineCommonLocaleTests(name, -1, -1);
    }

    module('duration');

    test('object instantiation', function (assert) {
        var d = moment.duration({
            years: 2,
            months: 3,
            weeks: 2,
            days: 1,
            hours: 8,
            minutes: 9,
            seconds: 20,
            milliseconds: 12
        });

        assert.equal(d.years(),        2,  'years');
        assert.equal(d.months(),       3,  'months');
        assert.equal(d.weeks(),        2,  'weeks');
        assert.equal(d.days(),         15, 'days'); // two weeks + 1 day
        assert.equal(d.hours(),        8,  'hours');
        assert.equal(d.minutes(),      9,  'minutes');
        assert.equal(d.seconds(),      20, 'seconds');
        assert.equal(d.milliseconds(), 12, 'milliseconds');
    });

    test('object instantiation with strings', function (assert) {
        var d = moment.duration({
            years: '2',
            months: '3',
            weeks: '2',
            days: '1',
            hours: '8',
            minutes: '9',
            seconds: '20',
            milliseconds: '12'
        });

        assert.equal(d.years(),        2,  'years');
        assert.equal(d.months(),       3,  'months');
        assert.equal(d.weeks(),        2,  'weeks');
        assert.equal(d.days(),         15, 'days'); // two weeks + 1 day
        assert.equal(d.hours(),        8,  'hours');
        assert.equal(d.minutes(),      9,  'minutes');
        assert.equal(d.seconds(),      20, 'seconds');
        assert.equal(d.milliseconds(), 12, 'milliseconds');
    });

    test('milliseconds instantiation', function (assert) {
        assert.equal(moment.duration(72).milliseconds(), 72, 'milliseconds');
    });

    test('undefined instantiation', function (assert) {
        assert.equal(moment.duration(undefined).milliseconds(), 0, 'milliseconds');
    });

    test('null instantiation', function (assert) {
        assert.equal(moment.duration(null).milliseconds(), 0, 'milliseconds');
    });

    test('instantiation by type', function (assert) {
        assert.equal(moment.duration(1, 'years').years(),                 1, 'years');
        assert.equal(moment.duration(1, 'y').years(),                     1, 'y');
        assert.equal(moment.duration(2, 'months').months(),               2, 'months');
        assert.equal(moment.duration(2, 'M').months(),                    2, 'M');
        assert.equal(moment.duration(3, 'weeks').weeks(),                 3, 'weeks');
        assert.equal(moment.duration(3, 'w').weeks(),                     3, 'weeks');
        assert.equal(moment.duration(4, 'days').days(),                   4, 'days');
        assert.equal(moment.duration(4, 'd').days(),                      4, 'd');
        assert.equal(moment.duration(5, 'hours').hours(),                 5, 'hours');
        assert.equal(moment.duration(5, 'h').hours(),                     5, 'h');
        assert.equal(moment.duration(6, 'minutes').minutes(),             6, 'minutes');
        assert.equal(moment.duration(6, 'm').minutes(),                   6, 'm');
        assert.equal(moment.duration(7, 'seconds').seconds(),             7, 'seconds');
        assert.equal(moment.duration(7, 's').seconds(),                   7, 's');
        assert.equal(moment.duration(8, 'milliseconds').milliseconds(),   8, 'milliseconds');
        assert.equal(moment.duration(8, 'ms').milliseconds(),             8, 'ms');
    });

    test('shortcuts', function (assert) {
        assert.equal(moment.duration({y: 1}).years(),         1, 'years = y');
        assert.equal(moment.duration({M: 2}).months(),        2, 'months = M');
        assert.equal(moment.duration({w: 3}).weeks(),         3, 'weeks = w');
        assert.equal(moment.duration({d: 4}).days(),          4, 'days = d');
        assert.equal(moment.duration({h: 5}).hours(),         5, 'hours = h');
        assert.equal(moment.duration({m: 6}).minutes(),       6, 'minutes = m');
        assert.equal(moment.duration({s: 7}).seconds(),       7, 'seconds = s');
        assert.equal(moment.duration({ms: 8}).milliseconds(), 8, 'milliseconds = ms');
    });

    test('generic getter', function (assert) {
        assert.equal(moment.duration(1, 'years').get('years'),                1, 'years');
        assert.equal(moment.duration(1, 'years').get('year'),                 1, 'years = year');
        assert.equal(moment.duration(1, 'years').get('y'),                    1, 'years = y');
        assert.equal(moment.duration(2, 'months').get('months'),              2, 'months');
        assert.equal(moment.duration(2, 'months').get('month'),               2, 'months = month');
        assert.equal(moment.duration(2, 'months').get('M'),                   2, 'months = M');
        assert.equal(moment.duration(3, 'weeks').get('weeks'),                3, 'weeks');
        assert.equal(moment.duration(3, 'weeks').get('week'),                 3, 'weeks = week');
        assert.equal(moment.duration(3, 'weeks').get('w'),                    3, 'weeks = w');
        assert.equal(moment.duration(4, 'days').get('days'),                  4, 'days');
        assert.equal(moment.duration(4, 'days').get('day'),                   4, 'days = day');
        assert.equal(moment.duration(4, 'days').get('d'),                     4, 'days = d');
        assert.equal(moment.duration(5, 'hours').get('hours'),                5, 'hours');
        assert.equal(moment.duration(5, 'hours').get('hour'),                 5, 'hours = hour');
        assert.equal(moment.duration(5, 'hours').get('h'),                    5, 'hours = h');
        assert.equal(moment.duration(6, 'minutes').get('minutes'),            6, 'minutes');
        assert.equal(moment.duration(6, 'minutes').get('minute'),             6, 'minutes = minute');
        assert.equal(moment.duration(6, 'minutes').get('m'),                  6, 'minutes = m');
        assert.equal(moment.duration(7, 'seconds').get('seconds'),            7, 'seconds');
        assert.equal(moment.duration(7, 'seconds').get('second'),             7, 'seconds = second');
        assert.equal(moment.duration(7, 'seconds').get('s'),                  7, 'seconds = s');
        assert.equal(moment.duration(8, 'milliseconds').get('milliseconds'),  8, 'milliseconds');
        assert.equal(moment.duration(8, 'milliseconds').get('millisecond'),   8, 'milliseconds = millisecond');
        assert.equal(moment.duration(8, 'milliseconds').get('ms'),            8, 'milliseconds = ms');
    });

    test('instantiation from another duration', function (assert) {
        var simple = moment.duration(1234),
            lengthy = moment.duration(60 * 60 * 24 * 360 * 1e3),
            complicated = moment.duration({
                years: 2,
                months: 3,
                weeks: 4,
                days: 1,
                hours: 8,
                minutes: 9,
                seconds: 20,
                milliseconds: 12
            }),
            modified = moment.duration(1, 'day').add(moment.duration(1, 'day'));

        assert.deepEqual(moment.duration(simple), simple, 'simple clones are equal');
        assert.deepEqual(moment.duration(lengthy), lengthy, 'lengthy clones are equal');
        assert.deepEqual(moment.duration(complicated), complicated, 'complicated clones are equal');
        assert.deepEqual(moment.duration(modified), modified, 'cloning modified duration works');
    });

    test('instantiation from 24-hour time zero', function (assert) {
        assert.equal(moment.duration('00:00').years(), 0, '0 years');
        assert.equal(moment.duration('00:00').days(), 0, '0 days');
        assert.equal(moment.duration('00:00').hours(), 0, '0 hours');
        assert.equal(moment.duration('00:00').minutes(), 0, '0 minutes');
        assert.equal(moment.duration('00:00').seconds(), 0, '0 seconds');
        assert.equal(moment.duration('00:00').milliseconds(), 0, '0 milliseconds');
    });

    test('instantiation from 24-hour time <24 hours', function (assert) {
        assert.equal(moment.duration('06:45').years(), 0, '0 years');
        assert.equal(moment.duration('06:45').days(), 0, '0 days');
        assert.equal(moment.duration('06:45').hours(), 6, '6 hours');
        assert.equal(moment.duration('06:45').minutes(), 45, '45 minutes');
        assert.equal(moment.duration('06:45').seconds(), 0, '0 seconds');
        assert.equal(moment.duration('06:45').milliseconds(), 0, '0 milliseconds');
    });

    test('instantiation from 24-hour time >24 hours', function (assert) {
        assert.equal(moment.duration('26:45').years(), 0, '0 years');
        assert.equal(moment.duration('26:45').days(), 1, '0 days');
        assert.equal(moment.duration('26:45').hours(), 2, '2 hours');
        assert.equal(moment.duration('26:45').minutes(), 45, '45 minutes');
        assert.equal(moment.duration('26:45').seconds(), 0, '0 seconds');
        assert.equal(moment.duration('26:45').milliseconds(), 0, '0 milliseconds');
    });

    test('instatiation from serialized C# TimeSpan zero', function (assert) {
        assert.equal(moment.duration('00:00:00').years(), 0, '0 years');
        assert.equal(moment.duration('00:00:00').days(), 0, '0 days');
        assert.equal(moment.duration('00:00:00').hours(), 0, '0 hours');
        assert.equal(moment.duration('00:00:00').minutes(), 0, '0 minutes');
        assert.equal(moment.duration('00:00:00').seconds(), 0, '0 seconds');
        assert.equal(moment.duration('00:00:00').milliseconds(), 0, '0 milliseconds');
    });

    test('instatiation from serialized C# TimeSpan with days', function (assert) {
        assert.equal(moment.duration('1.02:03:04.9999999').years(), 0, '0 years');
        assert.equal(moment.duration('1.02:03:04.9999999').days(), 1, '1 day');
        assert.equal(moment.duration('1.02:03:04.9999999').hours(), 2, '2 hours');
        assert.equal(moment.duration('1.02:03:04.9999999').minutes(), 3, '3 minutes');
        assert.equal(moment.duration('1.02:03:04.9999999').seconds(), 4, '4 seconds');
        assert.equal(moment.duration('1.02:03:04.9999999').milliseconds(), 999, '999 milliseconds');

        assert.equal(moment.duration('1 02:03:04.9999999').years(), 0, '0 years');
        assert.equal(moment.duration('1 02:03:04.9999999').days(), 1, '1 day');
        assert.equal(moment.duration('1 02:03:04.9999999').hours(), 2, '2 hours');
        assert.equal(moment.duration('1 02:03:04.9999999').minutes(), 3, '3 minutes');
        assert.equal(moment.duration('1 02:03:04.9999999').seconds(), 4, '4 seconds');
        assert.equal(moment.duration('1 02:03:04.9999999').milliseconds(), 999, '999 milliseconds');
    });

    test('instatiation from serialized C# TimeSpan without days', function (assert) {
        assert.equal(moment.duration('01:02:03.9999999').years(), 0, '0 years');
        assert.equal(moment.duration('01:02:03.9999999').days(), 0, '0 days');
        assert.equal(moment.duration('01:02:03.9999999').hours(), 1, '1 hour');
        assert.equal(moment.duration('01:02:03.9999999').minutes(), 2, '2 minutes');
        assert.equal(moment.duration('01:02:03.9999999').seconds(), 3, '3 seconds');
        assert.equal(moment.duration('01:02:03.9999999').milliseconds(), 999, '999 milliseconds');

        assert.equal(moment.duration('23:59:59.9999999').days(), 0, '0 days');
        assert.equal(moment.duration('23:59:59.9999999').hours(), 23, '23 hours');

        assert.equal(moment.duration('500:59:59.9999999').days(), 20, '500 hours overflows to 20 days');
        assert.equal(moment.duration('500:59:59.9999999').hours(), 20, '500 hours overflows to 20 hours');
    });

    test('instatiation from serialized C# TimeSpan without days or milliseconds', function (assert) {
        assert.equal(moment.duration('01:02:03').years(), 0, '0 years');
        assert.equal(moment.duration('01:02:03').days(), 0, '0 days');
        assert.equal(moment.duration('01:02:03').hours(), 1, '1 hour');
        assert.equal(moment.duration('01:02:03').minutes(), 2, '2 minutes');
        assert.equal(moment.duration('01:02:03').seconds(), 3, '3 seconds');
        assert.equal(moment.duration('01:02:03').milliseconds(), 0, '0 milliseconds');
    });

    test('instatiation from serialized C# TimeSpan without milliseconds', function (assert) {
        assert.equal(moment.duration('1.02:03:04').years(), 0, '0 years');
        assert.equal(moment.duration('1.02:03:04').days(), 1, '1 day');
        assert.equal(moment.duration('1.02:03:04').hours(), 2, '2 hours');
        assert.equal(moment.duration('1.02:03:04').minutes(), 3, '3 minutes');
        assert.equal(moment.duration('1.02:03:04').seconds(), 4, '4 seconds');
        assert.equal(moment.duration('1.02:03:04').milliseconds(), 0, '0 milliseconds');
    });

    test('instatiation from serialized C# TimeSpan maxValue', function (assert) {
        var d = moment.duration('10675199.02:48:05.4775807');

        assert.equal(d.years(), 29227, '29227 years');
        assert.equal(d.months(), 8, '8 months');
        assert.equal(d.days(), 12, '12 day');  // if you have to change this value -- just do it

        assert.equal(d.hours(), 2, '2 hours');
        assert.equal(d.minutes(), 48, '48 minutes');
        assert.equal(d.seconds(), 5, '5 seconds');
        assert.equal(d.milliseconds(), 477, '477 milliseconds');
    });

    test('instatiation from serialized C# TimeSpan minValue', function (assert) {
        var d = moment.duration('-10675199.02:48:05.4775808');

        assert.equal(d.years(), -29227, '29653 years');
        assert.equal(d.months(), -8, '8 day');
        assert.equal(d.days(), -12, '12 day');  // if you have to change this value -- just do it

        assert.equal(d.hours(), -2, '2 hours');
        assert.equal(d.minutes(), -48, '48 minutes');
        assert.equal(d.seconds(), -5, '5 seconds');
        assert.equal(d.milliseconds(), -477, '477 milliseconds');
    });

    test('instantiation from ISO 8601 duration', function (assert) {
        assert.equal(moment.duration('P1Y2M3DT4H5M6S').asSeconds(), moment.duration({y: 1, M: 2, d: 3, h: 4, m: 5, s: 6}).asSeconds(), 'all fields');
        assert.equal(moment.duration('P3W3D').asSeconds(), moment.duration({w: 3, d: 3}).asSeconds(), 'week and day fields');
        assert.equal(moment.duration('P1M').asSeconds(), moment.duration({M: 1}).asSeconds(), 'single month field');
        assert.equal(moment.duration('PT1M').asSeconds(), moment.duration({m: 1}).asSeconds(), 'single minute field');
        assert.equal(moment.duration('P1MT2H').asSeconds(), moment.duration({M: 1, h: 2}).asSeconds(), 'random fields missing');
        assert.equal(moment.duration('-P60D').asSeconds(), moment.duration({d: -60}).asSeconds(), 'negative days');
        assert.equal(moment.duration('PT0.5S').asSeconds(), moment.duration({s: 0.5}).asSeconds(), 'fractional seconds');
        assert.equal(moment.duration('PT0,5S').asSeconds(), moment.duration({s: 0.5}).asSeconds(), 'fractional seconds (comma)');
    });

    test('serialization to ISO 8601 duration strings', function (assert) {
        assert.equal(moment.duration({y: 1, M: 2, d: 3, h: 4, m: 5, s: 6}).toISOString(), 'P1Y2M3DT4H5M6S', 'all fields');
        assert.equal(moment.duration({M: -1}).toISOString(), '-P1M', 'one month ago');
        assert.equal(moment.duration({m: -1}).toISOString(), '-PT1M', 'one minute ago');
        assert.equal(moment.duration({s: -0.5}).toISOString(), '-PT0.5S', 'one half second ago');
        assert.equal(moment.duration({y: -0.5, M: 1}).toISOString(), '-P5M', 'a month after half a year ago');
        assert.equal(moment.duration({}).toISOString(), 'P0D', 'zero duration');
        assert.equal(moment.duration({M: 16, d:40, s: 86465}).toISOString(), 'P1Y4M40DT24H1M5S', 'all fields');
    });

    test('toString acts as toISOString', function (assert) {
        assert.equal(moment.duration({y: 1, M: 2, d: 3, h: 4, m: 5, s: 6}).toString(), 'P1Y2M3DT4H5M6S', 'all fields');
        assert.equal(moment.duration({M: -1}).toString(), '-P1M', 'one month ago');
        assert.equal(moment.duration({m: -1}).toString(), '-PT1M', 'one minute ago');
        assert.equal(moment.duration({s: -0.5}).toString(), '-PT0.5S', 'one half second ago');
        assert.equal(moment.duration({y: -0.5, M: 1}).toString(), '-P5M', 'a month after half a year ago');
        assert.equal(moment.duration({}).toString(), 'P0D', 'zero duration');
        assert.equal(moment.duration({M: 16, d:40, s: 86465}).toString(), 'P1Y4M40DT24H1M5S', 'all fields');
    });

    test('toIsoString deprecation', function (assert) {
        test.expectedDeprecations('toIsoString()');

        assert.equal(moment.duration({}).toIsoString(), moment.duration({}).toISOString(), 'toIsoString delegates to toISOString');
    });

    test('`isodate` (python) test cases', function (assert) {
        assert.equal(moment.duration('P18Y9M4DT11H9M8S').asSeconds(), moment.duration({y: 18, M: 9, d: 4, h: 11, m: 9, s: 8}).asSeconds(), 'python isodate 1');
        assert.equal(moment.duration('P2W').asSeconds(), moment.duration({w: 2}).asSeconds(), 'python isodate 2');
        assert.equal(moment.duration('P3Y6M4DT12H30M5S').asSeconds(), moment.duration({y: 3, M: 6, d: 4, h: 12, m: 30, s: 5}).asSeconds(), 'python isodate 3');
        assert.equal(moment.duration('P23DT23H').asSeconds(), moment.duration({d: 23, h: 23}).asSeconds(), 'python isodate 4');
        assert.equal(moment.duration('P4Y').asSeconds(), moment.duration({y: 4}).asSeconds(), 'python isodate 5');
        assert.equal(moment.duration('P1M').asSeconds(), moment.duration({M: 1}).asSeconds(), 'python isodate 6');
        assert.equal(moment.duration('PT1M').asSeconds(), moment.duration({m: 1}).asSeconds(), 'python isodate 7');
        assert.equal(moment.duration('P0.5Y').asSeconds(), moment.duration({y: 0.5}).asSeconds(), 'python isodate 8');
        assert.equal(moment.duration('PT36H').asSeconds(), moment.duration({h: 36}).asSeconds(), 'python isodate 9');
        assert.equal(moment.duration('P1DT12H').asSeconds(), moment.duration({d: 1, h: 12}).asSeconds(), 'python isodate 10');
        assert.equal(moment.duration('-P2W').asSeconds(), moment.duration({w: -2}).asSeconds(), 'python isodate 11');
        assert.equal(moment.duration('-P2.2W').asSeconds(), moment.duration({w: -2.2}).asSeconds(), 'python isodate 12');
        assert.equal(moment.duration('P1DT2H3M4S').asSeconds(), moment.duration({d: 1, h: 2, m: 3, s: 4}).asSeconds(), 'python isodate 13');
        assert.equal(moment.duration('P1DT2H3M').asSeconds(), moment.duration({d: 1, h: 2, m: 3}).asSeconds(), 'python isodate 14');
        assert.equal(moment.duration('P1DT2H').asSeconds(), moment.duration({d: 1, h: 2}).asSeconds(), 'python isodate 15');
        assert.equal(moment.duration('PT2H').asSeconds(), moment.duration({h: 2}).asSeconds(), 'python isodate 16');
        assert.equal(moment.duration('PT2.3H').asSeconds(), moment.duration({h: 2.3}).asSeconds(), 'python isodate 17');
        assert.equal(moment.duration('PT2H3M4S').asSeconds(), moment.duration({h: 2, m: 3, s: 4}).asSeconds(), 'python isodate 18');
        assert.equal(moment.duration('PT3M4S').asSeconds(), moment.duration({m: 3, s: 4}).asSeconds(), 'python isodate 19');
        assert.equal(moment.duration('PT22S').asSeconds(), moment.duration({s: 22}).asSeconds(), 'python isodate 20');
        assert.equal(moment.duration('PT22.22S').asSeconds(), moment.duration({s: 22.22}).asSeconds(), 'python isodate 21');
        assert.equal(moment.duration('-P2Y').asSeconds(), moment.duration({y: -2}).asSeconds(), 'python isodate 22');
        assert.equal(moment.duration('-P3Y6M4DT12H30M5S').asSeconds(), moment.duration({y: -3, M: -6, d: -4, h: -12, m: -30, s: -5}).asSeconds(), 'python isodate 23');
        assert.equal(moment.duration('-P1DT2H3M4S').asSeconds(), moment.duration({d: -1, h: -2, m: -3, s: -4}).asSeconds(), 'python isodate 24');
        assert.equal(moment.duration('PT-6H3M').asSeconds(), moment.duration({h: -6, m: 3}).asSeconds(), 'python isodate 25');
        assert.equal(moment.duration('-PT-6H3M').asSeconds(), moment.duration({h: 6, m: -3}).asSeconds(), 'python isodate 26');
        assert.equal(moment.duration('-P-3Y-6M-4DT-12H-30M-5S').asSeconds(), moment.duration({y: 3, M: 6, d: 4, h: 12, m: 30, s: 5}).asSeconds(), 'python isodate 27');
        assert.equal(moment.duration('P-3Y-6M-4DT-12H-30M-5S').asSeconds(), moment.duration({y: -3, M: -6, d: -4, h: -12, m: -30, s: -5}).asSeconds(), 'python isodate 28');
        assert.equal(moment.duration('-P-2W').asSeconds(), moment.duration({w: 2}).asSeconds(), 'python isodate 29');
        assert.equal(moment.duration('P-2W').asSeconds(), moment.duration({w: -2}).asSeconds(), 'python isodate 30');
    });

    test('ISO 8601 misuse cases', function (assert) {
        assert.equal(moment.duration('P').asSeconds(), 0, 'lonely P');
        assert.equal(moment.duration('PT').asSeconds(), 0, 'just P and T');
        assert.equal(moment.duration('P1H').asSeconds(), 0, 'missing T');
        assert.equal(moment.duration('P1D1Y').asSeconds(), 0, 'out of order');
        assert.equal(moment.duration('PT.5S').asSeconds(), 0.5, 'accept no leading zero for decimal');
        assert.equal(moment.duration('PT1,S').asSeconds(), 1, 'accept trailing decimal separator');
        assert.equal(moment.duration('PT1M0,,5S').asSeconds(), 60, 'extra decimal separators are ignored as 0');
    });

    test('humanize', function (assert) {
        moment.locale('en');
        assert.equal(moment.duration({seconds: 44}).humanize(),  'a few seconds', '44 seconds = a few seconds');
        assert.equal(moment.duration({seconds: 45}).humanize(),  'a minute',      '45 seconds = a minute');
        assert.equal(moment.duration({seconds: 89}).humanize(),  'a minute',      '89 seconds = a minute');
        assert.equal(moment.duration({seconds: 90}).humanize(),  '2 minutes',     '90 seconds = 2 minutes');
        assert.equal(moment.duration({minutes: 44}).humanize(),  '44 minutes',    '44 minutes = 44 minutes');
        assert.equal(moment.duration({minutes: 45}).humanize(),  'an hour',       '45 minutes = an hour');
        assert.equal(moment.duration({minutes: 89}).humanize(),  'an hour',       '89 minutes = an hour');
        assert.equal(moment.duration({minutes: 90}).humanize(),  '2 hours',       '90 minutes = 2 hours');
        assert.equal(moment.duration({hours: 5}).humanize(),     '5 hours',       '5 hours = 5 hours');
        assert.equal(moment.duration({hours: 21}).humanize(),    '21 hours',      '21 hours = 21 hours');
        assert.equal(moment.duration({hours: 22}).humanize(),    'a day',         '22 hours = a day');
        assert.equal(moment.duration({hours: 35}).humanize(),    'a day',         '35 hours = a day');
        assert.equal(moment.duration({hours: 36}).humanize(),    '2 days',        '36 hours = 2 days');
        assert.equal(moment.duration({days: 1}).humanize(),      'a day',         '1 day = a day');
        assert.equal(moment.duration({days: 5}).humanize(),      '5 days',        '5 days = 5 days');
        assert.equal(moment.duration({weeks: 1}).humanize(),     '7 days',        '1 week = 7 days');
        assert.equal(moment.duration({days: 25}).humanize(),     '25 days',       '25 days = 25 days');
        assert.equal(moment.duration({days: 26}).humanize(),     'a month',       '26 days = a month');
        assert.equal(moment.duration({days: 30}).humanize(),     'a month',       '30 days = a month');
        assert.equal(moment.duration({days: 45}).humanize(),     'a month',       '45 days = a month');
        assert.equal(moment.duration({days: 46}).humanize(),     '2 months',      '46 days = 2 months');
        assert.equal(moment.duration({days: 74}).humanize(),     '2 months',      '74 days = 2 months');
        assert.equal(moment.duration({days: 77}).humanize(),     '3 months',      '77 days = 3 months');
        assert.equal(moment.duration({months: 1}).humanize(),    'a month',       '1 month = a month');
        assert.equal(moment.duration({months: 5}).humanize(),    '5 months',      '5 months = 5 months');
        assert.equal(moment.duration({days: 344}).humanize(),    'a year',        '344 days = a year');
        assert.equal(moment.duration({days: 345}).humanize(),    'a year',        '345 days = a year');
        assert.equal(moment.duration({days: 547}).humanize(),    'a year',        '547 days = a year');
        assert.equal(moment.duration({days: 548}).humanize(),    '2 years',       '548 days = 2 years');
        assert.equal(moment.duration({years: 1}).humanize(),     'a year',        '1 year = a year');
        assert.equal(moment.duration({years: 5}).humanize(),     '5 years',       '5 years = 5 years');
        assert.equal(moment.duration(7200000).humanize(),        '2 hours',       '7200000 = 2 minutes');
    });

    test('humanize duration with suffix', function (assert) {
        moment.locale('en');
        assert.equal(moment.duration({seconds:  44}).humanize(true),  'in a few seconds', '44 seconds = a few seconds');
        assert.equal(moment.duration({seconds: -44}).humanize(true),  'a few seconds ago', '44 seconds = a few seconds');
    });

    test('bubble value up', function (assert) {
        assert.equal(moment.duration({milliseconds: 61001}).milliseconds(), 1, '61001 milliseconds has 1 millisecond left over');
        assert.equal(moment.duration({milliseconds: 61001}).seconds(),      1, '61001 milliseconds has 1 second left over');
        assert.equal(moment.duration({milliseconds: 61001}).minutes(),      1, '61001 milliseconds has 1 minute left over');

        assert.equal(moment.duration({minutes: 350}).minutes(), 50, '350 minutes has 50 minutes left over');
        assert.equal(moment.duration({minutes: 350}).hours(),   5,  '350 minutes has 5 hours left over');
    });

    test('clipping', function (assert) {
        assert.equal(moment.duration({months: 11}).months(), 11, '11 months is 11 months');
        assert.equal(moment.duration({months: 11}).years(),  0,  '11 months makes no year');
        assert.equal(moment.duration({months: 12}).months(), 0,  '12 months is 0 months left over');
        assert.equal(moment.duration({months: 12}).years(),  1,  '12 months makes 1 year');
        assert.equal(moment.duration({months: 13}).months(), 1,  '13 months is 1 month left over');
        assert.equal(moment.duration({months: 13}).years(),  1,  '13 months makes 1 year');

        assert.equal(moment.duration({days: 30}).days(),   30, '30 days is 30 days');
        assert.equal(moment.duration({days: 30}).months(), 0,  '30 days makes no month');
        assert.equal(moment.duration({days: 31}).days(),   0,  '31 days is 0 days left over');
        assert.equal(moment.duration({days: 31}).months(), 1,  '31 days is a month');
        assert.equal(moment.duration({days: 32}).days(),   1,  '32 days is 1 day left over');
        assert.equal(moment.duration({days: 32}).months(), 1,  '32 days is a month');

        assert.equal(moment.duration({hours: 23}).hours(), 23, '23 hours is 23 hours');
        assert.equal(moment.duration({hours: 23}).days(),  0,  '23 hours makes no day');
        assert.equal(moment.duration({hours: 24}).hours(), 0,  '24 hours is 0 hours left over');
        assert.equal(moment.duration({hours: 24}).days(),  1,  '24 hours makes 1 day');
        assert.equal(moment.duration({hours: 25}).hours(), 1,  '25 hours is 1 hour left over');
        assert.equal(moment.duration({hours: 25}).days(),  1,  '25 hours makes 1 day');
    });

    test('bubbling consistency', function (assert) {
        var days = 0, months = 0, newDays, newMonths, totalDays, d;
        for (totalDays = 1; totalDays <= 500; ++totalDays) {
            d = moment.duration(totalDays, 'days');
            newDays = d.days();
            newMonths = d.months() + d.years() * 12;
            assert.ok(
                    (months === newMonths && days + 1 === newDays) ||
                    (months + 1 === newMonths && newDays === 0),
                    'consistent total days ' + totalDays +
                    ' was ' + months + ' ' + days +
                    ' now ' + newMonths + ' ' + newDays);
            days = newDays;
            months = newMonths;
        }
    });

    test('effective equivalency', function (assert) {
        assert.deepEqual(moment.duration({seconds: 1})._data,  moment.duration({milliseconds: 1000})._data, '1 second is the same as 1000 milliseconds');
        assert.deepEqual(moment.duration({seconds: 60})._data, moment.duration({minutes: 1})._data,         '1 minute is the same as 60 seconds');
        assert.deepEqual(moment.duration({minutes: 60})._data, moment.duration({hours: 1})._data,           '1 hour is the same as 60 minutes');
        assert.deepEqual(moment.duration({hours: 24})._data,   moment.duration({days: 1})._data,            '1 day is the same as 24 hours');
        assert.deepEqual(moment.duration({days: 7})._data,     moment.duration({weeks: 1})._data,           '1 week is the same as 7 days');
        assert.deepEqual(moment.duration({days: 31})._data,    moment.duration({months: 1})._data,          '1 month is the same as 30 days');
        assert.deepEqual(moment.duration({months: 12})._data,  moment.duration({years: 1})._data,           '1 years is the same as 12 months');
    });

    test('asGetters', function (assert) {
        // 400 years have exactly 146097 days

        // years
        assert.equal(moment.duration(1, 'year').asYears(),            1,           '1 year as years');
        assert.equal(moment.duration(1, 'year').asMonths(),           12,          '1 year as months');
        assert.equal(moment.duration(400, 'year').asMonths(),         4800,        '400 years as months');
        assert.equal(moment.duration(1, 'year').asWeeks().toFixed(3), 52.143,      '1 year as weeks');
        assert.equal(moment.duration(1, 'year').asDays(),             365,         '1 year as days');
        assert.equal(moment.duration(2, 'year').asDays(),             730,         '2 years as days');
        assert.equal(moment.duration(3, 'year').asDays(),             1096,        '3 years as days');
        assert.equal(moment.duration(4, 'year').asDays(),             1461,        '4 years as days');
        assert.equal(moment.duration(400, 'year').asDays(),           146097,      '400 years as days');
        assert.equal(moment.duration(1, 'year').asHours(),            8760,        '1 year as hours');
        assert.equal(moment.duration(1, 'year').asMinutes(),          525600,      '1 year as minutes');
        assert.equal(moment.duration(1, 'year').asSeconds(),          31536000,    '1 year as seconds');
        assert.equal(moment.duration(1, 'year').asMilliseconds(),     31536000000, '1 year as milliseconds');

        // months
        assert.equal(moment.duration(1, 'month').asYears().toFixed(4), 0.0833,     '1 month as years');
        assert.equal(moment.duration(1, 'month').asMonths(),           1,          '1 month as months');
        assert.equal(moment.duration(1, 'month').asWeeks().toFixed(3), 4.286,      '1 month as weeks');
        assert.equal(moment.duration(1, 'month').asDays(),             30,         '1 month as days');
        assert.equal(moment.duration(2, 'month').asDays(),             61,         '2 months as days');
        assert.equal(moment.duration(3, 'month').asDays(),             91,         '3 months as days');
        assert.equal(moment.duration(4, 'month').asDays(),             122,        '4 months as days');
        assert.equal(moment.duration(5, 'month').asDays(),             152,        '5 months as days');
        assert.equal(moment.duration(6, 'month').asDays(),             183,        '6 months as days');
        assert.equal(moment.duration(7, 'month').asDays(),             213,        '7 months as days');
        assert.equal(moment.duration(8, 'month').asDays(),             243,        '8 months as days');
        assert.equal(moment.duration(9, 'month').asDays(),             274,        '9 months as days');
        assert.equal(moment.duration(10, 'month').asDays(),            304,        '10 months as days');
        assert.equal(moment.duration(11, 'month').asDays(),            335,        '11 months as days');
        assert.equal(moment.duration(12, 'month').asDays(),            365,        '12 months as days');
        assert.equal(moment.duration(24, 'month').asDays(),            730,        '24 months as days');
        assert.equal(moment.duration(36, 'month').asDays(),            1096,       '36 months as days');
        assert.equal(moment.duration(48, 'month').asDays(),            1461,       '48 months as days');
        assert.equal(moment.duration(4800, 'month').asDays(),          146097,     '4800 months as days');
        assert.equal(moment.duration(1, 'month').asHours(),            720,        '1 month as hours');
        assert.equal(moment.duration(1, 'month').asMinutes(),          43200,      '1 month as minutes');
        assert.equal(moment.duration(1, 'month').asSeconds(),          2592000,    '1 month as seconds');
        assert.equal(moment.duration(1, 'month').asMilliseconds(),     2592000000, '1 month as milliseconds');

        // weeks
        assert.equal(moment.duration(1, 'week').asYears().toFixed(4),  0.0192,    '1 week as years');
        assert.equal(moment.duration(1, 'week').asMonths().toFixed(3), 0.230,     '1 week as months');
        assert.equal(moment.duration(1, 'week').asWeeks(),             1,         '1 week as weeks');
        assert.equal(moment.duration(1, 'week').asDays(),              7,         '1 week as days');
        assert.equal(moment.duration(1, 'week').asHours(),             168,       '1 week as hours');
        assert.equal(moment.duration(1, 'week').asMinutes(),           10080,     '1 week as minutes');
        assert.equal(moment.duration(1, 'week').asSeconds(),           604800,    '1 week as seconds');
        assert.equal(moment.duration(1, 'week').asMilliseconds(),      604800000, '1 week as milliseconds');

        // days
        assert.equal(moment.duration(1, 'day').asYears().toFixed(4),  0.0027,   '1 day as years');
        assert.equal(moment.duration(1, 'day').asMonths().toFixed(3), 0.033,    '1 day as months');
        assert.equal(moment.duration(1, 'day').asWeeks().toFixed(3),  0.143,    '1 day as weeks');
        assert.equal(moment.duration(1, 'day').asDays(),              1,        '1 day as days');
        assert.equal(moment.duration(1, 'day').asHours(),             24,       '1 day as hours');
        assert.equal(moment.duration(1, 'day').asMinutes(),           1440,     '1 day as minutes');
        assert.equal(moment.duration(1, 'day').asSeconds(),           86400,    '1 day as seconds');
        assert.equal(moment.duration(1, 'day').asMilliseconds(),      86400000, '1 day as milliseconds');

        // hours
        assert.equal(moment.duration(1, 'hour').asYears().toFixed(6),  0.000114, '1 hour as years');
        assert.equal(moment.duration(1, 'hour').asMonths().toFixed(5), 0.00137,  '1 hour as months');
        assert.equal(moment.duration(1, 'hour').asWeeks().toFixed(5),  0.00595,  '1 hour as weeks');
        assert.equal(moment.duration(1, 'hour').asDays().toFixed(4),   0.0417,   '1 hour as days');
        assert.equal(moment.duration(1, 'hour').asHours(),             1,        '1 hour as hours');
        assert.equal(moment.duration(1, 'hour').asMinutes(),           60,       '1 hour as minutes');
        assert.equal(moment.duration(1, 'hour').asSeconds(),           3600,     '1 hour as seconds');
        assert.equal(moment.duration(1, 'hour').asMilliseconds(),      3600000,  '1 hour as milliseconds');

        // minutes
        assert.equal(moment.duration(1, 'minute').asYears().toFixed(8),  0.00000190, '1 minute as years');
        assert.equal(moment.duration(1, 'minute').asMonths().toFixed(7), 0.0000228,  '1 minute as months');
        assert.equal(moment.duration(1, 'minute').asWeeks().toFixed(7),  0.0000992,  '1 minute as weeks');
        assert.equal(moment.duration(1, 'minute').asDays().toFixed(6),   0.000694,   '1 minute as days');
        assert.equal(moment.duration(1, 'minute').asHours().toFixed(4),  0.0167,     '1 minute as hours');
        assert.equal(moment.duration(1, 'minute').asMinutes(),           1,          '1 minute as minutes');
        assert.equal(moment.duration(1, 'minute').asSeconds(),           60,         '1 minute as seconds');
        assert.equal(moment.duration(1, 'minute').asMilliseconds(),      60000,      '1 minute as milliseconds');

        // seconds
        assert.equal(moment.duration(1, 'second').asYears().toFixed(10),  0.0000000317, '1 second as years');
        assert.equal(moment.duration(1, 'second').asMonths().toFixed(9),  0.000000380,  '1 second as months');
        assert.equal(moment.duration(1, 'second').asWeeks().toFixed(8),   0.00000165,   '1 second as weeks');
        assert.equal(moment.duration(1, 'second').asDays().toFixed(7),    0.0000116,    '1 second as days');
        assert.equal(moment.duration(1, 'second').asHours().toFixed(6),   0.000278,     '1 second as hours');
        assert.equal(moment.duration(1, 'second').asMinutes().toFixed(4), 0.0167,       '1 second as minutes');
        assert.equal(moment.duration(1, 'second').asSeconds(),            1,            '1 second as seconds');
        assert.equal(moment.duration(1, 'second').asMilliseconds(),       1000,         '1 second as milliseconds');

        // milliseconds
        assert.equal(moment.duration(1, 'millisecond').asYears().toFixed(13),  0.0000000000317, '1 millisecond as years');
        assert.equal(moment.duration(1, 'millisecond').asMonths().toFixed(12), 0.000000000380,  '1 millisecond as months');
        assert.equal(moment.duration(1, 'millisecond').asWeeks().toFixed(11),  0.00000000165,   '1 millisecond as weeks');
        assert.equal(moment.duration(1, 'millisecond').asDays().toFixed(10),   0.0000000116,    '1 millisecond as days');
        assert.equal(moment.duration(1, 'millisecond').asHours().toFixed(9),   0.000000278,     '1 millisecond as hours');
        assert.equal(moment.duration(1, 'millisecond').asMinutes().toFixed(7), 0.0000167,       '1 millisecond as minutes');
        assert.equal(moment.duration(1, 'millisecond').asSeconds(),            0.001,           '1 millisecond as seconds');
        assert.equal(moment.duration(1, 'millisecond').asMilliseconds(),       1,               '1 millisecond as milliseconds');
    });

    test('as getters for small units', function (assert) {
        var dS = moment.duration(1, 'milliseconds'),
            ds = moment.duration(3, 'seconds'),
            dm = moment.duration(13, 'minutes');

        // Tests for issue #1867.
        // Floating point errors for small duration units were introduced in version 2.8.0.
        assert.equal(dS.as('milliseconds'), 1, 'as("milliseconds")');
        assert.equal(dS.asMilliseconds(),   1, 'asMilliseconds()');
        assert.equal(ds.as('seconds'),      3, 'as("seconds")');
        assert.equal(ds.asSeconds(),        3, 'asSeconds()');
        assert.equal(dm.as('minutes'),      13, 'as("minutes")');
        assert.equal(dm.asMinutes(),        13, 'asMinutes()');
    });

    test('minutes getter for floating point hours', function (assert) {
        // Tests for issue #2978.
        // For certain floating point hours, .minutes() getter produced incorrect values due to the rounding errors
        assert.equal(moment.duration(2.3, 'h').minutes(), 18, 'minutes()');
        assert.equal(moment.duration(4.1, 'h').minutes(), 6, 'minutes()');
    });

    test('isDuration', function (assert) {
        assert.ok(moment.isDuration(moment.duration(12345678)), 'correctly says true');
        assert.ok(!moment.isDuration(moment()), 'moment object is not a duration');
        assert.ok(!moment.isDuration({milliseconds: 1}), 'plain object is not a duration');
    });

    test('add', function (assert) {
        var d = moment.duration({months: 4, weeks: 3, days: 2});
        // for some reason, d._data._months does not get updated; use d._months instead.
        assert.equal(d.add(1, 'month')._months, 5, 'Add months');
        assert.equal(d.add(5, 'days')._days, 28, 'Add days');
        assert.equal(d.add(10000)._milliseconds, 10000, 'Add milliseconds');
        assert.equal(d.add({h: 23, m: 59})._milliseconds, 23 * 60 * 60 * 1000 + 59 * 60 * 1000 + 10000, 'Add hour:minute');
    });

    test('add and bubble', function (assert) {
        var d;

        assert.equal(moment.duration(1, 'second').add(1000, 'milliseconds').seconds(), 2, 'Adding milliseconds should bubble up to seconds');
        assert.equal(moment.duration(1, 'minute').add(60, 'second').minutes(), 2, 'Adding seconds should bubble up to minutes');
        assert.equal(moment.duration(1, 'hour').add(60, 'minutes').hours(), 2, 'Adding minutes should bubble up to hours');
        assert.equal(moment.duration(1, 'day').add(24, 'hours').days(), 2, 'Adding hours should bubble up to days');

        d = moment.duration(-1, 'day').add(1, 'hour');
        assert.equal(d.hours(), -23, '-1 day + 1 hour == -23 hour (component)');
        assert.equal(d.asHours(), -23, '-1 day + 1 hour == -23 hours');

        d = moment.duration(-1, 'year').add(1, 'day');
        assert.equal(d.days(), -30, '- 1 year + 1 day == -30 days (component)');
        assert.equal(d.months(), -11, '- 1 year + 1 day == -11 months (component)');
        assert.equal(d.years(), 0, '- 1 year + 1 day == 0 years (component)');
        assert.equal(d.asDays(), -364, '- 1 year + 1 day == -364 days');

        d = moment.duration(-1, 'year').add(1, 'hour');
        assert.equal(d.hours(), -23, '- 1 year + 1 hour == -23 hours (component)');
        assert.equal(d.days(), -30, '- 1 year + 1 hour == -30 days (component)');
        assert.equal(d.months(), -11, '- 1 year + 1 hour == -11 months (component)');
        assert.equal(d.years(), 0, '- 1 year + 1 hour == 0 years (component)');
    });

    test('subtract and bubble', function (assert) {
        var d;

        assert.equal(moment.duration(2, 'second').subtract(1000, 'milliseconds').seconds(), 1, 'Subtracting milliseconds should bubble up to seconds');
        assert.equal(moment.duration(2, 'minute').subtract(60, 'second').minutes(), 1, 'Subtracting seconds should bubble up to minutes');
        assert.equal(moment.duration(2, 'hour').subtract(60, 'minutes').hours(), 1, 'Subtracting minutes should bubble up to hours');
        assert.equal(moment.duration(2, 'day').subtract(24, 'hours').days(), 1, 'Subtracting hours should bubble up to days');

        d = moment.duration(1, 'day').subtract(1, 'hour');
        assert.equal(d.hours(), 23, '1 day - 1 hour == 23 hour (component)');
        assert.equal(d.asHours(), 23, '1 day - 1 hour == 23 hours');

        d = moment.duration(1, 'year').subtract(1, 'day');
        assert.equal(d.days(), 30, '1 year - 1 day == 30 days (component)');
        assert.equal(d.months(), 11, '1 year - 1 day == 11 months (component)');
        assert.equal(d.years(), 0, '1 year - 1 day == 0 years (component)');
        assert.equal(d.asDays(), 364, '1 year - 1 day == 364 days');

        d = moment.duration(1, 'year').subtract(1, 'hour');
        assert.equal(d.hours(), 23, '1 year - 1 hour == 23 hours (component)');
        assert.equal(d.days(), 30, '1 year - 1 hour == 30 days (component)');
        assert.equal(d.months(), 11, '1 year - 1 hour == 11 months (component)');
        assert.equal(d.years(), 0, '1 year - 1 hour == 0 years (component)');
    });

    test('subtract', function (assert) {
        var d = moment.duration({months: 2, weeks: 2, days: 0, hours: 5});
        // for some reason, d._data._months does not get updated; use d._months instead.
        assert.equal(d.subtract(1, 'months')._months, 1, 'Subtract months');
        assert.equal(d.subtract(14, 'days')._days, 0, 'Subtract days');
        assert.equal(d.subtract(10000)._milliseconds, 5 * 60 * 60 * 1000 - 10000, 'Subtract milliseconds');
        assert.equal(d.subtract({h: 1, m: 59})._milliseconds, 3 * 60 * 60 * 1000 + 1 * 60 * 1000 - 10000, 'Subtract hour:minute');
    });

    test('JSON.stringify duration', function (assert) {
        var d = moment.duration(1024, 'h');

        assert.equal(JSON.stringify(d), '"' + d.toISOString() + '"', 'JSON.stringify on duration should return ISO string');
    });

    test('duration plugins', function (assert) {
        var durationObject = moment.duration();
        moment.duration.fn.foo = function (arg) {
            assert.equal(this, durationObject);
            assert.equal(arg, 5);
        };
        durationObject.foo(5);
    });

}));

;(function (global, factory) {
   typeof exports === 'object' && typeof module !== 'undefined'
       && typeof require === 'function' ? factory(require('../../moment')) :
   typeof define === 'function' && define.amd ? define(['../../moment'], factory) :
   factory(global.moment)
}(this, function (moment) { 'use strict';

    function each(array, callback) {
        var i;
        for (i = 0; i < array.length; i++) {
            callback(array[i], i, array);
        }
    }

    function objectKeys(obj) {
        if (Object.keys) {
            return Object.keys(obj);
        } else {
            // IE8
            var res = [], i;
            for (i in obj) {
                if (obj.hasOwnProperty(i)) {
                    res.push(i);
                }
            }
            return res;
        }
    }

    // Pick the first defined of two or three arguments.
    function defaults(a, b, c) {
        if (a != null) {
            return a;
        }
        if (b != null) {
            return b;
        }
        return c;
    }

    function defineCommonLocaleTests(locale, options) {
        test('lenient ordinal parsing', function (assert) {
            var i, ordinalStr, testMoment;
            for (i = 1; i <= 31; ++i) {
                ordinalStr = moment([2014, 0, i]).format('YYYY MM Do');
                testMoment = moment(ordinalStr, 'YYYY MM Do');
                assert.equal(testMoment.year(), 2014,
                        'lenient ordinal parsing ' + i + ' year check');
                assert.equal(testMoment.month(), 0,
                        'lenient ordinal parsing ' + i + ' month check');
                assert.equal(testMoment.date(), i,
                        'lenient ordinal parsing ' + i + ' date check');
            }
        });

        test('lenient ordinal parsing of number', function (assert) {
            var i, testMoment;
            for (i = 1; i <= 31; ++i) {
                testMoment = moment('2014 01 ' + i, 'YYYY MM Do');
                assert.equal(testMoment.year(), 2014,
                        'lenient ordinal parsing of number ' + i + ' year check');
                assert.equal(testMoment.month(), 0,
                        'lenient ordinal parsing of number ' + i + ' month check');
                assert.equal(testMoment.date(), i,
                        'lenient ordinal parsing of number ' + i + ' date check');
            }
        });

        test('strict ordinal parsing', function (assert) {
            var i, ordinalStr, testMoment;
            for (i = 1; i <= 31; ++i) {
                ordinalStr = moment([2014, 0, i]).format('YYYY MM Do');
                testMoment = moment(ordinalStr, 'YYYY MM Do', true);
                assert.ok(testMoment.isValid(), 'strict ordinal parsing ' + i);
            }
        });

        test('meridiem invariant', function (assert) {
            var h, m, t1, t2;
            for (h = 0; h < 24; ++h) {
                for (m = 0; m < 60; m += 15) {
                    t1 = moment.utc([2000, 0, 1, h, m]);
                    t2 = moment.utc(t1.format('A h:mm'), 'A h:mm');
                    assert.equal(t2.format('HH:mm'), t1.format('HH:mm'),
                            'meridiem at ' + t1.format('HH:mm'));
                }
            }
        });

        test('date format correctness', function (assert) {
            var data, tokens;
            data = moment.localeData()._longDateFormat;
            tokens = objectKeys(data);
            each(tokens, function (srchToken) {
                // Check each format string to make sure it does not contain any
                // tokens that need to be expanded.
                each(tokens, function (baseToken) {
                    // strip escaped sequences
                    var format = data[baseToken].replace(/(\[[^\]]*\])/g, '');
                    assert.equal(false, !!~format.indexOf(srchToken),
                            'contains ' + srchToken + ' in ' + baseToken);
                });
            });
        });

        test('month parsing correctness', function (assert) {
            var i, m;

            if (locale === 'tr') {
                // I can't fix it :(
                expect(0);
                return;
            }
            function tester(format) {
                var r;
                r = moment(m.format(format), format);
                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format);
                r = moment(m.format(format).toLocaleUpperCase(), format);
                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' upper');
                r = moment(m.format(format).toLocaleLowerCase(), format);
                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' lower');

                r = moment(m.format(format), format, true);
                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' strict');
                r = moment(m.format(format).toLocaleUpperCase(), format, true);
                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' upper strict');
                r = moment(m.format(format).toLocaleLowerCase(), format, true);
                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' lower strict');
            }

            for (i = 0; i < 12; ++i) {
                m = moment([2015, i, 15, 18]);
                tester('MMM');
                tester('MMM.');
                tester('MMMM');
                tester('MMMM.');
            }
        });

        test('weekday parsing correctness', function (assert) {
            var i, m;

            if (locale === 'tr' || locale === 'az') {
                // There is a lower-case letter (Ä±), that converted to upper then
                // lower changes to i
                expect(0);
                return;
            }
            function tester(format) {
                var r, baseMsg = 'weekday ' + m.weekday() + ' fmt ' + format;
                r = moment(m.format(format), format);
                assert.equal(r.weekday(), m.weekday(), baseMsg);
                r = moment(m.format(format).toLocaleUpperCase(), format);
                assert.equal(r.weekday(), m.weekday(), baseMsg + ' upper');
                r = moment(m.format(format).toLocaleLowerCase(), format);
                assert.equal(r.weekday(), m.weekday(), baseMsg + ' lower');

                r = moment(m.format(format), format, true);
                assert.equal(r.weekday(), m.weekday(), baseMsg + ' strict');
                r = moment(m.format(format).toLocaleUpperCase(), format, true);
                assert.equal(r.weekday(), m.weekday(), baseMsg + ' upper strict');
                r = moment(m.format(format).toLocaleLowerCase(), format, true);
                assert.equal(r.weekday(), m.weekday(), baseMsg + ' lower strict');
            }

            for (i = 0; i < 7; ++i) {
                m = moment.utc([2015, i, 15, 18]);
                tester('dd');
                tester('ddd');
                tester('dddd');
            }
        });
    }

    function setupDeprecationHandler(test, moment, scope) {
        test._expectedDeprecations = null;
        test._observedDeprecations = null;
        test._oldSupress = moment.suppressDeprecationWarnings;
        moment.suppressDeprecationWarnings = true;
        test.expectedDeprecations = function () {
            test._expectedDeprecations = arguments;
            test._observedDeprecations = [];
        };
        moment.deprecationHandler = function (name, msg) {
            var deprecationId = matchedDeprecation(name, msg, test._expectedDeprecations);
            if (deprecationId === -1) {
                throw new Error('Unexpected deprecation thrown name=' +
                        name + ' msg=' + msg);
            }
            test._observedDeprecations[deprecationId] = 1;
        };
    }

    function teardownDeprecationHandler(test, moment, scope) {
        moment.suppressDeprecationWarnings = test._oldSupress;

        if (test._expectedDeprecations != null) {
            var missedDeprecations = [];
            each(test._expectedDeprecations, function (deprecationPattern, id) {
                if (test._observedDeprecations[id] !== 1) {
                    missedDeprecations.push(deprecationPattern);
                }
            });
            if (missedDeprecations.length !== 0) {
                throw new Error('Expected deprecation warnings did not happen: ' +
                        missedDeprecations.join(' '));
            }
        }
    }

    function matchedDeprecation(name, msg, deprecations) {
        if (deprecations == null) {
            return -1;
        }
        for (var i = 0; i < deprecations.length; ++i) {
            if (name != null && name === deprecations[i]) {
                return i;
            }
            if (msg != null && msg.substring(0, deprecations[i].length) === deprecations[i]) {
                return i;
            }
        }
        return -1;
    }

    /*global QUnit:false*/

    var test = QUnit.test;

    var expect = QUnit.expect;

    function module (name, lifecycle) {
        QUnit.module(name, {
            setup : function () {
                moment.locale('en');
                moment.createFromInputFallback = function (config) {
                    throw new Error('input not handled by moment: ' + config._i);
                };
                setupDeprecationHandler(test, moment, 'core');
                if (lifecycle && lifecycle.setup) {
                    lifecycle.setup();
                }
            },
            teardown : function () {
                teardownDeprecationHandler(test, moment, 'core');
                if (lifecycle && lifecycle.teardown) {
                    lifecycle.teardown();
                }
            }
        });
    }

    function localeModule (name, lifecycle) {
        QUnit.module('locale:' + name, {
            setup : function () {
                moment.locale(name);
                moment.createFromInputFallback = function (config) {
                    throw new Error('input not handled by moment: ' + config._i);
                };
                setupDeprecationHandler(test, moment, 'locale');
                if (lifecycle && lifecycle.setup) {
                    lifecycle.setup();
                }
            },
            teardown : function () {
                moment.locale('en');
                teardownDeprecationHandler(test, moment, 'locale');
                if (lifecycle && lifecycle.teardown) {
                    lifecycle.teardown();
                }
            }
        });
        defineCommonLocaleTests(name, -1, -1);
    }

    module('duration from moments');

    test('pure year diff', function (assert) {
        var m1 = moment('2012-01-01T00:00:00.000Z'),
            m2 = moment('2013-01-01T00:00:00.000Z');

        assert.equal(moment.duration({from: m1, to: m2}).as('years'), 1, 'year moment difference');
        assert.equal(moment.duration({from: m2, to: m1}).as('years'), -1, 'negative year moment difference');
    });

    test('month and day diff', function (assert) {
        var m1 = moment('2012-01-15T00:00:00.000Z'),
            m2 = moment('2012-02-17T00:00:00.000Z'),
            d = moment.duration({from: m1, to: m2});

        assert.equal(d.get('days'), 2);
        assert.equal(d.get('months'), 1);
    });

    test('day diff, separate months', function (assert) {
        var m1 = moment('2012-01-15T00:00:00.000Z'),
            m2 = moment('2012-02-13T00:00:00.000Z'),
            d = moment.duration({from: m1, to: m2});

        assert.equal(d.as('days'), 29);
    });

    test('hour diff', function (assert) {
        var m1 = moment('2012-01-15T17:00:00.000Z'),
            m2 = moment('2012-01-16T03:00:00.000Z'),
            d = moment.duration({from: m1, to: m2});

        assert.equal(d.as('hours'), 10);
    });

    test('minute diff', function (assert) {
        var m1 = moment('2012-01-15T17:45:00.000Z'),
            m2 = moment('2012-01-16T03:15:00.000Z'),
            d = moment.duration({from: m1, to: m2});

        assert.equal(d.as('hours'), 9.5);
    });

}));

;(function (global, factory) {
   typeof exports === 'object' && typeof module !== 'undefined'
       && typeof require === 'function' ? factory(require('../../moment')) :
   typeof define === 'function' && define.amd ? define(['../../moment'], factory) :
   factory(global.moment)
}(this, function (moment) { 'use strict';

    function each(array, callback) {
        var i;
        for (i = 0; i < array.length; i++) {
            callback(array[i], i, array);
        }
    }

    function objectKeys(obj) {
        if (Object.keys) {
            return Object.keys(obj);
        } else {
            // IE8
            var res = [], i;
            for (i in obj) {
                if (obj.hasOwnProperty(i)) {
                    res.push(i);
                }
            }
            return res;
        }
    }

    // Pick the first defined of two or three arguments.
    function defaults(a, b, c) {
        if (a != null) {
            return a;
        }
        if (b != null) {
            return b;
        }
        return c;
    }

    function defineCommonLocaleTests(locale, options) {
        test('lenient ordinal parsing', function (assert) {
            var i, ordinalStr, testMoment;
            for (i = 1; i <= 31; ++i) {
                ordinalStr = moment([2014, 0, i]).format('YYYY MM Do');
                testMoment = moment(ordinalStr, 'YYYY MM Do');
                assert.equal(testMoment.year(), 2014,
                        'lenient ordinal parsing ' + i + ' year check');
                assert.equal(testMoment.month(), 0,
                        'lenient ordinal parsing ' + i + ' month check');
                assert.equal(testMoment.date(), i,
                        'lenient ordinal parsing ' + i + ' date check');
            }
        });

        test('lenient ordinal parsing of number', function (assert) {
            var i, testMoment;
            for (i = 1; i <= 31; ++i) {
                testMoment = moment('2014 01 ' + i, 'YYYY MM Do');
                assert.equal(testMoment.year(), 2014,
                        'lenient ordinal parsing of number ' + i + ' year check');
                assert.equal(testMoment.month(), 0,
                        'lenient ordinal parsing of number ' + i + ' month check');
                assert.equal(testMoment.date(), i,
                        'lenient ordinal parsing of number ' + i + ' date check');
            }
        });

        test('strict ordinal parsing', function (assert) {
            var i, ordinalStr, testMoment;
            for (i = 1; i <= 31; ++i) {
                ordinalStr = moment([2014, 0, i]).format('YYYY MM Do');
                testMoment = moment(ordinalStr, 'YYYY MM Do', true);
                assert.ok(testMoment.isValid(), 'strict ordinal parsing ' + i);
            }
        });

        test('meridiem invariant', function (assert) {
            var h, m, t1, t2;
            for (h = 0; h < 24; ++h) {
                for (m = 0; m < 60; m += 15) {
                    t1 = moment.utc([2000, 0, 1, h, m]);
                    t2 = moment.utc(t1.format('A h:mm'), 'A h:mm');
                    assert.equal(t2.format('HH:mm'), t1.format('HH:mm'),
                            'meridiem at ' + t1.format('HH:mm'));
                }
            }
        });

        test('date format correctness', function (assert) {
            var data, tokens;
            data = moment.localeData()._longDateFormat;
            tokens = objectKeys(data);
            each(tokens, function (srchToken) {
                // Check each format string to make sure it does not contain any
                // tokens that need to be expanded.
                each(tokens, function (baseToken) {
                    // strip escaped sequences
                    var format = data[baseToken].replace(/(\[[^\]]*\])/g, '');
                    assert.equal(false, !!~format.indexOf(srchToken),
                            'contains ' + srchToken + ' in ' + baseToken);
                });
            });
        });

        test('month parsing correctness', function (assert) {
            var i, m;

            if (locale === 'tr') {
                // I can't fix it :(
                expect(0);
                return;
            }
            function tester(format) {
                var r;
                r = moment(m.format(format), format);
                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format);
                r = moment(m.format(format).toLocaleUpperCase(), format);
                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' upper');
                r = moment(m.format(format).toLocaleLowerCase(), format);
                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' lower');

                r = moment(m.format(format), format, true);
                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' strict');
                r = moment(m.format(format).toLocaleUpperCase(), format, true);
                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' upper strict');
                r = moment(m.format(format).toLocaleLowerCase(), format, true);
                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' lower strict');
            }

            for (i = 0; i < 12; ++i) {
                m = moment([2015, i, 15, 18]);
                tester('MMM');
                tester('MMM.');
                tester('MMMM');
                tester('MMMM.');
            }
        });

        test('weekday parsing correctness', function (assert) {
            var i, m;

            if (locale === 'tr' || locale === 'az') {
                // There is a lower-case letter (Ä±), that converted to upper then
                // lower changes to i
                expect(0);
                return;
            }
            function tester(format) {
                var r, baseMsg = 'weekday ' + m.weekday() + ' fmt ' + format;
                r = moment(m.format(format), format);
                assert.equal(r.weekday(), m.weekday(), baseMsg);
                r = moment(m.format(format).toLocaleUpperCase(), format);
                assert.equal(r.weekday(), m.weekday(), baseMsg + ' upper');
                r = moment(m.format(format).toLocaleLowerCase(), format);
                assert.equal(r.weekday(), m.weekday(), baseMsg + ' lower');

                r = moment(m.format(format), format, true);
                assert.equal(r.weekday(), m.weekday(), baseMsg + ' strict');
                r = moment(m.format(format).toLocaleUpperCase(), format, true);
                assert.equal(r.weekday(), m.weekday(), baseMsg + ' upper strict');
                r = moment(m.format(format).toLocaleLowerCase(), format, true);
                assert.equal(r.weekday(), m.weekday(), baseMsg + ' lower strict');
            }

            for (i = 0; i < 7; ++i) {
                m = moment.utc([2015, i, 15, 18]);
                tester('dd');
                tester('ddd');
                tester('dddd');
            }
        });
    }

    function setupDeprecationHandler(test, moment, scope) {
        test._expectedDeprecations = null;
        test._observedDeprecations = null;
        test._oldSupress = moment.suppressDeprecationWarnings;
        moment.suppressDeprecationWarnings = true;
        test.expectedDeprecations = function () {
            test._expectedDeprecations = arguments;
            test._observedDeprecations = [];
        };
        moment.deprecationHandler = function (name, msg) {
            var deprecationId = matchedDeprecation(name, msg, test._expectedDeprecations);
            if (deprecationId === -1) {
                throw new Error('Unexpected deprecation thrown name=' +
                        name + ' msg=' + msg);
            }
            test._observedDeprecations[deprecationId] = 1;
        };
    }

    function teardownDeprecationHandler(test, moment, scope) {
        moment.suppressDeprecationWarnings = test._oldSupress;

        if (test._expectedDeprecations != null) {
            var missedDeprecations = [];
            each(test._expectedDeprecations, function (deprecationPattern, id) {
                if (test._observedDeprecations[id] !== 1) {
                    missedDeprecations.push(deprecationPattern);
                }
            });
            if (missedDeprecations.length !== 0) {
                throw new Error('Expected deprecation warnings did not happen: ' +
                        missedDeprecations.join(' '));
            }
        }
    }

    function matchedDeprecation(name, msg, deprecations) {
        if (deprecations == null) {
            return -1;
        }
        for (var i = 0; i < deprecations.length; ++i) {
            if (name != null && name === deprecations[i]) {
                return i;
            }
            if (msg != null && msg.substring(0, deprecations[i].length) === deprecations[i]) {
                return i;
            }
        }
        return -1;
    }

    /*global QUnit:false*/

    var test = QUnit.test;

    var expect = QUnit.expect;

    function module (name, lifecycle) {
        QUnit.module(name, {
            setup : function () {
                moment.locale('en');
                moment.createFromInputFallback = function (config) {
                    throw new Error('input not handled by moment: ' + config._i);
                };
                setupDeprecationHandler(test, moment, 'core');
                if (lifecycle && lifecycle.setup) {
                    lifecycle.setup();
                }
            },
            teardown : function () {
                teardownDeprecationHandler(test, moment, 'core');
                if (lifecycle && lifecycle.teardown) {
                    lifecycle.teardown();
                }
            }
        });
    }

    function localeModule (name, lifecycle) {
        QUnit.module('locale:' + name, {
            setup : function () {
                moment.locale(name);
                moment.createFromInputFallback = function (config) {
                    throw new Error('input not handled by moment: ' + config._i);
                };
                setupDeprecationHandler(test, moment, 'locale');
                if (lifecycle && lifecycle.setup) {
                    lifecycle.setup();
                }
            },
            teardown : function () {
                moment.locale('en');
                teardownDeprecationHandler(test, moment, 'locale');
                if (lifecycle && lifecycle.teardown) {
                    lifecycle.teardown();
                }
            }
        });
        defineCommonLocaleTests(name, -1, -1);
    }

    module('format');

    test('format YY', function (assert) {
        var b = moment(new Date(2009, 1, 14, 15, 25, 50, 125));
        assert.equal(b.format('YY'), '09', 'YY ---> 09');
    });

    test('format escape brackets', function (assert) {
        moment.locale('en');

        var b = moment(new Date(2009, 1, 14, 15, 25, 50, 125));
        assert.equal(b.format('[day]'), 'day', 'Single bracket');
        assert.equal(b.format('[day] YY [YY]'), 'day 09 YY', 'Double bracket');
        assert.equal(b.format('[YY'), '[09', 'Un-ended bracket');
        assert.equal(b.format('[[YY]]'), '[YY]', 'Double nested brackets');
        assert.equal(b.format('[[]'), '[', 'Escape open bracket');
        assert.equal(b.format('[Last]'), 'Last', 'localized tokens');
        assert.equal(b.format('[L] L'), 'L 02/14/2009', 'localized tokens with escaped localized tokens');
        assert.equal(b.format('[L LL LLL LLLL aLa]'), 'L LL LLL LLLL aLa', 'localized tokens with escaped localized tokens');
        assert.equal(b.format('[LLL] LLL'), 'LLL February 14, 2009 3:25 PM', 'localized tokens with escaped localized tokens (recursion)');
        assert.equal(b.format('YYYY[\n]DD[\n]'), '2009\n14\n', 'Newlines');
    });

    test('handle negative years', function (assert) {
        moment.locale('en');
        assert.equal(moment.utc().year(-1).format('YY'), '-01', 'YY with negative year');
        assert.equal(moment.utc().year(-1).format('YYYY'), '-0001', 'YYYY with negative year');
        assert.equal(moment.utc().year(-12).format('YY'), '-12', 'YY with negative year');
        assert.equal(moment.utc().year(-12).format('YYYY'), '-0012', 'YYYY with negative year');
        assert.equal(moment.utc().year(-123).format('YY'), '-23', 'YY with negative year');
        assert.equal(moment.utc().year(-123).format('YYYY'), '-0123', 'YYYY with negative year');
        assert.equal(moment.utc().year(-1234).format('YY'), '-34', 'YY with negative year');
        assert.equal(moment.utc().year(-1234).format('YYYY'), '-1234', 'YYYY with negative year');
        assert.equal(moment.utc().year(-12345).format('YY'), '-45', 'YY with negative year');
        assert.equal(moment.utc().year(-12345).format('YYYY'), '-12345', 'YYYY with negative year');
    });

    test('format milliseconds', function (assert) {
        var b = moment(new Date(2009, 1, 14, 15, 25, 50, 123));
        assert.equal(b.format('S'), '1', 'Deciseconds');
        assert.equal(b.format('SS'), '12', 'Centiseconds');
        assert.equal(b.format('SSS'), '123', 'Milliseconds');
        b.milliseconds(789);
        assert.equal(b.format('S'), '7', 'Deciseconds');
        assert.equal(b.format('SS'), '78', 'Centiseconds');
        assert.equal(b.format('SSS'), '789', 'Milliseconds');
    });

    test('format timezone', function (assert) {
        var b = moment(new Date(2010, 1, 14, 15, 25, 50, 125));
        assert.ok(b.format('Z').match(/^[\+\-]\d\d:\d\d$/), b.format('Z') + ' should be something like \'+07:30\'');
        assert.ok(b.format('ZZ').match(/^[\+\-]\d{4}$/), b.format('ZZ') + ' should be something like \'+0700\'');
    });

    test('format multiple with utc offset', function (assert) {
        var b = moment('2012-10-08 -1200', ['YYYY-MM-DD HH:mm ZZ', 'YYYY-MM-DD ZZ', 'YYYY-MM-DD']);
        assert.equal(b.format('YYYY-MM'), '2012-10', 'Parsing multiple formats should not crash with different sized formats');
    });

    test('isDST', function (assert) {
        var janOffset = new Date(2011, 0, 1).getTimezoneOffset(),
            julOffset = new Date(2011, 6, 1).getTimezoneOffset(),
            janIsDst = janOffset < julOffset,
            julIsDst = julOffset < janOffset,
            jan1 = moment([2011]),
            jul1 = moment([2011, 6]);

        if (janIsDst && julIsDst) {
            assert.ok(0, 'January and July cannot both be in DST');
            assert.ok(0, 'January and July cannot both be in DST');
        } else if (janIsDst) {
            assert.ok(jan1.isDST(), 'January 1 is DST');
            assert.ok(!jul1.isDST(), 'July 1 is not DST');
        } else if (julIsDst) {
            assert.ok(!jan1.isDST(), 'January 1 is not DST');
            assert.ok(jul1.isDST(), 'July 1 is DST');
        } else {
            assert.ok(!jan1.isDST(), 'January 1 is not DST');
            assert.ok(!jul1.isDST(), 'July 1 is not DST');
        }
    });

    test('unix timestamp', function (assert) {
        var m = moment('1234567890.123', 'X');
        assert.equal(m.format('X'), '1234567890', 'unix timestamp without milliseconds');
        assert.equal(m.format('X.S'), '1234567890.1', 'unix timestamp with deciseconds');
        assert.equal(m.format('X.SS'), '1234567890.12', 'unix timestamp with centiseconds');
        assert.equal(m.format('X.SSS'), '1234567890.123', 'unix timestamp with milliseconds');

        m = moment(1234567890.123, 'X');
        assert.equal(m.format('X'), '1234567890', 'unix timestamp as integer');
    });

    test('unix offset milliseconds', function (assert) {
        var m = moment('1234567890123', 'x');
        assert.equal(m.format('x'), '1234567890123', 'unix offset in milliseconds');

        m = moment(1234567890123, 'x');
        assert.equal(m.format('x'), '1234567890123', 'unix offset in milliseconds as integer');
    });

    test('utcOffset sanity checks', function (assert) {
        assert.equal(moment().utcOffset() % 15, 0,
                'utc offset should be a multiple of 15 (was ' + moment().utcOffset() + ')');

        assert.equal(moment().utcOffset(), -(new Date()).getTimezoneOffset(),
            'utcOffset should return the opposite of getTimezoneOffset');
    });

    test('default format', function (assert) {
        var isoRegex = /\d{4}.\d\d.\d\dT\d\d.\d\d.\d\d[\+\-]\d\d:\d\d/;
        assert.ok(isoRegex.exec(moment().format()), 'default format (' + moment().format() + ') should match ISO');
    });

    test('default UTC format', function (assert) {
        var isoRegex = /\d{4}.\d\d.\d\dT\d\d.\d\d.\d\dZ/;
        assert.ok(isoRegex.exec(moment.utc().format()), 'default UTC format (' + moment.utc().format() + ') should match ISO');
    });

    test('toJSON', function (assert) {
        var supportsJson = typeof JSON !== 'undefined' && JSON.stringify && JSON.stringify.call,
            date = moment('2012-10-09T21:30:40.678+0100');

        assert.equal(date.toJSON(), '2012-10-09T20:30:40.678Z', 'should output ISO8601 on moment.fn.toJSON');

        if (supportsJson) {
            assert.equal(JSON.stringify({
                date : date
            }), '{"date":"2012-10-09T20:30:40.678Z"}', 'should output ISO8601 on JSON.stringify');
        }
    });

    test('toISOString', function (assert) {
        var date = moment.utc('2012-10-09T20:30:40.678');

        assert.equal(date.toISOString(), '2012-10-09T20:30:40.678Z', 'should output ISO8601 on moment.fn.toISOString');

        // big years
        date = moment.utc('+020123-10-09T20:30:40.678');
        assert.equal(date.toISOString(), '+020123-10-09T20:30:40.678Z', 'ISO8601 format on big positive year');
        // negative years
        date = moment.utc('-000001-10-09T20:30:40.678');
        assert.equal(date.toISOString(), '-000001-10-09T20:30:40.678Z', 'ISO8601 format on negative year');
        // big negative years
        date = moment.utc('-020123-10-09T20:30:40.678');
        assert.equal(date.toISOString(), '-020123-10-09T20:30:40.678Z', 'ISO8601 format on big negative year');
    });

    test('long years', function (assert) {
        assert.equal(moment.utc().year(2).format('YYYYYY'), '+000002', 'small year with YYYYYY');
        assert.equal(moment.utc().year(2012).format('YYYYYY'), '+002012', 'regular year with YYYYYY');
        assert.equal(moment.utc().year(20123).format('YYYYYY'), '+020123', 'big year with YYYYYY');

        assert.equal(moment.utc().year(-1).format('YYYYYY'), '-000001', 'small negative year with YYYYYY');
        assert.equal(moment.utc().year(-2012).format('YYYYYY'), '-002012', 'negative year with YYYYYY');
        assert.equal(moment.utc().year(-20123).format('YYYYYY'), '-020123', 'big negative year with YYYYYY');
    });

    test('iso week formats', function (assert) {
        // http://en.wikipedia.org/wiki/ISO_week_date
        var cases = {
            '2005-01-02': '2004-53',
            '2005-12-31': '2005-52',
            '2007-01-01': '2007-01',
            '2007-12-30': '2007-52',
            '2007-12-31': '2008-01',
            '2008-01-01': '2008-01',
            '2008-12-28': '2008-52',
            '2008-12-29': '2009-01',
            '2008-12-30': '2009-01',
            '2008-12-31': '2009-01',
            '2009-01-01': '2009-01',
            '2009-12-31': '2009-53',
            '2010-01-01': '2009-53',
            '2010-01-02': '2009-53',
            '2010-01-03': '2009-53',
            '404-12-31': '0404-53',
            '405-12-31': '0405-52'
        }, i, isoWeek, formatted2, formatted1;

        for (i in cases) {
            isoWeek = cases[i].split('-').pop();
            formatted2 = moment(i, 'YYYY-MM-DD').format('WW');
            assert.equal(isoWeek, formatted2, i + ': WW should be ' + isoWeek + ', but ' + formatted2);
            isoWeek = isoWeek.replace(/^0+/, '');
            formatted1 = moment(i, 'YYYY-MM-DD').format('W');
            assert.equal(isoWeek, formatted1, i + ': W should be ' + isoWeek + ', but ' + formatted1);
        }
    });

    test('iso week year formats', function (assert) {
        // http://en.wikipedia.org/wiki/ISO_week_date
        var cases = {
            '2005-01-02': '2004-53',
            '2005-12-31': '2005-52',
            '2007-01-01': '2007-01',
            '2007-12-30': '2007-52',
            '2007-12-31': '2008-01',
            '2008-01-01': '2008-01',
            '2008-12-28': '2008-52',
            '2008-12-29': '2009-01',
            '2008-12-30': '2009-01',
            '2008-12-31': '2009-01',
            '2009-01-01': '2009-01',
            '2009-12-31': '2009-53',
            '2010-01-01': '2009-53',
            '2010-01-02': '2009-53',
            '2010-01-03': '2009-53',
            '404-12-31': '0404-53',
            '405-12-31': '0405-52'
        }, i, isoWeekYear, formatted5, formatted4, formatted2;

        for (i in cases) {
            isoWeekYear = cases[i].split('-')[0];
            formatted5 = moment(i, 'YYYY-MM-DD').format('GGGGG');
            assert.equal('0' + isoWeekYear, formatted5, i + ': GGGGG should be ' + isoWeekYear + ', but ' + formatted5);
            formatted4 = moment(i, 'YYYY-MM-DD').format('GGGG');
            assert.equal(isoWeekYear, formatted4, i + ': GGGG should be ' + isoWeekYear + ', but ' + formatted4);
            formatted2 = moment(i, 'YYYY-MM-DD').format('GG');
            assert.equal(isoWeekYear.slice(2, 4), formatted2, i + ': GG should be ' + isoWeekYear + ', but ' + formatted2);
        }
    });

    test('week year formats', function (assert) {
        // http://en.wikipedia.org/wiki/ISO_week_date
        var cases = {
            '2005-01-02': '2004-53',
            '2005-12-31': '2005-52',
            '2007-01-01': '2007-01',
            '2007-12-30': '2007-52',
            '2007-12-31': '2008-01',
            '2008-01-01': '2008-01',
            '2008-12-28': '2008-52',
            '2008-12-29': '2009-01',
            '2008-12-30': '2009-01',
            '2008-12-31': '2009-01',
            '2009-01-01': '2009-01',
            '2009-12-31': '2009-53',
            '2010-01-01': '2009-53',
            '2010-01-02': '2009-53',
            '2010-01-03': '2009-53',
            '404-12-31': '0404-53',
            '405-12-31': '0405-52'
        }, i, isoWeekYear, formatted5, formatted4, formatted2;

        moment.defineLocale('dow:1,doy:4', {week: {dow: 1, doy: 4}});

        for (i in cases) {
            isoWeekYear = cases[i].split('-')[0];
            formatted5 = moment(i, 'YYYY-MM-DD').format('ggggg');
            assert.equal('0' + isoWeekYear, formatted5, i + ': ggggg should be ' + isoWeekYear + ', but ' + formatted5);
            formatted4 = moment(i, 'YYYY-MM-DD').format('gggg');
            assert.equal(isoWeekYear, formatted4, i + ': gggg should be ' + isoWeekYear + ', but ' + formatted4);
            formatted2 = moment(i, 'YYYY-MM-DD').format('gg');
            assert.equal(isoWeekYear.slice(2, 4), formatted2, i + ': gg should be ' + isoWeekYear + ', but ' + formatted2);
        }
        moment.defineLocale('dow:1,doy:4', null);
    });

    test('iso weekday formats', function (assert) {
        assert.equal(moment([1985, 1,  4]).format('E'), '1', 'Feb  4 1985 is Monday    -- 1st day');
        assert.equal(moment([2029, 8, 18]).format('E'), '2', 'Sep 18 2029 is Tuesday   -- 2nd day');
        assert.equal(moment([2013, 3, 24]).format('E'), '3', 'Apr 24 2013 is Wednesday -- 3rd day');
        assert.equal(moment([2015, 2,  5]).format('E'), '4', 'Mar  5 2015 is Thursday  -- 4th day');
        assert.equal(moment([1970, 0,  2]).format('E'), '5', 'Jan  2 1970 is Friday    -- 5th day');
        assert.equal(moment([2001, 4, 12]).format('E'), '6', 'May 12 2001 is Saturday  -- 6th day');
        assert.equal(moment([2000, 0,  2]).format('E'), '7', 'Jan  2 2000 is Sunday    -- 7th day');
    });

    test('weekday formats', function (assert) {
        moment.defineLocale('dow: 3,doy: 5', {week: {dow: 3, doy: 5}});
        assert.equal(moment([1985, 1,  6]).format('e'), '0', 'Feb  6 1985 is Wednesday -- 0th day');
        assert.equal(moment([2029, 8, 20]).format('e'), '1', 'Sep 20 2029 is Thursday  -- 1st day');
        assert.equal(moment([2013, 3, 26]).format('e'), '2', 'Apr 26 2013 is Friday    -- 2nd day');
        assert.equal(moment([2015, 2,  7]).format('e'), '3', 'Mar  7 2015 is Saturday  -- 3nd day');
        assert.equal(moment([1970, 0,  4]).format('e'), '4', 'Jan  4 1970 is Sunday    -- 4th day');
        assert.equal(moment([2001, 4, 14]).format('e'), '5', 'May 14 2001 is Monday    -- 5th day');
        assert.equal(moment([2000, 0,  4]).format('e'), '6', 'Jan  4 2000 is Tuesday   -- 6th day');
        moment.defineLocale('dow: 3,doy: 5', null);
    });

    test('toString is just human readable format', function (assert) {
        var b = moment(new Date(2009, 1, 5, 15, 25, 50, 125));
        assert.equal(b.toString(), b.format('ddd MMM DD YYYY HH:mm:ss [GMT]ZZ'));
    });

    test('toJSON skips postformat', function (assert) {
        moment.defineLocale('postformat', {
            postformat: function (s) {
                s.replace(/./g, 'X');
            }
        });
        assert.equal(moment.utc([2000, 0, 1]).toJSON(), '2000-01-01T00:00:00.000Z', 'toJSON doesn\'t postformat');
        moment.defineLocale('postformat', null);
    });

    test('calendar day timezone', function (assert) {
        moment.locale('en');
        var zones = [60, -60, 90, -90, 360, -360, 720, -720],
            b = moment().utc().startOf('day').subtract({m : 1}),
            c = moment().local().startOf('day').subtract({m : 1}),
            d = moment().local().startOf('day').subtract({d : 2}),
            i, z, a;

        for (i = 0; i < zones.length; ++i) {
            z = zones[i];
            a = moment().utcOffset(z).startOf('day').subtract({m: 1});
            assert.equal(moment(a).utcOffset(z).calendar(), 'Yesterday at 11:59 PM',
                         'Yesterday at 11:59 PM, not Today, or the wrong time, tz = ' + z);
        }

        assert.equal(moment(b).utc().calendar(), 'Yesterday at 11:59 PM', 'Yesterday at 11:59 PM, not Today, or the wrong time');
        assert.equal(moment(c).local().calendar(), 'Yesterday at 11:59 PM', 'Yesterday at 11:59 PM, not Today, or the wrong time');
        assert.equal(moment(c).local().calendar(d), 'Tomorrow at 11:59 PM', 'Tomorrow at 11:59 PM, not Yesterday, or the wrong time');
    });

    test('calendar with custom formats', function (assert) {
        assert.equal(moment().calendar(null, {sameDay: '[Today]'}), 'Today', 'Today');
        assert.equal(moment().add(1, 'days').calendar(null, {nextDay: '[Tomorrow]'}), 'Tomorrow', 'Tomorrow');
        assert.equal(moment([1985, 1, 4]).calendar(null, {sameElse: 'YYYY-MM-DD'}), '1985-02-04', 'Else');
    });

    test('invalid', function (assert) {
        assert.equal(moment.invalid().format(), 'Invalid date');
        assert.equal(moment.invalid().format('YYYY-MM-DD'), 'Invalid date');
    });

    test('quarter formats', function (assert) {
        assert.equal(moment([1985, 1,  4]).format('Q'), '1', 'Feb  4 1985 is Q1');
        assert.equal(moment([2029, 8, 18]).format('Q'), '3', 'Sep 18 2029 is Q3');
        assert.equal(moment([2013, 3, 24]).format('Q'), '2', 'Apr 24 2013 is Q2');
        assert.equal(moment([2015, 2,  5]).format('Q'), '1', 'Mar  5 2015 is Q1');
        assert.equal(moment([1970, 0,  2]).format('Q'), '1', 'Jan  2 1970 is Q1');
        assert.equal(moment([2001, 11, 12]).format('Q'), '4', 'Dec 12 2001 is Q4');
        assert.equal(moment([2000, 0,  2]).format('[Q]Q-YYYY'), 'Q1-2000', 'Jan  2 2000 is Q1');
    });

    test('quarter ordinal formats', function (assert) {
        assert.equal(moment([1985, 1, 4]).format('Qo'), '1st', 'Feb 4 1985 is 1st quarter');
        assert.equal(moment([2029, 8, 18]).format('Qo'), '3rd', 'Sep 18 2029 is 3rd quarter');
        assert.equal(moment([2013, 3, 24]).format('Qo'), '2nd', 'Apr 24 2013 is 2nd quarter');
        assert.equal(moment([2015, 2,  5]).format('Qo'), '1st', 'Mar  5 2015 is 1st quarter');
        assert.equal(moment([1970, 0,  2]).format('Qo'), '1st', 'Jan  2 1970 is 1st quarter');
        assert.equal(moment([2001, 11, 12]).format('Qo'), '4th', 'Dec 12 2001 is 4th quarter');
        assert.equal(moment([2000, 0,  2]).format('Qo [quarter] YYYY'), '1st quarter 2000', 'Jan  2 2000 is 1st quarter');
    });

    // test('full expanded format is returned from abbreviated formats', function (assert) {
    //     function objectKeys(obj) {
    //         if (Object.keys) {
    //             return Object.keys(obj);
    //         } else {
    //             // IE8
    //             var res = [], i;
    //             for (i in obj) {
    //                 if (obj.hasOwnProperty(i)) {
    //                     res.push(i);
    //                 }
    //             }
    //             return res;
    //         }
    //     }

    //     var locales =
    //         'ar-sa ar-tn ar az be bg bn bo br bs ca cs cv cy da de-at de dv el ' +
    //         'en-au en-ca en-gb en-ie en-nz eo es et eu fa fi fo fr-ca fr-ch fr fy ' +
    //         'gd gl he hi hr hu hy-am id is it ja jv ka kk km ko lb lo lt lv me mk ml ' +
    //         'mr ms-my ms my nb ne nl nn pl pt-br pt ro ru se si sk sl sq sr-cyrl ' +
    //         'sr sv sw ta te th tl-ph tlh tr tzl tzm-latn tzm uk uz vi zh-cn zh-tw';

    //     each(locales.split(' '), function (locale) {
    //         var data, tokens;
    //         data = moment().locale(locale).localeData()._longDateFormat;
    //         tokens = objectKeys(data);
    //         each(tokens, function (token) {
    //             // Check each format string to make sure it does not contain any
    //             // tokens that need to be expanded.
    //             each(tokens, function (i) {
    //                 // strip escaped sequences
    //                 var format = data[i].replace(/(\[[^\]]*\])/g, '');
    //                 assert.equal(false, !!~format.indexOf(token), 'locale ' + locale + ' contains ' + token + ' in ' + i);
    //             });
    //         });
    //     });
    // });

    test('milliseconds', function (assert) {
        var m = moment('123', 'SSS');

        assert.equal(m.format('S'), '1');
        assert.equal(m.format('SS'), '12');
        assert.equal(m.format('SSS'), '123');
        assert.equal(m.format('SSSS'), '1230');
        assert.equal(m.format('SSSSS'), '12300');
        assert.equal(m.format('SSSSSS'), '123000');
        assert.equal(m.format('SSSSSSS'), '1230000');
        assert.equal(m.format('SSSSSSSS'), '12300000');
        assert.equal(m.format('SSSSSSSSS'), '123000000');
    });

    test('hmm and hmmss', function (assert) {
        assert.equal(moment('12:34:56', 'HH:mm:ss').format('hmm'), '1234');
        assert.equal(moment('01:34:56', 'HH:mm:ss').format('hmm'), '134');
        assert.equal(moment('13:34:56', 'HH:mm:ss').format('hmm'), '134');

        assert.equal(moment('12:34:56', 'HH:mm:ss').format('hmmss'), '123456');
        assert.equal(moment('01:34:56', 'HH:mm:ss').format('hmmss'), '13456');
        assert.equal(moment('13:34:56', 'HH:mm:ss').format('hmmss'), '13456');
    });

    test('Hmm and Hmmss', function (assert) {
        assert.equal(moment('12:34:56', 'HH:mm:ss').format('Hmm'), '1234');
        assert.equal(moment('01:34:56', 'HH:mm:ss').format('Hmm'), '134');
        assert.equal(moment('13:34:56', 'HH:mm:ss').format('Hmm'), '1334');

        assert.equal(moment('12:34:56', 'HH:mm:ss').format('Hmmss'), '123456');
        assert.equal(moment('01:34:56', 'HH:mm:ss').format('Hmmss'), '13456');
        assert.equal(moment('08:34:56', 'HH:mm:ss').format('Hmmss'), '83456');
        assert.equal(moment('18:34:56', 'HH:mm:ss').format('Hmmss'), '183456');
    });

    test('k and kk', function (assert) {
        assert.equal(moment('01:23:45', 'HH:mm:ss').format('k'), '1');
        assert.equal(moment('12:34:56', 'HH:mm:ss').format('k'), '12');
        assert.equal(moment('01:23:45', 'HH:mm:ss').format('kk'), '01');
        assert.equal(moment('12:34:56', 'HH:mm:ss').format('kk'), '12');
        assert.equal(moment('00:34:56', 'HH:mm:ss').format('kk'), '24');
        assert.equal(moment('00:00:00', 'HH:mm:ss').format('kk'), '24');
    });

    test('Y token', function (assert) {
        assert.equal(moment('2010-01-01', 'YYYY-MM-DD', true).format('Y'), '2010', 'format 2010 with Y');
        assert.equal(moment('-123-01-01', 'Y-MM-DD', true).format('Y'), '-123', 'format -123 with Y');
        assert.equal(moment('12345-01-01', 'Y-MM-DD', true).format('Y'), '+12345', 'format 12345 with Y');
        assert.equal(moment('0-01-01', 'Y-MM-DD', true).format('Y'), '0', 'format 0 with Y');
        assert.equal(moment('1-01-01', 'Y-MM-DD', true).format('Y'), '1', 'format 1 with Y');
        assert.equal(moment('9999-01-01', 'Y-MM-DD', true).format('Y'), '9999', 'format 9999 with Y');
        assert.equal(moment('10000-01-01', 'Y-MM-DD', true).format('Y'), '+10000', 'format 10000 with Y');
    });

}));

;(function (global, factory) {
   typeof exports === 'object' && typeof module !== 'undefined'
       && typeof require === 'function' ? factory(require('../../moment')) :
   typeof define === 'function' && define.amd ? define(['../../moment'], factory) :
   factory(global.moment)
}(this, function (moment) { 'use strict';

    function each(array, callback) {
        var i;
        for (i = 0; i < array.length; i++) {
            callback(array[i], i, array);
        }
    }

    function objectKeys(obj) {
        if (Object.keys) {
            return Object.keys(obj);
        } else {
            // IE8
            var res = [], i;
            for (i in obj) {
                if (obj.hasOwnProperty(i)) {
                    res.push(i);
                }
            }
            return res;
        }
    }

    // Pick the first defined of two or three arguments.
    function defaults(a, b, c) {
        if (a != null) {
            return a;
        }
        if (b != null) {
            return b;
        }
        return c;
    }

    function defineCommonLocaleTests(locale, options) {
        test('lenient ordinal parsing', function (assert) {
            var i, ordinalStr, testMoment;
            for (i = 1; i <= 31; ++i) {
                ordinalStr = moment([2014, 0, i]).format('YYYY MM Do');
                testMoment = moment(ordinalStr, 'YYYY MM Do');
                assert.equal(testMoment.year(), 2014,
                        'lenient ordinal parsing ' + i + ' year check');
                assert.equal(testMoment.month(), 0,
                        'lenient ordinal parsing ' + i + ' month check');
                assert.equal(testMoment.date(), i,
                        'lenient ordinal parsing ' + i + ' date check');
            }
        });

        test('lenient ordinal parsing of number', function (assert) {
            var i, testMoment;
            for (i = 1; i <= 31; ++i) {
                testMoment = moment('2014 01 ' + i, 'YYYY MM Do');
                assert.equal(testMoment.year(), 2014,
                        'lenient ordinal parsing of number ' + i + ' year check');
                assert.equal(testMoment.month(), 0,
                        'lenient ordinal parsing of number ' + i + ' month check');
                assert.equal(testMoment.date(), i,
                        'lenient ordinal parsing of number ' + i + ' date check');
            }
        });

        test('strict ordinal parsing', function (assert) {
            var i, ordinalStr, testMoment;
            for (i = 1; i <= 31; ++i) {
                ordinalStr = moment([2014, 0, i]).format('YYYY MM Do');
                testMoment = moment(ordinalStr, 'YYYY MM Do', true);
                assert.ok(testMoment.isValid(), 'strict ordinal parsing ' + i);
            }
        });

        test('meridiem invariant', function (assert) {
            var h, m, t1, t2;
            for (h = 0; h < 24; ++h) {
                for (m = 0; m < 60; m += 15) {
                    t1 = moment.utc([2000, 0, 1, h, m]);
                    t2 = moment.utc(t1.format('A h:mm'), 'A h:mm');
                    assert.equal(t2.format('HH:mm'), t1.format('HH:mm'),
                            'meridiem at ' + t1.format('HH:mm'));
                }
            }
        });

        test('date format correctness', function (assert) {
            var data, tokens;
            data = moment.localeData()._longDateFormat;
            tokens = objectKeys(data);
            each(tokens, function (srchToken) {
                // Check each format string to make sure it does not contain any
                // tokens that need to be expanded.
                each(tokens, function (baseToken) {
                    // strip escaped sequences
                    var format = data[baseToken].replace(/(\[[^\]]*\])/g, '');
                    assert.equal(false, !!~format.indexOf(srchToken),
                            'contains ' + srchToken + ' in ' + baseToken);
                });
            });
        });

        test('month parsing correctness', function (assert) {
            var i, m;

            if (locale === 'tr') {
                // I can't fix it :(
                expect(0);
                return;
            }
            function tester(format) {
                var r;
                r = moment(m.format(format), format);
                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format);
                r = moment(m.format(format).toLocaleUpperCase(), format);
                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' upper');
                r = moment(m.format(format).toLocaleLowerCase(), format);
                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' lower');

                r = moment(m.format(format), format, true);
                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' strict');
                r = moment(m.format(format).toLocaleUpperCase(), format, true);
                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' upper strict');
                r = moment(m.format(format).toLocaleLowerCase(), format, true);
                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' lower strict');
            }

            for (i = 0; i < 12; ++i) {
                m = moment([2015, i, 15, 18]);
                tester('MMM');
                tester('MMM.');
                tester('MMMM');
                tester('MMMM.');
            }
        });

        test('weekday parsing correctness', function (assert) {
            var i, m;

            if (locale === 'tr' || locale === 'az') {
                // There is a lower-case letter (Ä±), that converted to upper then
                // lower changes to i
                expect(0);
                return;
            }
            function tester(format) {
                var r, baseMsg = 'weekday ' + m.weekday() + ' fmt ' + format;
                r = moment(m.format(format), format);
                assert.equal(r.weekday(), m.weekday(), baseMsg);
                r = moment(m.format(format).toLocaleUpperCase(), format);
                assert.equal(r.weekday(), m.weekday(), baseMsg + ' upper');
                r = moment(m.format(format).toLocaleLowerCase(), format);
                assert.equal(r.weekday(), m.weekday(), baseMsg + ' lower');

                r = moment(m.format(format), format, true);
                assert.equal(r.weekday(), m.weekday(), baseMsg + ' strict');
                r = moment(m.format(format).toLocaleUpperCase(), format, true);
                assert.equal(r.weekday(), m.weekday(), baseMsg + ' upper strict');
                r = moment(m.format(format).toLocaleLowerCase(), format, true);
                assert.equal(r.weekday(), m.weekday(), baseMsg + ' lower strict');
            }

            for (i = 0; i < 7; ++i) {
                m = moment.utc([2015, i, 15, 18]);
                tester('dd');
                tester('ddd');
                tester('dddd');
            }
        });
    }

    function setupDeprecationHandler(test, moment, scope) {
        test._expectedDeprecations = null;
        test._observedDeprecations = null;
        test._oldSupress = moment.suppressDeprecationWarnings;
        moment.suppressDeprecationWarnings = true;
        test.expectedDeprecations = function () {
            test._expectedDeprecations = arguments;
            test._observedDeprecations = [];
        };
        moment.deprecationHandler = function (name, msg) {
            var deprecationId = matchedDeprecation(name, msg, test._expectedDeprecations);
            if (deprecationId === -1) {
                throw new Error('Unexpected deprecation thrown name=' +
                        name + ' msg=' + msg);
            }
            test._observedDeprecations[deprecationId] = 1;
        };
    }

    function teardownDeprecationHandler(test, moment, scope) {
        moment.suppressDeprecationWarnings = test._oldSupress;

        if (test._expectedDeprecations != null) {
            var missedDeprecations = [];
            each(test._expectedDeprecations, function (deprecationPattern, id) {
                if (test._observedDeprecations[id] !== 1) {
                    missedDeprecations.push(deprecationPattern);
                }
            });
            if (missedDeprecations.length !== 0) {
                throw new Error('Expected deprecation warnings did not happen: ' +
                        missedDeprecations.join(' '));
            }
        }
    }

    function matchedDeprecation(name, msg, deprecations) {
        if (deprecations == null) {
            return -1;
        }
        for (var i = 0; i < deprecations.length; ++i) {
            if (name != null && name === deprecations[i]) {
                return i;
            }
            if (msg != null && msg.substring(0, deprecations[i].length) === deprecations[i]) {
                return i;
            }
        }
        return -1;
    }

    /*global QUnit:false*/

    var test = QUnit.test;

    var expect = QUnit.expect;

    function module (name, lifecycle) {
        QUnit.module(name, {
            setup : function () {
                moment.locale('en');
                moment.createFromInputFallback = function (config) {
                    throw new Error('input not handled by moment: ' + config._i);
                };
                setupDeprecationHandler(test, moment, 'core');
                if (lifecycle && lifecycle.setup) {
                    lifecycle.setup();
                }
            },
            teardown : function () {
                teardownDeprecationHandler(test, moment, 'core');
                if (lifecycle && lifecycle.teardown) {
                    lifecycle.teardown();
                }
            }
        });
    }

    function localeModule (name, lifecycle) {
        QUnit.module('locale:' + name, {
            setup : function () {
                moment.locale(name);
                moment.createFromInputFallback = function (config) {
                    throw new Error('input not handled by moment: ' + config._i);
                };
                setupDeprecationHandler(test, moment, 'locale');
                if (lifecycle && lifecycle.setup) {
                    lifecycle.setup();
                }
            },
            teardown : function () {
                moment.locale('en');
                teardownDeprecationHandler(test, moment, 'locale');
                if (lifecycle && lifecycle.teardown) {
                    lifecycle.teardown();
                }
            }
        });
        defineCommonLocaleTests(name, -1, -1);
    }

    module('from_to');

    test('from', function (assert) {
        var start = moment();
        moment.locale('en');
        assert.equal(start.from(start.clone().add(5, 'seconds')),  'a few seconds ago', '5 seconds = a few seconds ago');
        assert.equal(start.from(start.clone().add(1, 'minute')),  'a minute ago', '1 minute = a minute ago');
        assert.equal(start.from(start.clone().add(5, 'minutes')),  '5 minutes ago', '5 minutes = 5 minutes ago');

        assert.equal(start.from(start.clone().subtract(5, 'seconds')),  'in a few seconds', '5 seconds = in a few seconds');
        assert.equal(start.from(start.clone().subtract(1, 'minute')),  'in a minute', '1 minute = in a minute');
        assert.equal(start.from(start.clone().subtract(5, 'minutes')),  'in 5 minutes', '5 minutes = in 5 minutes');
    });

    test('from with absolute duration', function (assert) {
        var start = moment();
        moment.locale('en');
        assert.equal(start.from(start.clone().add(5, 'seconds'), true),  'a few seconds', '5 seconds = a few seconds');
        assert.equal(start.from(start.clone().add(1, 'minute'), true),  'a minute', '1 minute = a minute');
        assert.equal(start.from(start.clone().add(5, 'minutes'), true),  '5 minutes', '5 minutes = 5 minutes');

        assert.equal(start.from(start.clone().subtract(5, 'seconds'), true),  'a few seconds', '5 seconds = a few seconds');
        assert.equal(start.from(start.clone().subtract(1, 'minute'), true),  'a minute', '1 minute = a minute');
        assert.equal(start.from(start.clone().subtract(5, 'minutes'), true),  '5 minutes', '5 minutes = 5 minutes');
    });

    test('to', function (assert) {
        var start = moment();
        moment.locale('en');
        assert.equal(start.to(start.clone().subtract(5, 'seconds')),  'a few seconds ago', '5 seconds = a few seconds ago');
        assert.equal(start.to(start.clone().subtract(1, 'minute')),  'a minute ago', '1 minute = a minute ago');
        assert.equal(start.to(start.clone().subtract(5, 'minutes')),  '5 minutes ago', '5 minutes = 5 minutes ago');

        assert.equal(start.to(start.clone().add(5, 'seconds')),  'in a few seconds', '5 seconds = in a few seconds');
        assert.equal(start.to(start.clone().add(1, 'minute')),  'in a minute', '1 minute = in a minute');
        assert.equal(start.to(start.clone().add(5, 'minutes')),  'in 5 minutes', '5 minutes = in 5 minutes');
    });

    test('to with absolute duration', function (assert) {
        var start = moment();
        moment.locale('en');
        assert.equal(start.to(start.clone().add(5, 'seconds'), true),  'a few seconds', '5 seconds = a few seconds');
        assert.equal(start.to(start.clone().add(1, 'minute'), true),  'a minute', '1 minute = a minute');
        assert.equal(start.to(start.clone().add(5, 'minutes'), true),  '5 minutes', '5 minutes = 5 minutes');

        assert.equal(start.to(start.clone().subtract(5, 'seconds'), true),  'a few seconds', '5 seconds = a few seconds');
        assert.equal(start.to(start.clone().subtract(1, 'minute'), true),  'a minute', '1 minute = a minute');
        assert.equal(start.to(start.clone().subtract(5, 'minutes'), true),  '5 minutes', '5 minutes = 5 minutes');
    });

}));

;(function (global, factory) {
   typeof exports === 'object' && typeof module !== 'undefined'
       && typeof require === 'function' ? factory(require('../../moment')) :
   typeof define === 'function' && define.amd ? define(['../../moment'], factory) :
   factory(global.moment)
}(this, function (moment) { 'use strict';

    function each(array, callback) {
        var i;
        for (i = 0; i < array.length; i++) {
            callback(array[i], i, array);
        }
    }

    function objectKeys(obj) {
        if (Object.keys) {
            return Object.keys(obj);
        } else {
            // IE8
            var res = [], i;
            for (i in obj) {
                if (obj.hasOwnProperty(i)) {
                    res.push(i);
                }
            }
            return res;
        }
    }

    // Pick the first defined of two or three arguments.
    function defaults(a, b, c) {
        if (a != null) {
            return a;
        }
        if (b != null) {
            return b;
        }
        return c;
    }

    function defineCommonLocaleTests(locale, options) {
        test('lenient ordinal parsing', function (assert) {
            var i, ordinalStr, testMoment;
            for (i = 1; i <= 31; ++i) {
                ordinalStr = moment([2014, 0, i]).format('YYYY MM Do');
                testMoment = moment(ordinalStr, 'YYYY MM Do');
                assert.equal(testMoment.year(), 2014,
                        'lenient ordinal parsing ' + i + ' year check');
                assert.equal(testMoment.month(), 0,
                        'lenient ordinal parsing ' + i + ' month check');
                assert.equal(testMoment.date(), i,
                        'lenient ordinal parsing ' + i + ' date check');
            }
        });

        test('lenient ordinal parsing of number', function (assert) {
            var i, testMoment;
            for (i = 1; i <= 31; ++i) {
                testMoment = moment('2014 01 ' + i, 'YYYY MM Do');
                assert.equal(testMoment.year(), 2014,
                        'lenient ordinal parsing of number ' + i + ' year check');
                assert.equal(testMoment.month(), 0,
                        'lenient ordinal parsing of number ' + i + ' month check');
                assert.equal(testMoment.date(), i,
                        'lenient ordinal parsing of number ' + i + ' date check');
            }
        });

        test('strict ordinal parsing', function (assert) {
            var i, ordinalStr, testMoment;
            for (i = 1; i <= 31; ++i) {
                ordinalStr = moment([2014, 0, i]).format('YYYY MM Do');
                testMoment = moment(ordinalStr, 'YYYY MM Do', true);
                assert.ok(testMoment.isValid(), 'strict ordinal parsing ' + i);
            }
        });

        test('meridiem invariant', function (assert) {
            var h, m, t1, t2;
            for (h = 0; h < 24; ++h) {
                for (m = 0; m < 60; m += 15) {
                    t1 = moment.utc([2000, 0, 1, h, m]);
                    t2 = moment.utc(t1.format('A h:mm'), 'A h:mm');
                    assert.equal(t2.format('HH:mm'), t1.format('HH:mm'),
                            'meridiem at ' + t1.format('HH:mm'));
                }
            }
        });

        test('date format correctness', function (assert) {
            var data, tokens;
            data = moment.localeData()._longDateFormat;
            tokens = objectKeys(data);
            each(tokens, function (srchToken) {
                // Check each format string to make sure it does not contain any
                // tokens that need to be expanded.
                each(tokens, function (baseToken) {
                    // strip escaped sequences
                    var format = data[baseToken].replace(/(\[[^\]]*\])/g, '');
                    assert.equal(false, !!~format.indexOf(srchToken),
                            'contains ' + srchToken + ' in ' + baseToken);
                });
            });
        });

        test('month parsing correctness', function (assert) {
            var i, m;

            if (locale === 'tr') {
                // I can't fix it :(
                expect(0);
                return;
            }
            function tester(format) {
                var r;
                r = moment(m.format(format), format);
                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format);
                r = moment(m.format(format).toLocaleUpperCase(), format);
                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' upper');
                r = moment(m.format(format).toLocaleLowerCase(), format);
                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' lower');

                r = moment(m.format(format), format, true);
                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' strict');
                r = moment(m.format(format).toLocaleUpperCase(), format, true);
                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' upper strict');
                r = moment(m.format(format).toLocaleLowerCase(), format, true);
                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' lower strict');
            }

            for (i = 0; i < 12; ++i) {
                m = moment([2015, i, 15, 18]);
                tester('MMM');
                tester('MMM.');
                tester('MMMM');
                tester('MMMM.');
            }
        });

        test('weekday parsing correctness', function (assert) {
            var i, m;

            if (locale === 'tr' || locale === 'az') {
                // There is a lower-case letter (Ä±), that converted to upper then
                // lower changes to i
                expect(0);
                return;
            }
            function tester(format) {
                var r, baseMsg = 'weekday ' + m.weekday() + ' fmt ' + format;
                r = moment(m.format(format), format);
                assert.equal(r.weekday(), m.weekday(), baseMsg);
                r = moment(m.format(format).toLocaleUpperCase(), format);
                assert.equal(r.weekday(), m.weekday(), baseMsg + ' upper');
                r = moment(m.format(format).toLocaleLowerCase(), format);
                assert.equal(r.weekday(), m.weekday(), baseMsg + ' lower');

                r = moment(m.format(format), format, true);
                assert.equal(r.weekday(), m.weekday(), baseMsg + ' strict');
                r = moment(m.format(format).toLocaleUpperCase(), format, true);
                assert.equal(r.weekday(), m.weekday(), baseMsg + ' upper strict');
                r = moment(m.format(format).toLocaleLowerCase(), format, true);
                assert.equal(r.weekday(), m.weekday(), baseMsg + ' lower strict');
            }

            for (i = 0; i < 7; ++i) {
                m = moment.utc([2015, i, 15, 18]);
                tester('dd');
                tester('ddd');
                tester('dddd');
            }
        });
    }

    function setupDeprecationHandler(test, moment, scope) {
        test._expectedDeprecations = null;
        test._observedDeprecations = null;
        test._oldSupress = moment.suppressDeprecationWarnings;
        moment.suppressDeprecationWarnings = true;
        test.expectedDeprecations = function () {
            test._expectedDeprecations = arguments;
            test._observedDeprecations = [];
        };
        moment.deprecationHandler = function (name, msg) {
            var deprecationId = matchedDeprecation(name, msg, test._expectedDeprecations);
            if (deprecationId === -1) {
                throw new Error('Unexpected deprecation thrown name=' +
                        name + ' msg=' + msg);
            }
            test._observedDeprecations[deprecationId] = 1;
        };
    }

    function teardownDeprecationHandler(test, moment, scope) {
        moment.suppressDeprecationWarnings = test._oldSupress;

        if (test._expectedDeprecations != null) {
            var missedDeprecations = [];
            each(test._expectedDeprecations, function (deprecationPattern, id) {
                if (test._observedDeprecations[id] !== 1) {
                    missedDeprecations.push(deprecationPattern);
                }
            });
            if (missedDeprecations.length !== 0) {
                throw new Error('Expected deprecation warnings did not happen: ' +
                        missedDeprecations.join(' '));
            }
        }
    }

    function matchedDeprecation(name, msg, deprecations) {
        if (deprecations == null) {
            return -1;
        }
        for (var i = 0; i < deprecations.length; ++i) {
            if (name != null && name === deprecations[i]) {
                return i;
            }
            if (msg != null && msg.substring(0, deprecations[i].length) === deprecations[i]) {
                return i;
            }
        }
        return -1;
    }

    /*global QUnit:false*/

    var test = QUnit.test;

    var expect = QUnit.expect;

    function module (name, lifecycle) {
        QUnit.module(name, {
            setup : function () {
                moment.locale('en');
                moment.createFromInputFallback = function (config) {
                    throw new Error('input not handled by moment: ' + config._i);
                };
                setupDeprecationHandler(test, moment, 'core');
                if (lifecycle && lifecycle.setup) {
                    lifecycle.setup();
                }
            },
            teardown : function () {
                teardownDeprecationHandler(test, moment, 'core');
                if (lifecycle && lifecycle.teardown) {
                    lifecycle.teardown();
                }
            }
        });
    }

    function localeModule (name, lifecycle) {
        QUnit.module('locale:' + name, {
            setup : function () {
                moment.locale(name);
                moment.createFromInputFallback = function (config) {
                    throw new Error('input not handled by moment: ' + config._i);
                };
                setupDeprecationHandler(test, moment, 'locale');
                if (lifecycle && lifecycle.setup) {
                    lifecycle.setup();
                }
            },
            teardown : function () {
                moment.locale('en');
                teardownDeprecationHandler(test, moment, 'locale');
                if (lifecycle && lifecycle.teardown) {
                    lifecycle.teardown();
                }
            }
        });
        defineCommonLocaleTests(name, -1, -1);
    }

    module('getters and setters');

    test('getters', function (assert) {
        var a = moment([2011, 9, 12, 6, 7, 8, 9]);
        assert.equal(a.year(), 2011, 'year');
        assert.equal(a.month(), 9, 'month');
        assert.equal(a.date(), 12, 'date');
        assert.equal(a.day(), 3, 'day');
        assert.equal(a.hours(), 6, 'hour');
        assert.equal(a.minutes(), 7, 'minute');
        assert.equal(a.seconds(), 8, 'second');
        assert.equal(a.milliseconds(), 9, 'milliseconds');
    });

    test('getters programmatic', function (assert) {
        var a = moment([2011, 9, 12, 6, 7, 8, 9]);
        assert.equal(a.get('year'), 2011, 'year');
        assert.equal(a.get('month'), 9, 'month');
        assert.equal(a.get('date'), 12, 'date');
        assert.equal(a.get('day'), 3, 'day');
        assert.equal(a.get('hour'), 6, 'hour');
        assert.equal(a.get('minute'), 7, 'minute');
        assert.equal(a.get('second'), 8, 'second');
        assert.equal(a.get('milliseconds'), 9, 'milliseconds');

        //actual getters tested elsewhere
        assert.equal(a.get('weekday'), a.weekday(), 'weekday');
        assert.equal(a.get('isoWeekday'), a.isoWeekday(), 'isoWeekday');
        assert.equal(a.get('week'), a.week(), 'week');
        assert.equal(a.get('isoWeek'), a.isoWeek(), 'isoWeek');
        assert.equal(a.get('dayOfYear'), a.dayOfYear(), 'dayOfYear');
    });

    test('setters plural', function (assert) {
        var a = moment();
        test.expectedDeprecations('years accessor', 'months accessor', 'dates accessor');

        a.years(2011);
        a.months(9);
        a.dates(12);
        a.hours(6);
        a.minutes(7);
        a.seconds(8);
        a.milliseconds(9);
        assert.equal(a.years(), 2011, 'years');
        assert.equal(a.months(), 9, 'months');
        assert.equal(a.dates(), 12, 'dates');
        assert.equal(a.days(), 3, 'days');
        assert.equal(a.hours(), 6, 'hours');
        assert.equal(a.minutes(), 7, 'minutes');
        assert.equal(a.seconds(), 8, 'seconds');
        assert.equal(a.milliseconds(), 9, 'milliseconds');
    });

    test('setters singular', function (assert) {
        var a = moment();
        a.year(2011);
        a.month(9);
        a.date(12);
        a.hour(6);
        a.minute(7);
        a.second(8);
        a.millisecond(9);
        assert.equal(a.year(), 2011, 'year');
        assert.equal(a.month(), 9, 'month');
        assert.equal(a.date(), 12, 'date');
        assert.equal(a.day(), 3, 'day');
        assert.equal(a.hour(), 6, 'hour');
        assert.equal(a.minute(), 7, 'minute');
        assert.equal(a.second(), 8, 'second');
        assert.equal(a.millisecond(), 9, 'milliseconds');
    });

    test('setters', function (assert) {
        var a = moment();
        a.year(2011);
        a.month(9);
        a.date(12);
        a.hours(6);
        a.minutes(7);
        a.seconds(8);
        a.milliseconds(9);
        assert.equal(a.year(), 2011, 'year');
        assert.equal(a.month(), 9, 'month');
        assert.equal(a.date(), 12, 'date');
        assert.equal(a.day(), 3, 'day');
        assert.equal(a.hours(), 6, 'hour');
        assert.equal(a.minutes(), 7, 'minute');
        assert.equal(a.seconds(), 8, 'second');
        assert.equal(a.milliseconds(), 9, 'milliseconds');

        // Test month() behavior. See https://github.com/timrwood/moment/pull/822
        a = moment('20130531', 'YYYYMMDD');
        a.month(3);
        assert.equal(a.month(), 3, 'month edge case');
    });

    test('setter programmatic', function (assert) {
        var a = moment();
        a.set('year', 2011);
        a.set('month', 9);
        a.set('date', 12);
        a.set('hours', 6);
        a.set('minutes', 7);
        a.set('seconds', 8);
        a.set('milliseconds', 9);
        assert.equal(a.year(), 2011, 'year');
        assert.equal(a.month(), 9, 'month');
        assert.equal(a.date(), 12, 'date');
        assert.equal(a.day(), 3, 'day');
        assert.equal(a.hours(), 6, 'hour');
        assert.equal(a.minutes(), 7, 'minute');
        assert.equal(a.seconds(), 8, 'second');
        assert.equal(a.milliseconds(), 9, 'milliseconds');

        // Test month() behavior. See https://github.com/timrwood/moment/pull/822
        a = moment('20130531', 'YYYYMMDD');
        a.month(3);
        assert.equal(a.month(), 3, 'month edge case');
    });

    test('setters programatic with weeks', function (assert) {
        var a = moment();
        a.set('weekYear', 2001);
        a.set('week', 49);
        a.set('day', 4);

        assert.equal(a.weekYear(), 2001, 'weekYear');
        assert.equal(a.week(), 49, 'week');
        assert.equal(a.day(), 4, 'day');

        a.set('weekday', 1);
        assert.equal(a.weekday(), 1, 'weekday');
    });

    test('setters programatic with weeks ISO', function (assert) {
        var a = moment();
        a.set('isoWeekYear', 2001);
        a.set('isoWeek', 49);
        a.set('isoWeekday', 4);

        assert.equal(a.isoWeekYear(), 2001, 'isoWeekYear');
        assert.equal(a.isoWeek(), 49, 'isoWeek');
        assert.equal(a.isoWeekday(), 4, 'isoWeekday');
    });

    test('setters strings', function (assert) {
        var a = moment([2012]).locale('en');
        assert.equal(a.clone().day(0).day('Wednesday').day(), 3, 'day full name');
        assert.equal(a.clone().day(0).day('Wed').day(), 3, 'day short name');
        assert.equal(a.clone().day(0).day('We').day(), 3, 'day minimal name');
        assert.equal(a.clone().day(0).day('invalid').day(), 0, 'invalid day name');
        assert.equal(a.clone().month(0).month('April').month(), 3, 'month full name');
        assert.equal(a.clone().month(0).month('Apr').month(), 3, 'month short name');
        assert.equal(a.clone().month(0).month('invalid').month(), 0, 'invalid month name');
    });

    test('setters - falsey values', function (assert) {
        var a = moment();
        // ensure minutes wasn't coincidentally 0 already
        a.minutes(1);
        a.minutes(0);
        assert.equal(a.minutes(), 0, 'falsey value');
    });

    test('chaining setters', function (assert) {
        var a = moment();
        a.year(2011)
         .month(9)
         .date(12)
         .hours(6)
         .minutes(7)
         .seconds(8);
        assert.equal(a.year(), 2011, 'year');
        assert.equal(a.month(), 9, 'month');
        assert.equal(a.date(), 12, 'date');
        assert.equal(a.day(), 3, 'day');
        assert.equal(a.hours(), 6, 'hour');
        assert.equal(a.minutes(), 7, 'minute');
        assert.equal(a.seconds(), 8, 'second');
    });

    test('setter with multiple unit values', function (assert) {
        var a = moment();
        a.set({
            year: 2011,
            month: 9,
            date: 12,
            hours: 6,
            minutes: 7,
            seconds: 8,
            milliseconds: 9
        });
        assert.equal(a.year(), 2011, 'year');
        assert.equal(a.month(), 9, 'month');
        assert.equal(a.date(), 12, 'date');
        assert.equal(a.day(), 3, 'day');
        assert.equal(a.hours(), 6, 'hour');
        assert.equal(a.minutes(), 7, 'minute');
        assert.equal(a.seconds(), 8, 'second');
        assert.equal(a.milliseconds(), 9, 'milliseconds');
    });

    test('day setter', function (assert) {
        var a = moment([2011, 0, 15]);
        assert.equal(moment(a).day(0).date(), 9, 'set from saturday to sunday');
        assert.equal(moment(a).day(6).date(), 15, 'set from saturday to saturday');
        assert.equal(moment(a).day(3).date(), 12, 'set from saturday to wednesday');

        a = moment([2011, 0, 9]);
        assert.equal(moment(a).day(0).date(), 9, 'set from sunday to sunday');
        assert.equal(moment(a).day(6).date(), 15, 'set from sunday to saturday');
        assert.equal(moment(a).day(3).date(), 12, 'set from sunday to wednesday');

        a = moment([2011, 0, 12]);
        assert.equal(moment(a).day(0).date(), 9, 'set from wednesday to sunday');
        assert.equal(moment(a).day(6).date(), 15, 'set from wednesday to saturday');
        assert.equal(moment(a).day(3).date(), 12, 'set from wednesday to wednesday');

        assert.equal(moment(a).day(-7).date(), 2, 'set from wednesday to last sunday');
        assert.equal(moment(a).day(-1).date(), 8, 'set from wednesday to last saturday');
        assert.equal(moment(a).day(-4).date(), 5, 'set from wednesday to last wednesday');

        assert.equal(moment(a).day(7).date(), 16, 'set from wednesday to next sunday');
        assert.equal(moment(a).day(13).date(), 22, 'set from wednesday to next saturday');
        assert.equal(moment(a).day(10).date(), 19, 'set from wednesday to next wednesday');

        assert.equal(moment(a).day(14).date(), 23, 'set from wednesday to second next sunday');
        assert.equal(moment(a).day(20).date(), 29, 'set from wednesday to second next saturday');
        assert.equal(moment(a).day(17).date(), 26, 'set from wednesday to second next wednesday');
    });

    test('string setters', function (assert) {
        var a = moment();
        a.year('2011');
        a.month('9');
        a.date('12');
        a.hours('6');
        a.minutes('7');
        a.seconds('8');
        a.milliseconds('9');
        assert.equal(a.year(), 2011, 'year');
        assert.equal(a.month(), 9, 'month');
        assert.equal(a.date(), 12, 'date');
        assert.equal(a.day(), 3, 'day');
        assert.equal(a.hours(), 6, 'hour');
        assert.equal(a.minutes(), 7, 'minute');
        assert.equal(a.seconds(), 8, 'second');
        assert.equal(a.milliseconds(), 9, 'milliseconds');
    });

    test('setters across DST +1', function (assert) {
        var oldUpdateOffset = moment.updateOffset,
            // Based on a real story somewhere in America/Los_Angeles
            dstAt = moment('2014-03-09T02:00:00-08:00').parseZone(),
            m;

        moment.updateOffset = function (mom, keepTime) {
            if (mom.isBefore(dstAt)) {
                mom.utcOffset(-8, keepTime);
            } else {
                mom.utcOffset(-7, keepTime);
            }
        };

        m = moment('2014-03-15T00:00:00-07:00').parseZone();
        m.year(2013);
        assert.equal(m.format(), '2013-03-15T00:00:00-08:00', 'year across +1');

        m = moment('2014-03-15T00:00:00-07:00').parseZone();
        m.month(0);
        assert.equal(m.format(), '2014-01-15T00:00:00-08:00', 'month across +1');

        m = moment('2014-03-15T00:00:00-07:00').parseZone();
        m.date(1);
        assert.equal(m.format(), '2014-03-01T00:00:00-08:00', 'date across +1');

        m = moment('2014-03-09T03:05:00-07:00').parseZone();
        m.hour(0);
        assert.equal(m.format(), '2014-03-09T00:05:00-08:00', 'hour across +1');

        moment.updateOffset = oldUpdateOffset;
    });

    test('setters across DST -1', function (assert) {
        var oldUpdateOffset = moment.updateOffset,
            // Based on a real story somewhere in America/Los_Angeles
            dstAt = moment('2014-11-02T02:00:00-07:00').parseZone(),
            m;

        moment.updateOffset = function (mom, keepTime) {
            if (mom.isBefore(dstAt)) {
                mom.utcOffset(-7, keepTime);
            } else {
                mom.utcOffset(-8, keepTime);
            }
        };

        m = moment('2014-11-15T00:00:00-08:00').parseZone();
        m.year(2013);
        assert.equal(m.format(), '2013-11-15T00:00:00-07:00', 'year across -1');

        m = moment('2014-11-15T00:00:00-08:00').parseZone();
        m.month(0);
        assert.equal(m.format(), '2014-01-15T00:00:00-07:00', 'month across -1');

        m = moment('2014-11-15T00:00:00-08:00').parseZone();
        m.date(1);
        assert.equal(m.format(), '2014-11-01T00:00:00-07:00', 'date across -1');

        m = moment('2014-11-02T03:30:00-08:00').parseZone();
        m.hour(0);
        assert.equal(m.format(), '2014-11-02T00:30:00-07:00', 'hour across -1');

        moment.updateOffset = oldUpdateOffset;
    });

}));

;(function (global, factory) {
   typeof exports === 'object' && typeof module !== 'undefined'
       && typeof require === 'function' ? factory(require('../../moment')) :
   typeof define === 'function' && define.amd ? define(['../../moment'], factory) :
   factory(global.moment)
}(this, function (moment) { 'use strict';

    function each(array, callback) {
        var i;
        for (i = 0; i < array.length; i++) {
            callback(array[i], i, array);
        }
    }

    function objectKeys(obj) {
        if (Object.keys) {
            return Object.keys(obj);
        } else {
            // IE8
            var res = [], i;
            for (i in obj) {
                if (obj.hasOwnProperty(i)) {
                    res.push(i);
                }
            }
            return res;
        }
    }

    // Pick the first defined of two or three arguments.
    function defaults(a, b, c) {
        if (a != null) {
            return a;
        }
        if (b != null) {
            return b;
        }
        return c;
    }

    function defineCommonLocaleTests(locale, options) {
        test('lenient ordinal parsing', function (assert) {
            var i, ordinalStr, testMoment;
            for (i = 1; i <= 31; ++i) {
                ordinalStr = moment([2014, 0, i]).format('YYYY MM Do');
                testMoment = moment(ordinalStr, 'YYYY MM Do');
                assert.equal(testMoment.year(), 2014,
                        'lenient ordinal parsing ' + i + ' year check');
                assert.equal(testMoment.month(), 0,
                        'lenient ordinal parsing ' + i + ' month check');
                assert.equal(testMoment.date(), i,
                        'lenient ordinal parsing ' + i + ' date check');
            }
        });

        test('lenient ordinal parsing of number', function (assert) {
            var i, testMoment;
            for (i = 1; i <= 31; ++i) {
                testMoment = moment('2014 01 ' + i, 'YYYY MM Do');
                assert.equal(testMoment.year(), 2014,
                        'lenient ordinal parsing of number ' + i + ' year check');
                assert.equal(testMoment.month(), 0,
                        'lenient ordinal parsing of number ' + i + ' month check');
                assert.equal(testMoment.date(), i,
                        'lenient ordinal parsing of number ' + i + ' date check');
            }
        });

        test('strict ordinal parsing', function (assert) {
            var i, ordinalStr, testMoment;
            for (i = 1; i <= 31; ++i) {
                ordinalStr = moment([2014, 0, i]).format('YYYY MM Do');
                testMoment = moment(ordinalStr, 'YYYY MM Do', true);
                assert.ok(testMoment.isValid(), 'strict ordinal parsing ' + i);
            }
        });

        test('meridiem invariant', function (assert) {
            var h, m, t1, t2;
            for (h = 0; h < 24; ++h) {
                for (m = 0; m < 60; m += 15) {
                    t1 = moment.utc([2000, 0, 1, h, m]);
                    t2 = moment.utc(t1.format('A h:mm'), 'A h:mm');
                    assert.equal(t2.format('HH:mm'), t1.format('HH:mm'),
                            'meridiem at ' + t1.format('HH:mm'));
                }
            }
        });

        test('date format correctness', function (assert) {
            var data, tokens;
            data = moment.localeData()._longDateFormat;
            tokens = objectKeys(data);
            each(tokens, function (srchToken) {
                // Check each format string to make sure it does not contain any
                // tokens that need to be expanded.
                each(tokens, function (baseToken) {
                    // strip escaped sequences
                    var format = data[baseToken].replace(/(\[[^\]]*\])/g, '');
                    assert.equal(false, !!~format.indexOf(srchToken),
                            'contains ' + srchToken + ' in ' + baseToken);
                });
            });
        });

        test('month parsing correctness', function (assert) {
            var i, m;

            if (locale === 'tr') {
                // I can't fix it :(
                expect(0);
                return;
            }
            function tester(format) {
                var r;
                r = moment(m.format(format), format);
                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format);
                r = moment(m.format(format).toLocaleUpperCase(), format);
                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' upper');
                r = moment(m.format(format).toLocaleLowerCase(), format);
                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' lower');

                r = moment(m.format(format), format, true);
                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' strict');
                r = moment(m.format(format).toLocaleUpperCase(), format, true);
                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' upper strict');
                r = moment(m.format(format).toLocaleLowerCase(), format, true);
                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' lower strict');
            }

            for (i = 0; i < 12; ++i) {
                m = moment([2015, i, 15, 18]);
                tester('MMM');
                tester('MMM.');
                tester('MMMM');
                tester('MMMM.');
            }
        });

        test('weekday parsing correctness', function (assert) {
            var i, m;

            if (locale === 'tr' || locale === 'az') {
                // There is a lower-case letter (Ä±), that converted to upper then
                // lower changes to i
                expect(0);
                return;
            }
            function tester(format) {
                var r, baseMsg = 'weekday ' + m.weekday() + ' fmt ' + format;
                r = moment(m.format(format), format);
                assert.equal(r.weekday(), m.weekday(), baseMsg);
                r = moment(m.format(format).toLocaleUpperCase(), format);
                assert.equal(r.weekday(), m.weekday(), baseMsg + ' upper');
                r = moment(m.format(format).toLocaleLowerCase(), format);
                assert.equal(r.weekday(), m.weekday(), baseMsg + ' lower');

                r = moment(m.format(format), format, true);
                assert.equal(r.weekday(), m.weekday(), baseMsg + ' strict');
                r = moment(m.format(format).toLocaleUpperCase(), format, true);
                assert.equal(r.weekday(), m.weekday(), baseMsg + ' upper strict');
                r = moment(m.format(format).toLocaleLowerCase(), format, true);
                assert.equal(r.weekday(), m.weekday(), baseMsg + ' lower strict');
            }

            for (i = 0; i < 7; ++i) {
                m = moment.utc([2015, i, 15, 18]);
                tester('dd');
                tester('ddd');
                tester('dddd');
            }
        });
    }

    function setupDeprecationHandler(test, moment, scope) {
        test._expectedDeprecations = null;
        test._observedDeprecations = null;
        test._oldSupress = moment.suppressDeprecationWarnings;
        moment.suppressDeprecationWarnings = true;
        test.expectedDeprecations = function () {
            test._expectedDeprecations = arguments;
            test._observedDeprecations = [];
        };
        moment.deprecationHandler = function (name, msg) {
            var deprecationId = matchedDeprecation(name, msg, test._expectedDeprecations);
            if (deprecationId === -1) {
                throw new Error('Unexpected deprecation thrown name=' +
                        name + ' msg=' + msg);
            }
            test._observedDeprecations[deprecationId] = 1;
        };
    }

    function teardownDeprecationHandler(test, moment, scope) {
        moment.suppressDeprecationWarnings = test._oldSupress;

        if (test._expectedDeprecations != null) {
            var missedDeprecations = [];
            each(test._expectedDeprecations, function (deprecationPattern, id) {
                if (test._observedDeprecations[id] !== 1) {
                    missedDeprecations.push(deprecationPattern);
                }
            });
            if (missedDeprecations.length !== 0) {
                throw new Error('Expected deprecation warnings did not happen: ' +
                        missedDeprecations.join(' '));
            }
        }
    }

    function matchedDeprecation(name, msg, deprecations) {
        if (deprecations == null) {
            return -1;
        }
        for (var i = 0; i < deprecations.length; ++i) {
            if (name != null && name === deprecations[i]) {
                return i;
            }
            if (msg != null && msg.substring(0, deprecations[i].length) === deprecations[i]) {
                return i;
            }
        }
        return -1;
    }

    /*global QUnit:false*/

    var test = QUnit.test;

    var expect = QUnit.expect;

    function module (name, lifecycle) {
        QUnit.module(name, {
            setup : function () {
                moment.locale('en');
                moment.createFromInputFallback = function (config) {
                    throw new Error('input not handled by moment: ' + config._i);
                };
                setupDeprecationHandler(test, moment, 'core');
                if (lifecycle && lifecycle.setup) {
                    lifecycle.setup();
                }
            },
            teardown : function () {
                teardownDeprecationHandler(test, moment, 'core');
                if (lifecycle && lifecycle.teardown) {
                    lifecycle.teardown();
                }
            }
        });
    }

    function localeModule (name, lifecycle) {
        QUnit.module('locale:' + name, {
            setup : function () {
                moment.locale(name);
                moment.createFromInputFallback = function (config) {
                    throw new Error('input not handled by moment: ' + config._i);
                };
                setupDeprecationHandler(test, moment, 'locale');
                if (lifecycle && lifecycle.setup) {
                    lifecycle.setup();
                }
            },
            teardown : function () {
                moment.locale('en');
                teardownDeprecationHandler(test, moment, 'locale');
                if (lifecycle && lifecycle.teardown) {
                    lifecycle.teardown();
                }
            }
        });
        defineCommonLocaleTests(name, -1, -1);
    }

    module('instanceof');

    test('instanceof', function (assert) {
        var mm = moment([2010, 0, 1]);

        var extend = function (a, b) {
            var i;
            for (i in b) {
                a[i] = b[i];
            }
            return a;
        };

        assert.equal(moment() instanceof moment, true, 'simple moment object');
        assert.equal(extend({}, moment()) instanceof moment, false, 'extended moment object');
        assert.equal(moment(null) instanceof moment, true, 'invalid moment object');

        assert.equal(new Date() instanceof moment, false, 'date object is not moment object');
        assert.equal(Object instanceof moment, false, 'Object is not moment object');
        assert.equal('foo' instanceof moment, false, 'string is not moment object');
        assert.equal(1 instanceof moment, false, 'number is not moment object');
        assert.equal(NaN instanceof moment, false, 'NaN is not moment object');
        assert.equal(null instanceof moment, false, 'null is not moment object');
        assert.equal(undefined instanceof moment, false, 'undefined is not moment object');
    });

}));

;(function (global, factory) {
   typeof exports === 'object' && typeof module !== 'undefined'
       && typeof require === 'function' ? factory(require('../../moment')) :
   typeof define === 'function' && define.amd ? define(['../../moment'], factory) :
   factory(global.moment)
}(this, function (moment) { 'use strict';

    function each(array, callback) {
        var i;
        for (i = 0; i < array.length; i++) {
            callback(array[i], i, array);
        }
    }

    function objectKeys(obj) {
        if (Object.keys) {
            return Object.keys(obj);
        } else {
            // IE8
            var res = [], i;
            for (i in obj) {
                if (obj.hasOwnProperty(i)) {
                    res.push(i);
                }
            }
            return res;
        }
    }

    // Pick the first defined of two or three arguments.
    function defaults(a, b, c) {
        if (a != null) {
            return a;
        }
        if (b != null) {
            return b;
        }
        return c;
    }

    function defineCommonLocaleTests(locale, options) {
        test('lenient ordinal parsing', function (assert) {
            var i, ordinalStr, testMoment;
            for (i = 1; i <= 31; ++i) {
                ordinalStr = moment([2014, 0, i]).format('YYYY MM Do');
                testMoment = moment(ordinalStr, 'YYYY MM Do');
                assert.equal(testMoment.year(), 2014,
                        'lenient ordinal parsing ' + i + ' year check');
                assert.equal(testMoment.month(), 0,
                        'lenient ordinal parsing ' + i + ' month check');
                assert.equal(testMoment.date(), i,
                        'lenient ordinal parsing ' + i + ' date check');
            }
        });

        test('lenient ordinal parsing of number', function (assert) {
            var i, testMoment;
            for (i = 1; i <= 31; ++i) {
                testMoment = moment('2014 01 ' + i, 'YYYY MM Do');
                assert.equal(testMoment.year(), 2014,
                        'lenient ordinal parsing of number ' + i + ' year check');
                assert.equal(testMoment.month(), 0,
                        'lenient ordinal parsing of number ' + i + ' month check');
                assert.equal(testMoment.date(), i,
                        'lenient ordinal parsing of number ' + i + ' date check');
            }
        });

        test('strict ordinal parsing', function (assert) {
            var i, ordinalStr, testMoment;
            for (i = 1; i <= 31; ++i) {
                ordinalStr = moment([2014, 0, i]).format('YYYY MM Do');
                testMoment = moment(ordinalStr, 'YYYY MM Do', true);
                assert.ok(testMoment.isValid(), 'strict ordinal parsing ' + i);
            }
        });

        test('meridiem invariant', function (assert) {
            var h, m, t1, t2;
            for (h = 0; h < 24; ++h) {
                for (m = 0; m < 60; m += 15) {
                    t1 = moment.utc([2000, 0, 1, h, m]);
                    t2 = moment.utc(t1.format('A h:mm'), 'A h:mm');
                    assert.equal(t2.format('HH:mm'), t1.format('HH:mm'),
                            'meridiem at ' + t1.format('HH:mm'));
                }
            }
        });

        test('date format correctness', function (assert) {
            var data, tokens;
            data = moment.localeData()._longDateFormat;
            tokens = objectKeys(data);
            each(tokens, function (srchToken) {
                // Check each format string to make sure it does not contain any
                // tokens that need to be expanded.
                each(tokens, function (baseToken) {
                    // strip escaped sequences
                    var format = data[baseToken].replace(/(\[[^\]]*\])/g, '');
                    assert.equal(false, !!~format.indexOf(srchToken),
                            'contains ' + srchToken + ' in ' + baseToken);
                });
            });
        });

        test('month parsing correctness', function (assert) {
            var i, m;

            if (locale === 'tr') {
                // I can't fix it :(
                expect(0);
                return;
            }
            function tester(format) {
                var r;
                r = moment(m.format(format), format);
                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format);
                r = moment(m.format(format).toLocaleUpperCase(), format);
                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' upper');
                r = moment(m.format(format).toLocaleLowerCase(), format);
                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' lower');

                r = moment(m.format(format), format, true);
                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' strict');
                r = moment(m.format(format).toLocaleUpperCase(), format, true);
                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' upper strict');
                r = moment(m.format(format).toLocaleLowerCase(), format, true);
                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' lower strict');
            }

            for (i = 0; i < 12; ++i) {
                m = moment([2015, i, 15, 18]);
                tester('MMM');
                tester('MMM.');
                tester('MMMM');
                tester('MMMM.');
            }
        });

        test('weekday parsing correctness', function (assert) {
            var i, m;

            if (locale === 'tr' || locale === 'az') {
                // There is a lower-case letter (Ä±), that converted to upper then
                // lower changes to i
                expect(0);
                return;
            }
            function tester(format) {
                var r, baseMsg = 'weekday ' + m.weekday() + ' fmt ' + format;
                r = moment(m.format(format), format);
                assert.equal(r.weekday(), m.weekday(), baseMsg);
                r = moment(m.format(format).toLocaleUpperCase(), format);
                assert.equal(r.weekday(), m.weekday(), baseMsg + ' upper');
                r = moment(m.format(format).toLocaleLowerCase(), format);
                assert.equal(r.weekday(), m.weekday(), baseMsg + ' lower');

                r = moment(m.format(format), format, true);
                assert.equal(r.weekday(), m.weekday(), baseMsg + ' strict');
                r = moment(m.format(format).toLocaleUpperCase(), format, true);
                assert.equal(r.weekday(), m.weekday(), baseMsg + ' upper strict');
                r = moment(m.format(format).toLocaleLowerCase(), format, true);
                assert.equal(r.weekday(), m.weekday(), baseMsg + ' lower strict');
            }

            for (i = 0; i < 7; ++i) {
                m = moment.utc([2015, i, 15, 18]);
                tester('dd');
                tester('ddd');
                tester('dddd');
            }
        });
    }

    function setupDeprecationHandler(test, moment, scope) {
        test._expectedDeprecations = null;
        test._observedDeprecations = null;
        test._oldSupress = moment.suppressDeprecationWarnings;
        moment.suppressDeprecationWarnings = true;
        test.expectedDeprecations = function () {
            test._expectedDeprecations = arguments;
            test._observedDeprecations = [];
        };
        moment.deprecationHandler = function (name, msg) {
            var deprecationId = matchedDeprecation(name, msg, test._expectedDeprecations);
            if (deprecationId === -1) {
                throw new Error('Unexpected deprecation thrown name=' +
                        name + ' msg=' + msg);
            }
            test._observedDeprecations[deprecationId] = 1;
        };
    }

    function teardownDeprecationHandler(test, moment, scope) {
        moment.suppressDeprecationWarnings = test._oldSupress;

        if (test._expectedDeprecations != null) {
            var missedDeprecations = [];
            each(test._expectedDeprecations, function (deprecationPattern, id) {
                if (test._observedDeprecations[id] !== 1) {
                    missedDeprecations.push(deprecationPattern);
                }
            });
            if (missedDeprecations.length !== 0) {
                throw new Error('Expected deprecation warnings did not happen: ' +
                        missedDeprecations.join(' '));
            }
        }
    }

    function matchedDeprecation(name, msg, deprecations) {
        if (deprecations == null) {
            return -1;
        }
        for (var i = 0; i < deprecations.length; ++i) {
            if (name != null && name === deprecations[i]) {
                return i;
            }
            if (msg != null && msg.substring(0, deprecations[i].length) === deprecations[i]) {
                return i;
            }
        }
        return -1;
    }

    /*global QUnit:false*/

    var test = QUnit.test;

    var expect = QUnit.expect;

    function module (name, lifecycle) {
        QUnit.module(name, {
            setup : function () {
                moment.locale('en');
                moment.createFromInputFallback = function (config) {
                    throw new Error('input not handled by moment: ' + config._i);
                };
                setupDeprecationHandler(test, moment, 'core');
                if (lifecycle && lifecycle.setup) {
                    lifecycle.setup();
                }
            },
            teardown : function () {
                teardownDeprecationHandler(test, moment, 'core');
                if (lifecycle && lifecycle.teardown) {
                    lifecycle.teardown();
                }
            }
        });
    }

    function localeModule (name, lifecycle) {
        QUnit.module('locale:' + name, {
            setup : function () {
                moment.locale(name);
                moment.createFromInputFallback = function (config) {
                    throw new Error('input not handled by moment: ' + config._i);
                };
                setupDeprecationHandler(test, moment, 'locale');
                if (lifecycle && lifecycle.setup) {
                    lifecycle.setup();
                }
            },
            teardown : function () {
                moment.locale('en');
                teardownDeprecationHandler(test, moment, 'locale');
                if (lifecycle && lifecycle.teardown) {
                    lifecycle.teardown();
                }
            }
        });
        defineCommonLocaleTests(name, -1, -1);
    }

    module('invalid');

    test('invalid', function (assert) {
        var m = moment.invalid();
        assert.equal(m.isValid(), false);
        assert.equal(m.parsingFlags().userInvalidated, true);
        assert.ok(isNaN(m.valueOf()));
    });

    test('invalid with existing flag', function (assert) {
        var m = moment.invalid({invalidMonth : 'whatchamacallit'});
        assert.equal(m.isValid(), false);
        assert.equal(m.parsingFlags().userInvalidated, false);
        assert.equal(m.parsingFlags().invalidMonth, 'whatchamacallit');
        assert.ok(isNaN(m.valueOf()));
    });

    test('invalid with custom flag', function (assert) {
        var m = moment.invalid({tooBusyWith : 'reiculating splines'});
        assert.equal(m.isValid(), false);
        assert.equal(m.parsingFlags().userInvalidated, false);
        assert.equal(m.parsingFlags().tooBusyWith, 'reiculating splines');
        assert.ok(isNaN(m.valueOf()));
    });

    test('invalid operations', function (assert) {
        var invalids = [
                moment.invalid(),
                moment('xyz', 'l'),
                moment('2015-01-35', 'YYYY-MM-DD'),
                moment('2015-01-25 a', 'YYYY-MM-DD', true)
            ],
            i,
            invalid,
            valid = moment();

        test.expectedDeprecations('moment().min', 'moment().max');

        for (i = 0; i < invalids.length; ++i) {
            invalid = invalids[i];

            assert.ok(!invalid.clone().add(5, 'hours').isValid(), 'invalid.add is invalid');
            assert.equal(invalid.calendar(), 'Invalid date', 'invalid.calendar is \'Invalid date\'');
            assert.ok(!invalid.clone().isValid(), 'invalid.clone is invalid');
            assert.ok(isNaN(invalid.diff(valid)), 'invalid.diff(valid) is NaN');
            assert.ok(isNaN(valid.diff(invalid)), 'valid.diff(invalid) is NaN');
            assert.ok(isNaN(invalid.diff(invalid)), 'invalid.diff(invalid) is NaN');
            assert.ok(!invalid.clone().endOf('month').isValid(), 'invalid.endOf is invalid');
            assert.equal(invalid.format(), 'Invalid date', 'invalid.format is \'Invalid date\'');
            assert.equal(invalid.from(), 'Invalid date');
            assert.equal(invalid.from(valid), 'Invalid date');
            assert.equal(valid.from(invalid), 'Invalid date');
            assert.equal(invalid.fromNow(), 'Invalid date');
            assert.equal(invalid.to(), 'Invalid date');
            assert.equal(invalid.to(valid), 'Invalid date');
            assert.equal(valid.to(invalid), 'Invalid date');
            assert.equal(invalid.toNow(), 'Invalid date');
            assert.ok(isNaN(invalid.get('year')), 'invalid.get is NaN');
            // TODO invalidAt
            assert.ok(!invalid.isAfter(valid));
            assert.ok(!valid.isAfter(invalid));
            assert.ok(!invalid.isAfter(invalid));
            assert.ok(!invalid.isBefore(valid));
            assert.ok(!valid.isBefore(invalid));
            assert.ok(!invalid.isBefore(invalid));
            assert.ok(!invalid.isBetween(valid, valid));
            assert.ok(!valid.isBetween(invalid, valid));
            assert.ok(!valid.isBetween(valid, invalid));
            assert.ok(!invalid.isSame(invalid));
            assert.ok(!invalid.isSame(valid));
            assert.ok(!valid.isSame(invalid));
            assert.ok(!invalid.isValid());
            assert.equal(invalid.locale(), 'en');
            assert.equal(invalid.localeData()._abbr, 'en');
            assert.ok(!invalid.clone().max(valid).isValid());
            assert.ok(!valid.clone().max(invalid).isValid());
            assert.ok(!invalid.clone().max(invalid).isValid());
            assert.ok(!invalid.clone().min(valid).isValid());
            assert.ok(!valid.clone().min(invalid).isValid());
            assert.ok(!invalid.clone().min(invalid).isValid());
            assert.ok(!moment.min(invalid, valid).isValid());
            assert.ok(!moment.min(valid, invalid).isValid());
            assert.ok(!moment.max(invalid, valid).isValid());
            assert.ok(!moment.max(valid, invalid).isValid());
            assert.ok(!invalid.clone().set('year', 2005).isValid());
            assert.ok(!invalid.clone().startOf('month').isValid());

            assert.ok(!invalid.clone().subtract(5, 'days').isValid());
            assert.deepEqual(invalid.toArray(), [NaN, NaN, NaN, NaN, NaN, NaN, NaN]);
            assert.deepEqual(invalid.toObject(), {
                years: NaN,
                months: NaN,
                date: NaN,
                hours: NaN,
                minutes: NaN,
                seconds: NaN,
                milliseconds: NaN
            });
            assert.ok(moment.isDate(invalid.toDate()));
            assert.ok(isNaN(invalid.toDate().valueOf()));
            assert.equal(invalid.toJSON(), null);
            assert.equal(invalid.toString(), 'Invalid date');
            assert.ok(isNaN(invalid.unix()));
            assert.ok(isNaN(invalid.valueOf()));

            assert.ok(isNaN(invalid.year()));
            assert.ok(isNaN(invalid.weekYear()));
            assert.ok(isNaN(invalid.isoWeekYear()));
            assert.ok(isNaN(invalid.quarter()));
            assert.ok(isNaN(invalid.quarters()));
            assert.ok(isNaN(invalid.month()));
            assert.ok(isNaN(invalid.daysInMonth()));
            assert.ok(isNaN(invalid.week()));
            assert.ok(isNaN(invalid.weeks()));
            assert.ok(isNaN(invalid.isoWeek()));
            assert.ok(isNaN(invalid.isoWeeks()));
            assert.ok(isNaN(invalid.weeksInYear()));
            assert.ok(isNaN(invalid.isoWeeksInYear()));
            assert.ok(isNaN(invalid.date()));
            assert.ok(isNaN(invalid.day()));
            assert.ok(isNaN(invalid.days()));
            assert.ok(isNaN(invalid.weekday()));
            assert.ok(isNaN(invalid.isoWeekday()));
            assert.ok(isNaN(invalid.dayOfYear()));
            assert.ok(isNaN(invalid.hour()));
            assert.ok(isNaN(invalid.hours()));
            assert.ok(isNaN(invalid.minute()));
            assert.ok(isNaN(invalid.minutes()));
            assert.ok(isNaN(invalid.second()));
            assert.ok(isNaN(invalid.seconds()));
            assert.ok(isNaN(invalid.millisecond()));
            assert.ok(isNaN(invalid.milliseconds()));
            assert.ok(isNaN(invalid.utcOffset()));

            assert.ok(!invalid.clone().year(2001).isValid());
            assert.ok(!invalid.clone().weekYear(2001).isValid());
            assert.ok(!invalid.clone().isoWeekYear(2001).isValid());
            assert.ok(!invalid.clone().quarter(1).isValid());
            assert.ok(!invalid.clone().quarters(1).isValid());
            assert.ok(!invalid.clone().month(1).isValid());
            assert.ok(!invalid.clone().week(1).isValid());
            assert.ok(!invalid.clone().weeks(1).isValid());
            assert.ok(!invalid.clone().isoWeek(1).isValid());
            assert.ok(!invalid.clone().isoWeeks(1).isValid());
            assert.ok(!invalid.clone().date(1).isValid());
            assert.ok(!invalid.clone().day(1).isValid());
            assert.ok(!invalid.clone().days(1).isValid());
            assert.ok(!invalid.clone().weekday(1).isValid());
            assert.ok(!invalid.clone().isoWeekday(1).isValid());
            assert.ok(!invalid.clone().dayOfYear(1).isValid());
            assert.ok(!invalid.clone().hour(1).isValid());
            assert.ok(!invalid.clone().hours(1).isValid());
            assert.ok(!invalid.clone().minute(1).isValid());
            assert.ok(!invalid.clone().minutes(1).isValid());
            assert.ok(!invalid.clone().second(1).isValid());
            assert.ok(!invalid.clone().seconds(1).isValid());
            assert.ok(!invalid.clone().millisecond(1).isValid());
            assert.ok(!invalid.clone().milliseconds(1).isValid());
            assert.ok(!invalid.clone().utcOffset(1).isValid());

            assert.ok(!invalid.clone().utc().isValid());
            assert.ok(!invalid.clone().local().isValid());
            assert.ok(!invalid.clone().parseZone('05:30').isValid());
            assert.ok(!invalid.hasAlignedHourOffset());
            assert.ok(!invalid.isDST());
            assert.ok(!invalid.isDSTShifted());
            assert.ok(!invalid.isLocal());
            assert.ok(!invalid.isUtcOffset());
            assert.ok(!invalid.isUtc());
            assert.ok(!invalid.isUTC());

            assert.ok(!invalid.isLeapYear());

            assert.equal(moment.duration({from: invalid, to: valid}).asMilliseconds(), 0);
            assert.equal(moment.duration({from: valid, to: invalid}).asMilliseconds(), 0);
            assert.equal(moment.duration({from: invalid, to: invalid}).asMilliseconds(), 0);
        }
    });

}));

;(function (global, factory) {
   typeof exports === 'object' && typeof module !== 'undefined'
       && typeof require === 'function' ? factory(require('../../moment')) :
   typeof define === 'function' && define.amd ? define(['../../moment'], factory) :
   factory(global.moment)
}(this, function (moment) { 'use strict';

    function each(array, callback) {
        var i;
        for (i = 0; i < array.length; i++) {
            callback(array[i], i, array);
        }
    }

    function objectKeys(obj) {
        if (Object.keys) {
            return Object.keys(obj);
        } else {
            // IE8
            var res = [], i;
            for (i in obj) {
                if (obj.hasOwnProperty(i)) {
                    res.push(i);
                }
            }
            return res;
        }
    }

    // Pick the first defined of two or three arguments.
    function defaults(a, b, c) {
        if (a != null) {
            return a;
        }
        if (b != null) {
            return b;
        }
        return c;
    }

    function defineCommonLocaleTests(locale, options) {
        test('lenient ordinal parsing', function (assert) {
            var i, ordinalStr, testMoment;
            for (i = 1; i <= 31; ++i) {
                ordinalStr = moment([2014, 0, i]).format('YYYY MM Do');
                testMoment = moment(ordinalStr, 'YYYY MM Do');
                assert.equal(testMoment.year(), 2014,
                        'lenient ordinal parsing ' + i + ' year check');
                assert.equal(testMoment.month(), 0,
                        'lenient ordinal parsing ' + i + ' month check');
                assert.equal(testMoment.date(), i,
                        'lenient ordinal parsing ' + i + ' date check');
            }
        });

        test('lenient ordinal parsing of number', function (assert) {
            var i, testMoment;
            for (i = 1; i <= 31; ++i) {
                testMoment = moment('2014 01 ' + i, 'YYYY MM Do');
                assert.equal(testMoment.year(), 2014,
                        'lenient ordinal parsing of number ' + i + ' year check');
                assert.equal(testMoment.month(), 0,
                        'lenient ordinal parsing of number ' + i + ' month check');
                assert.equal(testMoment.date(), i,
                        'lenient ordinal parsing of number ' + i + ' date check');
            }
        });

        test('strict ordinal parsing', function (assert) {
            var i, ordinalStr, testMoment;
            for (i = 1; i <= 31; ++i) {
                ordinalStr = moment([2014, 0, i]).format('YYYY MM Do');
                testMoment = moment(ordinalStr, 'YYYY MM Do', true);
                assert.ok(testMoment.isValid(), 'strict ordinal parsing ' + i);
            }
        });

        test('meridiem invariant', function (assert) {
            var h, m, t1, t2;
            for (h = 0; h < 24; ++h) {
                for (m = 0; m < 60; m += 15) {
                    t1 = moment.utc([2000, 0, 1, h, m]);
                    t2 = moment.utc(t1.format('A h:mm'), 'A h:mm');
                    assert.equal(t2.format('HH:mm'), t1.format('HH:mm'),
                            'meridiem at ' + t1.format('HH:mm'));
                }
            }
        });

        test('date format correctness', function (assert) {
            var data, tokens;
            data = moment.localeData()._longDateFormat;
            tokens = objectKeys(data);
            each(tokens, function (srchToken) {
                // Check each format string to make sure it does not contain any
                // tokens that need to be expanded.
                each(tokens, function (baseToken) {
                    // strip escaped sequences
                    var format = data[baseToken].replace(/(\[[^\]]*\])/g, '');
                    assert.equal(false, !!~format.indexOf(srchToken),
                            'contains ' + srchToken + ' in ' + baseToken);
                });
            });
        });

        test('month parsing correctness', function (assert) {
            var i, m;

            if (locale === 'tr') {
                // I can't fix it :(
                expect(0);
                return;
            }
            function tester(format) {
                var r;
                r = moment(m.format(format), format);
                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format);
                r = moment(m.format(format).toLocaleUpperCase(), format);
                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' upper');
                r = moment(m.format(format).toLocaleLowerCase(), format);
                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' lower');

                r = moment(m.format(format), format, true);
                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' strict');
                r = moment(m.format(format).toLocaleUpperCase(), format, true);
                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' upper strict');
                r = moment(m.format(format).toLocaleLowerCase(), format, true);
                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' lower strict');
            }

            for (i = 0; i < 12; ++i) {
                m = moment([2015, i, 15, 18]);
                tester('MMM');
                tester('MMM.');
                tester('MMMM');
                tester('MMMM.');
            }
        });

        test('weekday parsing correctness', function (assert) {
            var i, m;

            if (locale === 'tr' || locale === 'az') {
                // There is a lower-case letter (Ä±), that converted to upper then
                // lower changes to i
                expect(0);
                return;
            }
            function tester(format) {
                var r, baseMsg = 'weekday ' + m.weekday() + ' fmt ' + format;
                r = moment(m.format(format), format);
                assert.equal(r.weekday(), m.weekday(), baseMsg);
                r = moment(m.format(format).toLocaleUpperCase(), format);
                assert.equal(r.weekday(), m.weekday(), baseMsg + ' upper');
                r = moment(m.format(format).toLocaleLowerCase(), format);
                assert.equal(r.weekday(), m.weekday(), baseMsg + ' lower');

                r = moment(m.format(format), format, true);
                assert.equal(r.weekday(), m.weekday(), baseMsg + ' strict');
                r = moment(m.format(format).toLocaleUpperCase(), format, true);
                assert.equal(r.weekday(), m.weekday(), baseMsg + ' upper strict');
                r = moment(m.format(format).toLocaleLowerCase(), format, true);
                assert.equal(r.weekday(), m.weekday(), baseMsg + ' lower strict');
            }

            for (i = 0; i < 7; ++i) {
                m = moment.utc([2015, i, 15, 18]);
                tester('dd');
                tester('ddd');
                tester('dddd');
            }
        });
    }

    function setupDeprecationHandler(test, moment, scope) {
        test._expectedDeprecations = null;
        test._observedDeprecations = null;
        test._oldSupress = moment.suppressDeprecationWarnings;
        moment.suppressDeprecationWarnings = true;
        test.expectedDeprecations = function () {
            test._expectedDeprecations = arguments;
            test._observedDeprecations = [];
        };
        moment.deprecationHandler = function (name, msg) {
            var deprecationId = matchedDeprecation(name, msg, test._expectedDeprecations);
            if (deprecationId === -1) {
                throw new Error('Unexpected deprecation thrown name=' +
                        name + ' msg=' + msg);
            }
            test._observedDeprecations[deprecationId] = 1;
        };
    }

    function teardownDeprecationHandler(test, moment, scope) {
        moment.suppressDeprecationWarnings = test._oldSupress;

        if (test._expectedDeprecations != null) {
            var missedDeprecations = [];
            each(test._expectedDeprecations, function (deprecationPattern, id) {
                if (test._observedDeprecations[id] !== 1) {
                    missedDeprecations.push(deprecationPattern);
                }
            });
            if (missedDeprecations.length !== 0) {
                throw new Error('Expected deprecation warnings did not happen: ' +
                        missedDeprecations.join(' '));
            }
        }
    }

    function matchedDeprecation(name, msg, deprecations) {
        if (deprecations == null) {
            return -1;
        }
        for (var i = 0; i < deprecations.length; ++i) {
            if (name != null && name === deprecations[i]) {
                return i;
            }
            if (msg != null && msg.substring(0, deprecations[i].length) === deprecations[i]) {
                return i;
            }
        }
        return -1;
    }

    /*global QUnit:false*/

    var test = QUnit.test;

    var expect = QUnit.expect;

    function module (name, lifecycle) {
        QUnit.module(name, {
            setup : function () {
                moment.locale('en');
                moment.createFromInputFallback = function (config) {
                    throw new Error('input not handled by moment: ' + config._i);
                };
                setupDeprecationHandler(test, moment, 'core');
                if (lifecycle && lifecycle.setup) {
                    lifecycle.setup();
                }
            },
            teardown : function () {
                teardownDeprecationHandler(test, moment, 'core');
                if (lifecycle && lifecycle.teardown) {
                    lifecycle.teardown();
                }
            }
        });
    }

    function localeModule (name, lifecycle) {
        QUnit.module('locale:' + name, {
            setup : function () {
                moment.locale(name);
                moment.createFromInputFallback = function (config) {
                    throw new Error('input not handled by moment: ' + config._i);
                };
                setupDeprecationHandler(test, moment, 'locale');
                if (lifecycle && lifecycle.setup) {
                    lifecycle.setup();
                }
            },
            teardown : function () {
                moment.locale('en');
                teardownDeprecationHandler(test, moment, 'locale');
                if (lifecycle && lifecycle.teardown) {
                    lifecycle.teardown();
                }
            }
        });
        defineCommonLocaleTests(name, -1, -1);
    }

    module('is after');

    test('is after without units', function (assert) {
        var m = moment(new Date(2011, 3, 2, 3, 4, 5, 10)), mCopy = moment(m);
        assert.equal(m.isAfter(moment(new Date(2012, 3, 2, 3, 5, 5, 10))), false, 'year is later');
        assert.equal(m.isAfter(moment(new Date(2010, 3, 2, 3, 3, 5, 10))), true, 'year is earlier');
        assert.equal(m.isAfter(moment(new Date(2011, 4, 2, 3, 4, 5, 10))), false, 'month is later');
        assert.equal(m.isAfter(moment(new Date(2011, 2, 2, 3, 4, 5, 10))), true, 'month is earlier');
        assert.equal(m.isAfter(moment(new Date(2011, 3, 3, 3, 4, 5, 10))), false, 'day is later');
        assert.equal(m.isAfter(moment(new Date(2011, 3, 1, 3, 4, 5, 10))), true, 'day is earlier');
        assert.equal(m.isAfter(moment(new Date(2011, 3, 2, 4, 4, 5, 10))), false, 'hour is later');
        assert.equal(m.isAfter(moment(new Date(2011, 3, 2, 2, 4, 5, 10))), true, 'hour is earlier');
        assert.equal(m.isAfter(moment(new Date(2011, 3, 2, 3, 5, 5, 10))), false, 'minute is later');
        assert.equal(m.isAfter(moment(new Date(2011, 3, 2, 3, 3, 5, 10))), true, 'minute is earlier');
        assert.equal(m.isAfter(moment(new Date(2011, 3, 2, 3, 4, 6, 10))), false, 'second is later');
        assert.equal(m.isAfter(moment(new Date(2011, 3, 2, 3, 4, 4, 11))), true, 'second is earlier');
        assert.equal(m.isAfter(moment(new Date(2011, 3, 2, 3, 4, 5, 10))), false, 'millisecond match');
        assert.equal(m.isAfter(moment(new Date(2011, 3, 2, 3, 4, 5, 11))), false, 'millisecond is later');
        assert.equal(m.isAfter(moment(new Date(2011, 3, 2, 3, 4, 5, 9))), true, 'millisecond is earlier');
        assert.equal(m.isAfter(m), false, 'moments are not after themselves');
        assert.equal(+m, +mCopy, 'isAfter second should not change moment');
    });

    test('is after year', function (assert) {
        var m = moment(new Date(2011, 1, 2, 3, 4, 5, 6)), mCopy = moment(m);
        assert.equal(m.isAfter(moment(new Date(2011, 5, 6, 7, 8, 9, 10)), 'year'), false, 'year match');
        assert.equal(m.isAfter(moment(new Date(2010, 5, 6, 7, 8, 9, 10)), 'years'), true, 'plural should work');
        assert.equal(m.isAfter(moment(new Date(2013, 5, 6, 7, 8, 9, 10)), 'year'), false, 'year is later');
        assert.equal(m.isAfter(moment(new Date(2010, 5, 6, 7, 8, 9, 10)), 'year'), true, 'year is earlier');
        assert.equal(m.isAfter(moment(new Date(2011, 0, 1, 0, 0, 0, 0)), 'year'), false, 'exact start of year');
        assert.equal(m.isAfter(moment(new Date(2011, 11, 31, 23, 59, 59, 999)), 'year'), false, 'exact end of year');
        assert.equal(m.isAfter(moment(new Date(2012, 0, 1, 0, 0, 0, 0)), 'year'), false, 'start of next year');
        assert.equal(m.isAfter(moment(new Date(2010, 11, 31, 23, 59, 59, 999)), 'year'), true, 'end of previous year');
        assert.equal(m.isAfter(moment(new Date(1980, 11, 31, 23, 59, 59, 999)), 'year'), true, 'end of year far before');
        assert.equal(m.isAfter(m, 'year'), false, 'same moments are not after the same year');
        assert.equal(+m, +mCopy, 'isAfter year should not change moment');
    });

    test('is after month', function (assert) {
        var m = moment(new Date(2011, 2, 3, 4, 5, 6, 7)), mCopy = moment(m);
        assert.equal(m.isAfter(moment(new Date(2011, 2, 6, 7, 8, 9, 10)), 'month'), false, 'month match');
        assert.equal(m.isAfter(moment(new Date(2010, 2, 6, 7, 8, 9, 10)), 'months'), true, 'plural should work');
        assert.equal(m.isAfter(moment(new Date(2012, 2, 6, 7, 8, 9, 10)), 'month'), false, 'year is later');
        assert.equal(m.isAfter(moment(new Date(2010, 2, 6, 7, 8, 9, 10)), 'month'), true, 'year is earlier');
        assert.equal(m.isAfter(moment(new Date(2011, 5, 6, 7, 8, 9, 10)), 'month'), false, 'month is later');
        assert.equal(m.isAfter(moment(new Date(2011, 1, 6, 7, 8, 9, 10)), 'month'), true, 'month is earlier');
        assert.equal(m.isAfter(moment(new Date(2011, 2, 1, 0, 0, 0, 0)), 'month'), false, 'exact start of month');
        assert.equal(m.isAfter(moment(new Date(2011, 2, 31, 23, 59, 59, 999)), 'month'), false, 'exact end of month');
        assert.equal(m.isAfter(moment(new Date(2011, 3, 1, 0, 0, 0, 0)), 'month'), false, 'start of next month');
        assert.equal(m.isAfter(moment(new Date(2011, 1, 27, 23, 59, 59, 999)), 'month'), true, 'end of previous month');
        assert.equal(m.isAfter(moment(new Date(2010, 12, 31, 23, 59, 59, 999)), 'month'), true, 'later month but earlier year');
        assert.equal(m.isAfter(m, 'month'), false, 'same moments are not after the same month');
        assert.equal(+m, +mCopy, 'isAfter month should not change moment');
    });

    test('is after day', function (assert) {
        var m = moment(new Date(2011, 3, 2, 3, 4, 5, 6)), mCopy = moment(m);
        assert.equal(m.isAfter(moment(new Date(2011, 3, 2, 7, 8, 9, 10)), 'day'), false, 'day match');
        assert.equal(m.isAfter(moment(new Date(2010, 3, 2, 7, 8, 9, 10)), 'days'), true, 'plural should work');
        assert.equal(m.isAfter(moment(new Date(2012, 3, 2, 7, 8, 9, 10)), 'day'), false, 'year is later');
        assert.equal(m.isAfter(moment(new Date(2010, 3, 2, 7, 8, 9, 10)), 'day'), true, 'year is earlier');
        assert.equal(m.isAfter(moment(new Date(2011, 4, 2, 7, 8, 9, 10)), 'day'), false, 'month is later');
        assert.equal(m.isAfter(moment(new Date(2011, 2, 2, 7, 8, 9, 10)), 'day'), true, 'month is earlier');
        assert.equal(m.isAfter(moment(new Date(2011, 3, 3, 7, 8, 9, 10)), 'day'), false, 'day is later');
        assert.equal(m.isAfter(moment(new Date(2011, 3, 1, 7, 8, 9, 10)), 'day'), true, 'day is earlier');
        assert.equal(m.isAfter(moment(new Date(2011, 3, 2, 0, 0, 0, 0)), 'day'), false, 'exact start of day');
        assert.equal(m.isAfter(moment(new Date(2011, 3, 2, 23, 59, 59, 999)), 'day'), false, 'exact end of day');
        assert.equal(m.isAfter(moment(new Date(2011, 3, 3, 0, 0, 0, 0)), 'day'), false, 'start of next day');
        assert.equal(m.isAfter(moment(new Date(2011, 3, 1, 23, 59, 59, 999)), 'day'), true, 'end of previous day');
        assert.equal(m.isAfter(moment(new Date(2010, 3, 10, 0, 0, 0, 0)), 'day'), true, 'later day but earlier year');
        assert.equal(m.isAfter(m, 'day'), false, 'same moments are not after the same day');
        assert.equal(+m, +mCopy, 'isAfter day should not change moment');
    });

    test('is after hour', function (assert) {
        var m = moment(new Date(2011, 3, 2, 3, 4, 5, 6)), mCopy = moment(m);
        assert.equal(m.isAfter(moment(new Date(2011, 3, 2, 3, 8, 9, 10)), 'hour'), false, 'hour match');
        assert.equal(m.isAfter(moment(new Date(2010, 3, 2, 3, 8, 9, 10)), 'hours'), true, 'plural should work');
        assert.equal(m.isAfter(moment(new Date(2012, 3, 2, 3, 8, 9, 10)), 'hour'), false, 'year is later');
        assert.equal(m.isAfter(moment(new Date(2010, 3, 2, 3, 8, 9, 10)), 'hour'), true, 'year is earlier');
        assert.equal(m.isAfter(moment(new Date(2011, 4, 2, 3, 8, 9, 10)), 'hour'), false, 'month is later');
        assert.equal(m.isAfter(moment(new Date(2011, 1, 2, 3, 8, 9, 10)), 'hour'), true, 'month is earlier');
        assert.equal(m.isAfter(moment(new Date(2011, 3, 3, 3, 8, 9, 10)), 'hour'), false, 'day is later');
        assert.equal(m.isAfter(moment(new Date(2011, 3, 1, 3, 8, 9, 10)), 'hour'), true, 'day is earlier');
        assert.equal(m.isAfter(moment(new Date(2011, 3, 2, 4, 8, 9, 10)), 'hour'), false, 'hour is later');
        assert.equal(m.isAfter(moment(new Date(2011, 3, 2, 3, 8, 9, 10)), 'hour'), false, 'hour is earlier');
        assert.equal(m.isAfter(moment(new Date(2011, 3, 2, 3, 0, 0, 0)), 'hour'), false, 'exact start of hour');
        assert.equal(m.isAfter(moment(new Date(2011, 3, 2, 3, 59, 59, 999)), 'hour'), false, 'exact end of hour');
        assert.equal(m.isAfter(moment(new Date(2011, 3, 2, 4, 0, 0, 0)), 'hour'), false, 'start of next hour');
        assert.equal(m.isAfter(moment(new Date(2011, 3, 2, 2, 59, 59, 999)), 'hour'), true, 'end of previous hour');
        assert.equal(m.isAfter(m, 'hour'), false, 'same moments are not after the same hour');
        assert.equal(+m, +mCopy, 'isAfter hour should not change moment');
    });

    test('is after minute', function (assert) {
        var m = moment(new Date(2011, 3, 2, 3, 4, 5, 6)), mCopy = moment(m);
        assert.equal(m.isAfter(moment(new Date(2011, 3, 2, 3, 4, 9, 10)), 'minute'), false, 'minute match');
        assert.equal(m.isAfter(moment(new Date(2010, 3, 2, 3, 4, 9, 10)), 'minutes'), true, 'plural should work');
        assert.equal(m.isAfter(moment(new Date(2012, 3, 2, 3, 4, 9, 10)), 'minute'), false, 'year is later');
        assert.equal(m.isAfter(moment(new Date(2010, 3, 2, 3, 4, 9, 10)), 'minute'), true, 'year is earlier');
        assert.equal(m.isAfter(moment(new Date(2011, 4, 2, 3, 4, 9, 10)), 'minute'), false, 'month is later');
        assert.equal(m.isAfter(moment(new Date(2011, 2, 2, 3, 4, 9, 10)), 'minute'), true, 'month is earlier');
        assert.equal(m.isAfter(moment(new Date(2011, 3, 3, 3, 4, 9, 10)), 'minute'), false, 'day is later');
        assert.equal(m.isAfter(moment(new Date(2011, 3, 1, 3, 4, 9, 10)), 'minute'), true, 'day is earlier');
        assert.equal(m.isAfter(moment(new Date(2011, 3, 2, 4, 4, 9, 10)), 'minute'), false, 'hour is later');
        assert.equal(m.isAfter(moment(new Date(2011, 3, 2, 2, 4, 9, 10)), 'minute'), true, 'hour is earler');
        assert.equal(m.isAfter(moment(new Date(2011, 3, 2, 3, 5, 9, 10)), 'minute'), false, 'minute is later');
        assert.equal(m.isAfter(moment(new Date(2011, 3, 2, 3, 3, 9, 10)), 'minute'), true, 'minute is earlier');
        assert.equal(m.isAfter(moment(new Date(2011, 3, 2, 3, 4, 0, 0)), 'minute'), false, 'exact start of minute');
        assert.equal(m.isAfter(moment(new Date(2011, 3, 2, 3, 4, 59, 999)), 'minute'), false, 'exact end of minute');
        assert.equal(m.isAfter(moment(new Date(2011, 3, 2, 3, 5, 0, 0)), 'minute'), false, 'start of next minute');
        assert.equal(m.isAfter(moment(new Date(2011, 3, 2, 3, 3, 59, 999)), 'minute'), true, 'end of previous minute');
        assert.equal(m.isAfter(m, 'minute'), false, 'same moments are not after the same minute');
        assert.equal(+m, +mCopy, 'isAfter minute should not change moment');
    });

    test('is after second', function (assert) {
        var m = moment(new Date(2011, 3, 2, 3, 4, 5, 10)), mCopy = moment(m);
        assert.equal(m.isAfter(moment(new Date(2011, 3, 2, 3, 4, 5, 10)), 'second'), false, 'second match');
        assert.equal(m.isAfter(moment(new Date(2010, 3, 2, 3, 4, 5, 10)), 'seconds'), true, 'plural should work');
        assert.equal(m.isAfter(moment(new Date(2012, 3, 2, 3, 4, 5, 10)), 'second'), false, 'year is later');
        assert.equal(m.isAfter(moment(new Date(2010, 3, 2, 3, 4, 5, 10)), 'second'), true, 'year is earlier');
        assert.equal(m.isAfter(moment(new Date(2011, 4, 2, 3, 4, 5, 10)), 'second'), false, 'month is later');
        assert.equal(m.isAfter(moment(new Date(2011, 2, 2, 3, 4, 5, 10)), 'second'), true, 'month is earlier');
        assert.equal(m.isAfter(moment(new Date(2011, 3, 3, 3, 4, 5, 10)), 'second'), false, 'day is later');
        assert.equal(m.isAfter(moment(new Date(2011, 3, 1, 1, 4, 5, 10)), 'second'), true, 'day is earlier');
        assert.equal(m.isAfter(moment(new Date(2011, 3, 2, 4, 4, 5, 10)), 'second'), false, 'hour is later');
        assert.equal(m.isAfter(moment(new Date(2011, 3, 1, 4, 1, 5, 10)), 'second'), true, 'hour is earlier');
        assert.equal(m.isAfter(moment(new Date(2011, 3, 2, 3, 5, 5, 10)), 'second'), false, 'minute is later');
        assert.equal(m.isAfter(moment(new Date(2011, 3, 2, 3, 3, 5, 10)), 'second'), true, 'minute is earlier');
        assert.equal(m.isAfter(moment(new Date(2011, 3, 2, 3, 4, 6, 10)), 'second'), false, 'second is later');
        assert.equal(m.isAfter(moment(new Date(2011, 3, 2, 3, 4, 4, 5)), 'second'), true, 'second is earlier');
        assert.equal(m.isAfter(moment(new Date(2011, 3, 2, 3, 4, 5, 0)), 'second'), false, 'exact start of second');
        assert.equal(m.isAfter(moment(new Date(2011, 3, 2, 3, 4, 5, 999)), 'second'), false, 'exact end of second');
        assert.equal(m.isAfter(moment(new Date(2011, 3, 2, 3, 4, 6, 0)), 'second'), false, 'start of next second');
        assert.equal(m.isAfter(moment(new Date(2011, 3, 2, 3, 4, 4, 999)), 'second'), true, 'end of previous second');
        assert.equal(m.isAfter(m, 'second'), false, 'same moments are not after the same second');
        assert.equal(+m, +mCopy, 'isAfter second should not change moment');
    });

    test('is after millisecond', function (assert) {
        var m = moment(new Date(2011, 3, 2, 3, 4, 5, 10)), mCopy = moment(m);
        assert.equal(m.isAfter(moment(new Date(2011, 3, 2, 3, 4, 5, 10)), 'millisecond'), false, 'millisecond match');
        assert.equal(m.isAfter(moment(new Date(2010, 3, 2, 3, 4, 5, 10)), 'milliseconds'), true, 'plural should work');
        assert.equal(m.isAfter(moment(new Date(2012, 3, 2, 3, 4, 5, 10)), 'millisecond'), false, 'year is later');
        assert.equal(m.isAfter(moment(new Date(2010, 3, 2, 3, 4, 5, 10)), 'millisecond'), true, 'year is earlier');
        assert.equal(m.isAfter(moment(new Date(2011, 4, 2, 3, 4, 5, 10)), 'millisecond'), false, 'month is later');
        assert.equal(m.isAfter(moment(new Date(2011, 2, 2, 3, 4, 5, 10)), 'millisecond'), true, 'month is earlier');
        assert.equal(m.isAfter(moment(new Date(2011, 3, 3, 3, 4, 5, 10)), 'millisecond'), false, 'day is later');
        assert.equal(m.isAfter(moment(new Date(2011, 3, 1, 1, 4, 5, 10)), 'millisecond'), true, 'day is earlier');
        assert.equal(m.isAfter(moment(new Date(2011, 3, 2, 4, 4, 5, 10)), 'millisecond'), false, 'hour is later');
        assert.equal(m.isAfter(moment(new Date(2011, 3, 1, 4, 1, 5, 10)), 'millisecond'), true, 'hour is earlier');
        assert.equal(m.isAfter(moment(new Date(2011, 3, 2, 3, 5, 5, 10)), 'millisecond'), false, 'minute is later');
        assert.equal(m.isAfter(moment(new Date(2011, 3, 2, 3, 3, 5, 10)), 'millisecond'), true, 'minute is earlier');
        assert.equal(m.isAfter(moment(new Date(2011, 3, 2, 3, 4, 6, 10)), 'millisecond'), false, 'second is later');
        assert.equal(m.isAfter(moment(new Date(2011, 3, 2, 3, 4, 4, 5)), 'millisecond'), true, 'second is earlier');
        assert.equal(m.isAfter(moment(new Date(2011, 3, 2, 3, 4, 6, 11)), 'millisecond'), false, 'millisecond is later');
        assert.equal(m.isAfter(moment(new Date(2011, 3, 2, 3, 4, 4, 9)), 'millisecond'), true, 'millisecond is earlier');
        assert.equal(m.isAfter(m, 'millisecond'), false, 'same moments are not after the same millisecond');
        assert.equal(+m, +mCopy, 'isAfter millisecond should not change moment');
    });

    test('is after invalid', function (assert) {
        var m = moment(), invalid = moment.invalid();
        assert.equal(m.isAfter(invalid), false, 'valid moment is not after invalid moment');
        assert.equal(invalid.isAfter(m), false, 'invalid moment is not after valid moment');
        assert.equal(m.isAfter(invalid, 'year'), false, 'invalid moment year');
        assert.equal(m.isAfter(invalid, 'month'), false, 'invalid moment month');
        assert.equal(m.isAfter(invalid, 'day'), false, 'invalid moment day');
        assert.equal(m.isAfter(invalid, 'hour'), false, 'invalid moment hour');
        assert.equal(m.isAfter(invalid, 'minute'), false, 'invalid moment minute');
        assert.equal(m.isAfter(invalid, 'second'), false, 'invalid moment second');
        assert.equal(m.isAfter(invalid, 'milliseconds'), false, 'invalid moment milliseconds');
    });

}));

;(function (global, factory) {
   typeof exports === 'object' && typeof module !== 'undefined'
       && typeof require === 'function' ? factory(require('../../moment')) :
   typeof define === 'function' && define.amd ? define(['../../moment'], factory) :
   factory(global.moment)
}(this, function (moment) { 'use strict';

    function each(array, callback) {
        var i;
        for (i = 0; i < array.length; i++) {
            callback(array[i], i, array);
        }
    }

    function objectKeys(obj) {
        if (Object.keys) {
            return Object.keys(obj);
        } else {
            // IE8
            var res = [], i;
            for (i in obj) {
                if (obj.hasOwnProperty(i)) {
                    res.push(i);
                }
            }
            return res;
        }
    }

    // Pick the first defined of two or three arguments.
    function defaults(a, b, c) {
        if (a != null) {
            return a;
        }
        if (b != null) {
            return b;
        }
        return c;
    }

    function defineCommonLocaleTests(locale, options) {
        test('lenient ordinal parsing', function (assert) {
            var i, ordinalStr, testMoment;
            for (i = 1; i <= 31; ++i) {
                ordinalStr = moment([2014, 0, i]).format('YYYY MM Do');
                testMoment = moment(ordinalStr, 'YYYY MM Do');
                assert.equal(testMoment.year(), 2014,
                        'lenient ordinal parsing ' + i + ' year check');
                assert.equal(testMoment.month(), 0,
                        'lenient ordinal parsing ' + i + ' month check');
                assert.equal(testMoment.date(), i,
                        'lenient ordinal parsing ' + i + ' date check');
            }
        });

        test('lenient ordinal parsing of number', function (assert) {
            var i, testMoment;
            for (i = 1; i <= 31; ++i) {
                testMoment = moment('2014 01 ' + i, 'YYYY MM Do');
                assert.equal(testMoment.year(), 2014,
                        'lenient ordinal parsing of number ' + i + ' year check');
                assert.equal(testMoment.month(), 0,
                        'lenient ordinal parsing of number ' + i + ' month check');
                assert.equal(testMoment.date(), i,
                        'lenient ordinal parsing of number ' + i + ' date check');
            }
        });

        test('strict ordinal parsing', function (assert) {
            var i, ordinalStr, testMoment;
            for (i = 1; i <= 31; ++i) {
                ordinalStr = moment([2014, 0, i]).format('YYYY MM Do');
                testMoment = moment(ordinalStr, 'YYYY MM Do', true);
                assert.ok(testMoment.isValid(), 'strict ordinal parsing ' + i);
            }
        });

        test('meridiem invariant', function (assert) {
            var h, m, t1, t2;
            for (h = 0; h < 24; ++h) {
                for (m = 0; m < 60; m += 15) {
                    t1 = moment.utc([2000, 0, 1, h, m]);
                    t2 = moment.utc(t1.format('A h:mm'), 'A h:mm');
                    assert.equal(t2.format('HH:mm'), t1.format('HH:mm'),
                            'meridiem at ' + t1.format('HH:mm'));
                }
            }
        });

        test('date format correctness', function (assert) {
            var data, tokens;
            data = moment.localeData()._longDateFormat;
            tokens = objectKeys(data);
            each(tokens, function (srchToken) {
                // Check each format string to make sure it does not contain any
                // tokens that need to be expanded.
                each(tokens, function (baseToken) {
                    // strip escaped sequences
                    var format = data[baseToken].replace(/(\[[^\]]*\])/g, '');
                    assert.equal(false, !!~format.indexOf(srchToken),
                            'contains ' + srchToken + ' in ' + baseToken);
                });
            });
        });

        test('month parsing correctness', function (assert) {
            var i, m;

            if (locale === 'tr') {
                // I can't fix it :(
                expect(0);
                return;
            }
            function tester(format) {
                var r;
                r = moment(m.format(format), format);
                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format);
                r = moment(m.format(format).toLocaleUpperCase(), format);
                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' upper');
                r = moment(m.format(format).toLocaleLowerCase(), format);
                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' lower');

                r = moment(m.format(format), format, true);
                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' strict');
                r = moment(m.format(format).toLocaleUpperCase(), format, true);
                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' upper strict');
                r = moment(m.format(format).toLocaleLowerCase(), format, true);
                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' lower strict');
            }

            for (i = 0; i < 12; ++i) {
                m = moment([2015, i, 15, 18]);
                tester('MMM');
                tester('MMM.');
                tester('MMMM');
                tester('MMMM.');
            }
        });

        test('weekday parsing correctness', function (assert) {
            var i, m;

            if (locale === 'tr' || locale === 'az') {
                // There is a lower-case letter (Ä±), that converted to upper then
                // lower changes to i
                expect(0);
                return;
            }
            function tester(format) {
                var r, baseMsg = 'weekday ' + m.weekday() + ' fmt ' + format;
                r = moment(m.format(format), format);
                assert.equal(r.weekday(), m.weekday(), baseMsg);
                r = moment(m.format(format).toLocaleUpperCase(), format);
                assert.equal(r.weekday(), m.weekday(), baseMsg + ' upper');
                r = moment(m.format(format).toLocaleLowerCase(), format);
                assert.equal(r.weekday(), m.weekday(), baseMsg + ' lower');

                r = moment(m.format(format), format, true);
                assert.equal(r.weekday(), m.weekday(), baseMsg + ' strict');
                r = moment(m.format(format).toLocaleUpperCase(), format, true);
                assert.equal(r.weekday(), m.weekday(), baseMsg + ' upper strict');
                r = moment(m.format(format).toLocaleLowerCase(), format, true);
                assert.equal(r.weekday(), m.weekday(), baseMsg + ' lower strict');
            }

            for (i = 0; i < 7; ++i) {
                m = moment.utc([2015, i, 15, 18]);
                tester('dd');
                tester('ddd');
                tester('dddd');
            }
        });
    }

    function setupDeprecationHandler(test, moment, scope) {
        test._expectedDeprecations = null;
        test._observedDeprecations = null;
        test._oldSupress = moment.suppressDeprecationWarnings;
        moment.suppressDeprecationWarnings = true;
        test.expectedDeprecations = function () {
            test._expectedDeprecations = arguments;
            test._observedDeprecations = [];
        };
        moment.deprecationHandler = function (name, msg) {
            var deprecationId = matchedDeprecation(name, msg, test._expectedDeprecations);
            if (deprecationId === -1) {
                throw new Error('Unexpected deprecation thrown name=' +
                        name + ' msg=' + msg);
            }
            test._observedDeprecations[deprecationId] = 1;
        };
    }

    function teardownDeprecationHandler(test, moment, scope) {
        moment.suppressDeprecationWarnings = test._oldSupress;

        if (test._expectedDeprecations != null) {
            var missedDeprecations = [];
            each(test._expectedDeprecations, function (deprecationPattern, id) {
                if (test._observedDeprecations[id] !== 1) {
                    missedDeprecations.push(deprecationPattern);
                }
            });
            if (missedDeprecations.length !== 0) {
                throw new Error('Expected deprecation warnings did not happen: ' +
                        missedDeprecations.join(' '));
            }
        }
    }

    function matchedDeprecation(name, msg, deprecations) {
        if (deprecations == null) {
            return -1;
        }
        for (var i = 0; i < deprecations.length; ++i) {
            if (name != null && name === deprecations[i]) {
                return i;
            }
            if (msg != null && msg.substring(0, deprecations[i].length) === deprecations[i]) {
                return i;
            }
        }
        return -1;
    }

    /*global QUnit:false*/

    var test = QUnit.test;

    var expect = QUnit.expect;

    function module (name, lifecycle) {
        QUnit.module(name, {
            setup : function () {
                moment.locale('en');
                moment.createFromInputFallback = function (config) {
                    throw new Error('input not handled by moment: ' + config._i);
                };
                setupDeprecationHandler(test, moment, 'core');
                if (lifecycle && lifecycle.setup) {
                    lifecycle.setup();
                }
            },
            teardown : function () {
                teardownDeprecationHandler(test, moment, 'core');
                if (lifecycle && lifecycle.teardown) {
                    lifecycle.teardown();
                }
            }
        });
    }

    function localeModule (name, lifecycle) {
        QUnit.module('locale:' + name, {
            setup : function () {
                moment.locale(name);
                moment.createFromInputFallback = function (config) {
                    throw new Error('input not handled by moment: ' + config._i);
                };
                setupDeprecationHandler(test, moment, 'locale');
                if (lifecycle && lifecycle.setup) {
                    lifecycle.setup();
                }
            },
            teardown : function () {
                moment.locale('en');
                teardownDeprecationHandler(test, moment, 'locale');
                if (lifecycle && lifecycle.teardown) {
                    lifecycle.teardown();
                }
            }
        });
        defineCommonLocaleTests(name, -1, -1);
    }

    function isArray(input) {
        return input instanceof Array || Object.prototype.toString.call(input) === '[object Array]';
    }

    test('isArray recognizes Array objects', function (assert) {
        assert.ok(isArray([1,2,3]), 'array args');
        assert.ok(isArray([]), 'empty array');
        assert.ok(isArray(new Array(1,2,3)), 'array constructor');
    });

    test('isArray rejects non-Array objects', function (assert) {
        assert.ok(!isArray(), 'nothing');
        assert.ok(!isArray(undefined), 'undefined');
        assert.ok(!isArray(null), 'null');
        assert.ok(!isArray(123), 'number');
        assert.ok(!isArray('[1,2,3]'), 'string');
        assert.ok(!isArray(new Date()), 'date');
        assert.ok(!isArray({a:1,b:2}), 'object');
    });

}));

;(function (global, factory) {
   typeof exports === 'object' && typeof module !== 'undefined'
       && typeof require === 'function' ? factory(require('../../moment')) :
   typeof define === 'function' && define.amd ? define(['../../moment'], factory) :
   factory(global.moment)
}(this, function (moment) { 'use strict';

    function each(array, callback) {
        var i;
        for (i = 0; i < array.length; i++) {
            callback(array[i], i, array);
        }
    }

    function objectKeys(obj) {
        if (Object.keys) {
            return Object.keys(obj);
        } else {
            // IE8
            var res = [], i;
            for (i in obj) {
                if (obj.hasOwnProperty(i)) {
                    res.push(i);
                }
            }
            return res;
        }
    }

    // Pick the first defined of two or three arguments.
    function defaults(a, b, c) {
        if (a != null) {
            return a;
        }
        if (b != null) {
            return b;
        }
        return c;
    }

    function defineCommonLocaleTests(locale, options) {
        test('lenient ordinal parsing', function (assert) {
            var i, ordinalStr, testMoment;
            for (i = 1; i <= 31; ++i) {
                ordinalStr = moment([2014, 0, i]).format('YYYY MM Do');
                testMoment = moment(ordinalStr, 'YYYY MM Do');
                assert.equal(testMoment.year(), 2014,
                        'lenient ordinal parsing ' + i + ' year check');
                assert.equal(testMoment.month(), 0,
                        'lenient ordinal parsing ' + i + ' month check');
                assert.equal(testMoment.date(), i,
                        'lenient ordinal parsing ' + i + ' date check');
            }
        });

        test('lenient ordinal parsing of number', function (assert) {
            var i, testMoment;
            for (i = 1; i <= 31; ++i) {
                testMoment = moment('2014 01 ' + i, 'YYYY MM Do');
                assert.equal(testMoment.year(), 2014,
                        'lenient ordinal parsing of number ' + i + ' year check');
                assert.equal(testMoment.month(), 0,
                        'lenient ordinal parsing of number ' + i + ' month check');
                assert.equal(testMoment.date(), i,
                        'lenient ordinal parsing of number ' + i + ' date check');
            }
        });

        test('strict ordinal parsing', function (assert) {
            var i, ordinalStr, testMoment;
            for (i = 1; i <= 31; ++i) {
                ordinalStr = moment([2014, 0, i]).format('YYYY MM Do');
                testMoment = moment(ordinalStr, 'YYYY MM Do', true);
                assert.ok(testMoment.isValid(), 'strict ordinal parsing ' + i);
            }
        });

        test('meridiem invariant', function (assert) {
            var h, m, t1, t2;
            for (h = 0; h < 24; ++h) {
                for (m = 0; m < 60; m += 15) {
                    t1 = moment.utc([2000, 0, 1, h, m]);
                    t2 = moment.utc(t1.format('A h:mm'), 'A h:mm');
                    assert.equal(t2.format('HH:mm'), t1.format('HH:mm'),
                            'meridiem at ' + t1.format('HH:mm'));
                }
            }
        });

        test('date format correctness', function (assert) {
            var data, tokens;
            data = moment.localeData()._longDateFormat;
            tokens = objectKeys(data);
            each(tokens, function (srchToken) {
                // Check each format string to make sure it does not contain any
                // tokens that need to be expanded.
                each(tokens, function (baseToken) {
                    // strip escaped sequences
                    var format = data[baseToken].replace(/(\[[^\]]*\])/g, '');
                    assert.equal(false, !!~format.indexOf(srchToken),
                            'contains ' + srchToken + ' in ' + baseToken);
                });
            });
        });

        test('month parsing correctness', function (assert) {
            var i, m;

            if (locale === 'tr') {
                // I can't fix it :(
                expect(0);
                return;
            }
            function tester(format) {
                var r;
                r = moment(m.format(format), format);
                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format);
                r = moment(m.format(format).toLocaleUpperCase(), format);
                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' upper');
                r = moment(m.format(format).toLocaleLowerCase(), format);
                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' lower');

                r = moment(m.format(format), format, true);
                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' strict');
                r = moment(m.format(format).toLocaleUpperCase(), format, true);
                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' upper strict');
                r = moment(m.format(format).toLocaleLowerCase(), format, true);
                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' lower strict');
            }

            for (i = 0; i < 12; ++i) {
                m = moment([2015, i, 15, 18]);
                tester('MMM');
                tester('MMM.');
                tester('MMMM');
                tester('MMMM.');
            }
        });

        test('weekday parsing correctness', function (assert) {
            var i, m;

            if (locale === 'tr' || locale === 'az') {
                // There is a lower-case letter (Ä±), that converted to upper then
                // lower changes to i
                expect(0);
                return;
            }
            function tester(format) {
                var r, baseMsg = 'weekday ' + m.weekday() + ' fmt ' + format;
                r = moment(m.format(format), format);
                assert.equal(r.weekday(), m.weekday(), baseMsg);
                r = moment(m.format(format).toLocaleUpperCase(), format);
                assert.equal(r.weekday(), m.weekday(), baseMsg + ' upper');
                r = moment(m.format(format).toLocaleLowerCase(), format);
                assert.equal(r.weekday(), m.weekday(), baseMsg + ' lower');

                r = moment(m.format(format), format, true);
                assert.equal(r.weekday(), m.weekday(), baseMsg + ' strict');
                r = moment(m.format(format).toLocaleUpperCase(), format, true);
                assert.equal(r.weekday(), m.weekday(), baseMsg + ' upper strict');
                r = moment(m.format(format).toLocaleLowerCase(), format, true);
                assert.equal(r.weekday(), m.weekday(), baseMsg + ' lower strict');
            }

            for (i = 0; i < 7; ++i) {
                m = moment.utc([2015, i, 15, 18]);
                tester('dd');
                tester('ddd');
                tester('dddd');
            }
        });
    }

    function setupDeprecationHandler(test, moment, scope) {
        test._expectedDeprecations = null;
        test._observedDeprecations = null;
        test._oldSupress = moment.suppressDeprecationWarnings;
        moment.suppressDeprecationWarnings = true;
        test.expectedDeprecations = function () {
            test._expectedDeprecations = arguments;
            test._observedDeprecations = [];
        };
        moment.deprecationHandler = function (name, msg) {
            var deprecationId = matchedDeprecation(name, msg, test._expectedDeprecations);
            if (deprecationId === -1) {
                throw new Error('Unexpected deprecation thrown name=' +
                        name + ' msg=' + msg);
            }
            test._observedDeprecations[deprecationId] = 1;
        };
    }

    function teardownDeprecationHandler(test, moment, scope) {
        moment.suppressDeprecationWarnings = test._oldSupress;

        if (test._expectedDeprecations != null) {
            var missedDeprecations = [];
            each(test._expectedDeprecations, function (deprecationPattern, id) {
                if (test._observedDeprecations[id] !== 1) {
                    missedDeprecations.push(deprecationPattern);
                }
            });
            if (missedDeprecations.length !== 0) {
                throw new Error('Expected deprecation warnings did not happen: ' +
                        missedDeprecations.join(' '));
            }
        }
    }

    function matchedDeprecation(name, msg, deprecations) {
        if (deprecations == null) {
            return -1;
        }
        for (var i = 0; i < deprecations.length; ++i) {
            if (name != null && name === deprecations[i]) {
                return i;
            }
            if (msg != null && msg.substring(0, deprecations[i].length) === deprecations[i]) {
                return i;
            }
        }
        return -1;
    }

    /*global QUnit:false*/

    var test = QUnit.test;

    var expect = QUnit.expect;

    function module (name, lifecycle) {
        QUnit.module(name, {
            setup : function () {
                moment.locale('en');
                moment.createFromInputFallback = function (config) {
                    throw new Error('input not handled by moment: ' + config._i);
                };
                setupDeprecationHandler(test, moment, 'core');
                if (lifecycle && lifecycle.setup) {
                    lifecycle.setup();
                }
            },
            teardown : function () {
                teardownDeprecationHandler(test, moment, 'core');
                if (lifecycle && lifecycle.teardown) {
                    lifecycle.teardown();
                }
            }
        });
    }

    function localeModule (name, lifecycle) {
        QUnit.module('locale:' + name, {
            setup : function () {
                moment.locale(name);
                moment.createFromInputFallback = function (config) {
                    throw new Error('input not handled by moment: ' + config._i);
                };
                setupDeprecationHandler(test, moment, 'locale');
                if (lifecycle && lifecycle.setup) {
                    lifecycle.setup();
                }
            },
            teardown : function () {
                moment.locale('en');
                teardownDeprecationHandler(test, moment, 'locale');
                if (lifecycle && lifecycle.teardown) {
                    lifecycle.teardown();
                }
            }
        });
        defineCommonLocaleTests(name, -1, -1);
    }

    module('is before');

    test('is after without units', function (assert) {
        var m = moment(new Date(2011, 3, 2, 3, 4, 5, 10)), mCopy = moment(m);
        assert.equal(m.isBefore(moment(new Date(2012, 3, 2, 3, 5, 5, 10))), true, 'year is later');
        assert.equal(m.isBefore(moment(new Date(2010, 3, 2, 3, 3, 5, 10))), false, 'year is earlier');
        assert.equal(m.isBefore(moment(new Date(2011, 4, 2, 3, 4, 5, 10))), true, 'month is later');
        assert.equal(m.isBefore(moment(new Date(2011, 2, 2, 3, 4, 5, 10))), false, 'month is earlier');
        assert.equal(m.isBefore(moment(new Date(2011, 3, 3, 3, 4, 5, 10))), true, 'day is later');
        assert.equal(m.isBefore(moment(new Date(2011, 3, 1, 3, 4, 5, 10))), false, 'day is earlier');
        assert.equal(m.isBefore(moment(new Date(2011, 3, 2, 4, 4, 5, 10))), true, 'hour is later');
        assert.equal(m.isBefore(moment(new Date(2011, 3, 2, 2, 4, 5, 10))), false, 'hour is earlier');
        assert.equal(m.isBefore(moment(new Date(2011, 3, 2, 3, 5, 5, 10))), true, 'minute is later');
        assert.equal(m.isBefore(moment(new Date(2011, 3, 2, 3, 3, 5, 10))), false, 'minute is earlier');
        assert.equal(m.isBefore(moment(new Date(2011, 3, 2, 3, 4, 6, 10))), true, 'second is later');
        assert.equal(m.isBefore(moment(new Date(2011, 3, 2, 3, 4, 4, 11))), false, 'second is earlier');
        assert.equal(m.isBefore(moment(new Date(2011, 3, 2, 3, 4, 5, 10))), false, 'millisecond match');
        assert.equal(m.isBefore(moment(new Date(2011, 3, 2, 3, 4, 5, 11))), true, 'millisecond is later');
        assert.equal(m.isBefore(moment(new Date(2011, 3, 2, 3, 4, 5, 9))), false, 'millisecond is earlier');
        assert.equal(m.isBefore(m), false, 'moments are not before themselves');
        assert.equal(+m, +mCopy, 'isBefore second should not change moment');
    });

    test('is before year', function (assert) {
        var m = moment(new Date(2011, 1, 2, 3, 4, 5, 6)), mCopy = moment(m);
        assert.equal(m.isBefore(moment(new Date(2011, 5, 6, 7, 8, 9, 10)), 'year'), false, 'year match');
        assert.equal(m.isBefore(moment(new Date(2012, 5, 6, 7, 8, 9, 10)), 'years'), true, 'plural should work');
        assert.equal(m.isBefore(moment(new Date(2013, 5, 6, 7, 8, 9, 10)), 'year'), true, 'year is later');
        assert.equal(m.isBefore(moment(new Date(2010, 5, 6, 7, 8, 9, 10)), 'year'), false, 'year is earlier');
        assert.equal(m.isBefore(moment(new Date(2011, 0, 1, 0, 0, 0, 0)), 'year'), false, 'exact start of year');
        assert.equal(m.isBefore(moment(new Date(2011, 11, 31, 23, 59, 59, 999)), 'year'), false, 'exact end of year');
        assert.equal(m.isBefore(moment(new Date(2012, 0, 1, 0, 0, 0, 0)), 'year'), true, 'start of next year');
        assert.equal(m.isBefore(moment(new Date(2010, 11, 31, 23, 59, 59, 999)), 'year'), false, 'end of previous year');
        assert.equal(m.isBefore(moment(new Date(1980, 11, 31, 23, 59, 59, 999)), 'year'), false, 'end of year far before');
        assert.equal(m.isBefore(m, 'year'), false, 'same moments are not before the same year');
        assert.equal(+m, +mCopy, 'isBefore year should not change moment');
    });

    test('is before month', function (assert) {
        var m = moment(new Date(2011, 2, 3, 4, 5, 6, 7)), mCopy = moment(m);
        assert.equal(m.isBefore(moment(new Date(2011, 2, 6, 7, 8, 9, 10)), 'month'), false, 'month match');
        assert.equal(m.isBefore(moment(new Date(2012, 2, 6, 7, 8, 9, 10)), 'months'), true, 'plural should work');
        assert.equal(m.isBefore(moment(new Date(2012, 2, 6, 7, 8, 9, 10)), 'month'), true, 'year is later');
        assert.equal(m.isBefore(moment(new Date(2010, 2, 6, 7, 8, 9, 10)), 'month'), false, 'year is earlier');
        assert.equal(m.isBefore(moment(new Date(2011, 5, 6, 7, 8, 9, 10)), 'month'), true, 'month is later');
        assert.equal(m.isBefore(moment(new Date(2011, 1, 6, 7, 8, 9, 10)), 'month'), false, 'month is earlier');
        assert.equal(m.isBefore(moment(new Date(2011, 2, 1, 0, 0, 0, 0)), 'month'), false, 'exact start of month');
        assert.equal(m.isBefore(moment(new Date(2011, 2, 31, 23, 59, 59, 999)), 'month'), false, 'exact end of month');
        assert.equal(m.isBefore(moment(new Date(2011, 3, 1, 0, 0, 0, 0)), 'month'), true, 'start of next month');
        assert.equal(m.isBefore(moment(new Date(2011, 1, 27, 23, 59, 59, 999)), 'month'), false, 'end of previous month');
        assert.equal(m.isBefore(moment(new Date(2010, 12, 31, 23, 59, 59, 999)), 'month'), false, 'later month but earlier year');
        assert.equal(m.isBefore(m, 'month'), false, 'same moments are not before the same month');
        assert.equal(+m, +mCopy, 'isBefore month should not change moment');
    });

    test('is before day', function (assert) {
        var m = moment(new Date(2011, 3, 2, 3, 4, 5, 6)), mCopy = moment(m);
        assert.equal(m.isBefore(moment(new Date(2011, 3, 2, 7, 8, 9, 10)), 'day'), false, 'day match');
        assert.equal(m.isBefore(moment(new Date(2012, 3, 2, 7, 8, 9, 10)), 'days'), true, 'plural should work');
        assert.equal(m.isBefore(moment(new Date(2012, 3, 2, 7, 8, 9, 10)), 'day'), true, 'year is later');
        assert.equal(m.isBefore(moment(new Date(2010, 3, 2, 7, 8, 9, 10)), 'day'), false, 'year is earlier');
        assert.equal(m.isBefore(moment(new Date(2011, 4, 2, 7, 8, 9, 10)), 'day'), true, 'month is later');
        assert.equal(m.isBefore(moment(new Date(2011, 2, 2, 7, 8, 9, 10)), 'day'), false, 'month is earlier');
        assert.equal(m.isBefore(moment(new Date(2011, 3, 3, 7, 8, 9, 10)), 'day'), true, 'day is later');
        assert.equal(m.isBefore(moment(new Date(2011, 3, 1, 7, 8, 9, 10)), 'day'), false, 'day is earlier');
        assert.equal(m.isBefore(moment(new Date(2011, 3, 2, 0, 0, 0, 0)), 'day'), false, 'exact start of day');
        assert.equal(m.isBefore(moment(new Date(2011, 3, 2, 23, 59, 59, 999)), 'day'), false, 'exact end of day');
        assert.equal(m.isBefore(moment(new Date(2011, 3, 3, 0, 0, 0, 0)), 'day'), true, 'start of next day');
        assert.equal(m.isBefore(moment(new Date(2011, 3, 1, 23, 59, 59, 999)), 'day'), false, 'end of previous day');
        assert.equal(m.isBefore(moment(new Date(2010, 3, 10, 0, 0, 0, 0)), 'day'), false, 'later day but earlier year');
        assert.equal(m.isBefore(m, 'day'), false, 'same moments are not before the same day');
        assert.equal(+m, +mCopy, 'isBefore day should not change moment');
    });

    test('is before hour', function (assert) {
        var m = moment(new Date(2011, 3, 2, 3, 4, 5, 6)), mCopy = moment(m);
        assert.equal(m.isBefore(moment(new Date(2011, 3, 2, 3, 8, 9, 10)), 'hour'), false, 'hour match');
        assert.equal(m.isBefore(moment(new Date(2012, 3, 2, 3, 8, 9, 10)), 'hours'), true, 'plural should work');
        assert.equal(m.isBefore(moment(new Date(2012, 3, 2, 3, 8, 9, 10)), 'hour'), true, 'year is later');
        assert.equal(m.isBefore(moment(new Date(2010, 3, 2, 3, 8, 9, 10)), 'hour'), false, 'year is earlier');
        assert.equal(m.isBefore(moment(new Date(2011, 4, 2, 3, 8, 9, 10)), 'hour'), true, 'month is later');
        assert.equal(m.isBefore(moment(new Date(2011, 1, 2, 3, 8, 9, 10)), 'hour'), false, 'month is earlier');
        assert.equal(m.isBefore(moment(new Date(2011, 3, 3, 3, 8, 9, 10)), 'hour'), true, 'day is later');
        assert.equal(m.isBefore(moment(new Date(2011, 3, 1, 3, 8, 9, 10)), 'hour'), false, 'day is earlier');
        assert.equal(m.isBefore(moment(new Date(2011, 3, 2, 4, 8, 9, 10)), 'hour'), true, 'hour is later');
        assert.equal(m.isBefore(moment(new Date(2011, 3, 2, 3, 8, 9, 10)), 'hour'), false, 'hour is earlier');
        assert.equal(m.isBefore(moment(new Date(2011, 3, 2, 3, 0, 0, 0)), 'hour'), false, 'exact start of hour');
        assert.equal(m.isBefore(moment(new Date(2011, 3, 2, 3, 59, 59, 999)), 'hour'), false, 'exact end of hour');
        assert.equal(m.isBefore(moment(new Date(2011, 3, 2, 4, 0, 0, 0)), 'hour'), true, 'start of next hour');
        assert.equal(m.isBefore(moment(new Date(2011, 3, 2, 2, 59, 59, 999)), 'hour'), false, 'end of previous hour');
        assert.equal(m.isBefore(m, 'hour'), false, 'same moments are not before the same hour');
        assert.equal(+m, +mCopy, 'isBefore hour should not change moment');
    });

    test('is before minute', function (assert) {
        var m = moment(new Date(2011, 3, 2, 3, 4, 5, 6)), mCopy = moment(m);
        assert.equal(m.isBefore(moment(new Date(2011, 3, 2, 3, 4, 9, 10)), 'minute'), false, 'minute match');
        assert.equal(m.isBefore(moment(new Date(2012, 3, 2, 3, 4, 9, 10)), 'minutes'), true, 'plural should work');
        assert.equal(m.isBefore(moment(new Date(2012, 3, 2, 3, 4, 9, 10)), 'minute'), true, 'year is later');
        assert.equal(m.isBefore(moment(new Date(2010, 3, 2, 3, 4, 9, 10)), 'minute'), false, 'year is earlier');
        assert.equal(m.isBefore(moment(new Date(2011, 4, 2, 3, 4, 9, 10)), 'minute'), true, 'month is later');
        assert.equal(m.isBefore(moment(new Date(2011, 2, 2, 3, 4, 9, 10)), 'minute'), false, 'month is earlier');
        assert.equal(m.isBefore(moment(new Date(2011, 3, 3, 3, 4, 9, 10)), 'minute'), true, 'day is later');
        assert.equal(m.isBefore(moment(new Date(2011, 3, 1, 3, 4, 9, 10)), 'minute'), false, 'day is earlier');
        assert.equal(m.isBefore(moment(new Date(2011, 3, 2, 4, 4, 9, 10)), 'minute'), true, 'hour is later');
        assert.equal(m.isBefore(moment(new Date(2011, 3, 2, 2, 4, 9, 10)), 'minute'), false, 'hour is earler');
        assert.equal(m.isBefore(moment(new Date(2011, 3, 2, 3, 5, 9, 10)), 'minute'), true, 'minute is later');
        assert.equal(m.isBefore(moment(new Date(2011, 3, 2, 3, 3, 9, 10)), 'minute'), false, 'minute is earlier');
        assert.equal(m.isBefore(moment(new Date(2011, 3, 2, 3, 4, 0, 0)), 'minute'), false, 'exact start of minute');
        assert.equal(m.isBefore(moment(new Date(2011, 3, 2, 3, 4, 59, 999)), 'minute'), false, 'exact end of minute');
        assert.equal(m.isBefore(moment(new Date(2011, 3, 2, 3, 5, 0, 0)), 'minute'), true, 'start of next minute');
        assert.equal(m.isBefore(moment(new Date(2011, 3, 2, 3, 3, 59, 999)), 'minute'), false, 'end of previous minute');
        assert.equal(m.isBefore(m, 'minute'), false, 'same moments are not before the same minute');
        assert.equal(+m, +mCopy, 'isBefore minute should not change moment');
    });

    test('is before second', function (assert) {
        var m = moment(new Date(2011, 3, 2, 3, 4, 5, 10)), mCopy = moment(m);
        assert.equal(m.isBefore(moment(new Date(2011, 3, 2, 3, 4, 5, 10)), 'second'), false, 'second match');
        assert.equal(m.isBefore(moment(new Date(2012, 3, 2, 3, 4, 5, 10)), 'seconds'), true, 'plural should work');
        assert.equal(m.isBefore(moment(new Date(2012, 3, 2, 3, 4, 5, 10)), 'second'), true, 'year is later');
        assert.equal(m.isBefore(moment(new Date(2010, 3, 2, 3, 4, 5, 10)), 'second'), false, 'year is earlier');
        assert.equal(m.isBefore(moment(new Date(2011, 4, 2, 3, 4, 5, 10)), 'second'), true, 'month is later');
        assert.equal(m.isBefore(moment(new Date(2011, 2, 2, 3, 4, 5, 10)), 'second'), false, 'month is earlier');
        assert.equal(m.isBefore(moment(new Date(2011, 3, 3, 3, 4, 5, 10)), 'second'), true, 'day is later');
        assert.equal(m.isBefore(moment(new Date(2011, 3, 1, 1, 4, 5, 10)), 'second'), false, 'day is earlier');
        assert.equal(m.isBefore(moment(new Date(2011, 3, 2, 4, 4, 5, 10)), 'second'), true, 'hour is later');
        assert.equal(m.isBefore(moment(new Date(2011, 3, 1, 4, 1, 5, 10)), 'second'), false, 'hour is earlier');
        assert.equal(m.isBefore(moment(new Date(2011, 3, 2, 3, 5, 5, 10)), 'second'), true, 'minute is later');
        assert.equal(m.isBefore(moment(new Date(2011, 3, 2, 3, 3, 5, 10)), 'second'), false, 'minute is earlier');
        assert.equal(m.isBefore(moment(new Date(2011, 3, 2, 3, 4, 6, 10)), 'second'), true, 'second is later');
        assert.equal(m.isBefore(moment(new Date(2011, 3, 2, 3, 4, 4, 5)), 'second'), false, 'second is earlier');
        assert.equal(m.isBefore(moment(new Date(2011, 3, 2, 3, 4, 5, 0)), 'second'), false, 'exact start of second');
        assert.equal(m.isBefore(moment(new Date(2011, 3, 2, 3, 4, 5, 999)), 'second'), false, 'exact end of second');
        assert.equal(m.isBefore(moment(new Date(2011, 3, 2, 3, 4, 6, 0)), 'second'), true, 'start of next second');
        assert.equal(m.isBefore(moment(new Date(2011, 3, 2, 3, 4, 4, 999)), 'second'), false, 'end of previous second');
        assert.equal(m.isBefore(m, 'second'), false, 'same moments are not before the same second');
        assert.equal(+m, +mCopy, 'isBefore second should not change moment');
    });

    test('is before millisecond', function (assert) {
        var m = moment(new Date(2011, 3, 2, 3, 4, 5, 10)), mCopy = moment(m);
        assert.equal(m.isBefore(moment(new Date(2011, 3, 2, 3, 4, 5, 10)), 'millisecond'), false, 'millisecond match');
        assert.equal(m.isBefore(moment(new Date(2010, 3, 2, 3, 4, 5, 10)), 'milliseconds'), false, 'plural should work');
        assert.equal(m.isBefore(moment(new Date(2012, 3, 2, 3, 4, 5, 10)), 'millisecond'), true, 'year is later');
        assert.equal(m.isBefore(moment(new Date(2010, 3, 2, 3, 4, 5, 10)), 'millisecond'), false, 'year is earlier');
        assert.equal(m.isBefore(moment(new Date(2011, 4, 2, 3, 4, 5, 10)), 'millisecond'), true, 'month is later');
        assert.equal(m.isBefore(moment(new Date(2011, 2, 2, 3, 4, 5, 10)), 'millisecond'), false, 'month is earlier');
        assert.equal(m.isBefore(moment(new Date(2011, 3, 3, 3, 4, 5, 10)), 'millisecond'), true, 'day is later');
        assert.equal(m.isBefore(moment(new Date(2011, 3, 1, 1, 4, 5, 10)), 'millisecond'), false, 'day is earlier');
        assert.equal(m.isBefore(moment(new Date(2011, 3, 2, 4, 4, 5, 10)), 'millisecond'), true, 'hour is later');
        assert.equal(m.isBefore(moment(new Date(2011, 3, 1, 4, 1, 5, 10)), 'millisecond'), false, 'hour is earlier');
        assert.equal(m.isBefore(moment(new Date(2011, 3, 2, 3, 5, 5, 10)), 'millisecond'), true, 'minute is later');
        assert.equal(m.isBefore(moment(new Date(2011, 3, 2, 3, 3, 5, 10)), 'millisecond'), false, 'minute is earlier');
        assert.equal(m.isBefore(moment(new Date(2011, 3, 2, 3, 4, 6, 10)), 'millisecond'), true, 'second is later');
        assert.equal(m.isBefore(moment(new Date(2011, 3, 2, 3, 4, 4, 5)), 'millisecond'), false, 'second is earlier');
        assert.equal(m.isBefore(moment(new Date(2011, 3, 2, 3, 4, 6, 11)), 'millisecond'), true, 'millisecond is later');
        assert.equal(m.isBefore(moment(new Date(2011, 3, 2, 3, 4, 4, 9)), 'millisecond'), false, 'millisecond is earlier');
        assert.equal(m.isBefore(m, 'millisecond'), false, 'same moments are not before the same millisecond');
        assert.equal(+m, +mCopy, 'isBefore millisecond should not change moment');
    });

    test('is before invalid', function (assert) {
        var m = moment(), invalid = moment.invalid();
        assert.equal(m.isBefore(invalid), false, 'valid moment is not before invalid moment');
        assert.equal(invalid.isBefore(m), false, 'invalid moment is not before valid moment');
        assert.equal(m.isBefore(invalid, 'year'), false, 'invalid moment year');
        assert.equal(m.isBefore(invalid, 'month'), false, 'invalid moment month');
        assert.equal(m.isBefore(invalid, 'day'), false, 'invalid moment day');
        assert.equal(m.isBefore(invalid, 'hour'), false, 'invalid moment hour');
        assert.equal(m.isBefore(invalid, 'minute'), false, 'invalid moment minute');
        assert.equal(m.isBefore(invalid, 'second'), false, 'invalid moment second');
        assert.equal(m.isBefore(invalid, 'milliseconds'), false, 'invalid moment milliseconds');
    });

}));

;(function (global, factory) {
   typeof exports === 'object' && typeof module !== 'undefined'
       && typeof require === 'function' ? factory(require('../../moment')) :
   typeof define === 'function' && define.amd ? define(['../../moment'], factory) :
   factory(global.moment)
}(this, function (moment) { 'use strict';

    function each(array, callback) {
        var i;
        for (i = 0; i < array.length; i++) {
            callback(array[i], i, array);
        }
    }

    function objectKeys(obj) {
        if (Object.keys) {
            return Object.keys(obj);
        } else {
            // IE8
            var res = [], i;
            for (i in obj) {
                if (obj.hasOwnProperty(i)) {
                    res.push(i);
                }
            }
            return res;
        }
    }

    // Pick the first defined of two or three arguments.
    function defaults(a, b, c) {
        if (a != null) {
            return a;
        }
        if (b != null) {
            return b;
        }
        return c;
    }

    function defineCommonLocaleTests(locale, options) {
        test('lenient ordinal parsing', function (assert) {
            var i, ordinalStr, testMoment;
            for (i = 1; i <= 31; ++i) {
                ordinalStr = moment([2014, 0, i]).format('YYYY MM Do');
                testMoment = moment(ordinalStr, 'YYYY MM Do');
                assert.equal(testMoment.year(), 2014,
                        'lenient ordinal parsing ' + i + ' year check');
                assert.equal(testMoment.month(), 0,
                        'lenient ordinal parsing ' + i + ' month check');
                assert.equal(testMoment.date(), i,
                        'lenient ordinal parsing ' + i + ' date check');
            }
        });

        test('lenient ordinal parsing of number', function (assert) {
            var i, testMoment;
            for (i = 1; i <= 31; ++i) {
                testMoment = moment('2014 01 ' + i, 'YYYY MM Do');
                assert.equal(testMoment.year(), 2014,
                        'lenient ordinal parsing of number ' + i + ' year check');
                assert.equal(testMoment.month(), 0,
                        'lenient ordinal parsing of number ' + i + ' month check');
                assert.equal(testMoment.date(), i,
                        'lenient ordinal parsing of number ' + i + ' date check');
            }
        });

        test('strict ordinal parsing', function (assert) {
            var i, ordinalStr, testMoment;
            for (i = 1; i <= 31; ++i) {
                ordinalStr = moment([2014, 0, i]).format('YYYY MM Do');
                testMoment = moment(ordinalStr, 'YYYY MM Do', true);
                assert.ok(testMoment.isValid(), 'strict ordinal parsing ' + i);
            }
        });

        test('meridiem invariant', function (assert) {
            var h, m, t1, t2;
            for (h = 0; h < 24; ++h) {
                for (m = 0; m < 60; m += 15) {
                    t1 = moment.utc([2000, 0, 1, h, m]);
                    t2 = moment.utc(t1.format('A h:mm'), 'A h:mm');
                    assert.equal(t2.format('HH:mm'), t1.format('HH:mm'),
                            'meridiem at ' + t1.format('HH:mm'));
                }
            }
        });

        test('date format correctness', function (assert) {
            var data, tokens;
            data = moment.localeData()._longDateFormat;
            tokens = objectKeys(data);
            each(tokens, function (srchToken) {
                // Check each format string to make sure it does not contain any
                // tokens that need to be expanded.
                each(tokens, function (baseToken) {
                    // strip escaped sequences
                    var format = data[baseToken].replace(/(\[[^\]]*\])/g, '');
                    assert.equal(false, !!~format.indexOf(srchToken),
                            'contains ' + srchToken + ' in ' + baseToken);
                });
            });
        });

        test('month parsing correctness', function (assert) {
            var i, m;

            if (locale === 'tr') {
                // I can't fix it :(
                expect(0);
                return;
            }
            function tester(format) {
                var r;
                r = moment(m.format(format), format);
                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format);
                r = moment(m.format(format).toLocaleUpperCase(), format);
                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' upper');
                r = moment(m.format(format).toLocaleLowerCase(), format);
                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' lower');

                r = moment(m.format(format), format, true);
                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' strict');
                r = moment(m.format(format).toLocaleUpperCase(), format, true);
                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' upper strict');
                r = moment(m.format(format).toLocaleLowerCase(), format, true);
                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' lower strict');
            }

            for (i = 0; i < 12; ++i) {
                m = moment([2015, i, 15, 18]);
                tester('MMM');
                tester('MMM.');
                tester('MMMM');
                tester('MMMM.');
            }
        });

        test('weekday parsing correctness', function (assert) {
            var i, m;

            if (locale === 'tr' || locale === 'az') {
                // There is a lower-case letter (Ä±), that converted to upper then
                // lower changes to i
                expect(0);
                return;
            }
            function tester(format) {
                var r, baseMsg = 'weekday ' + m.weekday() + ' fmt ' + format;
                r = moment(m.format(format), format);
                assert.equal(r.weekday(), m.weekday(), baseMsg);
                r = moment(m.format(format).toLocaleUpperCase(), format);
                assert.equal(r.weekday(), m.weekday(), baseMsg + ' upper');
                r = moment(m.format(format).toLocaleLowerCase(), format);
                assert.equal(r.weekday(), m.weekday(), baseMsg + ' lower');

                r = moment(m.format(format), format, true);
                assert.equal(r.weekday(), m.weekday(), baseMsg + ' strict');
                r = moment(m.format(format).toLocaleUpperCase(), format, true);
                assert.equal(r.weekday(), m.weekday(), baseMsg + ' upper strict');
                r = moment(m.format(format).toLocaleLowerCase(), format, true);
                assert.equal(r.weekday(), m.weekday(), baseMsg + ' lower strict');
            }

            for (i = 0; i < 7; ++i) {
                m = moment.utc([2015, i, 15, 18]);
                tester('dd');
                tester('ddd');
                tester('dddd');
            }
        });
    }

    function setupDeprecationHandler(test, moment, scope) {
        test._expectedDeprecations = null;
        test._observedDeprecations = null;
        test._oldSupress = moment.suppressDeprecationWarnings;
        moment.suppressDeprecationWarnings = true;
        test.expectedDeprecations = function () {
            test._expectedDeprecations = arguments;
            test._observedDeprecations = [];
        };
        moment.deprecationHandler = function (name, msg) {
            var deprecationId = matchedDeprecation(name, msg, test._expectedDeprecations);
            if (deprecationId === -1) {
                throw new Error('Unexpected deprecation thrown name=' +
                        name + ' msg=' + msg);
            }
            test._observedDeprecations[deprecationId] = 1;
        };
    }

    function teardownDeprecationHandler(test, moment, scope) {
        moment.suppressDeprecationWarnings = test._oldSupress;

        if (test._expectedDeprecations != null) {
            var missedDeprecations = [];
            each(test._expectedDeprecations, function (deprecationPattern, id) {
                if (test._observedDeprecations[id] !== 1) {
                    missedDeprecations.push(deprecationPattern);
                }
            });
            if (missedDeprecations.length !== 0) {
                throw new Error('Expected deprecation warnings did not happen: ' +
                        missedDeprecations.join(' '));
            }
        }
    }

    function matchedDeprecation(name, msg, deprecations) {
        if (deprecations == null) {
            return -1;
        }
        for (var i = 0; i < deprecations.length; ++i) {
            if (name != null && name === deprecations[i]) {
                return i;
            }
            if (msg != null && msg.substring(0, deprecations[i].length) === deprecations[i]) {
                return i;
            }
        }
        return -1;
    }

    /*global QUnit:false*/

    var test = QUnit.test;

    var expect = QUnit.expect;

    function module (name, lifecycle) {
        QUnit.module(name, {
            setup : function () {
                moment.locale('en');
                moment.createFromInputFallback = function (config) {
                    throw new Error('input not handled by moment: ' + config._i);
                };
                setupDeprecationHandler(test, moment, 'core');
                if (lifecycle && lifecycle.setup) {
                    lifecycle.setup();
                }
            },
            teardown : function () {
                teardownDeprecationHandler(test, moment, 'core');
                if (lifecycle && lifecycle.teardown) {
                    lifecycle.teardown();
                }
            }
        });
    }

    function localeModule (name, lifecycle) {
        QUnit.module('locale:' + name, {
            setup : function () {
                moment.locale(name);
                moment.createFromInputFallback = function (config) {
                    throw new Error('input not handled by moment: ' + config._i);
                };
                setupDeprecationHandler(test, moment, 'locale');
                if (lifecycle && lifecycle.setup) {
                    lifecycle.setup();
                }
            },
            teardown : function () {
                moment.locale('en');
                teardownDeprecationHandler(test, moment, 'locale');
                if (lifecycle && lifecycle.teardown) {
                    lifecycle.teardown();
                }
            }
        });
        defineCommonLocaleTests(name, -1, -1);
    }

    module('is between');

    test('is between without units', function (assert) {
        var m = moment(new Date(2011, 3, 2, 3, 4, 5, 10)), mCopy = moment(m);
        assert.equal(m.isBetween(
                    moment(new Date(2009, 3, 2, 3, 4, 5, 10)),
                    moment(new Date(2011, 3, 2, 3, 4, 5, 10))), false, 'year is later');
        assert.equal(m.isBetween(
                    moment(new Date(2011, 3, 2, 3, 4, 5, 10)),
                    moment(new Date(2013, 3, 2, 3, 4, 5, 10))), false, 'year is earlier');
        assert.equal(m.isBetween(
                    moment(new Date(2010, 3, 2, 3, 4, 5, 10)),
                    moment(new Date(2012, 3, 2, 3, 4, 5, 10))), true, 'year is between');
        assert.equal(m.isBetween(
                    moment(new Date(2011, 1, 2, 3, 4, 5, 10)),
                    moment(new Date(2011, 3, 2, 3, 4, 5, 10))), false, 'month is later');
        assert.equal(m.isBetween(
                    moment(new Date(2011, 3, 2, 3, 4, 5, 10)),
                    moment(new Date(2011, 5, 2, 3, 4, 5, 10))), false, 'month is earlier');
        assert.equal(m.isBetween(
                    moment(new Date(2011, 2, 2, 3, 4, 5, 10)),
                    moment(new Date(2011, 4, 2, 3, 4, 5, 10))), true, 'month is between');
        assert.equal(m.isBetween(
                    moment(new Date(2011, 3, 1, 3, 4, 5, 10)),
                    moment(new Date(2011, 3, 2, 3, 4, 5, 10))), false, 'day is later');
        assert.equal(m.isBetween(
                    moment(new Date(2011, 3, 2, 3, 4, 5, 10)),
                    moment(new Date(2011, 3, 4, 3, 4, 5, 10))), false, 'day is earlier');
        assert.equal(m.isBetween(
                    moment(new Date(2011, 3, 1, 3, 4, 5, 10)),
                    moment(new Date(2011, 3, 3, 3, 4, 5, 10))), true, 'day is between');
        assert.equal(m.isBetween(
                    moment(new Date(2011, 3, 2, 1, 4, 5, 10)),
                    moment(new Date(2011, 3, 2, 3, 4, 5, 10))), false, 'hour is later');
        assert.equal(m.isBetween(
                    moment(new Date(2011, 3, 2, 3, 4, 5, 10)),
                    moment(new Date(2011, 3, 2, 5, 4, 5, 10))), false, 'hour is earlier');
        assert.equal(m.isBetween(
                    moment(new Date(2011, 3, 2, 2, 4, 5, 10)),
                    moment(new Date(2011, 3, 2, 4, 4, 5, 10))), true, 'hour is between');
        assert.equal(m.isBetween(
                    moment(new Date(2011, 3, 2, 3, 4, 5, 10)),
                    moment(new Date(2011, 3, 2, 3, 6, 5, 10))), false, 'minute is later');
        assert.equal(m.isBetween(
                    moment(new Date(2011, 3, 2, 3, 2, 5, 10)),
                    moment(new Date(2011, 3, 2, 3, 4, 5, 10))), false, 'minute is earlier');
        assert.equal(m.isBetween(
                    moment(new Date(2011, 3, 2, 3, 3, 5, 10)),
                    moment(new Date(2011, 3, 2, 3, 5, 5, 10))), true, 'minute is between');
        assert.equal(m.isBetween(
                    moment(new Date(2011, 3, 2, 3, 4, 5, 10)),
                    moment(new Date(2011, 3, 2, 3, 4, 7, 10))), false, 'second is later');
        assert.equal(m.isBetween(
                    moment(new Date(2011, 3, 2, 3, 4, 3, 10)),
                    moment(new Date(2011, 3, 2, 3, 4, 5, 10))), false, 'second is earlier');
        assert.equal(m.isBetween(
                    moment(new Date(2011, 3, 2, 3, 4, 4, 10)),
                    moment(new Date(2011, 3, 2, 3, 4, 6, 10))), true, 'second is between');
        assert.equal(m.isBetween(
                    moment(new Date(2011, 3, 2, 3, 4, 5, 10)),
                    moment(new Date(2011, 3, 2, 3, 4, 5, 12))), false, 'millisecond is later');
        assert.equal(m.isBetween(
                    moment(new Date(2011, 3, 2, 3, 4, 5, 8)),
                    moment(new Date(2011, 3, 2, 3, 4, 5, 10))), false, 'millisecond is earlier');
        assert.equal(m.isBetween(
                    moment(new Date(2011, 3, 2, 3, 4, 5, 9)),
                    moment(new Date(2011, 3, 2, 3, 4, 5, 11))), true, 'millisecond is between');
        assert.equal(m.isBetween(m, m), false, 'moments are not between themselves');
        assert.equal(+m, +mCopy, 'isBetween second should not change moment');
    });

    test('is between without units inclusivity', function (assert) {
        var m = moment(new Date(2011, 3, 2, 3, 4, 5, 10)), mCopy = moment(m);
        assert.equal(m.isBetween(
            moment(new Date(2011, 3, 2, 3, 4, 5, 10)),
            moment(new Date(2012, 3, 2, 3, 4, 5, 10)), null, '()'), false, 'start and end are excluded, start is equal to moment');
        assert.equal(m.isBetween(
            moment(new Date(2010, 3, 2, 3, 4, 5, 10)),
            moment(new Date(2011, 3, 2, 3, 4, 5, 10)), null, '()'), false, 'start and end are excluded, end is equal to moment');
        assert.equal(m.isBetween(
            moment(new Date(2010, 3, 2, 3, 4, 5, 10)),
            moment(new Date(2012, 3, 2, 3, 4, 5, 10)), null, '()'), true, 'start and end are excluded, is between');
        assert.equal(m.isBetween(
            moment(new Date(2009, 3, 2, 3, 4, 5, 10)),
            moment(new Date(2010, 3, 2, 3, 4, 5, 10)), null, '()'), false, 'start and end are excluded, is not between');
        assert.equal(m.isBetween(
            moment(new Date(2011, 3, 2, 3, 4, 5, 10)),
            moment(new Date(2011, 3, 2, 3, 4, 5, 10)), null, '()'), false, 'start and end are excluded, should fail on same start/end date.');

        assert.equal(m.isBetween(
            moment(new Date(2011, 3, 2, 3, 4, 5, 10)),
            moment(new Date(2012, 3, 2, 3, 4, 5, 10)), null, '(]'), false, 'start is excluded and end is included should fail on same start date');
        assert.equal(m.isBetween(
            moment(new Date(2010, 3, 2, 3, 4, 5, 10)),
            moment(new Date(2011, 3, 2, 3, 4, 5, 10)), null, '(]'), true, 'start is excluded and end is included should succeed on end date');
        assert.equal(m.isBetween(
            moment(new Date(2010, 3, 2, 3, 4, 5, 10)),
            moment(new Date(2012, 3, 2, 3, 4, 5, 10)), null, '(]'), true, 'start is excluded and end is included, is between');
        assert.equal(m.isBetween(
            moment(new Date(2009, 3, 2, 3, 4, 5, 10)),
            moment(new Date(2010, 3, 2, 3, 4, 5, 10)), null, '(]'), false, 'start is excluded and end is included, is not between');
        assert.equal(m.isBetween(
            moment(new Date(2011, 3, 2, 3, 4, 5, 10)),
            moment(new Date(2011, 3, 2, 3, 4, 5, 10)), null, '(]'), false, 'start is excluded and end is included, should fail on same start/end date.');

        assert.equal(m.isBetween(
            moment(new Date(2011, 3, 2, 3, 4, 5, 10)),
            moment(new Date(2012, 3, 2, 3, 4, 5, 10)), null, '[)'), true, 'start is included and end is excluded should succeed on same start date');
        assert.equal(m.isBetween(
            moment(new Date(2010, 3, 2, 3, 4, 5, 10)),
            moment(new Date(2011, 3, 2, 3, 4, 5, 10)), null, '[)'), false, 'start is included and end is excluded should fail on same end date');
        assert.equal(m.isBetween(
            moment(new Date(2010, 3, 2, 3, 4, 5, 10)),
            moment(new Date(2012, 3, 2, 3, 4, 5, 10)), null, '[)'), true, 'start is included and end is excluded, is between');
        assert.equal(m.isBetween(
            moment(new Date(2009, 3, 2, 3, 4, 5, 10)),
            moment(new Date(2010, 3, 2, 3, 4, 5, 10)), null, '[)'), false, 'start is included and end is excluded, is not between');
        assert.equal(m.isBetween(
            moment(new Date(2011, 3, 2, 3, 4, 5, 10)),
            moment(new Date(2011, 3, 2, 3, 4, 5, 10)), null, '[)'), false, 'start is included and end is excluded, should fail on same end and start date');

        assert.equal(m.isBetween(
            moment(new Date(2011, 3, 2, 3, 4, 5, 10)),
            moment(new Date(2012, 3, 2, 3, 4, 5, 10)), null, '[]'), true, 'start and end inclusive should succeed on same start date');
        assert.equal(m.isBetween(
            moment(new Date(2010, 3, 2, 3, 4, 5, 10)),
            moment(new Date(2011, 3, 2, 3, 4, 5, 10)), null, '[]'), true, 'start and end inclusive should succeed on same end date');
        assert.equal(m.isBetween(
            moment(new Date(2010, 3, 2, 3, 4, 5, 10)),
            moment(new Date(2012, 3, 2, 3, 4, 5, 10)), null, '[]'), true, 'start and end inclusive, is between');
        assert.equal(m.isBetween(
            moment(new Date(2009, 3, 2, 3, 4, 5, 10)),
            moment(new Date(2010, 3, 2, 3, 4, 5, 10)), null, '[]'), false, 'start and end inclusive, is not between');
        assert.equal(m.isBetween(
            moment(new Date(2011, 3, 2, 3, 4, 5, 10)),
            moment(new Date(2011, 3, 2, 3, 4, 5, 10)), null, '[]'), true, 'start and end inclusive, should handle same end and start date');
    });

    test('is between milliseconds inclusivity', function (assert) {
        var m = moment(new Date(2011, 3, 2, 3, 4, 5, 10)), mCopy = moment(m);
        assert.equal(m.isBetween(
            moment(new Date(2010, 3, 2, 3, 4, 5, 10)),
            moment(new Date(2012, 3, 2, 3, 4, 5, 10)), 'milliseconds'), true, 'options, no inclusive');
        assert.equal(m.isBetween(
            moment(new Date(2011, 3, 2, 3, 4, 5, 10)),
            moment(new Date(2012, 3, 2, 3, 4, 5, 10)), 'milliseconds', '()'), false, 'start and end are excluded, start is equal to moment');
        assert.equal(m.isBetween(
            moment(new Date(2010, 3, 2, 3, 4, 5, 10)),
            moment(new Date(2011, 3, 2, 3, 4, 5, 10)), 'milliseconds', '()'), false, 'start and end are excluded, end is equal to moment');
        assert.equal(m.isBetween(
            moment(new Date(2010, 3, 2, 3, 4, 5, 10)),
            moment(new Date(2012, 3, 2, 3, 4, 5, 10)), 'milliseconds', '()'), true, 'start and end are excluded, is between');
        assert.equal(m.isBetween(
            moment(new Date(2009, 3, 2, 3, 4, 5, 10)),
            moment(new Date(2010, 3, 2, 3, 4, 5, 10)), 'milliseconds', '()'), false, 'start and end are excluded, is not between');
        assert.equal(m.isBetween(
            moment(new Date(2011, 3, 2, 3, 4, 5, 10)),
            moment(new Date(2011, 3, 2, 3, 4, 5, 10)), 'milliseconds', '()'), false, 'start and end are excluded, should fail on same start/end date.');

        assert.equal(m.isBetween(
            moment(new Date(2011, 3, 2, 3, 4, 5, 10)),
            moment(new Date(2012, 3, 2, 3, 4, 5, 10)), 'milliseconds', '(]'), false, 'start is excluded and end is included should fail on same start date');
        assert.equal(m.isBetween(
            moment(new Date(2010, 3, 2, 3, 4, 5, 10)),
            moment(new Date(2011, 3, 2, 3, 4, 5, 10)), 'milliseconds', '(]'), true, 'start is excluded and end is included should succeed on end date');
        assert.equal(m.isBetween(
            moment(new Date(2010, 3, 2, 3, 4, 5, 10)),
            moment(new Date(2012, 3, 2, 3, 4, 5, 10)), 'milliseconds', '(]'), true, 'start is excluded and end is included, is between');
        assert.equal(m.isBetween(
            moment(new Date(2009, 3, 2, 3, 4, 5, 10)),
            moment(new Date(2010, 3, 2, 3, 4, 5, 10)), 'milliseconds', '(]'), false, 'start is excluded and end is included, is not between');
        assert.equal(m.isBetween(
            moment(new Date(2011, 3, 2, 3, 4, 5, 10)),
            moment(new Date(2011, 3, 2, 3, 4, 5, 10)), 'milliseconds', '(]'), false, 'start is excluded and end is included, should fail on same start/end date.');

        assert.equal(m.isBetween(
            moment(new Date(2011, 3, 2, 3, 4, 5, 10)),
            moment(new Date(2012, 3, 2, 3, 4, 5, 10)), 'milliseconds', '[)'), true, 'start is included and end is excluded should succeed on same start date');
        assert.equal(m.isBetween(
            moment(new Date(2010, 3, 2, 3, 4, 5, 10)),
            moment(new Date(2011, 3, 2, 3, 4, 5, 10)), 'milliseconds', '[)'), false, 'start is included and end is excluded should fail on same end date');
        assert.equal(m.isBetween(
            moment(new Date(2010, 3, 2, 3, 4, 5, 10)),
            moment(new Date(2012, 3, 2, 3, 4, 5, 10)), 'milliseconds', '[)'), true, 'start is included and end is excluded, is between');
        assert.equal(m.isBetween(
            moment(new Date(2009, 3, 2, 3, 4, 5, 10)),
            moment(new Date(2010, 3, 2, 3, 4, 5, 10)), 'milliseconds', '[)'), false, 'start is included and end is excluded, is not between');
        assert.equal(m.isBetween(
            moment(new Date(2011, 3, 2, 3, 4, 5, 10)),
            moment(new Date(2011, 3, 2, 3, 4, 5, 10)), 'milliseconds', '[)'), false, 'start is included and end is excluded, should fail on same end and start date');

        assert.equal(m.isBetween(
            moment(new Date(2011, 3, 2, 3, 4, 5, 10)),
            moment(new Date(2012, 3, 2, 3, 4, 5, 10)), 'milliseconds', '[]'), true, 'start and end inclusive should succeed on same start date');
        assert.equal(m.isBetween(
            moment(new Date(2010, 3, 2, 3, 4, 5, 10)),
            moment(new Date(2011, 3, 2, 3, 4, 5, 10)), 'milliseconds', '[]'), true, 'start and end inclusive should succeed on same end date');
        assert.equal(m.isBetween(
            moment(new Date(2010, 3, 2, 3, 4, 5, 10)),
            moment(new Date(2012, 3, 2, 3, 4, 5, 10)), 'milliseconds', '[]'), true, 'start and end inclusive, is between');
        assert.equal(m.isBetween(
            moment(new Date(2009, 3, 2, 3, 4, 5, 10)),
            moment(new Date(2010, 3, 2, 3, 4, 5, 10)), 'milliseconds', '[]'), false, 'start and end inclusive, is not between');
        assert.equal(m.isBetween(
            moment(new Date(2011, 3, 2, 3, 4, 5, 10)),
            moment(new Date(2011, 3, 2, 3, 4, 5, 10)), 'milliseconds', '[]'), true, 'start and end inclusive, should handle same end and start date');
    });

    test('is between year', function (assert) {
        var m = moment(new Date(2011, 1, 2, 3, 4, 5, 6)), mCopy = moment(m);
        assert.equal(m.isBetween(
                    moment(new Date(2011, 5, 6, 7, 8, 9, 10)),
                    moment(new Date(2011, 5, 6, 7, 8, 9, 10)), 'year'), false, 'year match');
        assert.equal(m.isBetween(
                    moment(new Date(2010, 5, 6, 7, 8, 9, 10)),
                    moment(new Date(2012, 5, 6, 7, 8, 9, 10)), 'years'), true, 'plural should work');
        assert.equal(m.isBetween(
                    moment(new Date(2010, 5, 6, 7, 8, 9, 10)),
                    moment(new Date(2012, 5, 6, 7, 8, 9, 10)), 'year'), true, 'year is between');
        assert.equal(m.isBetween(
                    moment(new Date(2011, 5, 6, 7, 8, 9, 10)),
                    moment(new Date(2013, 5, 6, 7, 8, 9, 10)), 'year'), false, 'year is earlier');
        assert.equal(m.isBetween(
                    moment(new Date(2010, 5, 6, 7, 8, 9, 10)),
                    moment(new Date(2011, 5, 6, 7, 8, 9, 10)), 'year'), false, 'year is later');
        assert.equal(m.isBetween(m, 'year'), false, 'same moments are not between the same year');
        assert.equal(+m, +mCopy, 'isBetween year should not change moment');
    });

    test('is between month', function (assert) {
        var m = moment(new Date(2011, 1, 2, 3, 4, 5, 6)), mCopy = moment(m);
        assert.equal(m.isBetween(
                    moment(new Date(2011, 1, 6, 7, 8, 9, 10)),
                    moment(new Date(2011, 1, 6, 7, 8, 9, 10)), 'month'), false, 'month match');
        assert.equal(m.isBetween(
                    moment(new Date(2011, 0, 6, 7, 8, 9, 10)),
                    moment(new Date(2011, 2, 6, 7, 8, 9, 10)), 'months'), true, 'plural should work');
        assert.equal(m.isBetween(
                    moment(new Date(2011, 0, 31, 23, 59, 59, 999)),
                    moment(new Date(2011, 2, 1, 0, 0, 0, 0)), 'month'), true, 'month is between');
        assert.equal(m.isBetween(
                    moment(new Date(2011, 1, 6, 7, 8, 9, 10)),
                    moment(new Date(2011, 2, 6, 7, 8, 9, 10)), 'month'), false, 'month is earlier');
        assert.equal(m.isBetween(
                    moment(new Date(2011, 11, 6, 7, 8, 9, 10)),
                    moment(new Date(2011, 1, 6, 7, 8, 9, 10)), 'month'), false, 'month is later');
        assert.equal(m.isBetween(m, 'month'), false, 'same moments are not between the same month');
        assert.equal(+m, +mCopy, 'isBetween month should not change moment');
    });

    test('is between day', function (assert) {
        var m = moment(new Date(2011, 1, 2, 3, 4, 5, 6)), mCopy = moment(m);
        assert.equal(m.isBetween(
                    moment(new Date(2011, 1, 2, 7, 8, 9, 10)),
                    moment(new Date(2011, 1, 2, 7, 8, 9, 10)), 'day'), false, 'day match');
        assert.equal(m.isBetween(
                    moment(new Date(2011, 1, 1, 7, 8, 9, 10)),
                    moment(new Date(2011, 1, 3, 7, 8, 9, 10)), 'days'), true, 'plural should work');
        assert.equal(m.isBetween(
                    moment(new Date(2011, 1, 1, 7, 8, 9, 10)),
                    moment(new Date(2011, 1, 3, 7, 8, 9, 10)), 'day'), true, 'day is between');
        assert.equal(m.isBetween(
                    moment(new Date(2011, 1, 2, 7, 8, 9, 10)),
                    moment(new Date(2011, 1, 4, 7, 8, 9, 10)), 'day'), false, 'day is earlier');
        assert.equal(m.isBetween(
                    moment(new Date(2011, 1, 1, 7, 8, 9, 10)),
                    moment(new Date(2011, 1, 2, 7, 8, 9, 10)), 'day'), false, 'day is later');
        assert.equal(m.isBetween(m, 'day'), false, 'same moments are not between the same day');
        assert.equal(+m, +mCopy, 'isBetween day should not change moment');
    });

    test('is between hour', function (assert) {
        var m = moment(new Date(2011, 1, 2, 3, 4, 5, 6)), mCopy = moment(m);
        assert.equal(m.isBetween(
                    moment(new Date(2011, 1, 2, 3, 5, 9, 10)),
                    moment(new Date(2011, 1, 2, 3, 9, 9, 10)), 'hour'), false, 'hour match');
        assert.equal(m.isBetween(
                    moment(new Date(2011, 1, 2, 1, 59, 59, 999)),
                    moment(new Date(2011, 1, 2, 4, 0, 0, 0)), 'hours'), true, 'plural should work');
        assert.equal(m.isBetween(
                    moment(new Date(2011, 1, 2, 2, 59, 59, 999)),
                    moment(new Date(2011, 1, 2, 4, 0, 0, 0)), 'hour'), true, 'hour is between');
        assert.equal(m.isBetween(
                    moment(new Date(2011, 1, 2, 7, 8, 9, 10)),
                    moment(new Date(2011, 1, 2, 7, 8, 9, 10)), 'hour'), false, 'hour is earlier');
        assert.equal(m.isBetween(
                    moment(new Date(2011, 1, 2, 7, 8, 9, 10)),
                    moment(new Date(2011, 1, 2, 7, 8, 9, 10)), 'hour'), false, 'hour is later');
        assert.equal(m.isBetween(m, 'hour'), false, 'same moments are not between the same hour');
        assert.equal(+m, +mCopy, 'isBetween hour should not change moment');
    });

    test('is between minute', function (assert) {
        var m = moment(new Date(2011, 1, 2, 3, 4, 5, 6)), mCopy = moment(m);
        assert.equal(m.isBetween(
                    moment(new Date(2011, 1, 2, 3, 4, 9, 10)),
                    moment(new Date(2011, 1, 2, 3, 4, 9, 10)), 'minute'), false, 'minute match');
        assert.equal(m.isBetween(
                    moment(new Date(2011, 1, 2, 3, 3, 9, 10)),
                    moment(new Date(2011, 1, 2, 3, 5, 9, 10)), 'minutes'), true, 'plural should work');
        assert.equal(m.isBetween(
                    moment(new Date(2011, 1, 2, 3, 3, 59, 999)),
                    moment(new Date(2011, 1, 2, 3, 5, 0, 0)), 'minute'), true, 'minute is between');
        assert.equal(m.isBetween(
                    moment(new Date(2011, 1, 2, 3, 5, 0, 0)),
                    moment(new Date(2011, 1, 2, 3, 8, 9, 10)), 'minute'), false, 'minute is earlier');
        assert.equal(m.isBetween(
                    moment(new Date(2011, 1, 2, 3, 2, 9, 10)),
                    moment(new Date(2011, 1, 2, 3, 3, 59, 999)), 'minute'), false, 'minute is later');
        assert.equal(m.isBetween(m, 'minute'), false, 'same moments are not between the same minute');
        assert.equal(+m, +mCopy, 'isBetween minute should not change moment');
    });

    test('is between second', function (assert) {
        var m = moment(new Date(2011, 1, 2, 3, 4, 5, 6)), mCopy = moment(m);
        assert.equal(m.isBetween(
                    moment(new Date(2011, 1, 2, 3, 4, 5, 10)),
                    moment(new Date(2011, 1, 2, 3, 4, 5, 10)), 'second'), false, 'second match');
        assert.equal(m.isBetween(
                    moment(new Date(2011, 1, 2, 3, 4, 4, 10)),
                    moment(new Date(2011, 1, 2, 3, 4, 6, 10)), 'seconds'), true, 'plural should work');
        assert.equal(m.isBetween(
                    moment(new Date(2011, 1, 2, 3, 4, 4, 999)),
                    moment(new Date(2011, 1, 2, 3, 4, 6, 0)), 'second'), true, 'second is between');
        assert.equal(m.isBetween(
                    moment(new Date(2011, 1, 2, 3, 4, 6, 0)),
                    moment(new Date(2011, 1, 2, 3, 4, 7, 10)), 'second'), false, 'second is earlier');
        assert.equal(m.isBetween(
                    moment(new Date(2011, 1, 2, 3, 4, 3, 10)),
                    moment(new Date(2011, 1, 2, 3, 4, 4, 999)), 'second'), false, 'second is later');
        assert.equal(m.isBetween(m, 'second'), false, 'same moments are not between the same second');
        assert.equal(+m, +mCopy, 'isBetween second should not change moment');
    });

    test('is between millisecond', function (assert) {
        var m = moment(new Date(2011, 1, 2, 3, 4, 5, 6)), mCopy = moment(m);
        assert.equal(m.isBetween(
                    moment(new Date(2011, 1, 2, 3, 4, 5, 6)),
                    moment(new Date(2011, 1, 2, 3, 4, 5, 6)), 'millisecond'), false, 'millisecond match');
        assert.equal(m.isBetween(
                    moment(new Date(2011, 1, 2, 3, 4, 5, 5)),
                    moment(new Date(2011, 1, 2, 3, 4, 5, 7)), 'milliseconds'), true, 'plural should work');
        assert.equal(m.isBetween(
                    moment(new Date(2011, 1, 2, 3, 4, 5, 5)),
                    moment(new Date(2011, 1, 2, 3, 4, 5, 7)), 'millisecond'), true, 'millisecond is between');
        assert.equal(m.isBetween(
                    moment(new Date(2011, 1, 2, 3, 4, 5, 7)),
                    moment(new Date(2011, 1, 2, 3, 4, 5, 10)), 'millisecond'), false, 'millisecond is earlier');
        assert.equal(m.isBetween(
                    moment(new Date(2011, 1, 2, 3, 4, 5, 4)),
                    moment(new Date(2011, 1, 2, 3, 4, 5, 6)), 'millisecond'), false, 'millisecond is later');
        assert.equal(m.isBetween(m, 'millisecond'), false, 'same moments are not between the same millisecond');
        assert.equal(+m, +mCopy, 'isBetween millisecond should not change moment');
    });

}));

;(function (global, factory) {
   typeof exports === 'object' && typeof module !== 'undefined'
       && typeof require === 'function' ? factory(require('../../moment')) :
   typeof define === 'function' && define.amd ? define(['../../moment'], factory) :
   factory(global.moment)
}(this, function (moment) { 'use strict';

    function each(array, callback) {
        var i;
        for (i = 0; i < array.length; i++) {
            callback(array[i], i, array);
        }
    }

    function objectKeys(obj) {
        if (Object.keys) {
            return Object.keys(obj);
        } else {
            // IE8
            var res = [], i;
            for (i in obj) {
                if (obj.hasOwnProperty(i)) {
                    res.push(i);
                }
            }
            return res;
        }
    }

    // Pick the first defined of two or three arguments.
    function defaults(a, b, c) {
        if (a != null) {
            return a;
        }
        if (b != null) {
            return b;
        }
        return c;
    }

    function defineCommonLocaleTests(locale, options) {
        test('lenient ordinal parsing', function (assert) {
            var i, ordinalStr, testMoment;
            for (i = 1; i <= 31; ++i) {
                ordinalStr = moment([2014, 0, i]).format('YYYY MM Do');
                testMoment = moment(ordinalStr, 'YYYY MM Do');
                assert.equal(testMoment.year(), 2014,
                        'lenient ordinal parsing ' + i + ' year check');
                assert.equal(testMoment.month(), 0,
                        'lenient ordinal parsing ' + i + ' month check');
                assert.equal(testMoment.date(), i,
                        'lenient ordinal parsing ' + i + ' date check');
            }
        });

        test('lenient ordinal parsing of number', function (assert) {
            var i, testMoment;
            for (i = 1; i <= 31; ++i) {
                testMoment = moment('2014 01 ' + i, 'YYYY MM Do');
                assert.equal(testMoment.year(), 2014,
                        'lenient ordinal parsing of number ' + i + ' year check');
                assert.equal(testMoment.month(), 0,
                        'lenient ordinal parsing of number ' + i + ' month check');
                assert.equal(testMoment.date(), i,
                        'lenient ordinal parsing of number ' + i + ' date check');
            }
        });

        test('strict ordinal parsing', function (assert) {
            var i, ordinalStr, testMoment;
            for (i = 1; i <= 31; ++i) {
                ordinalStr = moment([2014, 0, i]).format('YYYY MM Do');
                testMoment = moment(ordinalStr, 'YYYY MM Do', true);
                assert.ok(testMoment.isValid(), 'strict ordinal parsing ' + i);
            }
        });

        test('meridiem invariant', function (assert) {
            var h, m, t1, t2;
            for (h = 0; h < 24; ++h) {
                for (m = 0; m < 60; m += 15) {
                    t1 = moment.utc([2000, 0, 1, h, m]);
                    t2 = moment.utc(t1.format('A h:mm'), 'A h:mm');
                    assert.equal(t2.format('HH:mm'), t1.format('HH:mm'),
                            'meridiem at ' + t1.format('HH:mm'));
                }
            }
        });

        test('date format correctness', function (assert) {
            var data, tokens;
            data = moment.localeData()._longDateFormat;
            tokens = objectKeys(data);
            each(tokens, function (srchToken) {
                // Check each format string to make sure it does not contain any
                // tokens that need to be expanded.
                each(tokens, function (baseToken) {
                    // strip escaped sequences
                    var format = data[baseToken].replace(/(\[[^\]]*\])/g, '');
                    assert.equal(false, !!~format.indexOf(srchToken),
                            'contains ' + srchToken + ' in ' + baseToken);
                });
            });
        });

        test('month parsing correctness', function (assert) {
            var i, m;

            if (locale === 'tr') {
                // I can't fix it :(
                expect(0);
                return;
            }
            function tester(format) {
                var r;
                r = moment(m.format(format), format);
                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format);
                r = moment(m.format(format).toLocaleUpperCase(), format);
                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' upper');
                r = moment(m.format(format).toLocaleLowerCase(), format);
                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' lower');

                r = moment(m.format(format), format, true);
                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' strict');
                r = moment(m.format(format).toLocaleUpperCase(), format, true);
                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' upper strict');
                r = moment(m.format(format).toLocaleLowerCase(), format, true);
                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' lower strict');
            }

            for (i = 0; i < 12; ++i) {
                m = moment([2015, i, 15, 18]);
                tester('MMM');
                tester('MMM.');
                tester('MMMM');
                tester('MMMM.');
            }
        });

        test('weekday parsing correctness', function (assert) {
            var i, m;

            if (locale === 'tr' || locale === 'az') {
                // There is a lower-case letter (Ä±), that converted to upper then
                // lower changes to i
                expect(0);
                return;
            }
            function tester(format) {
                var r, baseMsg = 'weekday ' + m.weekday() + ' fmt ' + format;
                r = moment(m.format(format), format);
                assert.equal(r.weekday(), m.weekday(), baseMsg);
                r = moment(m.format(format).toLocaleUpperCase(), format);
                assert.equal(r.weekday(), m.weekday(), baseMsg + ' upper');
                r = moment(m.format(format).toLocaleLowerCase(), format);
                assert.equal(r.weekday(), m.weekday(), baseMsg + ' lower');

                r = moment(m.format(format), format, true);
                assert.equal(r.weekday(), m.weekday(), baseMsg + ' strict');
                r = moment(m.format(format).toLocaleUpperCase(), format, true);
                assert.equal(r.weekday(), m.weekday(), baseMsg + ' upper strict');
                r = moment(m.format(format).toLocaleLowerCase(), format, true);
                assert.equal(r.weekday(), m.weekday(), baseMsg + ' lower strict');
            }

            for (i = 0; i < 7; ++i) {
                m = moment.utc([2015, i, 15, 18]);
                tester('dd');
                tester('ddd');
                tester('dddd');
            }
        });
    }

    function setupDeprecationHandler(test, moment, scope) {
        test._expectedDeprecations = null;
        test._observedDeprecations = null;
        test._oldSupress = moment.suppressDeprecationWarnings;
        moment.suppressDeprecationWarnings = true;
        test.expectedDeprecations = function () {
            test._expectedDeprecations = arguments;
            test._observedDeprecations = [];
        };
        moment.deprecationHandler = function (name, msg) {
            var deprecationId = matchedDeprecation(name, msg, test._expectedDeprecations);
            if (deprecationId === -1) {
                throw new Error('Unexpected deprecation thrown name=' +
                        name + ' msg=' + msg);
            }
            test._observedDeprecations[deprecationId] = 1;
        };
    }

    function teardownDeprecationHandler(test, moment, scope) {
        moment.suppressDeprecationWarnings = test._oldSupress;

        if (test._expectedDeprecations != null) {
            var missedDeprecations = [];
            each(test._expectedDeprecations, function (deprecationPattern, id) {
                if (test._observedDeprecations[id] !== 1) {
                    missedDeprecations.push(deprecationPattern);
                }
            });
            if (missedDeprecations.length !== 0) {
                throw new Error('Expected deprecation warnings did not happen: ' +
                        missedDeprecations.join(' '));
            }
        }
    }

    function matchedDeprecation(name, msg, deprecations) {
        if (deprecations == null) {
            return -1;
        }
        for (var i = 0; i < deprecations.length; ++i) {
            if (name != null && name === deprecations[i]) {
                return i;
            }
            if (msg != null && msg.substring(0, deprecations[i].length) === deprecations[i]) {
                return i;
            }
        }
        return -1;
    }

    /*global QUnit:false*/

    var test = QUnit.test;

    var expect = QUnit.expect;

    function module (name, lifecycle) {
        QUnit.module(name, {
            setup : function () {
                moment.locale('en');
                moment.createFromInputFallback = function (config) {
                    throw new Error('input not handled by moment: ' + config._i);
                };
                setupDeprecationHandler(test, moment, 'core');
                if (lifecycle && lifecycle.setup) {
                    lifecycle.setup();
                }
            },
            teardown : function () {
                teardownDeprecationHandler(test, moment, 'core');
                if (lifecycle && lifecycle.teardown) {
                    lifecycle.teardown();
                }
            }
        });
    }

    function localeModule (name, lifecycle) {
        QUnit.module('locale:' + name, {
            setup : function () {
                moment.locale(name);
                moment.createFromInputFallback = function (config) {
                    throw new Error('input not handled by moment: ' + config._i);
                };
                setupDeprecationHandler(test, moment, 'locale');
                if (lifecycle && lifecycle.setup) {
                    lifecycle.setup();
                }
            },
            teardown : function () {
                moment.locale('en');
                teardownDeprecationHandler(test, moment, 'locale');
                if (lifecycle && lifecycle.teardown) {
                    lifecycle.teardown();
                }
            }
        });
        defineCommonLocaleTests(name, -1, -1);
    }

    module('is date');

    test('isDate recognizes Date objects', function (assert) {
        assert.ok(moment.isDate(new Date()), 'no args (now)');
        assert.ok(moment.isDate(new Date([2014, 2, 15])), 'array args');
        assert.ok(moment.isDate(new Date('2014-03-15')), 'string args');
        assert.ok(moment.isDate(new Date('does NOT look like a date')), 'invalid date');
    });

    test('isDate rejects non-Date objects', function (assert) {
        assert.ok(!moment.isDate(), 'nothing');
        assert.ok(!moment.isDate(undefined), 'undefined');
        assert.ok(!moment.isDate(null), 'string args');
        assert.ok(!moment.isDate(42), 'number');
        assert.ok(!moment.isDate('2014-03-15'), 'string');
        assert.ok(!moment.isDate([2014, 2, 15]), 'array');
        assert.ok(!moment.isDate({year: 2014, month: 2, day: 15}), 'object');
        assert.ok(!moment.isDate({toString: function () {
            return '[object Date]';
        }}), 'lying object');
    });

}));

;(function (global, factory) {
   typeof exports === 'object' && typeof module !== 'undefined'
       && typeof require === 'function' ? factory(require('../../moment')) :
   typeof define === 'function' && define.amd ? define(['../../moment'], factory) :
   factory(global.moment)
}(this, function (moment) { 'use strict';

    function each(array, callback) {
        var i;
        for (i = 0; i < array.length; i++) {
            callback(array[i], i, array);
        }
    }

    function objectKeys(obj) {
        if (Object.keys) {
            return Object.keys(obj);
        } else {
            // IE8
            var res = [], i;
            for (i in obj) {
                if (obj.hasOwnProperty(i)) {
                    res.push(i);
                }
            }
            return res;
        }
    }

    // Pick the first defined of two or three arguments.
    function defaults(a, b, c) {
        if (a != null) {
            return a;
        }
        if (b != null) {
            return b;
        }
        return c;
    }

    function defineCommonLocaleTests(locale, options) {
        test('lenient ordinal parsing', function (assert) {
            var i, ordinalStr, testMoment;
            for (i = 1; i <= 31; ++i) {
                ordinalStr = moment([2014, 0, i]).format('YYYY MM Do');
                testMoment = moment(ordinalStr, 'YYYY MM Do');
                assert.equal(testMoment.year(), 2014,
                        'lenient ordinal parsing ' + i + ' year check');
                assert.equal(testMoment.month(), 0,
                        'lenient ordinal parsing ' + i + ' month check');
                assert.equal(testMoment.date(), i,
                        'lenient ordinal parsing ' + i + ' date check');
            }
        });

        test('lenient ordinal parsing of number', function (assert) {
            var i, testMoment;
            for (i = 1; i <= 31; ++i) {
                testMoment = moment('2014 01 ' + i, 'YYYY MM Do');
                assert.equal(testMoment.year(), 2014,
                        'lenient ordinal parsing of number ' + i + ' year check');
                assert.equal(testMoment.month(), 0,
                        'lenient ordinal parsing of number ' + i + ' month check');
                assert.equal(testMoment.date(), i,
                        'lenient ordinal parsing of number ' + i + ' date check');
            }
        });

        test('strict ordinal parsing', function (assert) {
            var i, ordinalStr, testMoment;
            for (i = 1; i <= 31; ++i) {
                ordinalStr = moment([2014, 0, i]).format('YYYY MM Do');
                testMoment = moment(ordinalStr, 'YYYY MM Do', true);
                assert.ok(testMoment.isValid(), 'strict ordinal parsing ' + i);
            }
        });

        test('meridiem invariant', function (assert) {
            var h, m, t1, t2;
            for (h = 0; h < 24; ++h) {
                for (m = 0; m < 60; m += 15) {
                    t1 = moment.utc([2000, 0, 1, h, m]);
                    t2 = moment.utc(t1.format('A h:mm'), 'A h:mm');
                    assert.equal(t2.format('HH:mm'), t1.format('HH:mm'),
                            'meridiem at ' + t1.format('HH:mm'));
                }
            }
        });

        test('date format correctness', function (assert) {
            var data, tokens;
            data = moment.localeData()._longDateFormat;
            tokens = objectKeys(data);
            each(tokens, function (srchToken) {
                // Check each format string to make sure it does not contain any
                // tokens that need to be expanded.
                each(tokens, function (baseToken) {
                    // strip escaped sequences
                    var format = data[baseToken].replace(/(\[[^\]]*\])/g, '');
                    assert.equal(false, !!~format.indexOf(srchToken),
                            'contains ' + srchToken + ' in ' + baseToken);
                });
            });
        });

        test('month parsing correctness', function (assert) {
            var i, m;

            if (locale === 'tr') {
                // I can't fix it :(
                expect(0);
                return;
            }
            function tester(format) {
                var r;
                r = moment(m.format(format), format);
                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format);
                r = moment(m.format(format).toLocaleUpperCase(), format);
                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' upper');
                r = moment(m.format(format).toLocaleLowerCase(), format);
                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' lower');

                r = moment(m.format(format), format, true);
                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' strict');
                r = moment(m.format(format).toLocaleUpperCase(), format, true);
                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' upper strict');
                r = moment(m.format(format).toLocaleLowerCase(), format, true);
                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' lower strict');
            }

            for (i = 0; i < 12; ++i) {
                m = moment([2015, i, 15, 18]);
                tester('MMM');
                tester('MMM.');
                tester('MMMM');
                tester('MMMM.');
            }
        });

        test('weekday parsing correctness', function (assert) {
            var i, m;

            if (locale === 'tr' || locale === 'az') {
                // There is a lower-case letter (Ä±), that converted to upper then
                // lower changes to i
                expect(0);
                return;
            }
            function tester(format) {
                var r, baseMsg = 'weekday ' + m.weekday() + ' fmt ' + format;
                r = moment(m.format(format), format);
                assert.equal(r.weekday(), m.weekday(), baseMsg);
                r = moment(m.format(format).toLocaleUpperCase(), format);
                assert.equal(r.weekday(), m.weekday(), baseMsg + ' upper');
                r = moment(m.format(format).toLocaleLowerCase(), format);
                assert.equal(r.weekday(), m.weekday(), baseMsg + ' lower');

                r = moment(m.format(format), format, true);
                assert.equal(r.weekday(), m.weekday(), baseMsg + ' strict');
                r = moment(m.format(format).toLocaleUpperCase(), format, true);
                assert.equal(r.weekday(), m.weekday(), baseMsg + ' upper strict');
                r = moment(m.format(format).toLocaleLowerCase(), format, true);
                assert.equal(r.weekday(), m.weekday(), baseMsg + ' lower strict');
            }

            for (i = 0; i < 7; ++i) {
                m = moment.utc([2015, i, 15, 18]);
                tester('dd');
                tester('ddd');
                tester('dddd');
            }
        });
    }

    function setupDeprecationHandler(test, moment, scope) {
        test._expectedDeprecations = null;
        test._observedDeprecations = null;
        test._oldSupress = moment.suppressDeprecationWarnings;
        moment.suppressDeprecationWarnings = true;
        test.expectedDeprecations = function () {
            test._expectedDeprecations = arguments;
            test._observedDeprecations = [];
        };
        moment.deprecationHandler = function (name, msg) {
            var deprecationId = matchedDeprecation(name, msg, test._expectedDeprecations);
            if (deprecationId === -1) {
                throw new Error('Unexpected deprecation thrown name=' +
                        name + ' msg=' + msg);
            }
            test._observedDeprecations[deprecationId] = 1;
        };
    }

    function teardownDeprecationHandler(test, moment, scope) {
        moment.suppressDeprecationWarnings = test._oldSupress;

        if (test._expectedDeprecations != null) {
            var missedDeprecations = [];
            each(test._expectedDeprecations, function (deprecationPattern, id) {
                if (test._observedDeprecations[id] !== 1) {
                    missedDeprecations.push(deprecationPattern);
                }
            });
            if (missedDeprecations.length !== 0) {
                throw new Error('Expected deprecation warnings did not happen: ' +
                        missedDeprecations.join(' '));
            }
        }
    }

    function matchedDeprecation(name, msg, deprecations) {
        if (deprecations == null) {
            return -1;
        }
        for (var i = 0; i < deprecations.length; ++i) {
            if (name != null && name === deprecations[i]) {
                return i;
            }
            if (msg != null && msg.substring(0, deprecations[i].length) === deprecations[i]) {
                return i;
            }
        }
        return -1;
    }

    /*global QUnit:false*/

    var test = QUnit.test;

    var expect = QUnit.expect;

    function module (name, lifecycle) {
        QUnit.module(name, {
            setup : function () {
                moment.locale('en');
                moment.createFromInputFallback = function (config) {
                    throw new Error('input not handled by moment: ' + config._i);
                };
                setupDeprecationHandler(test, moment, 'core');
                if (lifecycle && lifecycle.setup) {
                    lifecycle.setup();
                }
            },
            teardown : function () {
                teardownDeprecationHandler(test, moment, 'core');
                if (lifecycle && lifecycle.teardown) {
                    lifecycle.teardown();
                }
            }
        });
    }

    function localeModule (name, lifecycle) {
        QUnit.module('locale:' + name, {
            setup : function () {
                moment.locale(name);
                moment.createFromInputFallback = function (config) {
                    throw new Error('input not handled by moment: ' + config._i);
                };
                setupDeprecationHandler(test, moment, 'locale');
                if (lifecycle && lifecycle.setup) {
                    lifecycle.setup();
                }
            },
            teardown : function () {
                moment.locale('en');
                teardownDeprecationHandler(test, moment, 'locale');
                if (lifecycle && lifecycle.teardown) {
                    lifecycle.teardown();
                }
            }
        });
        defineCommonLocaleTests(name, -1, -1);
    }

    module('is moment');

    test('is moment object', function (assert) {
        var MyObj = function () {},
            extend = function (a, b) {
                var i;
                for (i in b) {
                    a[i] = b[i];
                }
                return a;
            };
        MyObj.prototype.toDate = function () {
            return new Date();
        };

        assert.ok(moment.isMoment(moment()), 'simple moment object');
        assert.ok(moment.isMoment(moment(null)), 'invalid moment object');
        assert.ok(moment.isMoment(extend({}, moment())), 'externally cloned moments are moments');
        assert.ok(moment.isMoment(extend({}, moment.utc())), 'externally cloned utc moments are moments');

        assert.ok(!moment.isMoment(new MyObj()), 'myObj is not moment object');
        assert.ok(!moment.isMoment(moment), 'moment function is not moment object');
        assert.ok(!moment.isMoment(new Date()), 'date object is not moment object');
        assert.ok(!moment.isMoment(Object), 'Object is not moment object');
        assert.ok(!moment.isMoment('foo'), 'string is not moment object');
        assert.ok(!moment.isMoment(1), 'number is not moment object');
        assert.ok(!moment.isMoment(NaN), 'NaN is not moment object');
        assert.ok(!moment.isMoment(null), 'null is not moment object');
        assert.ok(!moment.isMoment(undefined), 'undefined is not moment object');
    });

    test('is moment with hacked hasOwnProperty', function (assert) {
        var obj = {};
        // HACK to suppress jshint warning about bad property name
        obj['hasOwnMoney'.replace('Money', 'Property')] = function () {
            return true;
        };

        assert.ok(!moment.isMoment(obj), 'isMoment works even if passed object has a wrong hasOwnProperty implementation (ie8)');
    });

}));

;(function (global, factory) {
   typeof exports === 'object' && typeof module !== 'undefined'
       && typeof require === 'function' ? factory(require('../../moment')) :
   typeof define === 'function' && define.amd ? define(['../../moment'], factory) :
   factory(global.moment)
}(this, function (moment) { 'use strict';

    function each(array, callback) {
        var i;
        for (i = 0; i < array.length; i++) {
            callback(array[i], i, array);
        }
    }

    function objectKeys(obj) {
        if (Object.keys) {
            return Object.keys(obj);
        } else {
            // IE8
            var res = [], i;
            for (i in obj) {
                if (obj.hasOwnProperty(i)) {
                    res.push(i);
                }
            }
            return res;
        }
    }

    // Pick the first defined of two or three arguments.
    function defaults(a, b, c) {
        if (a != null) {
            return a;
        }
        if (b != null) {
            return b;
        }
        return c;
    }

    function defineCommonLocaleTests(locale, options) {
        test('lenient ordinal parsing', function (assert) {
            var i, ordinalStr, testMoment;
            for (i = 1; i <= 31; ++i) {
                ordinalStr = moment([2014, 0, i]).format('YYYY MM Do');
                testMoment = moment(ordinalStr, 'YYYY MM Do');
                assert.equal(testMoment.year(), 2014,
                        'lenient ordinal parsing ' + i + ' year check');
                assert.equal(testMoment.month(), 0,
                        'lenient ordinal parsing ' + i + ' month check');
                assert.equal(testMoment.date(), i,
                        'lenient ordinal parsing ' + i + ' date check');
            }
        });

        test('lenient ordinal parsing of number', function (assert) {
            var i, testMoment;
            for (i = 1; i <= 31; ++i) {
                testMoment = moment('2014 01 ' + i, 'YYYY MM Do');
                assert.equal(testMoment.year(), 2014,
                        'lenient ordinal parsing of number ' + i + ' year check');
                assert.equal(testMoment.month(), 0,
                        'lenient ordinal parsing of number ' + i + ' month check');
                assert.equal(testMoment.date(), i,
                        'lenient ordinal parsing of number ' + i + ' date check');
            }
        });

        test('strict ordinal parsing', function (assert) {
            var i, ordinalStr, testMoment;
            for (i = 1; i <= 31; ++i) {
                ordinalStr = moment([2014, 0, i]).format('YYYY MM Do');
                testMoment = moment(ordinalStr, 'YYYY MM Do', true);
                assert.ok(testMoment.isValid(), 'strict ordinal parsing ' + i);
            }
        });

        test('meridiem invariant', function (assert) {
            var h, m, t1, t2;
            for (h = 0; h < 24; ++h) {
                for (m = 0; m < 60; m += 15) {
                    t1 = moment.utc([2000, 0, 1, h, m]);
                    t2 = moment.utc(t1.format('A h:mm'), 'A h:mm');
                    assert.equal(t2.format('HH:mm'), t1.format('HH:mm'),
                            'meridiem at ' + t1.format('HH:mm'));
                }
            }
        });

        test('date format correctness', function (assert) {
            var data, tokens;
            data = moment.localeData()._longDateFormat;
            tokens = objectKeys(data);
            each(tokens, function (srchToken) {
                // Check each format string to make sure it does not contain any
                // tokens that need to be expanded.
                each(tokens, function (baseToken) {
                    // strip escaped sequences
                    var format = data[baseToken].replace(/(\[[^\]]*\])/g, '');
                    assert.equal(false, !!~format.indexOf(srchToken),
                            'contains ' + srchToken + ' in ' + baseToken);
                });
            });
        });

        test('month parsing correctness', function (assert) {
            var i, m;

            if (locale === 'tr') {
                // I can't fix it :(
                expect(0);
                return;
            }
            function tester(format) {
                var r;
                r = moment(m.format(format), format);
                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format);
                r = moment(m.format(format).toLocaleUpperCase(), format);
                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' upper');
                r = moment(m.format(format).toLocaleLowerCase(), format);
                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' lower');

                r = moment(m.format(format), format, true);
                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' strict');
                r = moment(m.format(format).toLocaleUpperCase(), format, true);
                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' upper strict');
                r = moment(m.format(format).toLocaleLowerCase(), format, true);
                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' lower strict');
            }

            for (i = 0; i < 12; ++i) {
                m = moment([2015, i, 15, 18]);
                tester('MMM');
                tester('MMM.');
                tester('MMMM');
                tester('MMMM.');
            }
        });

        test('weekday parsing correctness', function (assert) {
            var i, m;

            if (locale === 'tr' || locale === 'az') {
                // There is a lower-case letter (Ä±), that converted to upper then
                // lower changes to i
                expect(0);
                return;
            }
            function tester(format) {
                var r, baseMsg = 'weekday ' + m.weekday() + ' fmt ' + format;
                r = moment(m.format(format), format);
                assert.equal(r.weekday(), m.weekday(), baseMsg);
                r = moment(m.format(format).toLocaleUpperCase(), format);
                assert.equal(r.weekday(), m.weekday(), baseMsg + ' upper');
                r = moment(m.format(format).toLocaleLowerCase(), format);
                assert.equal(r.weekday(), m.weekday(), baseMsg + ' lower');

                r = moment(m.format(format), format, true);
                assert.equal(r.weekday(), m.weekday(), baseMsg + ' strict');
                r = moment(m.format(format).toLocaleUpperCase(), format, true);
                assert.equal(r.weekday(), m.weekday(), baseMsg + ' upper strict');
                r = moment(m.format(format).toLocaleLowerCase(), format, true);
                assert.equal(r.weekday(), m.weekday(), baseMsg + ' lower strict');
            }

            for (i = 0; i < 7; ++i) {
                m = moment.utc([2015, i, 15, 18]);
                tester('dd');
                tester('ddd');
                tester('dddd');
            }
        });
    }

    function setupDeprecationHandler(test, moment, scope) {
        test._expectedDeprecations = null;
        test._observedDeprecations = null;
        test._oldSupress = moment.suppressDeprecationWarnings;
        moment.suppressDeprecationWarnings = true;
        test.expectedDeprecations = function () {
            test._expectedDeprecations = arguments;
            test._observedDeprecations = [];
        };
        moment.deprecationHandler = function (name, msg) {
            var deprecationId = matchedDeprecation(name, msg, test._expectedDeprecations);
            if (deprecationId === -1) {
                throw new Error('Unexpected deprecation thrown name=' +
                        name + ' msg=' + msg);
            }
            test._observedDeprecations[deprecationId] = 1;
        };
    }

    function teardownDeprecationHandler(test, moment, scope) {
        moment.suppressDeprecationWarnings = test._oldSupress;

        if (test._expectedDeprecations != null) {
            var missedDeprecations = [];
            each(test._expectedDeprecations, function (deprecationPattern, id) {
                if (test._observedDeprecations[id] !== 1) {
                    missedDeprecations.push(deprecationPattern);
                }
            });
            if (missedDeprecations.length !== 0) {
                throw new Error('Expected deprecation warnings did not happen: ' +
                        missedDeprecations.join(' '));
            }
        }
    }

    function matchedDeprecation(name, msg, deprecations) {
        if (deprecations == null) {
            return -1;
        }
        for (var i = 0; i < deprecations.length; ++i) {
            if (name != null && name === deprecations[i]) {
                return i;
            }
            if (msg != null && msg.substring(0, deprecations[i].length) === deprecations[i]) {
                return i;
            }
        }
        return -1;
    }

    /*global QUnit:false*/

    var test = QUnit.test;

    var expect = QUnit.expect;

    function module (name, lifecycle) {
        QUnit.module(name, {
            setup : function () {
                moment.locale('en');
                moment.createFromInputFallback = function (config) {
                    throw new Error('input not handled by moment: ' + config._i);
                };
                setupDeprecationHandler(test, moment, 'core');
                if (lifecycle && lifecycle.setup) {
                    lifecycle.setup();
                }
            },
            teardown : function () {
                teardownDeprecationHandler(test, moment, 'core');
                if (lifecycle && lifecycle.teardown) {
                    lifecycle.teardown();
                }
            }
        });
    }

    function localeModule (name, lifecycle) {
        QUnit.module('locale:' + name, {
            setup : function () {
                moment.locale(name);
                moment.createFromInputFallback = function (config) {
                    throw new Error('input not handled by moment: ' + config._i);
                };
                setupDeprecationHandler(test, moment, 'locale');
                if (lifecycle && lifecycle.setup) {
                    lifecycle.setup();
                }
            },
            teardown : function () {
                moment.locale('en');
                teardownDeprecationHandler(test, moment, 'locale');
                if (lifecycle && lifecycle.teardown) {
                    lifecycle.teardown();
                }
            }
        });
        defineCommonLocaleTests(name, -1, -1);
    }

    module('is same');

    test('is same without units', function (assert) {
        var m = moment(new Date(2011, 3, 2, 3, 4, 5, 10)), mCopy = moment(m);
        assert.equal(m.isSame(moment(new Date(2012, 3, 2, 3, 5, 5, 10))), false, 'year is later');
        assert.equal(m.isSame(moment(new Date(2010, 3, 2, 3, 3, 5, 10))), false, 'year is earlier');
        assert.equal(m.isSame(moment(new Date(2011, 4, 2, 3, 4, 5, 10))), false, 'month is later');
        assert.equal(m.isSame(moment(new Date(2011, 2, 2, 3, 4, 5, 10))), false, 'month is earlier');
        assert.equal(m.isSame(moment(new Date(2011, 3, 3, 3, 4, 5, 10))), false, 'day is later');
        assert.equal(m.isSame(moment(new Date(2011, 3, 1, 3, 4, 5, 10))), false, 'day is earlier');
        assert.equal(m.isSame(moment(new Date(2011, 3, 2, 4, 4, 5, 10))), false, 'hour is later');
        assert.equal(m.isSame(moment(new Date(2011, 3, 2, 2, 4, 5, 10))), false, 'hour is earlier');
        assert.equal(m.isSame(moment(new Date(2011, 3, 2, 3, 5, 5, 10))), false, 'minute is later');
        assert.equal(m.isSame(moment(new Date(2011, 3, 2, 3, 3, 5, 10))), false, 'minute is earlier');
        assert.equal(m.isSame(moment(new Date(2011, 3, 2, 3, 4, 6, 10))), false, 'second is later');
        assert.equal(m.isSame(moment(new Date(2011, 3, 2, 3, 4, 4, 11))), false, 'second is earlier');
        assert.equal(m.isSame(moment(new Date(2011, 3, 2, 3, 4, 5, 10))), true, 'millisecond match');
        assert.equal(m.isSame(moment(new Date(2011, 3, 2, 3, 4, 5, 11))), false, 'millisecond is later');
        assert.equal(m.isSame(moment(new Date(2011, 3, 2, 3, 4, 5, 9))), false, 'millisecond is earlier');
        assert.equal(m.isSame(m), true, 'moments are the same as themselves');
        assert.equal(+m, +mCopy, 'isSame second should not change moment');
    });

    test('is same year', function (assert) {
        var m = moment(new Date(2011, 1, 2, 3, 4, 5, 6)), mCopy = moment(m);
        assert.equal(m.isSame(moment(new Date(2011, 5, 6, 7, 8, 9, 10)), 'year'), true, 'year match');
        assert.equal(m.isSame(moment(new Date(2011, 5, 6, 7, 8, 9, 10)), 'years'), true, 'plural should work');
        assert.equal(m.isSame(moment(new Date(2012, 5, 6, 7, 8, 9, 10)), 'year'), false, 'year mismatch');
        assert.equal(m.isSame(moment(new Date(2011, 0, 1, 0, 0, 0, 0)), 'year'), true, 'exact start of year');
        assert.equal(m.isSame(moment(new Date(2011, 11, 31, 23, 59, 59, 999)), 'year'), true, 'exact end of year');
        assert.equal(m.isSame(moment(new Date(2012, 0, 1, 0, 0, 0, 0)), 'year'), false, 'start of next year');
        assert.equal(m.isSame(moment(new Date(2010, 11, 31, 23, 59, 59, 999)), 'year'), false, 'end of previous year');
        assert.equal(m.isSame(m, 'year'), true, 'same moments are in the same year');
        assert.equal(+m, +mCopy, 'isSame year should not change moment');
    });

    test('is same month', function (assert) {
        var m = moment(new Date(2011, 2, 3, 4, 5, 6, 7)), mCopy = moment(m);
        assert.equal(m.isSame(moment(new Date(2011, 2, 6, 7, 8, 9, 10)), 'month'), true, 'month match');
        assert.equal(m.isSame(moment(new Date(2011, 2, 6, 7, 8, 9, 10)), 'months'), true, 'plural should work');
        assert.equal(m.isSame(moment(new Date(2012, 2, 6, 7, 8, 9, 10)), 'month'), false, 'year mismatch');
        assert.equal(m.isSame(moment(new Date(2011, 5, 6, 7, 8, 9, 10)), 'month'), false, 'month mismatch');
        assert.equal(m.isSame(moment(new Date(2011, 2, 1, 0, 0, 0, 0)), 'month'), true, 'exact start of month');
        assert.equal(m.isSame(moment(new Date(2011, 2, 31, 23, 59, 59, 999)), 'month'), true, 'exact end of month');
        assert.equal(m.isSame(moment(new Date(2011, 3, 1, 0, 0, 0, 0)), 'month'), false, 'start of next month');
        assert.equal(m.isSame(moment(new Date(2011, 1, 27, 23, 59, 59, 999)), 'month'), false, 'end of previous month');
        assert.equal(m.isSame(m, 'month'), true, 'same moments are in the same month');
        assert.equal(+m, +mCopy, 'isSame month should not change moment');
    });

    test('is same day', function (assert) {
        var m = moment(new Date(2011, 1, 2, 3, 4, 5, 6)), mCopy = moment(m);
        assert.equal(m.isSame(moment(new Date(2011, 1, 2, 7, 8, 9, 10)), 'day'), true, 'day match');
        assert.equal(m.isSame(moment(new Date(2011, 1, 2, 7, 8, 9, 10)), 'days'), true, 'plural should work');
        assert.equal(m.isSame(moment(new Date(2012, 1, 2, 7, 8, 9, 10)), 'day'), false, 'year mismatch');
        assert.equal(m.isSame(moment(new Date(2011, 2, 2, 7, 8, 9, 10)), 'day'), false, 'month mismatch');
        assert.equal(m.isSame(moment(new Date(2011, 1, 3, 7, 8, 9, 10)), 'day'), false, 'day mismatch');
        assert.equal(m.isSame(moment(new Date(2011, 1, 2, 0, 0, 0, 0)), 'day'), true, 'exact start of day');
        assert.equal(m.isSame(moment(new Date(2011, 1, 2, 23, 59, 59, 999)), 'day'), true, 'exact end of day');
        assert.equal(m.isSame(moment(new Date(2011, 1, 3, 0, 0, 0, 0)), 'day'), false, 'start of next day');
        assert.equal(m.isSame(moment(new Date(2011, 1, 1, 23, 59, 59, 999)), 'day'), false, 'end of previous day');
        assert.equal(m.isSame(m, 'day'), true, 'same moments are in the same day');
        assert.equal(+m, +mCopy, 'isSame day should not change moment');
    });

    test('is same hour', function (assert) {
        var m = moment(new Date(2011, 1, 2, 3, 4, 5, 6)), mCopy = moment(m);
        assert.equal(m.isSame(moment(new Date(2011, 1, 2, 3, 8, 9, 10)), 'hour'), true, 'hour match');
        assert.equal(m.isSame(moment(new Date(2011, 1, 2, 3, 8, 9, 10)), 'hours'), true, 'plural should work');
        assert.equal(m.isSame(moment(new Date(2012, 1, 2, 3, 8, 9, 10)), 'hour'), false, 'year mismatch');
        assert.equal(m.isSame(moment(new Date(2011, 2, 2, 3, 8, 9, 10)), 'hour'), false, 'month mismatch');
        assert.equal(m.isSame(moment(new Date(2011, 1, 3, 3, 8, 9, 10)), 'hour'), false, 'day mismatch');
        assert.equal(m.isSame(moment(new Date(2011, 1, 2, 4, 8, 9, 10)), 'hour'), false, 'hour mismatch');
        assert.equal(m.isSame(moment(new Date(2011, 1, 2, 3, 0, 0, 0)), 'hour'), true, 'exact start of hour');
        assert.equal(m.isSame(moment(new Date(2011, 1, 2, 3, 59, 59, 999)), 'hour'), true, 'exact end of hour');
        assert.equal(m.isSame(moment(new Date(2011, 1, 2, 4, 0, 0, 0)), 'hour'), false, 'start of next hour');
        assert.equal(m.isSame(moment(new Date(2011, 1, 2, 2, 59, 59, 999)), 'hour'), false, 'end of previous hour');
        assert.equal(m.isSame(m, 'hour'), true, 'same moments are in the same hour');
        assert.equal(+m, +mCopy, 'isSame hour should not change moment');
    });

    test('is same minute', function (assert) {
        var m = moment(new Date(2011, 1, 2, 3, 4, 5, 6)), mCopy = moment(m);
        assert.equal(m.isSame(moment(new Date(2011, 1, 2, 3, 4, 9, 10)), 'minute'), true, 'minute match');
        assert.equal(m.isSame(moment(new Date(2011, 1, 2, 3, 4, 9, 10)), 'minutes'), true, 'plural should work');
        assert.equal(m.isSame(moment(new Date(2012, 1, 2, 3, 4, 9, 10)), 'minute'), false, 'year mismatch');
        assert.equal(m.isSame(moment(new Date(2011, 2, 2, 3, 4, 9, 10)), 'minute'), false, 'month mismatch');
        assert.equal(m.isSame(moment(new Date(2011, 1, 3, 3, 4, 9, 10)), 'minute'), false, 'day mismatch');
        assert.equal(m.isSame(moment(new Date(2011, 1, 2, 4, 4, 9, 10)), 'minute'), false, 'hour mismatch');
        assert.equal(m.isSame(moment(new Date(2011, 1, 2, 3, 5, 9, 10)), 'minute'), false, 'minute mismatch');
        assert.equal(m.isSame(moment(new Date(2011, 1, 2, 3, 4, 0, 0)), 'minute'), true, 'exact start of minute');
        assert.equal(m.isSame(moment(new Date(2011, 1, 2, 3, 4, 59, 999)), 'minute'), true, 'exact end of minute');
        assert.equal(m.isSame(moment(new Date(2011, 1, 2, 3, 5, 0, 0)), 'minute'), false, 'start of next minute');
        assert.equal(m.isSame(moment(new Date(2011, 1, 2, 3, 3, 59, 999)), 'minute'), false, 'end of previous minute');
        assert.equal(m.isSame(m, 'minute'), true, 'same moments are in the same minute');
        assert.equal(+m, +mCopy, 'isSame minute should not change moment');
    });

    test('is same second', function (assert) {
        var m = moment(new Date(2011, 1, 2, 3, 4, 5, 6)), mCopy = moment(m);
        assert.equal(m.isSame(moment(new Date(2011, 1, 2, 3, 4, 5, 10)), 'second'), true, 'second match');
        assert.equal(m.isSame(moment(new Date(2011, 1, 2, 3, 4, 5, 10)), 'seconds'), true, 'plural should work');
        assert.equal(m.isSame(moment(new Date(2012, 1, 2, 3, 4, 5, 10)), 'second'), false, 'year mismatch');
        assert.equal(m.isSame(moment(new Date(2011, 2, 2, 3, 4, 5, 10)), 'second'), false, 'month mismatch');
        assert.equal(m.isSame(moment(new Date(2011, 1, 3, 3, 4, 5, 10)), 'second'), false, 'day mismatch');
        assert.equal(m.isSame(moment(new Date(2011, 1, 2, 4, 4, 5, 10)), 'second'), false, 'hour mismatch');
        assert.equal(m.isSame(moment(new Date(2011, 1, 2, 3, 5, 5, 10)), 'second'), false, 'minute mismatch');
        assert.equal(m.isSame(moment(new Date(2011, 1, 2, 3, 4, 6, 10)), 'second'), false, 'second mismatch');
        assert.equal(m.isSame(moment(new Date(2011, 1, 2, 3, 4, 5, 0)), 'second'), true, 'exact start of second');
        assert.equal(m.isSame(moment(new Date(2011, 1, 2, 3, 4, 5, 999)), 'second'), true, 'exact end of second');
        assert.equal(m.isSame(moment(new Date(2011, 1, 2, 3, 4, 6, 0)), 'second'), false, 'start of next second');
        assert.equal(m.isSame(moment(new Date(2011, 1, 2, 3, 4, 4, 999)), 'second'), false, 'end of previous second');
        assert.equal(m.isSame(m, 'second'), true, 'same moments are in the same second');
        assert.equal(+m, +mCopy, 'isSame second should not change moment');
    });

    test('is same millisecond', function (assert) {
        var m = moment(new Date(2011, 3, 2, 3, 4, 5, 10)), mCopy = moment(m);
        assert.equal(m.isSame(moment(new Date(2011, 3, 2, 3, 4, 5, 10)), 'millisecond'), true, 'millisecond match');
        assert.equal(m.isSame(moment(new Date(2011, 3, 2, 3, 4, 5, 10)), 'milliseconds'), true, 'plural should work');
        assert.equal(m.isSame(moment(new Date(2012, 3, 2, 3, 4, 5, 10)), 'millisecond'), false, 'year is later');
        assert.equal(m.isSame(moment(new Date(2010, 3, 2, 3, 4, 5, 10)), 'millisecond'), false, 'year is earlier');
        assert.equal(m.isSame(moment(new Date(2011, 4, 2, 3, 4, 5, 10)), 'millisecond'), false, 'month is later');
        assert.equal(m.isSame(moment(new Date(2011, 2, 2, 3, 4, 5, 10)), 'millisecond'), false, 'month is earlier');
        assert.equal(m.isSame(moment(new Date(2011, 3, 3, 3, 4, 5, 10)), 'millisecond'), false, 'day is later');
        assert.equal(m.isSame(moment(new Date(2011, 3, 1, 1, 4, 5, 10)), 'millisecond'), false, 'day is earlier');
        assert.equal(m.isSame(moment(new Date(2011, 3, 2, 4, 4, 5, 10)), 'millisecond'), false, 'hour is later');
        assert.equal(m.isSame(moment(new Date(2011, 3, 1, 4, 1, 5, 10)), 'millisecond'), false, 'hour is earlier');
        assert.equal(m.isSame(moment(new Date(2011, 3, 2, 3, 5, 5, 10)), 'millisecond'), false, 'minute is later');
        assert.equal(m.isSame(moment(new Date(2011, 3, 2, 3, 3, 5, 10)), 'millisecond'), false, 'minute is earlier');
        assert.equal(m.isSame(moment(new Date(2011, 3, 2, 3, 4, 6, 10)), 'millisecond'), false, 'second is later');
        assert.equal(m.isSame(moment(new Date(2011, 3, 2, 3, 4, 4, 5)), 'millisecond'), false, 'second is earlier');
        assert.equal(m.isSame(moment(new Date(2011, 3, 2, 3, 4, 6, 11)), 'millisecond'), false, 'millisecond is later');
        assert.equal(m.isSame(moment(new Date(2011, 3, 2, 3, 4, 4, 9)), 'millisecond'), false, 'millisecond is earlier');
        assert.equal(m.isSame(m, 'millisecond'), true, 'same moments are in the same millisecond');
        assert.equal(+m, +mCopy, 'isSame millisecond should not change moment');
    });

    test('is same with utc offset moments', function (assert) {
        assert.ok(moment.parseZone('2013-02-01T-05:00').isSame(moment('2013-02-01'), 'year'), 'zoned vs local moment');
        assert.ok(moment('2013-02-01').isSame(moment('2013-02-01').utcOffset('-05:00'), 'year'), 'local vs zoned moment');
        assert.ok(moment.parseZone('2013-02-01T-05:00').isSame(moment.parseZone('2013-02-01T-06:30'), 'year'),
                'zoned vs (differently) zoned moment');
    });

    test('is same with invalid moments', function (assert) {
        assert.equal(moment.invalid().isSame(moment.invalid()), false, 'invalid moments are not considered equal');
    });

}));

;(function (global, factory) {
   typeof exports === 'object' && typeof module !== 'undefined'
       && typeof require === 'function' ? factory(require('../../moment')) :
   typeof define === 'function' && define.amd ? define(['../../moment'], factory) :
   factory(global.moment)
}(this, function (moment) { 'use strict';

    function each(array, callback) {
        var i;
        for (i = 0; i < array.length; i++) {
            callback(array[i], i, array);
        }
    }

    function objectKeys(obj) {
        if (Object.keys) {
            return Object.keys(obj);
        } else {
            // IE8
            var res = [], i;
            for (i in obj) {
                if (obj.hasOwnProperty(i)) {
                    res.push(i);
                }
            }
            return res;
        }
    }

    // Pick the first defined of two or three arguments.
    function defaults(a, b, c) {
        if (a != null) {
            return a;
        }
        if (b != null) {
            return b;
        }
        return c;
    }

    function defineCommonLocaleTests(locale, options) {
        test('lenient ordinal parsing', function (assert) {
            var i, ordinalStr, testMoment;
            for (i = 1; i <= 31; ++i) {
                ordinalStr = moment([2014, 0, i]).format('YYYY MM Do');
                testMoment = moment(ordinalStr, 'YYYY MM Do');
                assert.equal(testMoment.year(), 2014,
                        'lenient ordinal parsing ' + i + ' year check');
                assert.equal(testMoment.month(), 0,
                        'lenient ordinal parsing ' + i + ' month check');
                assert.equal(testMoment.date(), i,
                        'lenient ordinal parsing ' + i + ' date check');
            }
        });

        test('lenient ordinal parsing of number', function (assert) {
            var i, testMoment;
            for (i = 1; i <= 31; ++i) {
                testMoment = moment('2014 01 ' + i, 'YYYY MM Do');
                assert.equal(testMoment.year(), 2014,
                        'lenient ordinal parsing of number ' + i + ' year check');
                assert.equal(testMoment.month(), 0,
                        'lenient ordinal parsing of number ' + i + ' month check');
                assert.equal(testMoment.date(), i,
                        'lenient ordinal parsing of number ' + i + ' date check');
            }
        });

        test('strict ordinal parsing', function (assert) {
            var i, ordinalStr, testMoment;
            for (i = 1; i <= 31; ++i) {
                ordinalStr = moment([2014, 0, i]).format('YYYY MM Do');
                testMoment = moment(ordinalStr, 'YYYY MM Do', true);
                assert.ok(testMoment.isValid(), 'strict ordinal parsing ' + i);
            }
        });

        test('meridiem invariant', function (assert) {
            var h, m, t1, t2;
            for (h = 0; h < 24; ++h) {
                for (m = 0; m < 60; m += 15) {
                    t1 = moment.utc([2000, 0, 1, h, m]);
                    t2 = moment.utc(t1.format('A h:mm'), 'A h:mm');
                    assert.equal(t2.format('HH:mm'), t1.format('HH:mm'),
                            'meridiem at ' + t1.format('HH:mm'));
                }
            }
        });

        test('date format correctness', function (assert) {
            var data, tokens;
            data = moment.localeData()._longDateFormat;
            tokens = objectKeys(data);
            each(tokens, function (srchToken) {
                // Check each format string to make sure it does not contain any
                // tokens that need to be expanded.
                each(tokens, function (baseToken) {
                    // strip escaped sequences
                    var format = data[baseToken].replace(/(\[[^\]]*\])/g, '');
                    assert.equal(false, !!~format.indexOf(srchToken),
                            'contains ' + srchToken + ' in ' + baseToken);
                });
            });
        });

        test('month parsing correctness', function (assert) {
            var i, m;

            if (locale === 'tr') {
                // I can't fix it :(
                expect(0);
                return;
            }
            function tester(format) {
                var r;
                r = moment(m.format(format), format);
                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format);
                r = moment(m.format(format).toLocaleUpperCase(), format);
                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' upper');
                r = moment(m.format(format).toLocaleLowerCase(), format);
                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' lower');

                r = moment(m.format(format), format, true);
                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' strict');
                r = moment(m.format(format).toLocaleUpperCase(), format, true);
                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' upper strict');
                r = moment(m.format(format).toLocaleLowerCase(), format, true);
                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' lower strict');
            }

            for (i = 0; i < 12; ++i) {
                m = moment([2015, i, 15, 18]);
                tester('MMM');
                tester('MMM.');
                tester('MMMM');
                tester('MMMM.');
            }
        });

        test('weekday parsing correctness', function (assert) {
            var i, m;

            if (locale === 'tr' || locale === 'az') {
                // There is a lower-case letter (Ä±), that converted to upper then
                // lower changes to i
                expect(0);
                return;
            }
            function tester(format) {
                var r, baseMsg = 'weekday ' + m.weekday() + ' fmt ' + format;
                r = moment(m.format(format), format);
                assert.equal(r.weekday(), m.weekday(), baseMsg);
                r = moment(m.format(format).toLocaleUpperCase(), format);
                assert.equal(r.weekday(), m.weekday(), baseMsg + ' upper');
                r = moment(m.format(format).toLocaleLowerCase(), format);
                assert.equal(r.weekday(), m.weekday(), baseMsg + ' lower');

                r = moment(m.format(format), format, true);
                assert.equal(r.weekday(), m.weekday(), baseMsg + ' strict');
                r = moment(m.format(format).toLocaleUpperCase(), format, true);
                assert.equal(r.weekday(), m.weekday(), baseMsg + ' upper strict');
                r = moment(m.format(format).toLocaleLowerCase(), format, true);
                assert.equal(r.weekday(), m.weekday(), baseMsg + ' lower strict');
            }

            for (i = 0; i < 7; ++i) {
                m = moment.utc([2015, i, 15, 18]);
                tester('dd');
                tester('ddd');
                tester('dddd');
            }
        });
    }

    function setupDeprecationHandler(test, moment, scope) {
        test._expectedDeprecations = null;
        test._observedDeprecations = null;
        test._oldSupress = moment.suppressDeprecationWarnings;
        moment.suppressDeprecationWarnings = true;
        test.expectedDeprecations = function () {
            test._expectedDeprecations = arguments;
            test._observedDeprecations = [];
        };
        moment.deprecationHandler = function (name, msg) {
            var deprecationId = matchedDeprecation(name, msg, test._expectedDeprecations);
            if (deprecationId === -1) {
                throw new Error('Unexpected deprecation thrown name=' +
                        name + ' msg=' + msg);
            }
            test._observedDeprecations[deprecationId] = 1;
        };
    }

    function teardownDeprecationHandler(test, moment, scope) {
        moment.suppressDeprecationWarnings = test._oldSupress;

        if (test._expectedDeprecations != null) {
            var missedDeprecations = [];
            each(test._expectedDeprecations, function (deprecationPattern, id) {
                if (test._observedDeprecations[id] !== 1) {
                    missedDeprecations.push(deprecationPattern);
                }
            });
            if (missedDeprecations.length !== 0) {
                throw new Error('Expected deprecation warnings did not happen: ' +
                        missedDeprecations.join(' '));
            }
        }
    }

    function matchedDeprecation(name, msg, deprecations) {
        if (deprecations == null) {
            return -1;
        }
        for (var i = 0; i < deprecations.length; ++i) {
            if (name != null && name === deprecations[i]) {
                return i;
            }
            if (msg != null && msg.substring(0, deprecations[i].length) === deprecations[i]) {
                return i;
            }
        }
        return -1;
    }

    /*global QUnit:false*/

    var test = QUnit.test;

    var expect = QUnit.expect;

    function module (name, lifecycle) {
        QUnit.module(name, {
            setup : function () {
                moment.locale('en');
                moment.createFromInputFallback = function (config) {
                    throw new Error('input not handled by moment: ' + config._i);
                };
                setupDeprecationHandler(test, moment, 'core');
                if (lifecycle && lifecycle.setup) {
                    lifecycle.setup();
                }
            },
            teardown : function () {
                teardownDeprecationHandler(test, moment, 'core');
                if (lifecycle && lifecycle.teardown) {
                    lifecycle.teardown();
                }
            }
        });
    }

    function localeModule (name, lifecycle) {
        QUnit.module('locale:' + name, {
            setup : function () {
                moment.locale(name);
                moment.createFromInputFallback = function (config) {
                    throw new Error('input not handled by moment: ' + config._i);
                };
                setupDeprecationHandler(test, moment, 'locale');
                if (lifecycle && lifecycle.setup) {
                    lifecycle.setup();
                }
            },
            teardown : function () {
                moment.locale('en');
                teardownDeprecationHandler(test, moment, 'locale');
                if (lifecycle && lifecycle.teardown) {
                    lifecycle.teardown();
                }
            }
        });
        defineCommonLocaleTests(name, -1, -1);
    }

    module('is same or after');

    test('is same or after without units', function (assert) {
        var m = moment(new Date(2011, 3, 2, 3, 4, 5, 10)), mCopy = moment(m);
        assert.equal(m.isSameOrAfter(moment(new Date(2012, 3, 2, 3, 5, 5, 10))), false, 'year is later');
        assert.equal(m.isSameOrAfter(moment(new Date(2010, 3, 2, 3, 3, 5, 10))), true, 'year is earlier');
        assert.equal(m.isSameOrAfter(moment(new Date(2011, 4, 2, 3, 4, 5, 10))), false, 'month is later');
        assert.equal(m.isSameOrAfter(moment(new Date(2011, 2, 2, 3, 4, 5, 10))), true, 'month is earlier');
        assert.equal(m.isSameOrAfter(moment(new Date(2011, 3, 3, 3, 4, 5, 10))), false, 'day is later');
        assert.equal(m.isSameOrAfter(moment(new Date(2011, 3, 1, 3, 4, 5, 10))), true, 'day is earlier');
        assert.equal(m.isSameOrAfter(moment(new Date(2011, 3, 2, 4, 4, 5, 10))), false, 'hour is later');
        assert.equal(m.isSameOrAfter(moment(new Date(2011, 3, 2, 2, 4, 5, 10))), true, 'hour is earlier');
        assert.equal(m.isSameOrAfter(moment(new Date(2011, 3, 2, 3, 5, 5, 10))), false, 'minute is later');
        assert.equal(m.isSameOrAfter(moment(new Date(2011, 3, 2, 3, 3, 5, 10))), true, 'minute is earlier');
        assert.equal(m.isSameOrAfter(moment(new Date(2011, 3, 2, 3, 4, 6, 10))), false, 'second is later');
        assert.equal(m.isSameOrAfter(moment(new Date(2011, 3, 2, 3, 4, 4, 11))), true, 'second is earlier');
        assert.equal(m.isSameOrAfter(moment(new Date(2011, 3, 2, 3, 4, 5, 10))), true, 'millisecond match');
        assert.equal(m.isSameOrAfter(moment(new Date(2011, 3, 2, 3, 4, 5, 11))), false, 'millisecond is later');
        assert.equal(m.isSameOrAfter(moment(new Date(2011, 3, 2, 3, 4, 5, 9))), true, 'millisecond is earlier');
        assert.equal(m.isSameOrAfter(m), true, 'moments are the same as themselves');
        assert.equal(+m, +mCopy, 'isSameOrAfter second should not change moment');
    });

    test('is same or after year', function (assert) {
        var m = moment(new Date(2011, 1, 2, 3, 4, 5, 6)), mCopy = moment(m);
        assert.equal(m.isSameOrAfter(moment(new Date(2011, 5, 6, 7, 8, 9, 10)), 'year'), true, 'year match');
        assert.equal(m.isSameOrAfter(moment(new Date(2011, 5, 6, 7, 8, 9, 10)), 'years'), true, 'plural should work');
        assert.equal(m.isSameOrAfter(moment(new Date(2012, 5, 6, 7, 8, 9, 10)), 'year'), false, 'year is later');
        assert.equal(m.isSameOrAfter(moment(new Date(2010, 5, 6, 7, 8, 9, 10)), 'year'), true, 'year is earlier');
        assert.equal(m.isSameOrAfter(moment(new Date(2011, 0, 1, 0, 0, 0, 0)), 'year'), true, 'exact start of year');
        assert.equal(m.isSameOrAfter(moment(new Date(2011, 11, 31, 23, 59, 59, 999)), 'year'), true, 'exact end of year');
        assert.equal(m.isSameOrAfter(moment(new Date(2012, 0, 1, 0, 0, 0, 0)), 'year'), false, 'start of next year');
        assert.equal(m.isSameOrAfter(moment(new Date(2010, 11, 31, 23, 59, 59, 999)), 'year'), true, 'end of previous year');
        assert.equal(m.isSameOrAfter(m, 'year'), true, 'same moments are in the same year');
        assert.equal(+m, +mCopy, 'isSameOrAfter year should not change moment');
    });

    test('is same or after month', function (assert) {
        var m = moment(new Date(2011, 2, 3, 4, 5, 6, 7)), mCopy = moment(m);
        assert.equal(m.isSameOrAfter(moment(new Date(2011, 2, 6, 7, 8, 9, 10)), 'month'), true, 'month match');
        assert.equal(m.isSameOrAfter(moment(new Date(2011, 2, 6, 7, 8, 9, 10)), 'months'), true, 'plural should work');
        assert.equal(m.isSameOrAfter(moment(new Date(2012, 2, 6, 7, 8, 9, 10)), 'month'), false, 'year is later');
        assert.equal(m.isSameOrAfter(moment(new Date(2010, 2, 6, 7, 8, 9, 10)), 'month'), true, 'year is earlier');
        assert.equal(m.isSameOrAfter(moment(new Date(2011, 5, 6, 7, 8, 9, 10)), 'month'), false, 'month is later');
        assert.equal(m.isSameOrAfter(moment(new Date(2011, 1, 6, 7, 8, 9, 10)), 'month'), true, 'month is earlier');
        assert.equal(m.isSameOrAfter(moment(new Date(2011, 2, 1, 0, 0, 0, 0)), 'month'), true, 'exact start of month');
        assert.equal(m.isSameOrAfter(moment(new Date(2011, 2, 31, 23, 59, 59, 999)), 'month'), true, 'exact end of month');
        assert.equal(m.isSameOrAfter(moment(new Date(2011, 3, 1, 0, 0, 0, 0)), 'month'), false, 'start of next month');
        assert.equal(m.isSameOrAfter(moment(new Date(2011, 1, 27, 23, 59, 59, 999)), 'month'), true, 'end of previous month');
        assert.equal(m.isSameOrAfter(m, 'month'), true, 'same moments are in the same month');
        assert.equal(+m, +mCopy, 'isSameOrAfter month should not change moment');
    });

    test('is same or after day', function (assert) {
        var m = moment(new Date(2011, 1, 2, 3, 4, 5, 6)), mCopy = moment(m);
        assert.equal(m.isSameOrAfter(moment(new Date(2011, 1, 2, 7, 8, 9, 10)), 'day'), true, 'day match');
        assert.equal(m.isSameOrAfter(moment(new Date(2011, 1, 2, 7, 8, 9, 10)), 'days'), true, 'plural should work');
        assert.equal(m.isSameOrAfter(moment(new Date(2012, 1, 2, 7, 8, 9, 10)), 'day'), false, 'year is later');
        assert.equal(m.isSameOrAfter(moment(new Date(2010, 1, 2, 7, 8, 9, 10)), 'day'), true, 'year is earlier');
        assert.equal(m.isSameOrAfter(moment(new Date(2011, 2, 2, 7, 8, 9, 10)), 'day'), false, 'month is later');
        assert.equal(m.isSameOrAfter(moment(new Date(2010, 12, 2, 7, 8, 9, 10)), 'day'), true, 'month is earlier');
        assert.equal(m.isSameOrAfter(moment(new Date(2011, 1, 3, 7, 8, 9, 10)), 'day'), false, 'day is later');
        assert.equal(m.isSameOrAfter(moment(new Date(2011, 1, 1, 7, 8, 9, 10)), 'day'), true, 'day is earlier');
        assert.equal(m.isSameOrAfter(moment(new Date(2011, 1, 2, 0, 0, 0, 0)), 'day'), true, 'exact start of day');
        assert.equal(m.isSameOrAfter(moment(new Date(2011, 1, 2, 23, 59, 59, 999)), 'day'), true, 'exact end of day');
        assert.equal(m.isSameOrAfter(moment(new Date(2011, 1, 3, 0, 0, 0, 0)), 'day'), false, 'start of next day');
        assert.equal(m.isSameOrAfter(moment(new Date(2011, 1, 1, 23, 59, 59, 999)), 'day'), true, 'end of previous day');
        assert.equal(m.isSameOrAfter(m, 'day'), true, 'same moments are in the same day');
        assert.equal(+m, +mCopy, 'isSameOrAfter day should not change moment');
    });

    test('is same or after hour', function (assert) {
        var m = moment(new Date(2011, 1, 2, 3, 4, 5, 6)), mCopy = moment(m);
        assert.equal(m.isSameOrAfter(moment(new Date(2011, 1, 2, 3, 8, 9, 10)), 'hour'), true, 'hour match');
        assert.equal(m.isSameOrAfter(moment(new Date(2011, 1, 2, 3, 8, 9, 10)), 'hours'), true, 'plural should work');
        assert.equal(m.isSameOrAfter(moment(new Date(2012, 1, 2, 3, 8, 9, 10)), 'hour'), false, 'year is later');
        assert.equal(m.isSameOrAfter(moment(new Date(2010, 1, 2, 3, 8, 9, 10)), 'hour'), true, 'year is earlier');
        assert.equal(m.isSameOrAfter(moment(new Date(2011, 2, 2, 3, 8, 9, 10)), 'hour'), false, 'month is later');
        assert.equal(m.isSameOrAfter(moment(new Date(2010, 12, 2, 3, 8, 9, 10)), 'hour'), true, 'month is earlier');
        assert.equal(m.isSameOrAfter(moment(new Date(2011, 1, 3, 3, 8, 9, 10)), 'hour'), false, 'day is later');
        assert.equal(m.isSameOrAfter(moment(new Date(2011, 1, 1, 3, 8, 9, 10)), 'hour'), true, 'day is earlier');
        assert.equal(m.isSameOrAfter(moment(new Date(2011, 1, 2, 4, 8, 9, 10)), 'hour'), false, 'hour is later');
        assert.equal(m.isSameOrAfter(moment(new Date(2011, 1, 2, 2, 8, 9, 10)), 'hour'), true, 'hour is earlier');
        assert.equal(m.isSameOrAfter(moment(new Date(2011, 1, 2, 3, 0, 0, 0)), 'hour'), true, 'exact start of hour');
        assert.equal(m.isSameOrAfter(moment(new Date(2011, 1, 2, 3, 59, 59, 999)), 'hour'), true, 'exact end of hour');
        assert.equal(m.isSameOrAfter(moment(new Date(2011, 1, 2, 4, 0, 0, 0)), 'hour'), false, 'start of next hour');
        assert.equal(m.isSameOrAfter(moment(new Date(2011, 1, 2, 2, 59, 59, 999)), 'hour'), true, 'end of previous hour');
        assert.equal(m.isSameOrAfter(m, 'hour'), true, 'same moments are in the same hour');
        assert.equal(+m, +mCopy, 'isSameOrAfter hour should not change moment');
    });

    test('is same or after minute', function (assert) {
        var m = moment(new Date(2011, 1, 2, 3, 4, 5, 6)), mCopy = moment(m);
        assert.equal(m.isSameOrAfter(moment(new Date(2011, 1, 2, 3, 4, 9, 10)), 'minute'), true, 'minute match');
        assert.equal(m.isSameOrAfter(moment(new Date(2011, 1, 2, 3, 4, 9, 10)), 'minutes'), true, 'plural should work');
        assert.equal(m.isSameOrAfter(moment(new Date(2012, 1, 2, 3, 4, 9, 10)), 'minute'), false, 'year is later');
        assert.equal(m.isSameOrAfter(moment(new Date(2010, 1, 2, 3, 4, 9, 10)), 'minute'), true, 'year is earlier');
        assert.equal(m.isSameOrAfter(moment(new Date(2011, 2, 2, 3, 4, 9, 10)), 'minute'), false, 'month is later');
        assert.equal(m.isSameOrAfter(moment(new Date(2010, 12, 2, 3, 4, 9, 10)), 'minute'), true, 'month is earlier');
        assert.equal(m.isSameOrAfter(moment(new Date(2011, 1, 3, 3, 4, 9, 10)), 'minute'), false, 'day is later');
        assert.equal(m.isSameOrAfter(moment(new Date(2011, 1, 1, 3, 4, 9, 10)), 'minute'), true, 'day is earlier');
        assert.equal(m.isSameOrAfter(moment(new Date(2011, 1, 2, 4, 4, 9, 10)), 'minute'), false, 'hour is later');
        assert.equal(m.isSameOrAfter(moment(new Date(2011, 1, 2, 2, 4, 9, 10)), 'minute'), true, 'hour is earlier');
        assert.equal(m.isSameOrAfter(moment(new Date(2011, 1, 2, 3, 5, 9, 10)), 'minute'), false, 'minute is later');
        assert.equal(m.isSameOrAfter(moment(new Date(2011, 1, 2, 3, 3, 9, 10)), 'minute'), true, 'minute is earlier');
        assert.equal(m.isSameOrAfter(moment(new Date(2011, 1, 2, 3, 4, 0, 0)), 'minute'), true, 'exact start of minute');
        assert.equal(m.isSameOrAfter(moment(new Date(2011, 1, 2, 3, 4, 59, 999)), 'minute'), true, 'exact end of minute');
        assert.equal(m.isSameOrAfter(moment(new Date(2011, 1, 2, 3, 5, 0, 0)), 'minute'), false, 'start of next minute');
        assert.equal(m.isSameOrAfter(moment(new Date(2011, 1, 2, 3, 3, 59, 999)), 'minute'), true, 'end of previous minute');
        assert.equal(m.isSameOrAfter(m, 'minute'), true, 'same moments are in the same minute');
        assert.equal(+m, +mCopy, 'isSameOrAfter minute should not change moment');
    });

    test('is same or after second', function (assert) {
        var m = moment(new Date(2011, 1, 2, 3, 4, 5, 6)), mCopy = moment(m);
        assert.equal(m.isSameOrAfter(moment(new Date(2011, 1, 2, 3, 4, 5, 10)), 'second'), true, 'second match');
        assert.equal(m.isSameOrAfter(moment(new Date(2011, 1, 2, 3, 4, 5, 10)), 'seconds'), true, 'plural should work');
        assert.equal(m.isSameOrAfter(moment(new Date(2012, 1, 2, 3, 4, 5, 10)), 'second'), false, 'year is later');
        assert.equal(m.isSameOrAfter(moment(new Date(2010, 1, 2, 3, 4, 5, 10)), 'second'), true, 'year is earlier');
        assert.equal(m.isSameOrAfter(moment(new Date(2011, 2, 2, 3, 4, 5, 10)), 'second'), false, 'month is later');
        assert.equal(m.isSameOrAfter(moment(new Date(2010, 12, 2, 3, 4, 5, 10)), 'second'), true, 'month is earlier');
        assert.equal(m.isSameOrAfter(moment(new Date(2011, 1, 3, 3, 4, 5, 10)), 'second'), false, 'day is later');
        assert.equal(m.isSameOrAfter(moment(new Date(2011, 1, 1, 3, 4, 5, 10)), 'second'), true, 'day is earlier');
        assert.equal(m.isSameOrAfter(moment(new Date(2011, 1, 2, 4, 4, 5, 10)), 'second'), false, 'hour is later');
        assert.equal(m.isSameOrAfter(moment(new Date(2011, 1, 2, 2, 4, 5, 10)), 'second'), true, 'hour is earlier');
        assert.equal(m.isSameOrAfter(moment(new Date(2011, 1, 2, 3, 5, 5, 10)), 'second'), false, 'minute is later');
        assert.equal(m.isSameOrAfter(moment(new Date(2011, 1, 2, 3, 3, 5, 10)), 'second'), true, 'minute is earlier');
        assert.equal(m.isSameOrAfter(moment(new Date(2011, 1, 2, 3, 4, 6, 10)), 'second'), false, 'second is later');
        assert.equal(m.isSameOrAfter(moment(new Date(2011, 1, 2, 3, 4, 4, 10)), 'second'), true, 'second is earlier');
        assert.equal(m.isSameOrAfter(moment(new Date(2011, 1, 2, 3, 4, 5, 0)), 'second'), true, 'exact start of second');
        assert.equal(m.isSameOrAfter(moment(new Date(2011, 1, 2, 3, 4, 5, 999)), 'second'), true, 'exact end of second');
        assert.equal(m.isSameOrAfter(moment(new Date(2011, 1, 2, 3, 4, 6, 0)), 'second'), false, 'start of next second');
        assert.equal(m.isSameOrAfter(moment(new Date(2011, 1, 2, 3, 4, 4, 999)), 'second'), true, 'end of previous second');
        assert.equal(m.isSameOrAfter(m, 'second'), true, 'same moments are in the same second');
        assert.equal(+m, +mCopy, 'isSameOrAfter second should not change moment');
    });

    test('is same or after millisecond', function (assert) {
        var m = moment(new Date(2011, 3, 2, 3, 4, 5, 10)), mCopy = moment(m);
        assert.equal(m.isSameOrAfter(moment(new Date(2011, 3, 2, 3, 4, 5, 10)), 'millisecond'), true, 'millisecond match');
        assert.equal(m.isSameOrAfter(moment(new Date(2011, 3, 2, 3, 4, 5, 10)), 'milliseconds'), true, 'plural should work');
        assert.equal(m.isSameOrAfter(moment(new Date(2012, 3, 2, 3, 4, 5, 10)), 'millisecond'), false, 'year is later');
        assert.equal(m.isSameOrAfter(moment(new Date(2010, 3, 2, 3, 4, 5, 10)), 'millisecond'), true, 'year is earlier');
        assert.equal(m.isSameOrAfter(moment(new Date(2011, 4, 2, 3, 4, 5, 10)), 'millisecond'), false, 'month is later');
        assert.equal(m.isSameOrAfter(moment(new Date(2011, 2, 2, 3, 4, 5, 10)), 'millisecond'), true, 'month is earlier');
        assert.equal(m.isSameOrAfter(moment(new Date(2011, 3, 3, 3, 4, 5, 10)), 'millisecond'), false, 'day is later');
        assert.equal(m.isSameOrAfter(moment(new Date(2011, 3, 1, 1, 4, 5, 10)), 'millisecond'), true, 'day is earlier');
        assert.equal(m.isSameOrAfter(moment(new Date(2011, 3, 2, 4, 4, 5, 10)), 'millisecond'), false, 'hour is later');
        assert.equal(m.isSameOrAfter(moment(new Date(2011, 3, 1, 4, 1, 5, 10)), 'millisecond'), true, 'hour is earlier');
        assert.equal(m.isSameOrAfter(moment(new Date(2011, 3, 2, 3, 5, 5, 10)), 'millisecond'), false, 'minute is later');
        assert.equal(m.isSameOrAfter(moment(new Date(2011, 3, 2, 3, 3, 5, 10)), 'millisecond'), true, 'minute is earlier');
        assert.equal(m.isSameOrAfter(moment(new Date(2011, 3, 2, 3, 4, 6, 10)), 'millisecond'), false, 'second is later');
        assert.equal(m.isSameOrAfter(moment(new Date(2011, 3, 2, 3, 4, 4, 5)), 'millisecond'), true, 'second is earlier');
        assert.equal(m.isSameOrAfter(moment(new Date(2011, 3, 2, 3, 4, 6, 11)), 'millisecond'), false, 'millisecond is later');
        assert.equal(m.isSameOrAfter(moment(new Date(2011, 3, 2, 3, 4, 4, 9)), 'millisecond'), true, 'millisecond is earlier');
        assert.equal(m.isSameOrAfter(m, 'millisecond'), true, 'same moments are in the same millisecond');
        assert.equal(+m, +mCopy, 'isSameOrAfter millisecond should not change moment');
    });

    test('is same or after with utc offset moments', function (assert) {
        assert.ok(moment.parseZone('2013-02-01T-05:00').isSameOrAfter(moment('2013-02-01'), 'year'), 'zoned vs local moment');
        assert.ok(moment('2013-02-01').isSameOrAfter(moment('2013-02-01').utcOffset('-05:00'), 'year'), 'local vs zoned moment');
        assert.ok(moment.parseZone('2013-02-01T-05:00').isSameOrAfter(moment.parseZone('2013-02-01T-06:30'), 'year'),
                'zoned vs (differently) zoned moment');
    });

    test('is same or after with invalid moments', function (assert) {
        var m = moment(), invalid = moment.invalid();
        assert.equal(invalid.isSameOrAfter(invalid), false, 'invalid moments are not considered equal');
        assert.equal(m.isSameOrAfter(invalid), false, 'valid moment is not after invalid moment');
        assert.equal(invalid.isSameOrAfter(m), false, 'invalid moment is not after valid moment');
        assert.equal(m.isSameOrAfter(invalid, 'year'), false, 'invalid moment year');
        assert.equal(m.isSameOrAfter(invalid, 'month'), false, 'invalid moment month');
        assert.equal(m.isSameOrAfter(invalid, 'day'), false, 'invalid moment day');
        assert.equal(m.isSameOrAfter(invalid, 'hour'), false, 'invalid moment hour');
        assert.equal(m.isSameOrAfter(invalid, 'minute'), false, 'invalid moment minute');
        assert.equal(m.isSameOrAfter(invalid, 'second'), false, 'invalid moment second');
        assert.equal(m.isSameOrAfter(invalid, 'milliseconds'), false, 'invalid moment milliseconds');
    });

}));

;(function (global, factory) {
   typeof exports === 'object' && typeof module !== 'undefined'
       && typeof require === 'function' ? factory(require('../../moment')) :
   typeof define === 'function' && define.amd ? define(['../../moment'], factory) :
   factory(global.moment)
}(this, function (moment) { 'use strict';

    function each(array, callback) {
        var i;
        for (i = 0; i < array.length; i++) {
            callback(array[i], i, array);
        }
    }

    function objectKeys(obj) {
        if (Object.keys) {
            return Object.keys(obj);
        } else {
            // IE8
            var res = [], i;
            for (i in obj) {
                if (obj.hasOwnProperty(i)) {
                    res.push(i);
                }
            }
            return res;
        }
    }

    // Pick the first defined of two or three arguments.
    function defaults(a, b, c) {
        if (a != null) {
            return a;
        }
        if (b != null) {
            return b;
        }
        return c;
    }

    function defineCommonLocaleTests(locale, options) {
        test('lenient ordinal parsing', function (assert) {
            var i, ordinalStr, testMoment;
            for (i = 1; i <= 31; ++i) {
                ordinalStr = moment([2014, 0, i]).format('YYYY MM Do');
                testMoment = moment(ordinalStr, 'YYYY MM Do');
                assert.equal(testMoment.year(), 2014,
                        'lenient ordinal parsing ' + i + ' year check');
                assert.equal(testMoment.month(), 0,
                        'lenient ordinal parsing ' + i + ' month check');
                assert.equal(testMoment.date(), i,
                        'lenient ordinal parsing ' + i + ' date check');
            }
        });

        test('lenient ordinal parsing of number', function (assert) {
            var i, testMoment;
            for (i = 1; i <= 31; ++i) {
                testMoment = moment('2014 01 ' + i, 'YYYY MM Do');
                assert.equal(testMoment.year(), 2014,
                        'lenient ordinal parsing of number ' + i + ' year check');
                assert.equal(testMoment.month(), 0,
                        'lenient ordinal parsing of number ' + i + ' month check');
                assert.equal(testMoment.date(), i,
                        'lenient ordinal parsing of number ' + i + ' date check');
            }
        });

        test('strict ordinal parsing', function (assert) {
            var i, ordinalStr, testMoment;
            for (i = 1; i <= 31; ++i) {
                ordinalStr = moment([2014, 0, i]).format('YYYY MM Do');
                testMoment = moment(ordinalStr, 'YYYY MM Do', true);
                assert.ok(testMoment.isValid(), 'strict ordinal parsing ' + i);
            }
        });

        test('meridiem invariant', function (assert) {
            var h, m, t1, t2;
            for (h = 0; h < 24; ++h) {
                for (m = 0; m < 60; m += 15) {
                    t1 = moment.utc([2000, 0, 1, h, m]);
                    t2 = moment.utc(t1.format('A h:mm'), 'A h:mm');
                    assert.equal(t2.format('HH:mm'), t1.format('HH:mm'),
                            'meridiem at ' + t1.format('HH:mm'));
                }
            }
        });

        test('date format correctness', function (assert) {
            var data, tokens;
            data = moment.localeData()._longDateFormat;
            tokens = objectKeys(data);
            each(tokens, function (srchToken) {
                // Check each format string to make sure it does not contain any
                // tokens that need to be expanded.
                each(tokens, function (baseToken) {
                    // strip escaped sequences
                    var format = data[baseToken].replace(/(\[[^\]]*\])/g, '');
                    assert.equal(false, !!~format.indexOf(srchToken),
                            'contains ' + srchToken + ' in ' + baseToken);
                });
            });
        });

        test('month parsing correctness', function (assert) {
            var i, m;

            if (locale === 'tr') {
                // I can't fix it :(
                expect(0);
                return;
            }
            function tester(format) {
                var r;
                r = moment(m.format(format), format);
                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format);
                r = moment(m.format(format).toLocaleUpperCase(), format);
                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' upper');
                r = moment(m.format(format).toLocaleLowerCase(), format);
                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' lower');

                r = moment(m.format(format), format, true);
                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' strict');
                r = moment(m.format(format).toLocaleUpperCase(), format, true);
                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' upper strict');
                r = moment(m.format(format).toLocaleLowerCase(), format, true);
                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' lower strict');
            }

            for (i = 0; i < 12; ++i) {
                m = moment([2015, i, 15, 18]);
                tester('MMM');
                tester('MMM.');
                tester('MMMM');
                tester('MMMM.');
            }
        });

        test('weekday parsing correctness', function (assert) {
            var i, m;

            if (locale === 'tr' || locale === 'az') {
                // There is a lower-case letter (Ä±), that converted to upper then
                // lower changes to i
                expect(0);
                return;
            }
            function tester(format) {
                var r, baseMsg = 'weekday ' + m.weekday() + ' fmt ' + format;
                r = moment(m.format(format), format);
                assert.equal(r.weekday(), m.weekday(), baseMsg);
                r = moment(m.format(format).toLocaleUpperCase(), format);
                assert.equal(r.weekday(), m.weekday(), baseMsg + ' upper');
                r = moment(m.format(format).toLocaleLowerCase(), format);
                assert.equal(r.weekday(), m.weekday(), baseMsg + ' lower');

                r = moment(m.format(format), format, true);
                assert.equal(r.weekday(), m.weekday(), baseMsg + ' strict');
                r = moment(m.format(format).toLocaleUpperCase(), format, true);
                assert.equal(r.weekday(), m.weekday(), baseMsg + ' upper strict');
                r = moment(m.format(format).toLocaleLowerCase(), format, true);
                assert.equal(r.weekday(), m.weekday(), baseMsg + ' lower strict');
            }

            for (i = 0; i < 7; ++i) {
                m = moment.utc([2015, i, 15, 18]);
                tester('dd');
                tester('ddd');
                tester('dddd');
            }
        });
    }

    function setupDeprecationHandler(test, moment, scope) {
        test._expectedDeprecations = null;
        test._observedDeprecations = null;
        test._oldSupress = moment.suppressDep4 } pÀ% "G4 %
~ÇG` +¸[v UÃMôd\é Y_^[E3ÍèçC2ó ¥Dó]Â MïOUVW¼rû3íLò¼ õ wSÆD¸ Ú ºÐ£:uÛtY:ZuÁÂ Û;ÉëÉÉÉ¹ ?NëíOAþ@Rí$O àSíN¯:ï?dëí Q &[?f\$S·Ã-VD$WÓfP  Bó á@Àº qÁ  à÷u= Eº4êá)T$!-ÁIîJ# m sté$­à>à7p;ðã 2 /Ø [1¡CIÅ_^]/ØAïØ  âO SP ¨A8 Ù"R3ö°AN ¯"Cñ
  $YBåòõBZªßID
#Îuó!L!Iâ\_éâ _ ,â_ ¢["wfSÑA(¹!íï oý
B5W_   GáCàF ñæ \"f{`s7ECèõ7OYÄ7;C"*òs?â+â( À'ûâ
  !#â°äæâ& â ;â8 ÖßdëGÁD ç oâ
o#[ Öß pà'O9FEoâª¯
 Cw¥ 1Øâ4é $C0 äà5F ã0KýÿVßã`<ãà ìI[Ä$J¥? ¬@äå?ã	  Aã5úyOÄãã& 8ãú7O%?ã  3jã7 @OI¹$·ú;Oco °B ú<OBþ d KÌèã!E 40  EÙ\$ &D$ 5ëF	 yÿ  ùÿ #  è ^£ýi@9CCÂãCãMÏ£è_ &(æ
? }  ëæ°?¤àã& ã {? @"Óè6_/K L K æ;? ßÏ ð%à7Oco Oý;CF X ëæ¤ç& "þ â þ læ
A6BþBçâþ&@â"ÿ ï"èâ
ÿ Í â´ÿ Ýâ&ÿ âÿ Ë³Eâ8ÿ K è'ïé?£O  à:O"¯ ÃO ¨à:OãOØ¹þ9?)¹cO  ã2OFNãO ã
Oñ2ãBO 5ã
O m ã³OTÚã&O hãO kK `%ã8O K h Kå7ÿi Ï pà:OcO£ï xà:OcO£ï à:O#O Ãï à:O @O§? à:O £ï  Kã2ï  ç?|üí	^/ãBïòÎdÖã&ïò	ã8ïeÿà£ó ãÇ6,eCSÒåÿÒpÅs, C,XÀLÒ4Á [4ÂÜ,â$é(_ìÎ_DÔâ&ì	_ºé:_¥ üè:of¬_ (sæ7_f¥ à:O&cé6ì_á)âú` â(ÿ ,'°é
 
 é³DÑâ&ÿ é s °â;ÿ ¼¿Ì½ë9o"ÿtp! |"«ç @õ \CöÕ å ßë
T'â	U¬$|ÿÿÿì\¥jÿhÈ¹d¡ y Pì0øÅ@SVWPEôd£  ÁEè½ 
3Û]ðúaÀ  HÐ 
MÈEÄÞ]ÐHÝ ô !Rà&ß|ÇÿEðU ;Ù+Ñ@¯  úo Pà a÷"_ à[úÃEÔ ÷ Ì 	 hPèÎâ ­$fUÌ·EÔË<ÈEèkUÔfÌ"MÜè¢*] MÈ3ÀÇ>  EØMä TÜh¨:1PèÁ@T "5KMàà$¿ 4 ÂEä'­'ªÙXøÿuØ@b ´`b ^à b H`b fì ?à_ ü _ À`_þÀÂ Gà&_ À¿HjM ¿ ^ Ð`^ à ^ J`^ãuà_ë lEØÁ@!!øe;vEÄ"ÙEäSA? à` à á?? ø`] ì`]ÀÁ=ÀÞ @à ßá`_øé;"` `à _ I¡>à!_á`^ê@^ à ^À¾ã"à_EäCû! uAF=dF  våX áÿ èÄ#Dê`R  à:R #ð@R R (à+R +p$F¥Ù R DR 8 R æ$àÿàY  Yê`ÿ»ü àR  R R D ¬á(¥à¥]AR DR P Rà>ÿ ¸ ¬ê`ÿ \ Yà7¬ ´ R R hà:R ¼ R DR x Rà%ÿó"èV¹ ;Â]ï:uÛtX@YuÀÁÛuÞ3ÀëÀÈ!é +"ÇÀ @ ]ð&Ï C&Æ(7ÿ]ð&hèTQçÿé¾3¹¨ `: T
]Ðu$}ï t e b  h@uÔàj à j@më¸Ä N
:uÉtJ:H@§Â AÉuäà<Gy§+ éS ¸äà"A F'CFä!¿$O!bÀ!  ¸ ;2  ( ø@}: ¿ Ò ¿P:Q@¿g Òà¿ Hà}Ir  à:à ¡   ê"}à< ¢ D ÿ  à"å ¤ãþ ¤ R E  R 0à:R ¨ JA¥ ò!c R @ Rá!ï#àª ¬ W W H WáÂàR °`R*¹Pà+NQ¦KÈ@N ó{#Æ£ÅèMç'] ð!Nô#6uèÿ¶@)
Nè8 f¾JÈpsY1ä A±ç @ùÀ@ºÀFqè/p YÄ2,`ÃMôd!9 Y_^[C3Íè¡ ¥Kï ]û ì^¶¦Ä$[­¾ ¬ G2ÀÙD$3í\$w-K$©aï ?@ / !`Lá¯À `,T$$E+Ñf`Oì;!¸ O Wä
 àXàRD$PÀ ,¬ÂJ;øu,fT$f\$·Ã,  Ó fSo?6#)) Ä.óì û
O @K Ý"] ï °"¨à$ïà
O!;O¬à8O-Y=Oò;2?íB ò) 9&` Efiâ¦^ C8ut{ q ¸aaâ OHào &æ æà h#4ë¨  {@ 0d u&í!º(ÀÅ_Á^K$! ]Uôç ÄC¡Ã¸ì¤ ã¯   £¯ ¸ 
Ùc©L$(l$±èf]e­  "©#± $ w .vÍÅáD@d)²'ã Â.ÿ(§' Û'héèZ@  E@Cé	 ¸ Fè@:%ã`FEÇC"  @IéÂ 	 ¸Dv¤?M è ë M¨ëÅhë ãè ë  !Â E( 0$@Oä,"- S"-@` í# àV$~ D` 8¤½ä D ä $ 0d"Ñµ@É¹póç!/N2A /­+D6tj J x J!ßåo 8.àLÙ\$$&¬D$$ V& CZÀÆC!¥/¨ =iíC# $ã  `3pBºèEF'N$°@Õ Å¹ÚCBþÃ  Uì3tºó tìS7 ÅEðóshJÒEUPT Çl  f è1"}WY~X È º` 	 ËÌ].Sg\ Æ0  Ç4@  @, L Ç8   ?Ç@`	   % Dà 	 $ 	¸(; `6 , Æ(  fÇ<  c° -° 0f"ÜG¿ ÂµH Añ a !¦Lïá!ñKÿ`íe6$Ï@Xáß a7#0«¢ ¥#º@ ÖN¬ðà! D"'uÙ@ú!^ @",ZÁXH× ANâ2a 6Z{ªà!{ Lxàþñ_àÿ Àÿôèà! Hàã_à ô0ÆA V Àá" 	¡D @ X"CJ-â% !áÇk b"!¿ Y¡  µ "£ È=1à&_ Pà e KèMNçÀ» Y  [ ñ"q +à NÂ|Cå"|cí¼ ó#ñ@A_ ö&[ b¨«á!ßà	b¤>dFàb@@b b Ü!Ââ!! GÇÂËã,Æ ¤!A@ Fãâ$	Ú",p!P&ï+Ñ&/IDÿÀuó"&L \!B@[à$ß 'à	[?à_d |PP@§N1¶ç N0f@ ·`.R+ÓFÙ @I8p öC]efæ ú àeô f5 (Qìø+$ÿ$@] ½@KR¨!WÇP¿!X èI "µF1ðf¿ #s`seÂu dÔ"u´ 6@B@ ¸ EÈ  fq@ Ì Ð ÇÔ @ ÇØ`	?fÇÜ 
 ·@n	ÏPè£¾ôÿéS à ¦ $  Ç`¦ + èu × ¦¿( " 0 ³Ap 3É9 0  ¯Ü¶Gxøu  YÁ ª AÀ ;`2|âéÒ ià  ¨!h!! èÿÿé© 	à   ð&â   è gÀ¡ ¹D«!M9¦ C@ sc¸áP | @@  á@   Ç @ Ç`	a@  
 ë)à  À   ú  èsOå¡.` g[ÆµBG§  A:AGÆCp  e C"­ÿ3ÿ9¾J !JÆ	WÉ ¯F/ÈvW ©G ¶ºèë`	ð¨¶Àt@ë   Fe `ÀtF#® ³x uëFÀtx@trgèôäü@.`~ tZ½@> tQ È(÷¸  Æ(~ u3É9÷N     YAçà XÀ= õ|À âsGÆ ;¸`þ «ðë3ÀÆõ!f f . hHóè %8I¯ÆEü$~t%hh h kÞ jxÇ  6jW½C>èM ë3ÿWF= ;	 PÎèèDøÿ¸@÷+Ç¿@8[@ß~!0fÐVè»G*`z$ÍïuÝc¡  *`ÿpüpü [jPè= xÍBÒQVè@¼bëÁñ£Mð1	 3å]Â fûX ¢Y #Z D  Ñ *æà  ìNÞQ¯N­ÿK,3íÙLÆ1­ « ;)+ 89ï ßÍý  í)ý Ç"§^¹øW+
Ã"æx&¯m¸   E`-ÿC`¹X@HàDlàD®éO"1¹ `H&ì¯àJ"n é@J `J /à0OD±é´$*¹$à<OBOéd O¸, O:×Ñ K®å Ã& ÷ÑAnÁzO3 <3  	3 ï// (ïM/àVï/ 0§àP®ç à,fTï/ xï/ !O( )wáâï/Å!î Nê#àNse vN ¨ê"xàNsd 'N ´à9NpkHf ì ø!;ã o =.ocúj±ár oCAb b#¡ u ¬ uà>ð $p (ðvÑ òDë¹ñàAo H`o Lào D@ß o à"o ,ÏAT Î'$&£Ù[d@N 3N (à9N h@N ä$;! 8à9N l@N N Hà9N p,a J  X Jå ¯á: tòÏøÿR ¨@¬ Å²TRGr	U¬$|ÿÿÿìH«2 Pòì8¨ÅJ¡SVWPEôd£ O Mè3ÿMÄ}àèÇ] @}ü]Ü;XúD£;ÈÿÇEð  EìçÓ   ïÞAN ã Ø/gã ";=.½"9 \"<@L LàÉó#ÿ g N
M¼èìçÿEæ)  ë Ð ¼Pè·Ôø.úEç "  èe2çÿ}ç t)MìUèEÐÁá}æ D¶D	jÜ jÜ .P 	 ¬   õÚ ì/ùä    A(  ëÄ;ÓÁà SÙ\@ø Wïã!ñ  ÀVq M`VUè Ê V f Êe~½v´Éå"/à ¯à
XA@¯¹; àB¯ 
@W£  Wá)_à¯"XtA#¥ Èâ"¡ [##èV<qö!`EÄPEèK¾Èè  tMÌb:ºèÁ$ FÔê ¯#p"0U pÙ µð × P ×^ôO& à[àSEØ#7 Ô   ¨éf¥héA v  pÌÁDîà ÏuB ogz ò,MÌÀ!V§D¾ô û%]Ü#G
}èÏPÿ3èC%%uìuðÏÿ3ðè2ëþ0ð "Ày3Àëø¹MmOÁKpÃö}àþ$ö%Dù _A÷>.!Ý Çí2þÖÊû þÖå  å Håì½EQ@B¥tquäUÔ;ØtðËè¦-"	Ã;Þuòuä :UÔBAÆA>M¸PEäèn ¿]ìM¬·ëC  	àè%I CÆ%&.HKPÉtèèÿëè-öNòÇC!í!&4]ØC *)ã`) )MÌ- + èzÿ\Né !§ ! íB§æ!³ N"6ãBß
ÿóßâ?ÿà SEè"û Ü â ÿ ¢bÿ_!fUÜ·Eè·ÊÁsÄ "cÁUèfPP; ø úÃ\ôå!Ê !Æ$qIèç7çÿ ø%Ã@K ®K h K få  > ?ã&o ì!sðAL@w 6w | wá²9]àuà9à{ <@{ º5ªà!{à5ñ =@u Du à"ñF$Mäè46á² û"¹%$  à"Há þ,èè5àK ¯K ¬ KáO!ØèàKtgjh¼ Gÿ6ÿpIv  *Q#¾ÀPèn -h|a$@Äè¡ç6ØMÌ$$è=  è() "©MÌèÝ 
MÔEÌPèñPC®Bµ óö ¹ þ%I]äËSèñ4 +SÒJÊq'ßA#Éù+Î@è@à 	EÀQRPèØÕ
E¡ð ¯;þtO$«%Gj+ÁPQè8kÑÿÇ2O$©ÄÇG$s  ÇGdºFGFGÇ1`  F# F#MÀ OEÈ OèjÑJ.ë&@;K]¬ $hQà Êù~Wÿuä%lèõ$ó$tHu°;Þt8WÎ+Ë+Ð;Ê)KuØPVSè0Qñ W  ' "ñ ¸"l ANë 3À@	  	ÆAN 4Ü@? Abº'çÿÛtGE´+Ã=Tg
r2öÃtÿ8*KCü;Ãr +Øûs û#v 
ØSè=ðeÓ@­ g REðMôd  Yæ×òôæ
×À ì_ ÆSÿ   =³ÿ ¸ 
Ù3íSû2ÉSf2ÒL$¦ÁT$$CcN
  ff$L¯,St$,@ êF.¹à)Åä4$­'D¢4 ,=S2è!óAé	  ¹< LM2ã oàO  éN@O Là<O! éþ"°¹Xà<OCé®@O hà<O3Ò é^@O xà<OC¨é O¸ Oô,oDB éD¸²G?M ô ¹ M´¹ Å´¹ ã*$À&5ç% $å E Aðßr 9"0%â,~ õóàNkV ê!> Nÿ#Ê E$Ø@Òâ%¯Á%§C& q x ¤!d ã"?ó4OLÝCó AB ¬ záB_ö@ó!Mè/E Æ;ÝVit	Cdõ`²0 ¼à"\ CáP$¢JoáÛ©8CM!N m!N Ì và#?ô
* ,:ÝD$, âóC sº $ /¨ =À ùCJ Û#Î v Tõ"a 0âÜD$ k T ¹! ;ÝÙXD $¶ÀEÁ 	A² sg Ü Þá$uàm \ÀmÙ[Há´· è ^ å%â4 A@Ú %a!B ô {áôuBâ0á#ïÂ/ @@y y éð"ïäKl| Î&{ É à:O T@ ~O à#Oá4 X@uQa Å , uáa Y@y #  y < yí oá¤C\#L@O >O Là7O ` O î#  Ð)+à¹@4NT$0»:¯
K ö`\tL Xár àS àO;5 PÀ 8²KêKOK ([5f$  M·ÃÈtM Ó fSt¤*)ì VÅõÿÿJ[*U·Ct¾S.	f;ÆsKL¹ !pf;ÁsÒt%FCDè~? óY "=EOD~°÷ Wüé ÄJÜwWÀ ì^áêï !F7G¼w3ÛL$^ì äAí ÷(¹ U%ê ßyÍ Õ *ßæ*¨ê!ß  ÈJß\ç 6Ãê#ß\$%¿C+Ç@ß~ª d Lê&ß FàO !éÿ)õ¹tà<O% é¯@O à<O&¨ é_ O¸ Oê?Iõ àæ @ é ¸¨ F1ê?& &ðA{¨©*Q§^fE"Ñ(ÃB- · §#r ° \ è"ouà^'¹ W 
cÃbT ¸ TãÇàO  O O Äà7O  O Â!ì ô Ìà7O  O rO Ôà"O á?E  N #N à Nå_àO  O Ó#+ î ðà7O  O O (©à GB,â¨¥EBT @u.¹ uä"Á Þ#?DÁ7ú Ã#?ëO# «L¤¿A$é%¹`FàD´ÀDÇA$ Â éJ H¸$ Æ EO î  K® Ã® äî  àJ D éÿ  ¸Gä@Ó!UÂ 67$C+ÑE ¶Öÿ3 óaætU"2`Zá1 %àQ ¥ß/à X' G` ,§ç  *G G ç AE§fQ(@É'  ç ùÿÿ]'SRÃ2N3Ìè©âGRG?çR U>¯ d9©ì^Â>¯
»d¡!^¯ PhÅ@5'g7þ ¯ì½G=Â_'|EÔ]ðzèç\ WÀ]üM¤]Ì'å8èìæ\ 1 ¬4·èà` ´ èÔ   BÙ° ³Þ]Ü@ ëh½¢á} $O6üÿ%ì:tmJÝø5 @V .V  VàR  Ob
ð ¡¹à"=à J4N6 RÄ½ä àRàãÙ¨R JR Ìà:R ¬ R ÷#± øÔ'{ ç#þ ¿@«Ù]à*EàbAU \¼©á!áU ¡U GR È Rà%¯àX  X î$o!$15â ?àR  R R ,à:R  R HR  "§Äã? Ã?â®f Z í$!!  ´ ZàSá ô£ R Ìà:Rpø12÷tK ¡ Øà:N x N$Dö@t)÷t   >á #Ë·@pÁà@ Ç`@ BÖÏ <¹è  fç o A$lü0/¡¤ Tz ô zá%ÿõ ¾V¹ ¾(_Â]ë:uÛtX@YuÀÁÛuÞç&EìC&Ç @ éÎ(0 $ N: B
]Üu$}ë t S P  V@uÔàX@Zéu X¸L X 
è ? J¨? Âè?à¢%+ é+ I¸@ KàOá5¯¹±¤ ¹Pàã¯à5 º  $ haKÿà ä/%×EÌ§+Ð`Ó x`Sà Oà5Ï ¸ Ï T{ `{à$Ïà5ÁÏÔ`û à)å+8YT zY ¬ Yá¢àR @ R 'R ¼à"R Gä¥ç"_%2$b w1D ~ ¨<ù"û Ìà"~àÑ H R UR àà"R EàÑ LâÿàÏ E |Ø`Ï ðà"| Hà|â!¯à `  Xü+-àÄ*Pêá = ¿â!_ã52 b ¶¡a6  x á ºâ
 L V JV $ Váà5Ï ] x Ñ?_"Ö 8 xà#Ïà5| ^ | T| H`|â!O!Oà5 _  Ô?o ü \àg g  T làg h  Ô?/ ÿ àg i  T àg j Ô`ÿ ¤àg k  T ´àg a  ÔXe¹Ìàg m  T Øàg n Ôaÿ äàg o  T ðà)æO,U ú? Àæ!OàR0ZR §R à:R 4 R TR 4 Rådÿ 8  Ô-U"ÿ Hà)ð p¡Ú yZ \ ZçÐá  ­ &R hà"R ö4áèÂçÿ¬ò Ýu |à+H¬èyàH H  Há&¿à ´è)àO DO  à)Oá Ì¡< é/!ê ° ZáàS Î S S Àà;S Ð S AS Ð S ê"_á O¼èÙ	á è ô04 ôX é$_¹ :+îU8'+Ñ¾¸ 
øx Pà a D ëÊ à[àSEä7Ç Ø  ¸psø p$fUØ·Eän?þ 1ÊjUäf1Ï;ó1>ø kPèÿÿ}À }ìtpj E¼·¤#¦PÎèÌãçÿ Õªè@Ñ ] 
Uè 
øtÿuÔèËÊ@
èØçÿë>ÿ·tø8QEÿ·SPPèíxçÿ8;Æt@N-dçÿM 	èQòæÿë@jèÔ[çÿf¿@pE8l
Mà¼ s
6`° 	ë 	Ø§è   @M¨MÐQ!Â?ÏA9ò
ù+ÊEÐMÔM Ã{ ðÇBBþt~Gør@jPÿ7èI>ÑÿÄÇG0m ÇG1G
  rëÇÆ ~sF2Ù	tPVWÿ,Q(ë
Ç'¨"JFGFGÇFN 8ÇFN6Æ4 @þ@ `u èÆ=`M°ÉàÅBÂ ÅuìøÆ@È÷t; i@FÈ6èEà
y ÈÆWÎ Ëè:Ñÿà @?M¸MÄá	OÄMÈaO¸Áà  ´àj@@ö<`Ïàþ9`@Ä `:! º;"¸ÓMbbI÷æU» ÊÁéiÁüÿÿÁáð¸ëQ÷æÁêkÂÊÁá ÍÌÌÌ÷æÎÁêRA%FBè¼ùæÿE¤ ´`¤è¬`¼è¤ ÃMôd0t  Y;r[53Íè0Ç ¥[`]Â  \à Uì;t Pût ;g»w#¢»nÁEð¸,%À u MA+AÁøàså];Ü}MØ;]w;tË\ 3[3ÉEìMèV }"uÞ@	 _@	¹ô05å ½Mÿ¸! ð3ô&þ ¢@R RÀÁæ!0ÿ Öôî!¯ }%R²OH: û Ìàg I   Øàg J  û èàg K  ù#Í iM¢ROBI ¾YÈù ?àJ sJ ø!ô"¯1« "o; .¢î Y§â!î3 S P##A@ñ Ì Tº~:uÀtA:B9sÁ8Ó&¥ äùã ]` >©cÙ0 J@R y #áþ) àR 4 J@R &  RÂà!ò 5!áMàèÕØ%.MðEàj P&Î 8%^ÛGß à  èQôæÿ ~¡ ¹· à"lá	_ è L l@Lº(@L á_3ä é Þä ¸ ÜA2 ó%¾!2 < xâ%à5~ ¹`~tx z T zà¿"ôå< º@{ óê ,ùÿÿ&EìMèuðP´ !+	¨ò è{ø'aØ"^ÆfñèE)ëç^fêçJ` 	U¬$dÿÿÿìGn'Z çZ $§WG'gç`Mì½¤!MÐG8 ð§8;Ä\ ]üA¼ uDÑg. ]@	¹È£÷![ì @ÐèýæÎ) Hæâ&BÂF¹ :áÏ +µ3É!z]#
fH éD¸ H  H få _  JC*àM I M   M KOì¯@O!ðàO ù @ ¬à+O àO ©@OV¸¼ÀOýß`!¬àO Y@O¸È`NMàO >-Èêá# û3A$B ÔB¹Ø zàA#Ð %~ xÉ³ ì$A@O O èà:O (@O 4O ôà:O ,@O äA}làï° 3 ðÏe"ßIïX_ è$W à Ï_¶cï _ !/_ à/_ èï _ #B¯_èfP0¥,# õû%/MÔÉtMMØ-U î¡ØMÜN¡f´-Q!Î ÁO;Èt
jÿ'Xè®I-MùMAQM/m[Dïìæå	U E,´{ºì´åfì !RFÄ$EeSUVW¼$´ é,_l$%AL$ \$F $Ç08% ÿ ×)-& t$b,  !ÜÈâ%Ì C b Î"ËD$ $Ö@^±`O (à7O $ O aO 4à"O #làa Q Q$15âÎ uIãàQf<!T R¼`ô ,à7R >àR iR¼©EÎDßåÏàü ª 8àW W È Wà4R :àR ¾ì ôà7R DàR kR ª@ýî!áª FàY Y Øà7¬ @àR ¾ì äà7R BàR kR "Pà;ÿ HàY Y Hã-OL#ï"öÙL TCñ ¿ $A Tà9Q P I@Q m  Q \à9Q]@Q Q h Qá&OäLE¨!@X Â\è.¹x XÅãPæE±^¹@6 Ãã$ßEÛ%éDL1íéF ¹`LàuàG Ç`G(7 éú P¸¤ K:/ ÉtK:HO ÃÀÉï @E M à I) é°@I ´ I5ßM à N M N Å N ãïO  äÀl$qP Pë  Az G "% Ä``å á	ÏQ I¡Ï ò< Ô TáIàQ RàQ  Q àà6Q SàQ NQ ðà-QãÂ T TAJ ü+`!J Éà!õC!1( @? ¼? à"?á5à \  jQ $ Qï%¯@Fgª käáÃ´Â` } ì,À! 4 }àAu?àw*ïç¯ y Ei uv @ và?uã.#*E8!A %O Là.Oá]P@O Õ#Ö! Xà#OLùDªê,fED   P h Pá/àO F OS    Tç"á? d N å% N x á4 \ O½V à7O ` O E  à5OE+ O õ%µ ï]UàïÀ@4NT$,C+ÑDÏï \} ó`_tS [ãuà[àVD$PÀ 4½UÀUí õ%fT$f&¦·Ze·Ã=Z ÷ÓfpH$/ ;-ó ,Þò-ü-Hf½K;}¸!k f@º@9K~ C@·kf9`"@` A < a }	3À @ 9Kè@"` 9@ 9@@` 9I·À9@ 9@@"`µ  	3ÀÉHÈ( höt,àMÕ @, 
ÀÊ;Á|@ÀüÂ-j2 @+	ÀUTOÁ@3 IÈB`N;È}+`=Â`U}+4 @-MXNg4 p u/+ $¬   _^][3Ìè¢« ÄNÆ.×T/ 4.ìÌ !4/ Øô/ (èÅÈ ô/ä½Ô MÔ.íô /°ô / HDV ÞD±W"uÈ£ð ºô/Ôèhéô / ã!þ H Çæ' %1*Mä% #fA@ VTôå! àP @P ;PxÀãaE¡`¡EïE ¡ÙXf ë!h ÷DàO· 3 PUH#»1ûï 
ä P Xà­ àYàSÿ Ü1ÿ H¤	¶Qä 	 $1ÿÜñÿ  ìQÿ"ä óä »ý$"]MØ#]¨ Ó6©2 ®ò=ÕðMPèX¢2}ä9D	w;ðtjÿ2Îè71û~r¿ÐEàFEä®21
,½} Äx ?r PO èäæ2*ÿiP M?iE,?² é@ he5M0ÇED ÇE@  ÆE0 è82 } w 0 f à¦÷6 Xà¦ Ì`¦ÐEÌ!U â¼à¦ à ¦ =`¦@r è© M ¦MDó0èC`çÙ ÜÃÿ¼Cò3s§SDSìUVW|$­ÒéT$2îÇ9t,_@B8 u÷@$Ô 03E03ö 
,SE4Ëÿ2ÀÇE #  &¤&.3ÒM$/3 ÇÉ~¯ O
éuø8Ïhà$?èÕò"¼tAh;OFèx ,  Zë"hèZ @ 3 	  cL¼ fh  !Ïè9  À( ÿwìºFèâ
 ht`cE,è`&t
»@A Æ ¶hhè÷Ô@At	» A \'    Ý
»* 4   ÂÀ+b  \  §3Û`g@½!Ô=Ë (~=ï }
».k6=ù 	~=ý  }à=þ  .   .à µ=   
  à =     à = ~=  }Àh¬;ýÓ`ù !7 F[%XfE*h´  Üà  (-h¼  »  ADûÝØ Ch$ haí  E)( "(AB=;L$À$* !!]8ë"t K|$0 [|_ÆÇE<! ^]ÄÂ !Uø~=ð  }   çà  =ñ ~=% |¿@'- ÿÀ@	ÌìóÌ]%³(áSÙ!² U3í"ÝóD#CVuW (X  ¶ $  ³út'út"ú	tú
t tútút	ú ~( Ç ë$9t#A9(uø@% Wæ)<$3í#;í~
Í !7 Èhª;!s(èNÒò"êt!$ÿpá ±ð!N$h 'è*# `auIè #ª `  &   J  à JAºÙ\$( å j!Â âD$E;ëf!2  ñ ¡#õ!*(ö?ÁOÆðþOñN³¸"ÙÀ!x tF |é(º3À[ÄÂ   4 ôIñ0 
Bÿø"Éÿ$Æ ÿt$0H GWèë' (øÅ] =3í9/ì#fïE?$¯à	# È # à Q Ú$¤)a k4Wèå6 @e èÀe
Éxù|3É  0kÉ,WÁ  ËèY;à+¼`ò uLjèÆjæÿ	`èCFéÿ¡@QWÇ@ }ÀÁP#°è.  éð",à
S rà	SïEàS óàS ø Ièz S  	à
S à	S à	S àS  aè¶  S HàSÊiàû Gà	S5>àS  aèr! S ô à
§ và	SóDàû"/àS @S ^"< éK)à
S "à	S à	S6æàS ,@S
(  ëOà
PÑhàø Nà	P àP <@P  ¢L$#g#vH "«@âÝuÃ #&@   µ #Ä Õ  ÷  w  Ë Å s  Ç   /@#Uìäøì,UÂ,ù'áL$9
t.qG¯ Aÿ 3ÀÇG# ÇG$   $ #¹!ùòÀ~vèGå6Îh|«$^¤ÍòD^ÿvÿÓ$LGh Îèàhç` nàhP Sà$h4 8 íNè' GhD  $ê @æ_  hæ(L$èµæÿJ^ÿÐÿ ØèÐæÿÛ öh G $èÞ´lÉ@+ Ó+   + h`+(,ëZh0,è­ 0@- ¥- ( - :à-!ý ë,h,-4è - w- 0 - -  [!t  %­ y @!ÀA ;",uþ+eG$G(G!kGG3À_^[å]Â Ì   f Aì<óé ÓWh0ò-¶ ^èý³*I ÕPèóa  ÏA  E@°   3ö)è$Á91)¶@F2 3ÿ3Ûö| **OñÛ&Ï ÃÂ!} 6Q hD y"xËa ! Gæ ÒEhP X ÁßGèF ]°h`# 4 !ã CfË]Aä h à
 @ pôÊà	? @ x Ôà
WPh ´à
 @?  à
b  tà
 $@?  Tà
G¤h  4à
 ,@? ¨ à
 0@ °ôÉà	ÿ 4@ ¸ Ôà
 8@ À ´à
 <@ È à
 @@ Ð tà
 D@ Ø Tà
 H@ à 4à
 L@ è à
 P@ ðôÈà	ÿ T@ ø Ôà
 X@ óbÃ ´à
 \@  à
 `@  tà
 d@  Tà
 h@   4à
 l@ ( à
 p@ 0ôÇà	ÿ t@ 8 Ôà
 x@ @ ´à
 |@ H  ãc ^@" P" qà
" $o@" X" Nà
" "DC;\$$û% Ç*r*2Âä û@ &ÿ3$xEd¡ 8 Pì '³'PEôd£ P¤
h@XMÜèè®%uÎPèÝ%MÜ%sÊe]ìÇC$Ì  ë\h\ 1 ¶ 1Eö ®à . Dà.)C ë-hdñ&WMäè . `. ä ] `. [%u CNS¦èo\ %ö3öÇEü  Âu92 å u(? LÎ'¼C,  ?3ÿÆC( fÇC-ÇCt@ÆCp  A]@ P L C`  ]   :Æ   fÇ¨ @ @º` @	   @ ¬   ` ¨@	  ¼ @ P   ` L@	  `  Æ` EèF1 À!DMèPC63 ò&ýhh!/&/HÅòåë [eK ¼@ (à
eë ° à
eË ¨èÄà	_f À Èà
 B¥ ¸ ¨à
f t¿ æÏ v fÏ # d &Ï /ã/]ð!ÚEð h*C,ZÀÆC0f/¨ =ÀC(h> %à> t`> xà>ph¨>æÃà} P`> Tà>Lh¸> §`>Ð!æàÀbc@E"àHbté <øAú¨aú M`YäFt@('	 Ð} *à
" p " °E à
" x " ÌÂäÂa 8à¾C`¾  8à¾ChàG `GÅ ÄàKC:`K °àKCKé <ø hôY B`YÁ
K!D Bk#( à" @@"  ×üÁ`ç¥à E < "¼!ÇEà  ]àEðfSEÔh ;Pè!éT EÃÐB° àä b«ÙEæ`6 `6êà6 6 à6 `2 `2 ·à2 Y27o *. ,Ài  !ë CÀ ®û J0»h  G!  í%T!6áØ àCX à!>#Xd­a T!áØD¾%D¥Eè@$·;ÁK&m ?es{ ux»CÉ to  C%XÀó\Â#§¼]r(Ê È(ÁóY`  ë-ûXÂ(È   \ * X YÈ ; K K/&= Kv&" `jFV
ÜÃ&« Çö
å]ç  QKø ñ1ÅL$ÁW+²9)t	@EkÃ3Û3ÿí¹ À K¿Áÿ+¿ Ï  0ÎegèÂ¿b9 ! C¡,!DÙX#h à#hºe­ zà#h`÷ V#B\Àk tk^2E Ä ÏG;ýK!î!wFèÛå !1Ä gÃ_!+F( Yá @ -
T3âÂSUé3ÉW.ö /
  ïï 3ÿÇE &Á5ÐE fÇE,2""p V&±Û~Ã vï	s¾a' ì½  h,b | "N¢Ì>0í` ]ìÖ !ch² ÔÎè=à
fj ²`? à
g
Ìè`ý½`~ 1!Ä ~4"b0G!3EC7ðæhÁM!4inü.{^Ç_nîj` )^ *$Âá ^ á^ N	03ÿfE3À AZ Ò!ZSVð_aU D¸áU 2  hU)! & !U Ö¤Õt÷  	ár$`ê¼`;ár Ar 0 Êà
a¨} ªà
a¨= à
a Ü<½  jàhé` K·PO 9 Eh`  /Ñ|$è4¤,*°#*SÁ¿j±chü@($Gè@% Dè&PÍ &9k4  ë3h`/,èß£ T@.Ö`UPÎ kà.!±  # |$YD$8!ö4@!Í 80¡"% 3B% ["YEèAâã ÇCE7Ñ  "<ã  £ C   & ã
»aßâ9øºòÿÃ ì "9á} o Íâ	 ¯ ­à
o  à
4"ÈaÝ mà
o¦  ? Mã¯ c¯ ã¯ !Ã¯ ÜA!vã¯-ôÙ3ÉVW9
 % ã¹	fE3öfC2j!ê C¸,@ ú4 f??Ïhc¹¹aa¡{ÿ ¹Ïèl ! Nã¹ÏèOúkü¹%Ïè0 ;HÙ[c¹a\Ïèà
c¹à£c' èú "ä -ò
bãC¼c9mhx9,FèÔ@% ½èË&C
 `& 9!ÇC! ë=hh34è¡À2 2SÞ -`2@0#pC 1 ë
&Ï #G E#G (pCF #F;# ¢!¼Æ_ó Öì¤ 3$¨@e!° L'Ö
tfæÇf$¸ 'Ek Iaµ Aµ ï8ÛS5ÿõ	ÏESèÔ·¡f(ÁAÐ$² ·¡ÒD ¥ h¼~`  !Òã3av<»!¶Îèyà
e0hì`? Yà
qZ p 9à
qZ | à
qZ ù¶à	qZ  Ùà
qZ  ¹à
qZ   à
qZ ¨ yà
qZ ´ Yà
qZ ¼ 9à
t Ä à
d Ìùµà	ÿds Ô Ùà
d³ Ü ¹à
t ä à
t ì yà
 @E ô Yà
t ü 9à
t 3 à
tªù´à	ÿt¤  'PèãDÎèÛd 'Pp¸D-rÔëg}(Gè¹ )Æx$ ®, $ , C`,t7D,W éc@4 Ü40è 3@] }0 , 0 à0 * é2 hä08èT 0 L0 4 0á·@`a#Ì é@0 ì0@è# 0 0 < 0 °à0 @0 Ð hô0Hèòê`ð D 0 à01¬ é@0 ü0PèÁ 0 ¹0 L 0 Nà0\ìén@0 !¶(Xè 0 0 T 0 à0\!é=@0 0`è_ 0 W0 \ 0ì¶à ô[ªé@0 0hè. 0 &0 d 0 »à0[éÛ%¦h0pèýôõ`ô l 0 à0Eéª@0 $0xèÌ 0 Ä0 t 0 Yà0 A% y@0 ,@0$Etè 3 3 | 3 %à3 @3 E@3 <3  èd 3 \@3$S¹ 6 î:¸¡ò  %é@6 Ì*G "  è- 6 %6   6 ·à6b) × hDmSúèöî!$T 6µà m  1}XhP6]dè¿ 6 ·6QØ 6 I6*PV 6ëlhX3F²è 3 3FÍ 3 à3 W@38h`3 ° èW 3 O3 ¬  3 á;=!@g X 'A|$'A 'Fõ @(¡».
ùÿÿ[EÀª2bw1Åd¾#- fJ  è × m/ºZÀò.A Éò 
óEôîuÙV^Ä@­*´lé ê¿ ):UW'îO C?A.OíÆC*¿C0¿ F!¿ V' í.O ÅîOJ°d®çl 8  h®O , 'lê¿®O çª¿í¯`>àOÓÎo Íà
g«®o ­à
lÜ 8 à
i¢® mêßC !ÆC$êßKJßE;lLi ¼)"êß Q (^øU3í!W9*ðü f"- \ÁfAQÊ A Âoß ËñHþèº®a2á ¨ i5&.  !é7  ü á¬¡L ` ð9 N 0éAht-î ` ;  `à$ ) $  ìC;Ý81 Yâ¯ÁB­B¬ï3ÿ!0+ç J+XVDËJ/ í2 Åð	÷¢­`á  Á   ¶á gá;`ò Hâ¤bD d&! (à
jpØ` à
bÄ äè¬`à_BÄAM¢c AO$+ C1"¸7/Ð]  Yz v+Ë' ?ëR t7$:`+C (@'À ð >@  ?C/ÁSÑ`?@Ç ÆC@`6 _áÅäo Uò*¿ï/Ú«aáÇ È Äo ¼ !Çáª¤o áJL¤o }à
AjÄo ]à
aÊ£" =à
aÊ¤O äOòß ÜäO S$F\|Á#" WõLÿ3ÛDFQVf? ñ$L
Ãã	/rªaIág ` Ág T ág @W 5U³Ç$ÊE¸U L# à#hðúí©`fàG ÅÃ Éà#hXk ¥à# $ ðá XäìÑ ! e¡T$6¤áS# Cc3ÿw( 'Ó(Ð L$(Ø $ó(7Ò\$3Û  d.â íÂì Áa ËåÇð%Çò¨`ú á 8V Ùõ
!Qh$õdB Åà,  D$\	 t&Ih,, à,  `,\¶`, jR$¼ kà, $`,$ , h4Y >, à³  , daü Yd$ë`W" ,f ø!w  Î ! !h  $ã $&( 9J_$ÐB@E R)
Z b?T æC Qa­ ¡­ á­çQ Ba¨ #
a GQç
Oj§òBéã X  hP! L #æ7 /ä ¹  á- íc$Z*- Ta" Z¥ßBAXÀ3, üBâ¨  à"ÿ B ­àÿ ¦`áàÿ à ÿ àÿàÿ °i àÿA»	^føpÇs"B
zËca!á&ZaéL$eÄèªæÿRÑ\$÷Ïÿ@Øè3©ë ­! ë,ub èx 1O pà- - ,C  -$ 3ÛÁ9i½ CºÀÇE 'U3öÆE+UE$ +ó	Û   WBoÁö% Îã ÿ8ÏhpóCÿ ¤aY 4= ÿ#k¤m x  ÏèÏ" 4à"q#MEJ 7ù0C}F;óz"Z% _:ÄúÁ? Wa@høWèia@  A@]öa@ !@ò§a@PP Û éê hXACè4 4AC ,à0 Áà0AC é[âh À0  0ûõÏA¢@a à0/U éNhÀ0Òa Êà0 _0MMMëZh$À- ¤ - à- 1à-@Á" ,À- v - nà- -B  #­3É'{ Â4éû¯  [¯H B	;¯ DB	 X_ 2 ø-^Û~Ã§ v¶64é ñ"ê¢bè2E)áá Haá LááÀEDfFÎè©@èóH³}O(h h ) à
)t ( _à
 h"eh8 ?à
t H à
t Xÿ¡`êà©TA\C;&Î&+ Nì¢«Uìjÿh¼d¡   PìdSVW¡¤P3ÅPEôd£  Ù]ä6º!£MÜa¢ ÿý WMÜ3öM¸3ÿuì}Øèw\  -
}üMÔ9MÜ
2EÉ~ 6~C®ï;}èè@¾ # F D ÿÖ,§hä1#² #CÕà#ChìVÏèù aà"gûàÉ1KMèåBìÏèÝò#MØès;:}ì7¼]ètYEóG üÐ}ìPCPèFøÿÄÀuþ ë6}ó UäMÐJ¶B	tºèëºðB	¶À   	AøwÆBhô Ç!&}àè ° rM¼ÉtQ"|D0÷A cù+ÊSÒtrB`Ö;Ê"ñQE°ËPèp`èÿE´]¼Àu	÷ÛÛéÓ!ªÛu
» & éÅ ¾ 
3Pÿ4Vø$¨;ø}Ëÿé $ ~ 0  U´úOÀG`|ùËqfÀÎÇ;ùMÄOÁ3öEÈ:7@ k2 l¾QEÌqÈ sEÌ;ÁuF;uÈ} hëÐMÄ;ù} ë3Û;ÁÃ]%Rÿë ùÃ}àM°èÒ¢æÿAÀ'1zC1î  kX¼ÿEìKð!·!¶ÀPQèãDA°  ¼ A®K}ä&%UÀÁáA¹T9!´D9áµ Á¶ 
BA·ÆD9EØ;ðOÆEØhüÃè_®ÁÀ !Àá¿ +!!¿ ¨A¿°^A¿¬á¿ Ð!á¿ Â á*¿ ¬á!¿ Ìá¿ Äá¿ Äá¿ ¬A¿ Ìá¿M¨è¡á¼ (a¼ 
Á¼s!¿ð©Eä")ÁæÙ\(r+#.èô¬Áj !jÂ£% #% ¿ã, l  AlC]Al ¤ál Ä!^ál ¶ álC Ã,  0U¤alã&À£$ád 3ã	 á` ¤á` è´á` &!`=CÀPÿ×á b×M¡^Dh¡^«á^ä 'W AWë[AW áW Ë!áW ½ áWV¥ÁW  0UaW áXäáZäá^ á^èUA^y,}èA[G$PÿÓ&±ÁÓ]¡^fDë MÔuìA' ;'úøÿ&hØGÀy3Àë
¹ ñ$úOÁ& Ièä!ÆMôdXt Y_" ö  ìTS>Y\Ãr/VW)B9t£'h AkM@2ÒÇE§*Ð ^6ÇE6©ÆD$/.äT ±)íÀ? ó%ÙvéU²ègdèjK0h,$ tà
 Hêè'ÇÎèT õ B   Ñê 2 %çé·ï8 Ev: Eö:)·hT«@bßèïò@B %î  á ;ß%æ ¹"Å EÁÙ]D øhÜ º4àÙ|~ è  à¹  EAhô  y  ¸à  g E@h â X   àa|   8à
 T µh à`  EXh, ÷``à  å EYh<  Ö Â  a Ó `E\hL! ´ !à `Ý@ (=@$è¢IB! é)BL$] /;]@ V!Yh,! 0Gèx )½@ m,] `,lï . é! h<48èD 3@] <0 4)¡ Ñ:û 0l¾ ð 5hL0@è 0 0]  à0"Ð é¿ hX0Hèâ~aÚè`¿] oà0LÁé@0 h0Pè± 0 ©0 L  >0	ÇElÄë`hx-Xè - {- T - à-[¦ë2h-`èU - M- \ -â`î@[+8þ  B¿#îh@"±;/Zü$O#¼ f/lfþ`sR EHV©¨O×^D$p/ÝEHÒt/÷EDè¼ @  "vªED 8ps,Òu@"2YÈÔ@> @
MH/ô]w7!W"Áv-¿-À@|$ ,XÁ^MLL^ TO
ì\T$`Âd W$û
> À,4D$Dz P!© S8 @MÝäf|$t`MÛs!hD&»èb§?BÃfEfEë4h¨ç  ëà
 h° "» Îà

h¸ ±à
hÄ à
hÌ wà
hÔ Zãu hà >à	hð "à	h"@ Ç ãðôò#ðhæc  #²èï{òçåbò "e|BeC} \ i#²(GèÅ )£² º,Cß O`,ã² @4 d40è 3C² 0Cã à0c² Q@0 t08è` 0 X0Cãí@`a" é @0 0@è/ 0 '0Cã ¼à0c² ï 5h0Hèþzöä`ðCã à0Pwé¾ 0^Xéµ h!O!PèÄ 9 ¼9Cì Q`9HhrÜXGè )¡* ,Cë $`,C½ $ WQ: 1`èi 0A' a-Cëö`ö#ë $A'1: $$| - 3- d!³ È-#z $!  $ 1 @#jp $À$5û[_]Ä\µâì C¾WqS× Ù'û 3~4¾@J\$t$$@  E W!Hùt'ùt"ù	tù
tùtùt	ùt	ù ? ~ 4/ò L$£ Â1Ävè 3íCâ @³ \7ÔNï=\o Í(§ðVè2c¸ I[mã& ð}£/¸ ¢ñOè h>}Ïèó`> `>p r ú%7 H`à @¯E;ëvÿ%C1@ðöº Ê OÆðþOòNf  ³¬2| À!x tF !|é3ü3À1R ÂAM8ÿI÷!I $Û í!   $  , (ù =ùAC AC ACÜ@`áC !A9(uøAU3ÿ1; y ¨òïÆÿ4ÿ Ï &?(Ía#èòòGÁ¡!Mèá a! ,^­ÍèÑ 'âÿu!`á!G;û|&X  t  "&H¸BÉ½A"IÁIé Ñ¸C¬  $¸C,3À!ðIÁ 8 8 (»´ ÷ß¸ ÿ#ø&6L t¨T»A^ë3ÿAúøq Oÿ$4
 ¼a| uLjè,)æÿ`è©éÿ¡¦ÿt$@ 8Ç@=hÀ!ÁP SèÖ!ô:L$H éó Îà
kÀ(àk =àkA# Áø °èÅÐàk àk Tà	kÑà× Éàk  yèéÞàk àkè'à× eàk 	àk@yèßàk ¯ á
C |à	kùà×Hóá C  åèaåàk Càk à	k àk 
à× ,@k õàk ×!Îà
×¤&áC !àk àk <@kYÒà× k@k<¯ uâ ï <@g¯¯èÁ!7¯"ßÂã @[¯ÁdèôÌ T¯ÂØ¯é L#Å<àPë% ¸èp`P àP `PÁVåèðÚÿÿéÊ@ \<»àF ¤àF )àF @3@F à è"3é 	 F (àF ]àFâ @Þà.º@F	Á(è¥ÏÿÿëB @ ,à@ à@ ¡à@ @Á(!èàÿ!" á " f8@åÏ½ '$~@)   m  Ù E @#	 ±  þ  E  Í _ @÷_ l·\Eð7i4® ô÷bÔM5OMÀÁuÌ91eÿ FÀuÌ03ÿè9`7X ÀWXEÐöö ÌuÀ+'
fvï© Ø)üèêòEæ®m ?&ÿChÈ *; Ê¦'NGè¸ C$hÈ£@  © &'F7M¸èH,hè= à](hô là ,M°}ÈèXqPÛ)¥M°(á æ:¼Ij  Úh IM¨Gè0 '©i %`* ¨ * »`*tf}`]Ôr13ÀfC éÏ!ìh`; èõpbíÚ@b   7 7  2 ¸ e  `3Hh `3èÁ 3 ¹`3  3 O3 @3$r`3ëjh¬`0è 0 `0XT à0%{09h¼`0è_ 0 W`0  a í;(XÔtgG@ë}ÈRIÔEÐ@!ô;EÌ
YÈx< P75(¢ø?EÄMÈMØPèØR{ KÆEü;Èt
jÿj Pè#èÐ ? ì(|rjAQÿuØèÎÐXä !ã d ÇòMð3ÍèóX å]ªOß âßú?Á5×¸! u3ÀàY O }GsÇEì + MwuÜÎ:\à)} Pè{oç Ç >,A`A0fs CÆCÿÃ é G u#rÀ!EÈÉÿfuºuÜ2ÿÑEü2ÛEEfE EE°E´ ¸}¼MèU¨;÷ä%¯Þ;Ñ kEäÁáÁ MÀQL èÚ MèUä·EE¨fV   a``	  	 d 	¶E¡]
   
 \ 
Eà@* X 
E  k 	UÀ/UÄó~E¸U¨fÖE E¤ °.ò¢Eà Eè@ª ×" ¹Ø#Ã:u/üP:QuÀÁÒuä3ÀëÀÈ4uÿvÿEûwE¨#n@L L¼É;à2L ¬ L :L |3¥5Ïà0 ° N ë#½ è  N à1O ´ O O È ëà"O 9!8¹FàE¹ sWP Ã Ô sà<à.p ¸ pXì p]àp ="MÌèªkæÿ;fDM&» Ü ÌPèu)øD9   @#&æÿ" Ü! p#Fº;÷tE p èà"áâE¼ L"ö
úÿt+}èÿu%C^Ccã AÕ
<xuTAP	MÄ'+M$ Ô%YØ¸«ªª*÷éMØÑúÂÁèÂ;Á}	Q#Þè½
 !À8 Ô#Iéª$<yuRàW Ø W Ôà W Ôà	W *ÀWMEØ@W@Ù\ëT<cu\à-UÔ¼ ­àUa@ÄÆ!;óu 	$®#å
"ûÿÿ]¸}¹=,
EÀòÁæPDÖÎè !Ô ¬.lU°$Ó Ó¨À#Áà=Ý ´ DÕ$¿¼DÔdÐ]À$Ð 7ä Ð 7DÐ9Pj!;MÈa +Ë÷éá =UUUvÿ8!Áà= 9(r2öÃt Cü;Ãr +Øûs û#À<ØSè`M  õEìùRìZ)¹@/x	ÏÿP$Ø3ö ²V"JUÏVÿR(P,T95Ò* h8.ìÇD$ÿ     ÿí é	ý}7©¸ ýÀt,pB&ÈAøuT%èë3É  ÁàO<Y	íxAý}< ? à?1¸%L  =O NtÀ1~T$ Ò ~fJ:
*AÀ ;L$ |ñR+ú~-úW>}% U u@ p+õë]@¼`_èA2(! FëÎú9 Û~ú^ } 4 @@;Pë+ú~=ú}8l$3À¨/jÉ 'Áá8å 
ÀÈQRèþÚü$& ?
A@	P0NKF;ó¬(Î]_^qDÃ:Ø  ìÁS0<U$þ  Ë 7$è+'l$ c  Wÿ@!x,ÿu -0NM +é:ì ÿ~ÿ@þ|ÿñ!?Ý ÿ% Ñ h<Íé txétZý¥ ý @PÑÀ !½R!A@PiÅ¨ IÁ0ú  *ßÙK@hkÍjA#L$@ë<H8ÉxMù}H@q   4@ /  ¸14"5  b5ÈèüäÿøÿtPWè£ÙÁZ JÀô 6 øë:ÿ, ~%ÿ/ }@<ø|ø|À0 ,Ç@<"´ÿë@AF;õ û!Í á
ÌU¬$hýÿÿìBjÿhÏê
¡¤P,ê"§#R&-Ìíñuì2Û3ÿ]óff!¼A=  3_ 7Üµ ¨¢àAPâä#o bß bßÊ|óv´`A¾@ODMÇ&  	ÇE `èä`&Å  Æ+èåR\    !j`"PÉtèeçÿëè1IdJ Ç`-@ FS@:è	ê ZF-*èMé+FMì |# jó´@à  lF@*DCÄÁâÑJBB " >> 
JB`ßÛt$A·5s	 ÿS-Ìmdçÿ - ÇE@   W @WÀy^nøº%H OÂ`Àèq;Ahh jj  ·$,-G hpdt@ ELKPèðF@" ÿ  !W7ë }Çÿ@0"4]ó-,aj    ¢:ü.¾-ÝÀå B$,aL ¥ ]Ã$ 'øâÀø ¹«Ð`,4"à ìØ °vÄ$Ô $UY$D H 
Cø 
   
 ô W¼$è   4 B$ 
¿h ´!¸&@|$H 1!L¿l@$ 3À  P:®-·@7!buÆ ëiÈB¼	Æþ  ñÎ6@è$dø$¦!_Nèô¹÷ÿ$; T I7r}+FL@ ÿ(Af0T"ð & D  P1N%Z $P²D$ÿ2@(ÿÐ Tð Ì@×ÂiÁâT$8R  ;Ht
&R ´  ¡$öu% uÔ[è ^` &@/ í!éN Étb TWÉ / <@w Áë7gÀ  P`³<q § ¼  ¸ A0¶ '  ó«7~ L #ì!û` è  é@Æ -ÈÁù¨)	DÁPVè½äóÿ ; X&T=Ä¸EL8  T(4º!ÄB7l8¿ø ~Fë Q 	LjPVWèèüyAO
<uÆA G<¼`¨ fnT$!\ D Õ
»[Ò¼º`Ì óYÓ~?öÂ&vWÒAÆE 3 =\AB!² YÂóXÓ  A!%#4ÀÁ H @'ÃL$0$!] +,x t
8"ÿu j QÊèb10ø ¤ ,9!0HRDÿÒ'g'g@HÿÐ"Yé@L$P·¤ Ñ át$ÿ1@(ÎÿÐÌ j x  ÁD$8 ÿÐx ~ ~L$4:4[ë(@H@  à C Lä Ga6H @3öA Ì  %ÙÃ  ´P¸  º<Æ÷¼cÁÁàÐ8 [@%
DD D´\u+!  ú`öx;p}H9 9¯Î<)? ÿ =4 ¼´G«t lL@À~*JPj WèHEÉ à"<`6ÇJo PF@¢;t$ S$ë #`Ó|#At@! "ßB  À"b4´`Ï!ùD$VPQ!æ$D$l $ÿqP$¸!
Pè¶"ô)   ´[ t PLÏ¯Æ9}HPV 2XèË ' !R ót7 *#ý  $&¯"IY c\P  X@r$Àÿ´$%7   E,PÿRâ ð"@M 0 . , Å @'K B~!« ,(|~'Ý ñ L  T@ Tø,+ 8·BR|$( B[LÇ4"¸$^ 4 qDK T$AA	Áâ¸° +Á*£@J $4¯ E/ Õ$|0  Tt 6b 0		L$$ë&ç t>9	øJ@C H"Po% #å!Gà!pD$(å @!dNe NAM Te 0 ¬ ëe	e	T$0Òu! Nå 	(v à/ò%¾éh %"¨$P ( @ó_¼]"äî`*6¤ôó«  F!·é  G 5#øöÁH$èÈ¤ÚÂtLöÂuG+Ià$øT$8ÄWÀÀ  0Äë)à ~7!/   H  X$îRVèù$î ´ ì#4 Ã <%ÎvÇ   I,AÉíë®dU T!µ 8D}u BTÆ@%Áå!y ÷å ´±C  "Ó~L Çu""T(Ð GÂ e¨ ; O%@A@p 4Å @a%C ¦ÿ¶"/B® D§@ j+Ä¢ D¢D@@P¾dé ¡ Ïd¡Pp#  Ï`< Ld­D$Êc$ºÆ¼&çu	 O, ö`X,Bµ$Ó´E£dÖ@Aä Ö 8 ¯äØ 3!ÉHQ@©@`äà ,äàgäà8äà 8à KDà¡|$H(åA!, !~LLJaFª89A"À   $((@ Â´eiø@|d'ïÆ÷Øà#v þÑ3ÀÁé(Êáóª"=(+Êò!ø)
|ÑÁêÂ÷ØFÈ)"êuõ"Ä   <þà >ë%áVèf  µ P8A$Ø 8¸ ;`²!­(X@ò ëëW%Ñ 0ÅÑ"Ô#¼ h«¥Ñ , HCá"RPGEa$#\Lÿ°A%z tå×Þå×}!¾6x  -qX+&;ÈLÈJ(;
L
 %M  °+a`
îuÏ·¤"s·T*\@µ*R Ï%ÏGâ+ð 
 D ë A°bÒ¦;ãÄ  &ÏjÿP@Ü  ; <&B / 0 0# æ >T$\R@Ø$ÿæ7 ãDÿP! T"® @ 6 4(³!&L@ÂÀ Ú!Ì4Æ#Â <%6 @&X&*&@úÿÿ^$×K	_3Ìè²@ Ä@Â  ì¼ :ë¯G$@OS$È UVWù \/ $@× `\&$@sD°FwKpèÉXZ @Îè®÷ÿ ß"ð 	 Ò Á    %wD$8s Ø   a@8\$3À3ÿ w  p,®KÁ@f¼C"-¼I© t	¬`	ëY`â) è!&l!iíì 7Ä ÍÉE ÿPHéÇ@L$µcýI0ÿ1)P(DWéÃ<õ  I Dò~ËI (ëE i I@C!}mi $·A"@!G @RÓ § ¿ òÁt/ó0Ãi L(ÃiA¬ -Âú xÿ)w xéwÏIw À$% !´HtÃë+@Ó ä Ê æ (äÐ9 *4ÃIr$   F$.E zC!A  @"³B ('Å^J!µ D #Ä V+ AÀ!Ð$Hû0@ÿ°@ã# `CAYPèKÃ !» V"Î$ÍI^è°Á^  "àDÒ3VL%L+ , l @aÊ`c#BSjC¡Ç £ð  B\Ç@Â?ÿ`¿ý)4"¹ Æ3Ò«I'¸8#Í#/  )  ")(O|+ñ< 4ëj R>Ïhô@`   `-£V"¬óE(ìÂÙ È  ! v
/M-© 4 !ç2! B= 
b=³ë2Û!®A$ Í"H ¡´Ûu ' @ ,ÆþG"C ¸Dï# 8,w·!° A  ÞBDB:Dâ-@t\´HëC!/ #5"G 7 ºâÌà âYB B8F   Bb6îb"X @ç teØ  !Ñâ TTÌ0F"Vó"QUÿÝ$  è P"RdPè ôÿ RdÄ %H $!E $B»e@â & W d ("(0ö A~$ |U~æ	 p? æ' F+`»Ñë µà ÖCû"è(3À6ÎIÂP èÐ¾ï$Î"Y"ü !. ,BÅâ="¬YBÇ e4 [%ÓÞ:EÓEÊÂñ PH P;Ê}ÈÿÃ3À;ÊÀ4H  )#@ à	ÌÌ_½d¡!7 Pì 0ÅEðSVôTÙE>F	EC;ø'd ÷'EÀ7t*Àuós@
èÁCïÿEÎ=Ô2©QÈM*EpM,FPK;Ï}-À@ @ AÆ@ÜÇ@D Ç@è  E3 ;Ï|Ýu1LM@KAéElE½t"x   e|`j]PÇE+ÇE F	 ÿ¼@2EÈÇEÈ1Ä ê ì; ÌE3¬ ) P&óöZ MèÎV ë>82 3!úötfF;Ç}v òN"¹èÍóÿÿ)a
è@ïÿÇF K	 {Môd  Y_^[Mð3¡ï8 _³ 9 ì5ô 8áG(á5ô¡¢Fa¢ KA¢ß+Ø&õÁá¢BïÿiË -íEá£ Xá£^;ß}q°\ XÆ0-¢¨)e4 Ç8 @ Ç<à 	 ¤ @èªÌ!NÀFÀ;Ît*àÀ;Æuõ!WKâ@*èsÍ  CÆ@;ß|!ä]Ûuá ç~é² R Aê p!Û ¡½!êóAê µAõáí@5EAí |áíËèYíàT!íC}A6aí@ áï¦Ëáï(>á ïExáòü6Áò#à SVñWY \1ø;ßt2£ DQSÿP,"25¤! @ÿP8yã U;ßsë@UÿP(E;ïróVúÿtf^;Ú~"`¿Ò;ÚúF$¹!Ì1½VjOÈ¯ÑRëP,;êTN ;Ñ~M@/  ïÁ~+ÂÑø è~íà<`9 !¯ÁPëà¯ËQ!âË¬èÿ?^;ßv;ûs@  W  G;ûró3À:£@½á  àaÿH°à2ÿ<à	ÿàÀÿ «`ÿ A ÿ ; ÿ 7Àÿ +,""¹°$ Q"f¯Ç@dt@Æ@ô ;,uíA) Éá	) á4/ â/*ÈÿB7 ë¢7 ^7 â3 Xâ	3 L3Pb3 I"â/8á	/à¡/ªa/ &!/  !/ á/ ;¦(#ñÿG"> äá
áe á/8á	à¡©aâ?Ç @;',exÇ@8@8t@Z  A*â?\oñ\oü-ÿh¾è L$$Æzø  è$â@µ EÄu]Ð- {½  uH½ ` ?[c:½ÇC O+:hð¥; è]uÏÿQË' "`$  ë=à>@O@> ¦@> 0@>  >@>$ >@ N&6ÿèP'Î°ÇØ 4@ Çèà 	 Üà 	 ìà 	 àà 	 ðà 	 äà 	 ô 	èï5<õFMÔ i ( XEÀè6æÿ2ÀÆEü)EëEó(l  8)Sß EÌ!k G)Mü'=@°H´=Ø^`Sè_èÿÄ8
]Ð±Mëé ;}Ð tw¡jE°ÿuÀÿuÌth ×;ëhH 
Pè&éÿE´@ô9{MÈÄaEÀ[ÉMÐjÿRA
 ÀóæÀÁèRòXÅ^fZ  ^M @&ÿP¡Øt$w$%îÌèÿ  EÔ;ð3íVÈé <ÉEÄ!;ÁtPèBÊ=ÖÐ èPOè#fç MÔ!(*èÛ  @ )èGX=õ!fè1÷ Ò!)èé!1@­-jH "@Dèb Mè02\ !6ðùrAjQÿµ@(èp¤Ð!OÇ@!B(ÇX +@  Æ`J þM@\hT1"¥ ¨  Ç¼ 0 ¸ 	@ Æ@ è¿Ðÿj ×@ » -`© ¿`4  )<Ìr@6;ÿµ@%èé£ àUéº ñ@ß x m`Q5a@ß@ß  àß@(èÀX@!®  +@  Æ`J ß!E m@\h`"%À  ÇÔ 0 Ð 	@ Æ@ è<¾ß@ Ì ,`'¨@ß Ô * àß@%è	À@ àUéÚ Z@ß ` B`QU`@ß¿@ß t àß@(è°¢¡8@!X p +@  Æ`J6`  ÞÌÃ@Þ  Ç¤ /   	@ Æ@$ ½Þ@ Ë +`H§@Þ@4 àÞ@%è*À@ àUO8CbõLÇ KuìÿµEÿµ 0Sè÷üBÀtÿµE' .!PVè
`ö ëfjS#èè#atJ$)	2ÛE¬ $Õ
;ÈtKfAD4B\ %ÆB\ ³ +	 +;ÈuÞÛt# _PèAUaWë SPèç g _D à´Æ ´ G-0µ@l#Û à#^(ð&=]ì@yÌ(ÒÈ Æ@ -D H  Çk¬!l ½K¶ ÇEmùÇE     8 L + P Ç`   Çdà 	 h 	 <` l 	  ?Æká $MÖ    t3À@fP%Bç PL&   @³E¸P!Ü.ÇEU0 èE
 ¹¨¼Ç0 [ `	 4 	 ó èç·{ »@f@Êá @Â% #¿Á   @ÈÂð±;ÂuÙ·`']ì)ó¹ OèÑ,}  + ëÆ8ÿ!*¡C
SKE¼C / 
JM¼@$` ( ÿ8"Ét Ç=èº?¿uK< @3;Ðu7¹  u. QÌ,@F%Døþ%¹l@¢¾ê	&¼PèðBÇaà@  ¹@Î 	0èÊÇéÿ¶Y(y j`Paô .P"ZPSè×QBß BZ $lMì]¸SAyèº
,Ï!>qaètóÿ½C u`-ÞÇE &E¨ÇE 	 # Ç<ÿÿÿ@ÇEN
ÿè0wÏÿjE  )"ßQÇçÿU %á	M¤úþuù &tcP0H4B¡ ¬2èÐÛ  6 
);u!QHÊt(MÔ(PÿPh @ÿÐ Ï÷ ¤ÿEÈÿEÌMëE?'¾E'Ö	1øÿÿÉ4Fû½#é7;wû!bí) Cï  ä ÑÁPè_ ¾g/  3=Ãæÿjhdeª ¼ )èL-æ!`#4èßÓG6@@2èQ `P@!èÁ`@_ )èòPæÿé@{¼Çá¿PWSèPa¸á #1è¬%ª ¾ ª	 ëEëÆEóA Q#Eó3ö¹    Eñ è b)gègZ$?ÆMðø JO3Íèó' ¥J}]Â   8À,DH#Âæÿÿe*/e,0;PèÇ@%/tdj M PènñÿÂ  ã5èNN)ðåQE *µZBÏ  ©] Í!xEÔÁ u¨Á@¶@A)èì1òÿë* a 7"SÝå $à	7 p 7"- â"  `=rAú!³á ò Ê B3;s" ¹@>ÿÿÿÇ¤Y 2|Ïè	]â 6  j" pbBýèC+â 7èÖÑ Á`!6èO `Ub ¸@EÔW"OàÎ !¸aÁ@xfÀ!¸}Ðÿt! Q=ð#ZöÃu9@¯ h)èNæÿ@ê Ì3 Äéç#C!Jè¥0òÿb6éä °éÑ À8óèe 8éºà èU / ´ ê`  V5w¶FP P5y  ÿvÿvÿvPÿvè%óÿÿ0®3À^5à ìSÙ{=^ î@òKÉã@
4áÁ|+ÁCSU@j îWÇ/©!Â 2 é@Bç+ê37$3ÉøuÆÇCM¿ +Å7HZ©
3ÿ9{~e4   8b yì {Yì@x$òCYì Yì É 5¼ ¸Öí~õIRÇAp\µ ê!G H|® .  $k@@ ; ®G&A3À+ÎÉ_OÁ^C][#54dáì/2t$(ÎrvV© ("t$¿| ÎØRÿÒ:ØuY Æ|&²ØÎ#Pf;Ø Ø! 0O§SW-jG#VF,Áø» #@ ³ à +ÿP1ûÄÃ7ý AS5P   =;WÀÆ ÍPfÖ!ÿ(U£   %T   +   +hÌ5s'Ü²x$MàO 0 #àO&¾@8`O ( +h(6@O b@O	L$è#qñÿhh @]PèJ AF Q"MCX© /jt
¸
 E[Y3© "!tïV³I6ÿ³ø) þè[÷ÿ^`&UWö~~I13ÀÁj IÁËâÿ"s<Áÿ	WV8>èÓ+ïW)DÏ;ÏMé4ª­6÷ÿMø&è  zÌ3ÒWÈ+÷1ÐR{ Z÷3ï ¢B3
+èECDkH«`¢íÒ 6Ëè¦× IÈ¸I+@ÈÑ`yJÊ $¨Bt	¸@ä+Â à Û @²à¹Á  Â4Áþ	öx
;÷O÷þ}cß
jV÷ÝËUè#Ò rÎ+ÈFÿ;Á:îé ÓMèèÉ5àã ¼ àã®Y@ã5"@à ß3À_]m!°ìÄ äÓÄ$U¬$Ô VW¼} 8Ï|= "è D$0ÿRjðÇ$ -MROF,´$HÆ XXFFIA%³2Ûè3+ç+¦uC, V%6jà-@4@A - ;  O C ;èü*`6
¸7 éù ³ 8!' h@a ,  MMOCP   ÏPèä, 7"v éJ=ÓA¿C@@$ 1 Ì ¸ "Ó `+ÄGðVeÕ;ÆuÂ@èù}#äD$`fL$fó~D$hf þ L!U b  N@ p@ \ rf!, Rc 
T=23niw+ a lfwt 
LFt=ENONëJ@ët=42nië<=twosw0ti intb + [¸CÝ; Ð G»Ì[A¼$À
=sowtuÙë-¸ ! µ LàËò"£@è Ï@Ê R z$ ²LHføwjC¿ÁPè¥á÷,ü  Ý,øÿ{&¼ávDNSSáv maå lap s D G@jQG/øc !@èÊ B"WD$DÏ@g 0<»LËáçTSNIÀpPèþbÜ!å¡ß S`¸Fvá	 ð':@èÇ|!Ñ¾D$` f #è!_Íèoòí å3í%C|KRAMUà }"R¢\Pè t c@t  P  zjÀß l  
+ðD$L$¹ER $!rf;Á&cF S È'<3Û"=\$ B­%)î í 'J$ Øf]Ï¿ @;è}LþrG KújÀug è8`î "½ È;Î ! `#   ¹L+ÈE+ Ãñu« ) 9n  ;Ò uyZSQA  '<3íC@û}X@(éY" - @ L# ÿ%Ó,QÇ$ . S  D  L jP&+xPèØ5ø"\èð!9ò|$P E\PWè®%óé!8 f!" h!AÇ
 fÀ~uÎÿÖ"¦D$(	cf s l!UVýD!·Hþf;L$ju0f;Ë Àïuä%n-ú~( p(+Ö! @c  6qqQQAÇAV?@ n@~ {à~if ¹ r ~ f  p¡`@v } ÏÀ}íuæ } 4@} / ÛA] ("@À+ÖtÃ TÃ LÃ(Ã"   [  k,¿!EWè«'÷ÿ¯Æ!?j ân V	LÁù3Ò÷ñÈ  ZÁ;ÈaBÁ! LAtVPèS4k !¬aû!ÏØë&	ÌÌUl$°ìP7	 V÷	ìT2ÅELSVÿ!hRYC`P.xè,¬ç!ëM´Ç>èzs./hX  @ '+,(éM´èÝ9WÝE°jDE`	§èÿøDª!i³Ü'[ d#
M´Æ<è©çÿ;$à   }1.¥ÆE tM è¨{Àuk}!ñub¸B!¹
9EuW·E;@VuK` SÛè(I´èK ]PèSs ø} è5@ W è  ðè! ;ðtWWèn- ¾Hý  Ý
ÇE´H7èÜ¶,zMàèB@    @ u îML3Íèä)ÀeP]Ã} ÓÏèÙz%0ÏèÂ Õw<+R »@¹~HDh2g·ËèrQ÷ ¸¾n@¸Æ@Ë èu` ¡  Gà  ;`G|½ÿu è¬@63öé<#Ý"À "*T$ó((Ñþ"¥ÆÒ V²ü7};Ðwf;ñrb¾D¿	¿RIWA[7-
YÁóBð¿Aúà ô  üà ø  þà üKñ¦^Ã¸@!ñ' a faÀIfrà fYÂ d à Aø@à ð7$uÆm
ÇKñÆ%ÿ.{= !¶ì [ ìº@dÁÆ]ÿúI ÁàvÁøàÕAØFå à	ÜFèààFëàäFîàèFñàìFôàðF÷àôê8, )!á^ÃW$c¹I@õ /vàÈ Gà Gà Gà)jàGô!d à	|øFýà ü>C È¶N.þ¶ÁáÈ@ÑÊÂÉ Úÿ%   DÊ"Q Á"&¢_b@ !òâßBÔâß Z"ß Vl  H"~"àBu NBð Aôà_Bô@ øà"nAüà üB ²¢Ó"Ï"dAà !¢Ê  ðà bÀ Ù@´%è.SwWÿ$ØPIÁ %æè* àôÿÿà(½à S(à	`kw   [      °  À A/Uì&¾ý $ì\æ  ðæùuM]èumæ V  Ç¦!Ø3Ftmë=F! Ø&±ñÀE»m,ðMìÄÀ zÀuØè²xýSVE)®èâ*`ðV%ð ÇEeZ±EyÄè=år ð%r q$üå]+W ßl$´ìL ä Üàä@SV æ&çôd£ ` ñ%ìèl@ÚEÆð P<¦ü.kt2Ûë`ÆE M Ha !w@ 8  Dm  D   H  èHÆ"¹uT R&Iÿ¶[ø APèÿ)*'-Ã   0@@y@\&\`ñh°@ñàè<æÿÃôv^[eL]/AÉ ìMÚÄØ U.  W¼`*¢Ïµ	 )ØjxPÿR+Ü x/÷"\ éM!v /©¨Ö,k t"+-è8s'àt
bfé 0"Ð =0 rëV3ö`	 -|*Gt$@<*	t#øtø À5 å kæÆë¾'Ó ë¾N- I 0ïSI$*8Áû	 g8 ujK+ Y
èOïÿ$ 8 ¥j *ô & 04ASS_ +R'  ,  f @%;  
<A<Ê3Àð±!ñ YRè4)4´ D!$C D#¡ Q <  «%j<P@X P@é L@	TVèò¢ [ít,Öåíÿ3».Nò_]3-ÿ MÿA¬b§À QVñFñ ^ñSUWÿ¶Ô)?èc÷ÿ ¶ 'åà ÏJN
,Áý¯®HU/ò¯Ýÿï óÿR ¸Ë;È~Aþ@ØÄ B+\!Ã÷ýPèzóÿqHÀuSW#!I÷ÿ_][` ½Q)"º C8÷|!FÌ A3Qö1ô q_  JÙÓá #Í"w ` ñtÅ+ÂØ@Ã;ØOØ¯!â!º Ã1F ¸¯!û,fHQß")! àgCÿÁù	 NDÂÁø	+Á@FHÀÊ¦ 6 °@q +¶3ÀÒHóËIÂ EÂ%`¹ gá2 ¹ I& ÌAt+éÝE;Ù@· Ù`¢2p Ï#Hà·âG@·u+à ³QçmÂ   Ue¯¿å¯ tí Åå
¯GX%² ©óËé#Ù³Ë=Æ¸[P 
péô+²$Ùèhæ:A
EÖ ÅÖqô2¼ (EÌPj$ÿuèÛÕ+Y 61¢ ÿ·Ø"EÔ3ö EÈèIØ@!&å !  !3Û9]È~.o ;jS *è±`I `' X ';uÀLuÀC;]È|ØA­Ï¯B×Æ  !ÁàPèjÜò u
¾CÞé$ @Åè¢&`, -q jEb `27Ö ¿@GE Eê}&u°E¸GO#43Ûð]Ä@¯ wà¯  ¯%ÓPÿuÀ`¿A×@ç  `¿ !;]À3ÒÛ~1?3ÉÀ~D´A8];È|é 1B;Ó|Û]ÄC v@ø3öE¨&ÇE¨r:t Ðèó#çÿ    - Ê$±&PÿVVÇE  &F ¤   %\!û ë°g!×èÀ)òÿì	´GA/A5Ðbo Hâo TâoMÈ¢RE"wEÄÂ[ â xA¤èB[`(2 Ç¨2ô!ÄN Â[ èÓAQ aQE)EÌH@| OÿuÐ]Ô9 ( æ!buk3ö!s W V@ Y`EBWuG}ÀF;ó|áUÌÇ6¯ÂBF)MÈå ËNBWR _j è,-¬EÄ!XÈèà%Ç öÁI ¡I èv(áIåIH@ ì<> Ä$S 8xªLÙW%É L&¬|$ç 'j*$M'*t_^g [%À 8&B  [Ä< [|$u1<ua¸D¬"o ` @S%	,òè]U*´ÈóæÉòYø!=è`=.l$1òZÀE-× o
ýt<ýt7]ào à o<u¥ #kà ü
À   Ï :$è2+ø%À Â `ÿP-³ g×¯ÕC  &ÇCB:o@¹Òk; {C$ÇC(TH C,ÆC0 S4ÆCuWUjËè*^óÿ2è G&¡oÞíÿT$>1¦|7!Bu0 ^6¹ §7×ÇFqHÁOü3¿NÈ+ùN;×NO×VVG%y ú [!a 'à ÔA»@ ì¸ é_ ´  U)_ Ä  W)_@ H~_u	Ï*PD$82­ 87QRP @EVAWèÝç"÷#&Hðé!PB|`- < $, tmfQñ 0&SèÐ ,A+ég ,N÷,wõ¸  õ	4 Á &5É Â!7jCx @
d&  ¨ %î ª 
"8  8q 
   0@ `+   @+X4 + ° 	    6 ´     
ET +¼   WCÉ     I  @+X1 +J«@+4.r} wwf ÃXÛ>R  Wþ f;Áu`¦ P! Ä 4è\ !O m @fà  u U Aà  ] J @Âà  E 2gI· ¼!\i·I·B#w u+ë uÎ)ã Î fùÀ¶"ú t) ·7Ê÷ÿ$Î##Îÿt£Aèaê @!ê0atadAê 4Aê åbt|$,G¡añ t/·i·´`f·aÚ SV,Áî)ùñÏWj ÷þ Y C>@ " @`a 4lpmsPè}`gB6,¸@+;ðP9H -Hj,¤B\CØþ< Ù6£L$DV+[8
 ;3·   6Æ P c *ðyS*ñäÚ#\$dA()Ö)Ô%^|$tÅ'_).ø|B3ÒÆE 5òñÇEBqOò` NÐuø+Îu >GLÊEMüMÅ0Çëu©[·è ú4¢K  0¥Ô!    (  0 (Pÿ´$è  DèHu7 )Õ Ì$>
WùÒ~"Â (RVòæ yNÎüF<%  +ÆÐ^O$^¯O Â_;ÈÀ"D'À  Q=O»H!Àu2À[YÃÿP8ÈÉt@ÿÐ!èåVW»D %3ÀBO 3öt? #jèä| FÄþè |è%ê_^Æ`Y U_^° &_$ìT  SV± U!øDX+ä Áû7ý (8« P+ÁúT$Fú ©3ÉÂº"ð ÷âUWÁ÷ÙÈQèO  3Ò  .è,ZÛÝ$OF"3Ûº   a &Ë;Ès9l 	Í .w+" 
+ùÁÿ;Fu&ÎèÚØÞE´N! $?w¸ëà! ¸À! F?t8F £|$ ÿ~="· $)\£@å 9h ÃuLÝ"< DÝCA;Ï*O"@¦hp+ *UÿÀI5 #x¶@Û î!~;ïsp;ÍwjVÝ+Ù!E
;úuNÂ+ÇÁø#÷sB+ù¸# ? Ú+Ç Ö ;+ÑG!^¹ÿÿÿ?Â!6,Ñè+ÈÂ3Ò"Þ,ÎCÐ;×CúWè5ðÒÿ  `A ëW^;ûuFÃà b:`ba?`dru+ÙG `Ã3Ò`^Ã;ËàZÚïÀZE \0ÅAC @#± #Sÿ$[!¢"ÿB ©;T$0##Uè^þ(h ^vÄ$Ãh4[ÿüÌÁÔþ!-@^ÿ`Æ Ã£ UR_ ê? 2UÅPEÑ{ù·h G;·l b"UU¯~$ uTh èý!×Ø"]ìÇ8Ût)hFø&Ø#ôèWd¯(àç
*ü ü Ùÿ^$ë^3Ûà
P2ÀV(Eó3Û&0	B
Éx+\ };` t@9Hux< uMÀ@uêEóCÂû@|Â%> ¢!ëOB¿4lø 	Àx*=    }#/ NÀy*QX ë° zëºPè&i"Ø"2u
V8 +"¦ë;(u@GY Aà Y 7Y 0`Y	ÐÁúÒyèÒ'mëú@}¨ò)ÈÿÁ|2ðÁÆ,!U¡a¢!Úàï @ïÆ@< àèñMôd-Ï  Y)3TÁ×À ß ¨áß Háßñuè}-Q]ð3ÉG,#²3%xü |21È|)x |x |ÁÃÀ -ù@|ØëÃëÃë- BÃÁàº$­$¥ä £«û""ËEäÁáQjÿPèUB CÌ  üDO(}ð@ÜMØ}àB9*+#Ë 0Ó Ò S ÄO°H;|¬@¿¸<!© > ;ø~ @8 !ÕEÈÀ$ : ;È<Uä;]èÁàÁBff!¿f2R@¦ A Ë`J8
~ã]ÜEèG@ÀUz~MØ  F B`Î*9"ÿ}àARëï@ò ø}à@]ð!O$è Ù
  
3ÀEÈUÄÇEÀ!1#A ¼ %0 Ì  EìUØ3Ò3É3ÿU¬M°}´3ö}ü2ÀuÜAg *Ë] cÔ ¿ ¶À]àIE YÐEà;Ásq;ÐwmØ+Ú$¾;ÏuWÇ+Á!~!0sK+ÊdçÁù+Á ø'q+úq%]ë Ç¤ëÇ;ÏM¬EGÖCòVèíêÒÿ}´M°U¬ 	Éthëaàe à e à	e.FEÐ!gÃJÊAuÜ!;u! óCn]ðD-ã"0÷E¬P09äè§¡öÿø"¦Eìÿ¾!h;ø¶ /HPN$èsØ!v$UìMìÁúáÇÛDû«È  E@$f|M¬É tE´ae =!Ï?¬ .þ=   r*öÁ AM 
+Èù 
ù#z  (
1øfÇEl.ÇEK; kúé¬#u°1;M¬+ñÁþ!M)Æ¸ö <  	 P@¨H$è5Ö
-á¨¨ÐMð(ÓUàWöûTe.¼Á(Þ9Có^Ø ,=È] Ì 	Fþ;ØuC@' Ð[Ò`+XÑ / Ð` }à ×@ 1P^È 
 Ã 9(à(è: é C Ç  %@gój  Á  á bÛu3 	jë?eÿÿÿ `4 JØ[Û \Xß `ØéG %Fÿ °  9bë B/Ör@Rë/ó bvÇB(	¿/ÞBr ë/ò  (à  sè/Ñ ¹#{AH /ÁrÇ G?ÀéuéMÐ$vJMÜcDb ßBdY `M@¸À%ýWà°¼` Và¸` Rà´`$¯1X à(ÏMÿ°SsèÈ$ Ôu¸@Eì%ÏÔ;Þå9¢Ó#· eâ­'â­ ë ¢­ à 
¢­ Õ 
b­D°B­õâ­#EÌEØ@ÿ$ÚEÌ=."û#X%ºUÄè,	%	= 9âæú!ÃuäèC[ç'3:ÀÊÒt+ú$¹  1ÿ?w9½ b>§CvöÂu&Bü;Âs+Ð0¹rú#wÐRé(»élÿ8Çy  Ui_(d¡ T[¿2Ué_}ð]{( ½Ý  hD£èzô	',	EÔèTN B$3öÆGG Î ^&ß&/;C(hù@¿]Ø "' fØS¬ûÁç@ +ç,UÔ!Gç&òðCï@tç	 Ø'`õÑ FÀÍ ;%48ÿK$è+Ò%WEÔÇEØ ÞAãFÙ(MèM¼]À}Ü}ÄfáÇEÐ 4ÿ$ÊäEàH¿¿Eì;EÐb# Ð!* 

uì;óuä XUì;ÊUàw{EìeEÌ;ßuc&ø Ã¦øT+Ùøû+Ãfø I;+ùsæø ¼æøôãFøÄM¼6D g x@¹Mè"Ý+$rëkào Ù$>ào ào ì o)¿!>FÂA.UàþY Ê'+Ù3ÿ å(]ä(|'{aOEÿuØF"Ðf f#è(%t%H5W! 
ìÿuSuð
  5FíýMìf9¸I(Ãéó!  
ôMì"¤@ % À%ðóYÄéD3»@,EðtºüC@1°f`O(ëë#Mð`Mì`àNè[í N ìB} `"IÉ!ñààMÓëààGFÄ GÔEÌà â)· ¿j @à·ó\Â ( Æ&bÅëà +uðCþ;øu% ùLº@ ûJV@DÈ[É < Ì`+®  ï`ü àü à ü@Ù ¡Hà ùà@ù*@-àùààGàù!^ à¬ ñ Ê ´ Î ñ Í@­4ºà¬á)©ào Ð(M 'X!°'yUÐàÄ ûá¾ø[(YüB`ûA	âàD óàDð[ö D ô"áû i" Á'!òeÐ a! Ö / C!×ÿheië("Hb as Q(s Ëhs Ihs)VaHs A¨sÃAhs  Hs Ù Hs rès ¬¿ è{"Oºc è ¨^} Û ðàcà'bàaI}ÌWV!\uìRQ@B Îèl[(l}àG^]äÇF%ÁÿÇ%W?$~;ûGêu&L SKhÚÍ&øÿx2 SèûÌ +w Ó+sË+u a+nëk ( èÇõÉtUEÜeé = q+n  èÀ +nuxh¼sqh¸rj(´weH° Ò$O0æÇE¼ 2(G À  Vá#ÈCh-bEÈûUFùÿ(Ôè³:èèI S5¤Uéûÿ+ÛwZ04ÀPÓË ó ñVWô0Õ ó-õwGÏ!ï2?QPq"$SWè"?  <ÛGþ'|Ø_^][U¯ Þð/ è¯ñP·'M K})? ¢ Ëÿ¾ÌK  uE¿.A]Øx 
ÈEìèNã| EðÇ,5g7<¿   <¾7;÷t%NèÛx9Y0u ÍEQ`Æè 6;÷uÞ`A 3@A $è¶,|%õñÂ5ù@ÎÙE ²6# ¶L$V(FL$$ÀW¶|$Ið·Ç6Ó5Í$ð5=Ô@F¶Ðf5Af3 u3Àë E 9½ 78´ 7"(U;Á	Áàåè¸Mf;ÐÞ!x·ÿõÁæÅ÷ !ò3, ÈÇÁè:¬ !ç!ÞÇú i³Ø ÿ_J h
¶y ÿ$l 9kRb$,f2Úf;ÁtÆ+Ø  7`fàÁáfÈf|$ cf`À+ *[eÄÂàP 7àPº? Ú#ÂfÁ`QbfiàQ X Á`¢ Q  @ë@Â@	 ¹T Á`' X R@6  Ð  A	´«Ø ¼`ß4 9!Yf¼`Í	 |_ËèµûÿD4tR úêÿG¿ÍO3É8`ìÁÁc¸O0¿`<G4@
@pG83À/ Hð!~07G< 4G@    A_á5 ¸Lõ!ëu. Ý 7é 4s@ä@0 ¿ ám¸Ð"Ë@7 % b @ò "@_À. à. Ò5´ ß A ¸ùß ·B×`ä·"Ö Ì ÚAG¿ÁàÎ Ì Õ @áôÉw é  w  &  b"Y à  àà Àí/ ä Ù6dÄ ï!ñ}%Å å 	uþÙ Éÿ»dMðud Ä È »dÏ}Øè¾ÞD Üä  BvÃ!Ü]à;}è&e )Gwè6F,=0 |=8 ~	9N01 
EìPF0¨U÷ À6iÀ#"]A	 "N4E F Qÿv0MäRè
æ.áä·FWfÀy #	Àt
H;EÓ"$=Ðd QÚ'a_èÆ4Ç¸ +± 9\E6M;ñty}ì~ucF;C,u[F;C0+¤V;S4uKN ;K8u(½F0.CHöÄDz1@ ,  D` " E<À
ÿvÿv$QRÿv&aOzö! %ñu}è !Æèi']à!9`KQ*&&è.%ÓMð'úAa¡,EÜ}Ø!!}  &" 7Ö&åß %ß V$ <5ÿv¶FPÿvèËùÿF3À^ÃÀ Ul$ìhjÿhnâtd¡¤P9Ed"~ Pù <Ñ]pE|±aË6Ë ÃWé"xFá  <
IÉAt3Û5±]']}tu9ëEM¤EüèæîåÿM¸ÆEüèÚ` ä èî[!    (°8WjÇA   ÿPht¥;M,è,Ïÿ &U,R * 9çP   èÀO I×ÇET 7  D  3ÒÇEX   H   \   L   `   P  ¨ U$H+Áù4¯rBØ]t@ <'¤}x u9[Ø' "ë%@tì }@ . . 
Y·EsRÍM¤À`&«Pè"þ ¸Àt }@E$MEÐ@\EÔE¤PÆEÕè=
 ¹¼ÇEØ ÜB8èãméÿÆEàG@l>! 	Aÿ8 íG ì 1øCZ	èº uB< @!;Èu.»  u"QÌ EðP¹l yè÷§	 SèQ­öÿ)êuÇ`Ç@ ` vèéÿ!R]t #ØBA`  Áb;Ñ þ#%E]}#È${Ï¸OìÄN+Ë÷éÁúÂÁè<®E =;ßÅ eÃ1ø ¯} $Kû [ <}ðtpÿuzWEähÌ;PèåÜè jèUTET2Y!c"P jU ÈE.RUDRf/óæÀ v	òXÅ^5Ñ Z ^È#ÃMDÿP 9CÏPÿR"ð$}ð( Y$Mj<jP@WVènùJA Dáø"2 ##]2ÀE+;ûtMÇø t!ÿ7ÎÆE+èh'C,?<;u
Ç`	$Pÿï4G;ÃuÏE+$)  oÿuìèdq;Æ}MäèIæClèa@¤èY Û÷!:
ó;ßtNèC Îè< 	Æ4;÷uêM á
|=ÄNìvyÿsûKÿÆ¢Ì
H\Kãè+Æçÿ BtÁtèywæÿë/¿@EP@%çÿOB
 è@Æ"è¸æÿ »Ã4"0!9;Ç$"éÕ kÀ4©2öÃtCü;Ãr +Øûs û#v 
ØSèàlÉ3Àë-Md3ÍèÉä ehX  (> %^¶APÿqÿq	è¶5m3ÀEZ¿ ®åJ@VW¥LåFñ÷FXU`t¸-ë"ë¬\ÆM´è°<ÏÿjE´Ç P!¼lüÿIÈu ÎPè;ö  . $"<$²´H7èÓA@àè{!< Çà_ Î ¯
Áè oì[è °EðåýU¥ uÿ¨¸&Í¤E w v"Æy^À°@ ë} tFÁû8øëØ@E°]´öt:ÎCÇF 2EÏ¥EÏ¸èÇ&%Ï  	 QBñüeÎF èLº%ÎMÇEà 3 ì Ô   ä  u#ÇEè   Ü   ì  Ð¬#éè¼ç[ t#- Xèmèå@;]°Ë%(óE,u¨U@ÉfìUuºIO%¹ ~@0 + Ñøë¸A3ÉEM-Y @Cu`$·H¿ÈÎ!M·`Y ÁA)ç>G1FÂA+5@W  hf0s<CK
º  Í  )foÂ`ærE¬@ú	;ÐtRÈè/|"M¤%Ô 9$Ù'26nË$íjÿ$ñ à4v RÄÚ àdÚ¤eÌ&§à)ÀþøwY-| ¿Dë t
M¬A8Àu?¿Z Meë-à #ëÀt	Æ`ëA9    ü CÀý7´!Á " GV3ÒÀÀ~!BÆ@9 7@À;Ð|ä]´ÏSè¨	 =Î&ßtVWèÖ½0Ðéà l!uákX"&R(8¹U Ä È 1'Î¸Aèfé"OÌW"]è_p V   + ¸@1ðÁfùu÷Á 9@v
¹G2T¾)Ñaã C . À|;Ø|@æ ¶MUA"M;M§ý!UCÂ#Rî"¬"²BÊG æèzDèR%É -C·(ü '½
¹à@{Ø½| `	 !VÿèÇ ÇD1Q@ Æ(&{äB%! ð%!§ß'S	å]Â £ Ô  Þ  È $Z` Å/ÿq%2%.E5E2ûe2J *n* \äìH¡Ê `ä 8@ulÆc7}pc8ÐÁúU¸LM´¹£ '#zE|Ï&'øwÁ1ë4æ£NÎFD±$ÿy$;Æëb8!Ø ¸C4!-*JX$Ø3G.Ê#u|! W@(H8,¿;Mtu+9p,;4 69H uf f9H*ux4 }Mx9H<t
G;û|»é} L ?Y u -Zm %úMÀè{æå<tÀv;!Äæ!¤ dß¡L@( Ç%  EÐèxµ #uÇEàIÉ%@>¨~5a P@UµSü @ ì 0  ;DMðV`Â2n >ñ À !(3@ÓÈèÛòÿÿEìF;ó|×Eí-W  7¹}Àuèj9$ìPÇE %Ã¼>WE8ÇE8è=#Ru<}%õ\]¼E *£ü  èÿ M   èåú ÿu¸Ëè[V(¨ËÿP8-ê  
jÿjÿ9dÿR8EÌ ë!Ù Øa$(!)Qy   O  ¨rà góæÿ   EÄ ]
Pÿ(*¥ Mç"Ý `"ÝÉÜGÿd]Ââ Î-/¬$<#\ìÄ "µ ±âµ DÂµÀ â¸O°ä»ÈFë:ÈÔ )ö|	øñ!Y½Ð 8}à @K`è4gç"ÂË %fnØ %Q¹ u*y$èà9ûH/M°èäå 	h!a °!.!- è SD	°è(¾ Eà½ !þ Ç  K B­ VW`PèDèà X´ FÇþ|ßÇ p"  `(ÿ³2ÕÀ Ç$ Aèn!èÉO  h@Ht h`¬t jj$"è
ÕAû}  ¬IÏèûR&Ïè½ £µ@ ¡Ç$F@zÛaFû ÿ b½Ì +ÎEì3ö9`~KEÜEÔGEè@ þÔQ~ËWVPÿuðèl5÷J OwÜëWÀE/µA÷;`G	|È}ðjÿuà`äèf« ¤ c w@W ¸O¡Ñ NA JEè0Há Û !Û|;CKÿPô!¸×¯A8 7EèMØÿuØQ :$Öÿ³BRPèás&=F Gmì ïCþ%» >Ç ´A33À¹Q þó«SVÃræ"	² Cû|ÐàäØ@5èwª 83ö(_ a ¿IÕHø @µAøI >¯RàAØB  ½B$ ÎAÜAÜB@ A àB@ AäAäB@ AèAèB6Ú @AìAìB@ AðAðB@ AôAô@ï# q! BR 	ÝXM#á¼©©A¼íV¢ßdåâßx±âßdÀÿBè"`@	røA¡ÿâ GE8ï äyMäâuö2âu Øâ uð¨@¸¢uqfHâo äâ%oäMÜÿuÜâoqqâoEìOH ê þ#s!_cÆ£Á%g#Å­Ñ%t ¼$b#% °åw°èïíEw °å w ´åwÀ F%zN×%z¥Ä  ]Yà E äe  %%Âìº ¤ å 7À$Âísµ$ -C·Np !µPè7ý) Ä/ÿ5Ø%{P ë Ò M èZÛåG3 Ø ïèí%B`  èÿ2·@Aeè@A U UÇE#& Gx!) © i üMÄ·çèÿMèÏ.Ïÿd l èà i j )hX  @ Z  '±è#õç%Òx -èfÞ )   èKç ¡LM%>µ| $EÐjP #þèÆN øt % ö@·`xè[þmé4"ê
EÐ=ã¤ö` }ÔREn -EÔFÆètºæ%G ßjEì@iè^g¨ Eð= ! ! `# : #à  }ÆD ï C&@*è20(@Àu!" 3 { %Æ PVèB*% ( {â¹`n@û ÒqæÿADM !.!¨@Ùóçÿ+÷ 	VWè=	éÿ¡ â!¡Gý 
 B_HÏÿë=èÛ"^ ½à$ " $!~  (ÇEos _ rM¼è   /M è«O "@èðüå-nègB£"î_Ô a ¥BÑï 9 SW»BÜ9Á"6V5I÷"±W"Ñ6ëæÿÇ@ @ ^_[Â£4;ìUl$VJÒW=7*Û4¨>ÿV'nõê"6 ³@!/N¨P+ÊQRPÿ,Fü!jN-nU÷ÁL-~) JTÙ;Å|H`
* B`)52;Ñ|×)Ý IÝËèÖ _^]°à¨  QS\$¶QL$ÂÑV=èøW²Kò ö^ ÿï ©` 7@öN¸9¨@uj WSÊèèÛùÿT$Op Gí lø|Ð])ý Yär@VWùÆ/]=ê8p tS¹Ø4êü·!8 ÃL4ÁþãYKËC8/[öy	j èA) ëVèÉ, L·SèO!­#5èC-óÿG + +u¥ ! Aþ@}@úL°ÈÿÁYõ.H !¡9 SUVW|$ñ\¾,¾ T'm  P¬#3m(¿;×t	À;ÁuòëPáúÄ@* þKâw S"w¾èæÿ_^ÇEQ0  ?@ Uì% XåìpÅòLUUD¸`%/áj Sà >jöë°@+°@ÆÑþÆÿx/§@+aÁâ@ 
·pÐRèQ¶$PîUyÙ@& s R Û R `R @1Ñûw!u°@ëaE}EEj,íOë%Ý   ÿô 0 =*xÐÄ%È}Ì':E$fIPl÷ò$@$©ÿèêí sÿöx%4L@¿pPè)N½îyää; [-µ$9%Ð#~å]!yÿUl$ìl! á Tá  hìM¨ut/O BaBÇrE¤æÉNO#L'(ä  &N27%	xEÜùÕA$Ä! O{»&  ¿)A+ (2ÇEð+"+ÇEì*+é· 1@* %»&,× ¿#!  (	@ð+ #@*#wé * %»&@*`# (
@#ð+ #@*'uëd@R "»&5Y¿)`  (:3@'  @'  ' <@' "»&  ¿)`  (`ð+  @'  ' +`õZÂ ]ð]ì&NM¬}ä]àèØÖåÿÇE¬¢^º : Ä!Ú r¯¢ ¬¢E¼èÕ¥Ï¢ Ì i@/@-»9uÜÚ MØÁ$0¡H,;M|;Ë~;Ï|0m ~
;Mð|;Mì}| tQÿp8H@ÿp0èÝ@
 / 	,ä/èë9hèF;uÜ|§3) |'¬èªCP
 è l 3öàoøOà q;Mäàr,Qÿw8O@ÿw0èjr4mM¬W=Wÿ ¸ÈèøñÿG}]ØEu¬]ÔjuØ#V!ýA!  ã V@ÇE@Ì°K]DuHEd]¨EðKÅî#S ' èêPK ¤&fF%iðK ¸!%!a¿!+0K¬èiPKVr  êÓ¬èãæ0K 6 ¬êÓ°ðK h#§}Ì el]Â ¦ Ñ  ü $ L ½¿} ìã¿ <ã ¿ýÁEÀC¼upÆã Á ¼ãÁÈE¸°BS'ë Î#ÃEOT%z3Û2ÜÀ~0@A¶@*ÓtÀUtK;P8DËÙëCE GG6;Ã^ ?CÌèÇÓC Ì ð!]!^ ä##bg£1eEÜèÄ¢Ã ìC	 /@ S $è	Aü.ã3ÿ9] ~@ÀWÎ`tB^Mt;H8tÀPEÌ ; S@ÈèöñÿCG;} |ÀuÈE%uÄ"v}È"v$S@qb}ÅÍ$<°¢vu@}DE`uÀEvÊNìBv bv"èBv ¼'C Eß² Ç!F 
)h¬f@ 1"X ÌâXÌèÂàBX 5 ÌâX ÐâXZ¤$ÊBXh]¨³)ï¸«ªª*VW)d"³` +Ö÷êÁú½1} ò U* *`9uJýÿt;nu@`6HèHìNHðNHôÀøNNPè6U@(Áøèöûåÿ`6èëGÆ`+@ ÷=¯À};Çw)gIý â ø  	ìSUÙÇD$dV½À"6\$W)Î»$!¥3ö2}Q+  .)&A¸CÈ  	À3ÉÒ	 fo?8 uAÀ ;Ê|óéñ $L/ü*i
ëc4/öÒ@ @?F ? ¿ à? §  èt
@é@¾   À-$ rZÎt$/Î ±@Yú#-yi|$ ß $'ÿú~ú|,ú|~ú H|ú£ @ ¥ |Y!øÚ C#¨xK<}G7r¾ÀD$(à&Ü  "I -¡"t$¸@ÿ~A aÏ|ó*=  @0  Â Òy+3Àë2"'  (R@SèÂ#< X@/ ä
 ÐëÊøºC¹OÂ`@þ;ñß   \ 0ÕBBüR JàG1ø È  ø ØBÜJà;»@|ØéLÑBéøcª >å;<}7¾È`¸ á Ý!x $ §@£@èn!ü`£.Dnë`­`@Õ=ôëà®}4`ªÅ@"ùüG@è   øHü:ö   ¨ Ú + $@] N!Ñë í FÃ Å "¹ $ ÿ!)Ç ( #u¹@á ui|$}.¼ËÿtWMÞëe$çèXÝæÿÇì@ ë4@A¼C 1 !à	1 &`1` @ `/t$>ÅF" CPýUõ«*-[Äþ ` UéVWMü*n¸k`)? "oMaCFt	PèW_ó/º 0 j2!nc CÿÀ # 4îaÜ$b µ`s n î`R3ÒÇ,U%¿  nsá`dÀu¸ ²u)¬ )G	I`
ëuÇ@ BÿÇ°  ÿ¸È 	u&9Ø ~ÿ@.@	 # . Ü   . ô 	`. "@.@.@	 # .    .   	`. 0 @.@.@	 # . 4   ÿÉ B`áoU@a&3ÉF+8!tP?#9¸A t !A+Â>E;È|æ!ô% Y,?ÆAÌ a!:úHpàO ïàOu	¸@5 uÈàX Ýà9bGÀ  Q"Gù3Ò¿wöO%/	Áòt$f8Ú6^æÀf/ÆwBÀ;Ö|êEÃ $ * VÿëR )À*vJó¨1q4R 
l±#6`Y-\  ©/((ýTø.9öÄDz "	aWÉ/ÌEs `3@'(Ú@*(ç O% "=TÜ(ÄWÃ(ÔóÂÁ 
ÈVËóXÑó\ Ì]@: Â  Ä !ÃTÁ(Ì !%p`\Ð  Ê )`µ(Á [ \È ` ³\á   %º,Ä%Ó Òd$ À 	7 9  µ¿OA?Ö|0B	I_^ÙDøY*lW ÓÛ² 6D² |²D² ] ø <'ý+Á!J yæÀ/Ïò\ð |$  À:`òZÞó^Ø $»vW- !@/-0§aW 5@è Mæ«"	 ®Ý_ f -@³(Í  1Ó(ÃW!T$7þÂÅ4Ê(Ó!!3\Ñ(Ë2 Ã  ' Â ¢!< Æ a1á) Ù g Ý!" Ã!" \ ` \ 4 ^!}YÇ ND²^ {D$Ù A &T&!Ì/Å³`»\Þ_ $@IàÀ8à"À à%À \ À ÀÀAY÷ Ät$!¸ #)ÀÃ ØL$_^Ø)2@ÕÙî_^@qUìäøìL'ËBÄ$H =Ä¸ E1É]Vu#A=(D$PF»&'h  -tPèhX ëj7øËu|¸.# H¼@É  È 3ö,PJä#¿+ÑD$O|$ u+
;\/´u
;d 	t'	FÁ;ð|Öë;ð%bÄ ] Æ!è$«°t 3°  pÀ $
|$P4°ó¥éÿ Ê¿¤  |A¿¨` 8$)Æ  °  O @@L Î 8·¬ @L I µ@è cÀx^=GF}WL$PQM6 x÷ÿ³@"Vÿ!² R ¿@,	Bðû7A'ëD$ xÿ° ^ VG¨Vètæ E¹éU@g A =[Á%)j 4q<@<Áÿ°`Tt¾!°	0Æ8  áÀIÉA´A|¸|!âAæ4 è7q÷ÿiè Ë ¨ Y0åLFi ~!T$ Cf;¼ 
|$}iø^úÿ Ê3Û( N8Ûx;X}HÉ~@¯Ëë3ÀàVDPC hZ¿Z F;Ø|µ V )1$@|@iú!J u-Üx A	 aA@(é Êá$ 8á$K <¡$p÷¡6ÿá»f;`»}c|!T3Û ½ !  á=  ¡ a @bhAa	@á	@@ D$ %p  "cÆ¼!ð  ?¿Yá òE(t)è{^q{9^fFÁèòXÅ^* X $(TÏÿ·BºSPõä  ÇPiÆ ä#
èzýÿ e u cì-º@ ·B¾ !­ÂÁøtBÇ  º t_è`ßà \ ¼ò^`å $[ZÈ Ø/_v
%3 @	 ëF`%K&ò `A÷  ¹uÇ 	 y¿è7ë ²  0(; ? G ¿h> 
Ç@)»à * ]Ü fnØ @ Z'Ì æ'QXÈ}'N"  $à4ê  Ò ÆÑò,Â%$é@9  Á $  éÇ@J A+°\!?ö¾@ÆÎá =ãö `-DD D9³DK@7`%4;K8uxà3Î $à Î @àÎDë Ë H L;ÈLÁa7å E 5E.»bt%%@ÙøÁù É(Ædæ3ÿ»è! vP³( ) 59ø L¤ÿÐ1y' @H`  X@u \`¶@JGÆ2Õ ¶ ;ø}»ÅC-ÆÆ uÆø r»`@ x!Jÿì _ÆØ $P!¦^[3Ìè|¸+Så])   Q$·SVØ&ÈÁëñ1¹ó#IøfÛt¸ú  èÁØ ë)È  #;t1@QBQ   &QW^rô÷ÿÿë²86Kê {@ %jAÿ=j"Èw"· "§P&{î¨OðìU<S ò"Áî÷Þ5çævEE EE ;ÆLð$Pÿu&ÿuQ@X$RWè	 ®M+t$ I
)19²¡ 6¥M9uC®U(=pJr(Ê"[ *#¼ F*ÊXÈ M#j2Y8kV #, ÊÆÀ#Q +0 X+f 	(d - )@2 h(l +ÇÆÄN,À*è,Ä(ÅÆÅN(ì*À\è K   *Xï -UtüÀÆÄªLàÿ| 	Tü;E"/(Þ(ÇÆñîÆÙD(ÎÆú 
 Â 

ÓÆ÷ÝYõÆÐ ÕÆÏÀ÷YÍ\ uØX@¿ # Y "` (  +>@Õ\!'*ØY5`@
Xò)2Âü!V	ÿÿÿ!¤!YÆä@ØÄw![Kï*l à!-f ´}Q!ºVQ!;  A¸K"ß ^BÉ BG UJ_â: T3É!õâ !¦â  E!Ù@µâ u ¶   @â7Vó[" ì Qá>ú Æáù Áù}Áü!Cáúg#Ë;Æ!ü VC±áü ®+wáü  3À8Å,GÀè t13YuU("/$J @	ÀûÀè¢%ÂHà+ v@+ oÂo(V%»ÑMlµT$Áï÷ßçvUE  |dÇLød É Jô@Ð"É$"ØÊè-"Í+|D M½ h ):ÈE:ô"ùë!/ #:W=$SM#=É A<fpÀ" è ADyXè)D\)L$ao@EM5ß	tüY@(ÕÔ0ÆÔì.×ÆÁ 9 Å$WÐ;Ö. 5(àâÆâé(ÑÆÑUX/,ÂBW ` Ù$þ$MªXÚ$àÄ!y D ÃDê  @)(Ù y T v ( GÃÆéÿXë.  N Å@$ ¿@$$á(|$ E$¬,ÀÇE$#ÆÀN@	\àDü%µÆðî0ÎEÆØ$Ã ÎdÜäÑôdÑ ÔäÑÌ\ç 3 YÜ  # DÌ  ÔäÌUAüA¤5\!¥U (ï!A í#Ì,Åw!®A£#Ô ó#Õ!ÿi!"âRB WB$ÿuQ"ì(è'Éå âGo"É +âo â!Óâ9o _@E Mâ'o  5âo þb âo Ô@)âo ¯@$bl(ÞEvBiEvâ_ ´â_"UÂb d »â] **¢Â]äÏUsì$¸c¤À(ÄCÆ DïBÆ fD$>/;$Wo (á B%´oÈ~À@4@2A ¨U;ÁWooÁHé (3þ@$,ò(Ø !)R /ªí\ýXþ#MY$2`(ÐYÏY×\ ç(ÊYÃYá(Ï@ Y3ß(×H@7 Ð`é\5+ ) ÂÀÔYß#(@¡ X$ YÚY-h¨,È¸$oÁ Êó/Çÿ î8&¼&$*È û\Á#â _ .Bè@ Ã¿ 8 8 ÚA\ IV&@A*!F !X Ð@b[Ò   Mo *Ó3mXR@ 0`° f ÆÒ!_0Ñ"Âá_[ÀA_(ù(â"Ê r!b X á_ X!<$ù ñá Y%A\$ï ì%!8 (e&AbÊ)Iú (%!æ(+KA]%\÷Y#`Ò\å(Æag@XT ³ - \ y[ÂYaa!¬@º`ÇXÜ!0 á_ .Ê_^[6~
UtRÉðÁO"¯ â¯M#Å AX"®"´9!"!B!Xb±$!TVâ®â« ïAKu'h+÷MEÊ@ B· Ï@$Íb±&Ú" # +°âo¾â´Xë!!,>ÿ
!L: AYBÚ"ß â ÕbÒ)bÆA=âÆæ"¿Ht E$w!iaïá iDw­ Ð¾OåbÂ VA ,À#lW!Ïâ¼ íAVápaoÕ!o ùbÍ AiBÂâÐâÍBÊ ÌâDÍbÈB½¢Çb» át 0i!"ñâ ç'q âØE  âßEº'HCMV$
#L{!µ 4ÑE($ø BóH.nÄ!   EC ø"í/[ÿ?j~9X*'ÿ Ù cuùI÷E§!z"2Áâ*à.{ë(÷"lXILÁð ¢,ÏäÂ\ôMÁ$" @bh(H Xõ	YÆ(æY!BÎ\õ |D7(ÖYP @	YØ(ÆM@ Y 7Î$l@*$< à\ÓÀèD_ÁYÖ$ÚYÓY%dTXâ)  ßÿ@Þ§,_!*,Ç§\ùe§#.nCà Á 8 ÜáAYE0 )Þ¡y N!yÉ @Atb÷!xAs£  Bþ  !v;+ 0#
+4Á² Sia Asf[À!!|An(ú \ø(ó!lXóÂÁqan þanÇ'An ÏFþ'G¡k$® Çak',!k ÏG/An'2, Ü  @ \/Ñ'k  aa Yg Xá  ) sÅå áay"ßâ õÂ1BõB¶[ÊÌ  S!{ Wá{Áoâ	ï#.â6ï  âï ìbï âï Ó@oâïA{Axâ	çauâä'BÂ¡uâáBÞ õâá	 ÀE@Ý&çeåa|XøCEã!{ %a{ããä|  Áâ	ÿ BäâÿDyâÿ&0âÿ ëAAbÿ Ú@âNÿ"ü#â5ÿAcá
 0¡"îã  ã S%êù·Ô%úÇä5!	  7_ØãtàðÀh 2  j8ÖÇ÷9!Û æðÆ 0ÔÀ § #E GF5óYØ= /ÏZ8x eX¦P 	Ç` @  3>Çd 8a 	 7p ó^ WG ¨ G  	Ç @ Çà 	  	@?        Ç( @ Ç,à 	 8à 	 < 	!EÿÇ@à 	 D 	6^é{föáìSUVñÇD$@T3ÉW63Çdj@!- @õ&ü   T!BøçánÁApVöap$ÿ!va:Ò d  aÇ@* + *!G Fá{ÇA 4Í!ÁA¦R@I C#±!CðÇ7¾  @? C-³! C4¤aA K? ^ Za~Cx4PÇC`  & @ h   !oKpÃ0ù@ ÿÿÿA{Îa} A}_a~ á ~ á ~ á ~ á ~ á ~ Á~^][Äéùdááä   á ÔáÖô¡@$á á « *á]¨ Æa _ÇYö@ Ç@  Ç @ !   ²WáUgcá á dG  á T"ãFó¡@$á Èá  *á^IM ° ÐÇJÏ@ ÇÄ@  Ç ` A Ð 	 á[×aáè$Ô  á Øá¶ñ¡@$á;¶ä  *á^  É^Çð Ö@ Çô@   Ç|Í@ A   / ²á[G`á hDù  á X%ã&ð¡@$á%^áûïá`EÍ !iÇEþ@ Ç$ @ ÇÆA 0  ²á[·^á èH  á Øáî¡@$á ^á k *ã^IZGSÇI@ ÇT!y@ ÇX 	AH° ²á[']áh¥¡á X8Íãí¡@$á*EãÛìá`JªBcÇJÔ@ Çã 	  	A ¨¡ 	á[[áìÙ   á Üávë¡@$á Âá K *ã^ È ÉL8Ç° @ Ç´à 	 ¸ 	A À  ²á[Zál*×  á \;ãæé¡@$á>ã » *á^ ø!_ Ð 	Çà @ Çäà 	 è 	A ð  ²á[wXápI)G  á`	áVè¡@$á á + *á^  É ð"cÇ  @ Çà 	  	A   ²á[çVálw »  á\áÆæ¡@$áXá  *á^ x¡ 0 	Ç@ @ ÇDà 	 H 	A P  9á[WUáð«   á àá6å¡@$á á  *á^  É ` 	Çp @ Çtà 	 x 	A   ²á[ÇSápà   á `2æ?¦ã¡@$á ¼á { *á^ ¸ É  	Ç  @ Ç¤à 	 ¨ 	A °  ²á[7Ráð@³á	 àáâ¡@$á îáëáá` è!_ À 	ÇÐ @ ÇSf@ ÇØ AB ²á[§Pá 5Ê ºUÈVfÇ@ü@ @ Ç@Ì@	Ç@Pd QÕ  ä   Ô   è  R! êuÀèK [ÎÿV  Ç´ô¿ÇNö   	^ÃÌà  è@2u4 u-O7 `:ÆH(í ¸@¢D P FvÇF FpþÇF`)'uÜà`@_¸O GO ºAuFø¹@O	FüFF ëU@à àUàé U `@ä ¾à`@_ Xà_BÃàD_ÇA/~ Þ A#@   @¿  AGà   &`ÇA %   `-à#/ÇA 5     =à1?ÇA$ E  ( à Mà?OÇA, U  0 à]àM_ÇA4 e  8 àmà[oÇA< u  @ à}àiÇA#@ H   ÇÂ¯â Çâ_ Çâ ÇáÏáo Çàÿ ÇàÇAL   P  ÌÌAcì ºÇ@þ #éÇ@5  cÛ ê@) @/  à#/@êà#/ à&_ à&/ à"/D¿J%²zS1^ÿ` x@å ÒSO@åÞà=? 8@?{"[(à!@ `U5@àøI `é  Và  @?  ðÇ(EÛ  gy, Î  <   L \ l |   ^éË$à`@_ x@ JõbJÆQWÉ@G¿Nvò ø@Ç@¼ "ffPÇ@«@|  Ç`  FP ÅfEA&å@ý|7 F¯@ Ç6%` ÇVi@ ÇW=<yÿÇA  	 D ' ÿéÇHç ß S>þè·  ~`hË@ÿÐÀt8ËVÿP ðÿR=Ä¸ tþ@|VPèj,?ëV]¤Øiq^Ç!.@ Pµ _a [(? ¸`A	 ü  ÿ@êã_AO (@}@ëÿPOZ@!þ áß ¸#0Î^é %  ? }e bPèÜG Æö s aOéË à =ÌÌì\CVW(f ± h0¾Aj WèÖ×J ,hu>BWä(Ü(ÔÀt+¼$!Q@A£  / D$8>(D$<!ô$@_   Ý
Û 8}â . S<ó  @A*` 4@S`8óX´= =Ì] Y §@ ,i7 % ;F -è =(È 'h 
 5!@YØ +L$D  H`\$P "Ä`*  @  è`s H(Ï? P  L ë g / By ï , V Ë ð0ZÁàó 0àó,fnÀÀ[ÀÁà@-ó\È(Á < Å ß Æ  XÇ  : h RÞ@áBöÀrBàRrC7 a3v|!ë Ç "§ ÿ  CA@Jsë@"X )|2! 1/Â  , 3ÿvB&`.@6 Lb.E`>hø>@à > ( = >@.@6X@X`>i+ø>@à > $ = >@.@6 \ }XÎ`>iqø>@à >   = >@.@>Kÿ@Y=`>i÷ø>@à >  = >@.@6 l }Wâ`>j=ø>@à >  = >@.@> t > x `>j³ø>@à >  = >@.@> | 6@XZ`>jùø	>@à >  = >@.@6X@X`>k?ø
>@à >  = >@.@6  }8®>H > >@à >  = >@.@>  6@Y'`}kÄSø|-Bv@ ?Ëÿ"yq@*@2  :WÈë3Ûø3@@3 Ïà3@#@3 ¤ 3 ¨  3ÿø3@@3 Êà3@#@3 ¬ +@X* 3Òø3@@3 Éà3@#@+XL@G- 3Éø|@Ï@@3 È`3  À#	ÀÁÂÇÃ!C             $  (  ,  0 4[E«¼`¢®  DDã õ E/ÈÇ ¦¯$ tEl$0w
  D$Hó_Á/ôÇ$à $\$L$©%MYü$El Ó 
Ó(Ê @&EkXÌe? Y \øà X<eh Èà  X%bYË(ß À%eE^Ø(%\ÁeYÃW ©EþÔ`×%2&2&Fx(Â DÜu \i Xlà \d j 3@@d% Ð ¸¨ Y@ÚÈ&wWwYË mÌ{ TF Ü L@YÃ L$|!( LF[ _ ÚT$t`ZXÂ@ Ø`2 T@Ä ^&g7 Ä "w(è T î ¹ lÁ(Å § §H$/c D$p@7q l@ À h@WÇ`) d@ À `@W³` \@ À X@WÛ` T@H`B¨ X`Gü".` @) øÀ @ ô`¾È¶Ä` ·  ðÀ  @ ìÀ $@ èÀ (@ äÀ ,@ àÀ 4@ ÜÀ 8@ ØÀ <@ ÔÀ @@ Ð |BÔ¾¨ tA¹tgD$D!Å þ Ì ¶ % Dc¾¬ b¤ D&õ_TF@ ´ @ ¸ (#0D`  4]@Àh #V Cs \`s \@¡  µ  É  Ý  ñ  (`!   ` `¾K `  ¸-Øi1%IA(Ì` `!Ï C!ã !÷  `` d`"3 "G  p"y\$t`#q"ìYËÂ  | ê©ÃXbÏd$]Õ£¢ T`Cn Ä ?D# Ù ) Ü#Ã|
Ç(
&$  ÆÇ!'@ @ ¨*§@ Çà (àÇà ¨f=À9Çà (àÇà ¨8@ s ¡ à (à	Çà ¨=s@ 9Ç à (àÇü#ñ@ `ç @	À9Çøà (àÇ<ï` `9sÀ9Ç]@ @ (àÇìà9#í@ ­Çèà (àÇo@ `V Ö"#¸exÌ  aÿÁá  3ÁÁéé,¸?"À\Ä++É[É"%$æYð&c N4  *¨" ¬ ¬à@Y@å F`'èNËLÏní ÀwYLS_Çkx    LN_C1" È 4 E^ÄL× Ãm¯x:/ Ijv*Ç@À   â uêUßÿ¤cm S-°è7 @µMz.jî WÎ øî ÿ.WPèê® WN$Ên_( ·!Ã íC  AÍ BH BÃ ÇiÁ@ ÇI9@ ÇI½  ! Çi,  `	HÎ@ ÇHÅ  ` À!@  Çfª   ^[ò 0@ÞX9 F@ ÎÇf£   (Ç4¢NÇ8`	?èY $	^éQ
óÿÌì!"ÙW\$è H*=@ÿPA0ÇÄR   	£N³È 	, BëØfWpÿFû Ï  $ 4Ás > 
 ÏArÏ-¦ átÈ.» /ú ø!zPQèo¡zPj Qè©ÈazÃpÆDl$u ¶ ¿DS|$Ø$$Ô#% X   L$`@ñ    @42R Ù  Î@ØÎÿPÐðtkû@|f÷Øà Rv §þÑ3ÀÁé+Úó«Êáòóª  jû|ÓÁêÂ÷ØÁàØ)ÆW¼õÛ~&Ë3ÀÑþ @ ><ëSj Vè¿Ç`é  »!ÁpÀD@Éï  @ì%+È 05Éò/[#=»A#pP¸ø%¤ZÒ +òYp&  ¢	ºÐ:;Ç!Ó Cÿ·AÉ¿ À óogXÂ2WYÂò,ÈA÷#Hl3!~úð C|Ñ Nº 
t$ @P àA @Aà C Ç!¬  Çú@|Ä 7@­@}Ã 
ÃfZÈûDE ¦ bÆT"tA¡á »  D á» iA» dÁ» vá» |A· á· á¸ 'á¸_^[ÄÃa¹Æa¹ 1ÿC¸5 (ÖCH LEf Qà O÷ oa d" nñM nLÌ n dæ dwdì  @o H o Çnñ  #ï Ç`V   	w pà / W3  0   ¾NxÀOðö"¹P@ 2«Pè*Å`Úö~(!+ fÂ¹Bs)% SkõÂAîuã_^Ã@¸4 ^qd ré a
h  k rÚQè dÇ,   è»Ä`nÀ§À @O h`O à"@$¦ Æjn% 7<"+ ÿÀ7 hFF´ RÆ `f @ Ç@  èJpÂó¾@oAr f X öÆ`IÆ\b `M@\¥ uæÇd *@ Çh 	 ÿè / L  ^`iÇAoÏÇApÇAp[ÇAp¡ÇA 3 ÿBFà   ÿ º!7!2QO]/A~!|8O ø èE3!rCýàOQH@OgR!Ì ÇÝjü=cÜèç2à]à_À¯à_ à"_Wùb´RÆ3ÀD f$Ìa& qÉÇ  @ROëÂ0"Óè@hF& B  ¿ÇHL   	"Â Åà á/ÀÏau@á /~Ç@ì   á = ô a=Îè©1á =àoDA'@o àhÕè@àh ÏùP#J@O ` @÷
`  /èè0àÀ QHpá 8v-  !8Çsþè[w"¬ (Ãw¡é¼ Çø¢Çb(  &Ïd(¼óYh`UFDm °áÌÆ° 2 AHÇ rÊ1BàBÑ ê#k ÿ  	DÇ  	  I  	 à 	E.    à  ¤à 	 ¨à 	 ¬ 	f± 
³  Çd = >X°  	Y  	Já  	 Ä -  	 È 	Ì 	¢Ñ2Æf\K A3VÃÆ»!+ H@Æ¹@	fÇxlÏÇ|`@	 @à 	 Dà 	 à@-  ÇD¶@ ÇÄÊÆZº  tDÂ  Çp 	Æx@	Ç@   g 	Æ@	;ÁtV3ö0À;Áuõ^ ÆES © `  #FdÐ Ç  @ À ,èè +@û 'EÙ  à.Ç´ Æ&¬ÇLà Ý Ì !NÿÇÐà 	[@ Ç` c@ ÆÆ   `@  BO!D ä@   º@Çè  N O Ø @ ÇÜ@  Çà @7Ç`H'\  0 1 `à 	 dà 	 Ü O   'Æ¸@	ÆGä  ÇÔ @SÆ½ 	  ì@  Ç F@ Çà 	 Ô K!Æè@    0 Çl @ Çpà 	 hà 	 tà 	 à	@F ¡Çà 	l  Çà   à 	 ø` @1 @¸  Çà 	 à 	 à 	 à 	Zú@ ÂïT$+UÁøâÈ¶³ÐgJ` ì&|$$+.·@µAÄFÁø¶ÐT$$Éà!ê÷AXHÓ  S,L$BÿU¯A¢ø§ zÿ$è Åâ+sÁù¨ò å  yMÍEDAÕ ¦,D¨äT  C2ëV	@\w4 X ¸|!(Áë;¸JÛ 2¸,!° )¸/}  ¸Ü(× ¸Bÿ ¤ ³ë@
FúuQ»A§t0Bè,è]èE/ñ/] æ,*Y5è»  ¦ ò<Lë%d¯YØ%p
$   BÎ > Bà»ð  æÀ][Z NXÈ@e È,^;.  L,!Âú
 !3°T'+ö %c¿;÷t8¾bÏt/¾bót&A;@uAÆ; @	+ú;At¶ ìöuºé¦ Q`@0ÿÐ" @´C7@­ , Ü   ÀÝ\$ ¾ T@\Ð # 	u\B1$8ò_Ð .Ø1H@Â[ @#0«X-`À(!  [ øYÊ-*Áa( 6-@w\È,Æ Á&µ AH[ì,Î Ï * @a!k  T ;!\ ^ ;Yð  m j$ÿR$ ´ Ê-úB ¨ Á@S!7© %P(_^ÄÂ(7¹ÿ @ Ê  *  q  Áà         § CPW¹ "g;ÏtqSVqZ-æé _NÇÿ!}ÇFF{ "4?f^ÆF
 ÆF&^ÉtjÿNàÇFJË 4   , Æ Fü;Çu¦^[_#ó(oNÉuP²nõÿj èGºPÁè`@jÿ j+×   /^é´ `¿Uìjÿh*d¡ b Pì ¡¤P3ÅEðSVWPEôd£  ùj¸ ÇGp%
ÿh§;MØÇ`Ù  f2I µ G`µÇEì ÇEi÷ÆEØ è×òÏÿEØÇE`8
PÏè>èÿEì  X:ñrj@PÿuØèª×Ïÿ0ÖÈÿ I¤#bàOÇH@ ÇL_ AÿÇPë-@H#HÇD@ ÇD	#zÇ#&@ è® 0H 
è D  @ ¾p f·À ¹@ Ç  
  3ÛÇ¤  J ! UjÇ¸ @ Ç¼à 	 ¬ 	 ÿ  Ç° 	Æ´ 	 5·ì ÇPf@ ÇÌ @\ÇÐ 	 Z Ô 
Çä @ Çèà 	 Ø 	 Y Z Ü 	ÆMù@Z  ÍÇô @ Çø 	Z ü 	 Z  `$  @ Çà 	  	 Y Z  	Æ 	@Z D Ç  @ Ç$ 	Z ( 	 Z , 
Ç< @ Ç@à 	 0 	 Y Z 4 	Æ8 	,ã?¸ MÔ# !$¼5L"ÍÿÿuÔ"Ð¬wæÿÇ`#@ Cû|Ë3Ûà? àà? l?@#@  ? à?]îà ,?@#@  ? |Ë @ÿP8A@#à GÐ@@  !'@@K¸@@_û@@^§@@Tö@@W³@@P@@ $  7 @G×@@ <(z@@  `@@I@@ $¸@@ ü`@$¥ IC@  ÆeÚ ihÇG0   4 E½¨O{%è G:,'N  (@ºð è'´W&G, :Môd%ß  Y29Mð3Íè^'å]%à ÆAÇV: î  06  $0@$@   $)s A.ÿ?ÀG H'þÑ&ÞÆBJ*  M `ºè `	  `	 3/Z%ønÀI' @&FÕAü=GÉ|å@MNO$É%ä&f#  F  FFÆF1%ö  "òæ  à¦ Ç&  ÆFò ­ÿÀË@ `ú?!+AÊ'À QSUÎ 3íV'1Y,W¸DìÉÈd!.s3ÀÇ"!0 C!ú &ÁCÜfKÞ`@x#r D!ÎèYèÿÆü Øïuî(OÿÃ '(,Û E hGpýa_^][Y ´ S&ÐWhüÔB±è+åÿ^Ëèøÿÿ³!sÇaÝ  ¾@B)$/`: ôåÿÆ;÷uí_!p^fMcø   nF); !b P!c
èYsæÿëèyWS`Ç!^  F$ $ 4$ TÀ$!¿@$ F$F0* ,* 	* )À*cF8$ 4$är`t À$ 8 N ¸` fÇFL !å N!ð <%U " Pï Ö¯º¸$EfAtÇA  ! Æ"ã!ï0@ @` D h ÇAAß"ÿl  >ÇAUG@X @q  Î¿ÇC/¿#à&c¸ A]Æ =º¼  D@'& H@ (  P@ L Tó,p A\AòTÃè lèÙÿ¨¸=hY{ «=vYlC
A+ÁøÀ~G 3öÀ-`
 °ÆF` Ýd  H+Áù;ñ|ÓSÿsè'¿	 Ä3ÿ} À"-Aj ³? |¸¸Q-, · 	¹¼ÇEV   $E¤èÈßèÿÆEU¤ÆEüB²@:JAÿ8! B­ BdÂ=èº uB< @"®;Èu.¾  u% 
QÄEP¹l èÙ	933öÿ pBÑ @l@ `¢ èåö@ ü¡** 4¸8F =Gm9îV)¤@pæÿ} Gá;ùóþÿÿj ,¼èf	L@?Pè@9 a!ø #ÌîòÿZ çô5!Q5EÆh < ¸« #¯6c:ï !fÇ    & @ ¹#Ç¼ @ Æ¸ 	ù t*÷7E 
èfçÏÿ$¿ oCÎÌ 	,U @i Ð  U v7 $1 	  @5 p@  Çxà 	  %(ºÿÇ %  0   
 t *è^%;u º @ ¾C] ¿@«â ?fpfxxÆ@Ç@.Ñ1µvç8ÇrHìëHìÀ4Æ +×uÅÇÜ X#î 9=Ô@FWjhT½ EkxUèUØèc!Ä 1!çEØ;Èt
A!PèHæÏK|   +ySMØ@=oûb-öÁtÿ8%\Aü;Ár +Èùs ù#vd$jhy%ÃMÀÇEÔþK {À èØ oà EÀà½å@ Ô r!MÀr@ ]ÈQè¾Qe!Ã%J	PèÇ³Ì!{|õ9Îèú!IÆTFñ³°þ CR!F¯Fø@ÇF$!ÉÿEE,ï¨h$ª;"µp£M$  ;ðta,@O`£ ¼ A.r@jPÿu¨èË¨~ø |
ó%¤P{9¨÷Fè@¨÷FìFìFFèFÆZÇ £i @' 4¨!³@ 7¬ é2ôª hô· ")=° 'èìD"ç ô è1H" ³"¸öt È	`]H jVèxPAJÇ@@ #1@ Çüà 	 øà 	 U@ ® -E$äGì u
¹àDoù2|">é	±êT$Uå]Eõà GK#& @+-Æ,'â*&á 0  `L +4 P g#ÆT 
' Ú x t | \ Ç ce 	!mÿx#iB r Æ bÎ3ÀÇ`;míÌ )@ ÇH:@@	  @ Ç 	  . 
ÆÄ8 è¿åòaÉXQg`µç ¹ hï¾p$(ÿt%e	ºcñÿjWèâN @@  ¸LNÇÅ¼ k p&Âx ;@¬ $ ò 8 <` @  * D ÇL   ?P 	ÇT    èE'íE (`@ ,à 	 0 	!#ÿÇ4à 	 d s@ xÇh Çl 	 p t 
Ç\ ÍÌÌ>!· 	ÇP ÇSË   zÇX   ¿` 	 : X fZ \`g± G±ÆP*~qe   #ûæ giæ@Æ F@HF1Z  F1m $  #auË,DÂjëÇA(  *Ò&3Àf&£&VWÇA,@q0 x,Z !@ ÀÎèiöçêï _ááVQ¾ ±À/3À@Â%h|õ[d	îqq± "8f±LS Ç(  ÇA ÿÇBh ÿÆ $âBAÇ ÿ  f 9;Âtß'¸À;Âuì1Õ¹l -Æ  L ÇMé@ ÷Çº  +ðÇÖ¼Æf  +
  Áî3Û3ÒÇí  ;ÇÇ `@J , 	ÆU$ GóÇ( Ç0à 	xÌ $B4à  8à 	 $± ;à 	 ,à 	W@ Ç< 1$×BÇ y!$@;Öuò!Å_fD " ¼ F 'H@t ^ Sf U$` 8 Çp %äïðÿ `   Q ä  ÆX4[Ã pÇA@fAB5 2#+   ÇK@DQ &}@    $Ez ÇB@|/ÇA+ï#! Ao?ÇA$S rAVÇAH!ñ h L   P ÿATAxÂ×À ìVWïñÿÿ! SÇÆ** W³ 8/
ÀSUïM÷¶
 |¨ t`=ê(g tW¹Ø)Vo4*N^TW#mõÿèæ©òÿ][_5]Â -ît$PÁ  |$è´Õï@( ½à(8 K4@ *D$ =PSjè1I 2 ð*¾l'áÿ3ÿR*ªÎèÇ4ï	L$VU	èÊR ècàYÁjp+03ÀÁþö~,ËÏ `	EjÒt
JXºñ JX@;Æ|Ü_ãáVWà0O àO"ê$ñ@ ÇAgo"ñà  X@áá'?~8 N8ÆF ÇFÿ  ð ÇF~ FJ*  $   ("\ dà Æ.ÇFbft3ÀP3fPèMd3^Nv#'`xQV!ÉWVùÇ0-  èÙ{ç5 VÀt!è8PåÿOõ_^YÂ23 X!ÉèÐÿÀt/p!±
-çÿÀu!Vè =@5 A @VèúOà= è7Rà!Åà @ÿt$ÿv7:ÿvÿvèfØåÿF3À´à à /jÿv  1FOèÑ@3 $@3NèCÒà à>®¯ªÃî¯ (%O ¡2*<×,ñuä}ÿ17ÇCiÁûS]àè3¦"¦¨ò Ïá$IÉADtN èb(µ ¬"ì3Òù$}UèMðEÔEì@ Û¢$<»ÈA ³Ä 1 ÿ!kÉ}Ñ
òMð@ `,1;q? =ÂÿVMÌèa!oMì`& Ã@5)è!ð ;Ès~;;ùwxS+ÏÁùMØ&XNÊ+È ùsB+Ç¹" <L#(%+xÁú`ÂUÜÑè+ÈÂ3Ò;MÜËCÐ;×CúWè5Ì,	UØKMÜ _Ð+qÉtqëi wàoTàoJào Øào Øào Å+»`j Ø m g  g	EÌPè{`!=C! þ ÿ  èx|A ðR^!>É.ùy!L÷t!o Y @¡o/æ è(OEìB2ûÁTAÂEì!Åú;@=}Ô3ö¯? ]äº!gON0+¹× ûÿÈ0{ EÇ¨ An&ÇA     ÿÇ!Í&& Ç5 ÇA ÿÇAjÚ Æ&] ÇÆ#÷!Ð Alù NAqq ÿ"j»@ >v
Ç`@Y `	UàAB¿¿P=³HAè§ëÿFÇþ Ý-ÿ!Màù?w-LYËÁ|&ÎðÁì*å]&1
h4[ÿü#sà / Øã p£|:¯VWã
Eu}ÇEz j}PÇEEÖ ÿ¼. EÈÇEÈH=&ªuÌ}Ð!E!ë $ PF²èÕi# M@ Ðÿè¦e } t!£!#hìõ"!6¦õGìôÁ$Ñ  á þàð'l$FdÍè è{ Ø\$Có ¸  V êç Ï'RÿÒ%D @ÿR[j +ÏPÿR PÏX 	0Ûtn3Û«O Íðè YD3 ,`)|$ ðt t	Eã{ Ù\3ëk^J )6ö.yDàF IFÃl$u^_][&@æ3ª&
à ¢ÁèÃ2ÀåoE¯ÑW~EJ  %ÿPô\SB%]Ï¨ÉåM|(½ H $à " çpOÏG@"VD¸úw Eq$kÒT¼	# uVjè8ëÿ[_ÆF(^!§62@kÁ 'YLwuü*@. ^ .à -@î Ì-ït$àÐ  ZÀÐ ° à Ï@.àÓ YàÓ NàÓAVjè¹7À¤ [ Óÿÿu* Øùw"àÝèà8 Ü  ìh'úlSÁà
ÙU)ù2ÀV"²@ÆD$"M$    $Wq¨ 4$ç«@³p@»8  '0T		@à	8ü	< Cl`a4Æ0 4 L h   ¼  ô  > 0 , H@ÒÞAfB<J ,02oCùB}(Éx$ÉÉyÁÁù ÕGØDDç@/  G#B tz t{z( ÆB ujR5	ûÿëez, u_@ À~H`
J8"  A  <8A89a;u	@ AF98 ;@8@
ÇBIê %q áB0!¢,Ð "$Î#Xé $i°'§OàBì @ìÆG ;År+Å¹ k
 HÁëc(A 8÷Ëè! Q¿  H, BöG0u<WWÂÀ!`À,­A`âÆJÊBLLèÙë W4!Õèí¹,@ì ø@ì  ì äT$AÚ  g Jz,!R9I"eá[¡Ý $!Ý  áÝ/áÙ"A×àìë
jAç	ûÿ×ÿu {öû D$ ~H%Â
~#â]WNà ¿ ) ât  /ÆFàëw~azV!z  "{ ~{ |!:¢{@
ND!F'áHNHDAD9³C«"j  @
9³t ;@D@
ÇFH  níÆF<`è ÷"s¡í*Ïu@Màð Ù <à#ð © /
}ABS4E 'uÆE!Ár+Áâ E éw  'Ëa
U!
úa
 }
  Î¡
@
MyE@A ¨ @a
 EC 9d¼ ù  DÇ9« ;@<@
ÇEø EcÆE4î!ý	AT$0Bõ  ­ r#àá × á# § /Á$h  T a$n! á  $$ Bùa ¤ ´ Ä¡ @
 äEÉ ï$¢eÔ9¬ ;@$@
 Çä	 ÖA    4A  ä@«rHá 5á$ @ïá    á 0$ú! aðï @ï 	àï $%; ï@
Jû Bbû Jû Bbû Fo@Þ"û@
9 ;@"û@
ÇBû BûB< ï ï 8@ï-Ú ïáð Ú á#ð ª /àï  Táð z a jA ûÿée ,|¡ó ì!·¡@
áóG@ò!ó@
9ä ;@!ó@
áóTÙ"ô <ALW  ¶r@áûáb 
Aüá !Ó¡@
ç zd  J  ý$  H@ú$ @
9  ;@!@
ÇB ÆB$ bÿ¡ @A v(rDJ-\X â# ( /â  $   òR(WÀf/ÐÆB 4 $s¨  "%§+Á$hó  X(êZ+Òhò^àf+ä$| -+ëfÛò\x óYÅZÈ(ÃòYÌ - Á i°#=w X5Ø] ðv(Ù?¦t0Áè
ÇGê; n dæÀ+ÿòXÅ^@+@x@S À P Ä f Ø >Ór 	ÓòR(ëC  @£3ÉÀZÉ  @ «YÊ7(¨ Èò,Á*!N(wjAë OVa O«P!®F ².ÌE}H4«ø* ÿ$<6£Y%F ¹åF
ëµu ËVèô:O'Hö Gi½¢@IÓNÈ FB3NN FiÈ ³I½"/ È ³I½@#L@
 ÇÇFÈF0é@c u`x¸ûÿ~ t&Ë!^Ì<îP¶F8@4PFNþ.
<¾ihLÌ"`µ 	öF0 	VÊêØ éwJåLÿ <9±\0u"!Ú@!ñ8Ç @ ë,@!'@@@@@@D$V¡E@
¬ H&J°@@@@!F < u f@@9³< @!@ Ç`@  Ç`@ Æ¤ gK/)FD#  é ¡s m)7I?´¡{+N  $!á ?i¶1! Ëá `  Õ@
N)ÔIh,A,NJ"(A(9³MB
,m9³X ;@(@
uÉ º F:Ê ·F év.M ¾!Æ T$ ¶Ò5A0=NjDÖ=Ou    $ @_§  $  ( (=E¤uy4ÿ? AÊÿfC ëQ)9P£+l `y - vq0þ`k Jãþ@oï þ@hã`@]} 1A4¶y!(Ï@<Áî
³BÈ V+ù¶ÀPjeW"¿D$F#s@4àPjdà@4+`Pj`FP 6  [@8`2 &`#åéy |þ µq àPjc`;à bà@8 éxGïÁã ÿq8!@ÿq4ÆËCA6y,S¢½:Së	QD8	AHBHQHDBD9Kz"  Kz@(@
ÇA AA<éY@c ud8HûD@jè¢ "dä ¤fò Nò$£&ò ³Jè g ó ³Jè@$Â@
ÇFò¸ÆF4éàW u`x oà x Ë@j` xjkå*ªk@g@
9³J`Úú(VE.@éÌ@j´íÅ ``jIÛ j@
ìâ &@Ò!\@
9³IÛ@!\@
 ÇâLÛéü$-UC?,rö­"J"ß  "V¡ »N¹ÆîËÎ÷ÿ ±m@/à)æïNÎF@'\ gD°°R±¸R© ¸&Q8q_ $Q?$ÿSjèÍ%ëO
ÆÇTè uÚ G D#ï ,C *ÆBB 6@Ìj¡) ìB J¿(Ô&¿ðJ! êéÒ#oA¢ VO Kýú, t Æ¡,ïø Êá,tDà%æ !(DsãóÚè²$!$Gg6@iõ ÿj Ç²ã
Iõ ÿ   ³Iõ÷64b©@éé@48 Bô8Ô8è% érD7 u!Òx7ç0*@èB!øëF,tè	# è(!Ë Ö@
ã ×LÚã @ã9³Su@ÖBï 59³  @ ç@
£äÆF8¯ç\#4 ^@
M /*A/àA9iv M  I9«T ;@@
ËÇE"/9VÇ/9èQ<@
ïPINö!aËè¿ Q<ÆD$é¡ë`*Ä<ED$ _^] h $ãî9_Pèt>Ý Ä"$  + ò!¶( 8 H  & à& X  & h x  [ÄhÂ . 4 65 ¤, À 
Ý0 V1 32`d3 Á  + 5>Ì¹t·uT¹t¹uK¹h!n uB¹ `9¹t¿u0¹`'¹tÃu¹t¾u¹tÀu¹!N u7X°Ã=¿ñW3ÿ@,ÿÐÈ!*"#¸S uÉu"=O$Î    èHòÿ?xøR0ÿÒ 2  ,@ =p   4à W  8` @V^  `Þ6@V3ö(Wt$(kÆL°  ÐJEz(l @+u0BG9'íöÁ@tºèëºðùr@ `   ¹ C : Z )ëD$d¿p@BE3ÒÀè\¶ÀNÐ ó GIÒ 4ÉÆ@ ¶ÂDÈ ?h3I-  8øÀ !%#XÉ@	t$\ÁáÈI?
;BtU3Ò`]@5'Ó @ &($T  ?-& c% f;ìï,¯ /IÀ% ,'Ø z-¾G uY K, ël c c L$G@^@f .9u ³`¶ ÁàPRVè:{ÖÄAS8émDM él  v3ÒT©-ï/ÁACÂ@}(¨t$T! < øu X @ô@ÐÁâ w$èA ! $#  "@¾@Ð@ \6Ó|$XaG 0ÃG} t  @ \ - "t@ ò, Ç { 4 ´@ë LX@@Hu 'l t@ÊöAE@u]è ë@3À  A,yu%f¾=|L$L·ÀP"  Xèµ{ûa ¿ÙY0!¢ 8%¨ ê"C n\¼@? ³  tF+ºÏG0ÇG}9wÖFÿÐv5ÃtBé     Ï uð¶G9 ï 4"ÀB¥ ]`3Òø|9!	@HüÁéAZ14ÿG4@ G 
F`Æéuá@?;ÐeG @È+Ê !vFü@!òéJ ! l@É`t.ñ7 D$Ì NàÌ&4àÅ!K @#o"AG( ë%4;õ HS(P ì@kuéÀ!N@~A +t$T 9 <ÀÂÿA\ JtT K @<i@!d NG,áb(Ð!à <àÁ`   ±ué%  3Cm8D$l	L$`?c	 @tR 8á÷á* `à @ ÜA+@A;Á|é .§D$` 	 w <"`¯a X à  Bá.@Và!*@A+;Â|"» p*Æ¬C· D= é 
b`A! \(Xc§ Ñ 3 4#Ð ,$"öGE@  0!"t$\Æd¿Cû <£m û!g  \¼cm $  ±@$ T"
B0a?Bãzá  ãs öCs 5 b	@PüÁêB4Asco #A $$@coAÁêÃoð#A@<Ð+Ö 'IAü@!òés a! `kBô ` Aâ@ÂaÀ S âà $äJàÏ Mãy !³Cy ò@quéß!Z@ Û @æo   D	tUàO$âXà!Üãt DbK <à{&}é? ã~  ¢þ ) !þ"ú ¯tW!Ñâÿá,>@ZâþACA)AD"÷éà XN@7 MO ? Yàá/?@]à!K@#<;Âw!C 3 ,!{#t7ë'Ö¸ µfDÖ    @F  8 7 ;t$÷ 9t$( F (þ O+>_^Ä@Â(¥à éý¯é]¯âxéT¯é±¯réý¯éý¯éý¯éý¯éý¯éý¯éÜ¯ éý¯éz¯2oéT¯á|é±¯Uhéý¯éý¯éý¯éý¯éý¯éý¯éÜ¯ éý¯éz¯eéT¯1sé±¯¥^éý¯éý¯éý¯éý¯éý¯éý¯éÜ¯ éý¯éz¯Ò[éT¯ié±¯õTéý¯éý¯éý¯éý¯éý¯éý¯éÜ¯ éý¯éz¯"RéT¯Ñ_é±¯EKéý¯éý¯éý¯éý¯éý¯éý¯éÜ¯ éý¯éz¯rHéT¯!Vé±¯Aéý¯éý¯éý¯éý¯éý¯éý¯éÜ¯ éý¯éz¯Â>éT¯qLé±¯å7éý¯éý¯éý¯éý¯éý¯éý¯éÜ¯ éý¯éz¯5éT¯ÁBé±¯5.éý¯éý¯éý¯éý¯éý¯éý¯éÜ¯ 	éý¯éz¯b+éT¯9é±¯$éý¯éý¯éý¯éý¯éý¯éý¯éÜ¯ 
éý¯éz¯²!éT¯a/é±¯Õéý¯éý¯éý¯éý¯éý¯éý¯éÜ¯ éý¯éz¯éT¯±%é±¯%éý¯éý¯éý¯éý¯éý¯éý¯éÜ¯ éý¯éz¯RéT¯é±¯uéý¯éý¯éý¯éý¯éý¯éý¯éÜ¯ éý¯éz¯¢éT¯Qé±¯ÅýúÿL$@T$ÙY0|$8 ê  D$\¼   ³  tFAÏG0ÇG,  wÖFÿÐvöt      Ï uð¶G9t$4ºè 
D$`3Òø|9|$@HüÁéA :	 @ G4@ G 
F`Æéuá@?;Ðe j @È+Ê !vFü@!òéJ |$l@É`tÀ7 D$Ì NàÌ }àÅA6 ÉóG( ëWÀóÆè ì@kuéÀ!N@~ ¸ +t$T 9 <À @ A\ JtT K@Ï@!d NG,áb!à <àÁ`   ±ué% 3À@8D$lA» `É	 @tR 8á÷á* `à @ ÜA+@|A;Á|é!9D$` 	 w <"`¯a X à  Bá.@Và!*@A+;Â|"»pö¬ D$ é 
b`A!\#-Ñ 34T$,tBöGE@  0!"t$\ÆcR  <£m û!g  \¼ ,±   T"
B0a?Bãzá  ãs öCs 5 b	@PüÁêB4Asco #AAco#ä@ÁêÃoð#A@<Ð+Ö !IAü@!òés a!` ô ` Aâ@ÂaÀ S âà $äJàÏ Mãy !³Cy ò@quéß!ZCy Û @ffão  D	tUàO$âXàAÐâP F DbK <à{ÿÿÿé? ã~ !4þ ) !þ"úä W!Ñâÿá,>@Zà­CACA)AD"÷éà   	@7D!;? Yàá/?@]à!K@#<;Â)_!C 3 ,!{#t $Ö¸ «fDÖ    @F  8 7 ;t$÷ 9t$( F (þ Oöÿÿ_^Ä@Â( Ìà ì@V3ö |W@.kÆL°!¤ÐJEz#ð@#¹B Â¶ÀöÁ@t#zëºðùr@ `G	 ¹ C : Zu"d¿p@
BE3ÒÀèù NNÐÆD$G ! 4ÉÆ@ ¶Â¹  DÈ h3Ò =  8øÀ  üXÉ@	t$\ÁáÈI$°;BtU3Ò`]@5! @ & ($ ÇD$  6 !Rã ?!û
 /IFA,Òtz$ G uY K, ël cdïEL$G@^@f .9u ³`¶ ÁàPRVèòú ÖÄAS8émÿ!ª él  v3ÒT© { ÁACÂ"°, ³ T!fÚøu X @ô ÐÁâ w$è¡é±¯ôéý¯éý¯éý¯éý¯éý¯éý¯éÜ¯ éý¯éz¯BñéT¯ñþ *À$À/PD$@¾@ÐIÊ \R.XjËG /> Ã/*\@ \ -t@*¢, Ç*+LI´J LX@@Hu 'l tJzöAE@uQ¾ ë@3À  O±yu%f¾/:
L$L·ÀPÿt$ Xèeêéý¯éý¯éý¯éý¯éý¯éý¯éÜ¯ é)¯ 43óý_óD_çóS_Aõé±¯µàéý¯éý¯éý¯éý¯éý¯éý¯éÜ¯ éý¯éz¯âÝéT¯ëé±¯×éý¯éý¯éý¯éý¯éý¯éý¯éÜ¯ éý¯éz¯2ÔéT¯ááé±¯UÍéý¯éý¯éý¯éý¯éý¯éý¯éÜ¯ éý¯éz¯ÊéT¯1Øé±¯¥Ãéý¯éý¯éý¯éý¯éý¯éý¯éÜ¯ éý¯éz¯ÒÀéT¯Îé±¯õ¹éý¯éý¯éý¯éý¯éý¯éý¯éÜ¯ éý¯éz¯"·éT¯ÑÄé±¯E°éý¯éý¯éý¯éý¯éý¯éý¯éÜ¯ éý¯éz¯r­éT¯!»é±¯¦éý¯éý¯éý¯éý¯éý¯éý¯éÜ¯ éý¯éz¯Â£éT¯q±é±¯åéý¯éý¯éý¯éý¯éý¯éý¯éÜ¯ éý¯éz¯éT¯Á§é±¯5éý¯éý¯éý¯éý¯éý¯éý¯éÜ¯ 	éý¯éz¯béT¯é±¯éý¯éý¯éý¯éý¯éý¯éý¯éÜ¯ 
éý¯éz¯²éT¯aé±¯Õéý¯éý¯éý¯éý¯éý¯éý¯éÜ¯ éý¯éz¯}éT¯±é±¯%véý¯éý¯éý¯éý¯éý¯éý¯éÜ¯ éý¯éz¯RséT¯é±¯uléý¯éý¯éý¯éý¯éý¯éý¯éÜ¯ éý¯éz¯¢iéT¯Qwé±¯Åbéý¯éý¯éý¯éý¯éý¯éý¯éÜ¯ éý¯éz¯ò_éT¯¡mé±¯Yéý¯éý¯éý¯éý¯éý¯éý¯éÜ¯ éý¯éz¯BVéT¯ñcé±¯eOéý¯éý¯éý¯éý¯éý¯éý¯éÜ¯ é¯ñ3ÀWt$,D$ kÀL  ÐJEzT$@|$0BG9¶ÀöÁ@tºèëºðùr@ `   ¹ C
 :L$u ZL$d¿A@BE3ÒÀèù ) XNÐÆ@
 t$hÉ¶Â¹ 
 DÈÆD$G3Ò 9  8þ}s N T$XÉ $ÁáÎ 7\I  ;Bt	3Ò`;ë@@  L$G@LÒt' K@9u" §`¶ ÁàPRVèÝL ÄÖ@*`&|$ ÇD$ t Þ  fff   ó /IÀ!Q ( _(|$G u ( ë $3ÒT© ) Á@ûCÂ@+ Â T! < øu @á@ÐÁâ $èSZé*%a[\R|$\ Ht@  ( Ç { 4 ´A+ }X@!u 'l tAöAE@u¸Aæë@3À  A^	yu%f¾A L·ÀPÿt$ XèÇEé @n\¼@? Å @ ,!3Ô ó\!`tDAÏG0óG,wÖFÿÐvöt -     Ï uð¶G9!b 4"¿B¤ Þ`3Òø|9!
@HüÁéA :	 @ G4@ G 
F`Æéuá@?;Ðµ@» @È+Ê !vFü@!òé ! l Ï£  à
Ë  ` ÅD$Ài 0 !ýDþtLàê àã!{ @#!=G( fëWÀ kÆ  rè!ï 4@quéì!Î ' `@ à +t$T C <À"A 7tT %@Ï@á À!?à <àÁ@   ³uéU ¡Dª  @¡ , !4 3Ch Â Þ D!JÉ 6@±tV -8â0 #Â!oà¯ `à¯@  q!RÁ&;Á|é  ©9D$`   <$´`/@ =tX à¡áO@[à£ aðAL!Z`¤ ;Â|#pöü D$ éà 
akR \d	 Ñ 3 4$2(tBêöGE@  0"$QÆeSE¹ <%!8 +"Ç  \¼cÏ 0Ã@$ T":B0@ý uã	Ü=BãÜâñ ãÕ öCÕ 5 t
@PüÁêB4 {cÑ #£ $@cÑAÁêÃÑðÌ½@Ð+Ö 'IAü@!òé± a â!Â ¤ D Ô"L$CH  0A{áï W "ã? $ / OäÇàê m Y@ì@ôáî H !æAØéü#
 rcØ ô à  R	tU  à O@å	[à@`" àÆ "{ <à{ÿÿÿé_ ¡Q¯ `§á Q 3 ÎS@± Ú ù9D#@. 4"I `BD ¾t[ ãB@¾á,R@VàÄCEAW@C
#>é¥ ®ãã  @=ãß_ Yà á/_@`à!k@¡Al;Â)ÿ!c 3 (!#ìt $Ö¸ ®fDÖ   @F  8 7;t$-÷ 9D$  ,@ ø øØõÿÿ_^Ä@Â( Ìà ìêýOêOBêOPê±Ow;êýOêýOêýOêýOêýOêýOêýOêO êýOê/O=8êO³Eê±O'1êýOêýOêýOêýOêýOêýOêýOêO êýOê/Oí-êOc;ê±O×&êýOêýOêýOêýOêýOêýOêýOêO êýOê/O#êO1ê±OêýOêýOêýOêýOêýOêýOêýOêO êýOê/OMêOÃ&ê±O7êýOêýOêýOêýOêýOêýOêýOêO êýOê/OýêOsê±OçêýOêýOêýOêýOêýOêýOêýOêO êýOê/O­êO#ê±OýùÿL$@T$ÙY0|$8   D$\¼   Å @,óÔ ó\tDAÏG0óG,wÖFÿ
Ðvöt -     Ï uð¶G9t$4ºè 
D$`3Òø|9|$@HüÁéA :	 @ G4@ G 
F`Æéuá@?;Ðµ@» @È+Ê !vFü@!òé |$l Ï£  à
Ë  ` ÅD$Ài 0D$DþtLàê àãAf ç!=G( fëWÀ kÆ  rè!@quéì`¢ `@ à +t$T C <À"A 7tT M@Ï@á À!?à <àÁ@   ³uéU ¡Dª  aD !43À@'Â Þ ×É 6@±tV -8â0faoà¯ `à¯@  q!RÁ&;Á|é  ©9D$`   <"ö`  =tX à¡áO@[à£ aðA$!Z`¤ ;Â|#pöü D$ éà 
akR \#Ñ 34T$(tBêöGE@  0"t$\Æc´  <£Ï +"Ç  \¼ ,Ã   T":B0A uã	Ü=BãÜâñ ãÕ öCÕ 5 t
@PüÁêB4 {cÑ #£AcÑ$D@ÁêÃÑðÌ½@Ð+Ö !IAü@!òé± a â!Â ¤ D Ô"L$CH  0A{b ,tW "ã? $ / OäÇàê @ Y@ì@ôáî H !æAØéü#
 rcØ ô à  R	tU  à O@å	[à@`" àÆ "{ <à{ÿÿÿé_ ¡Q¯ `§á Q 3 ÎS@± Ú ù9D#@. 4"I `BD ¾t[ ãB@¾á,R@VàÄCEAW@C
#>é¥ ®ãã  @=ãß_ Yà á/_@`à!k@¡Al;Âw!c 3 (!#ìt $Ö¸ ®fDÖ   @F  8 7;t$-÷ 9D$  ,@ ø ø	êýOê/O]ú ÄÖ%I 8Aq%- ÇD$! Þ! f&"Ø (î/IFæ(Òt(#,G uÆ  ë $3ÒT© )Á¶ÀCÂ!®(!¹ T!ÏgHøu!ÎÉ k ÐÁâ $èÓê±OGóùêýOêýOêýOêýOêýOêýOêýOêO 
êýOê/OðêOýM$À0.D$@¾@ÐJj \R/X0Z;G 0%-= t  @ \ -t@*ð( Ç*ËL×´p D E@@Hu 'l tKXöAE@u¸.% ë@3À  Pyu%f¾0L$L·ÀPÿ,ò Xè÷èêýOêýOêýOêýOêýOêýOêýOêO êýOê/O½åêO3óê±O§ÞêýOêýOêýOêýOêýOêýOêýOêO êýOê/OmÛêOãèê±OWÔêýOêýOêýOêýOêýOêýOêýOêO êýOê/OÑêOÞê±OÊêýOêýOêýOêýOêýOêýOêýOêO êýOê/OÍÆêOCÔê±O·¿êýOêýOêýOêýOêýOêýOêýOêO êýOê/O}¼êOóÉê±OgµêýOêýOêýOêýOêýOêýOêýOêO êO3öL$Wt$(kÆLÐ   ÐJEzT$@|$0BG9¶ÀöÁ@tºèëºðùr@ `  ¹ D: Z
uD$d¿p@
BE3ÒÀèù NNÐÆD$G ! 4ÉÆ@ ¶Â¹  DÈ h3Ò =  8øÀ T$XÉ@	t$\ÁáÈI  ;BtU3Ò`]@5L$@ &	(|$ ÇD$  6   ff   ó /IÀD$,Òtz|$G uY K, ël c c L$G@^@f .9u ³`¶ ÁàPRVèâ± ÖÄAS8émÿÿÿ@3él  v3ÒT© { ÁACÂ@} ³ T! < øu X @ô@ÐÁâ w$è¿ê*aÃ Ä	t$\R|$\ Ht@ ò, Ç { 4 ´@ë }X@Adu 'l t@ÊöAE@u¸Aùë@3À  A,	yu%f¾A L·ÀPÿt$ Xè«êa ê I n\¼@? ³  tFAÏG0ÇG,  wÖFÿÐvöt      Ï uð¶G9 ï 4"ÀB¥ ]`3Òø|9 þ
@HüÁéA :	 @ G4@ G 
F`Æéuá@?;Ðe j @È+Ê !vFü@!òéJ ! l@É`tÀ7 D$Ì NàÌ }àÅ!K @#o"AG( ëWÀóÆè!¹ 4@kuéÀ!N@~A +t$T 9 <ÀÂÿA\ JtT K@Ï@!d NG,áb!à <àÁ`   ±ué%  3Cm8D$lA» `É	 @tR 8á÷á* `à @ ÜA+@A;Á|é   9D$` 	 w <$j`¯a X à  Bá.@Và!*@A+;Â|"»pö¬C·D$ é 
b`A!\c§ Ñ 3 4#Ð,tBöGE@  0!"t$\Æd¿Cû <%8 û!g  \¼cm 0±@$ T"
B0a?Bãzá  ãs öCs 5 b	@PüÁêB4Asco #A $$@coAÁêÃoð#A@<Ð+Ö 'IAü@!òés a!` ô ` Aâ@ÂaÀ S âà $äJàÏ Mãy !³Cy ò@quéß!ZCy Û @æo   D	tUàO$âXà!Üãt DbK <à{&}é? ã~ !4þ ) !þ"ú ¯tW!Ñâÿá,>@ZâþACA)AD"÷éà   	@7Dà ? Yàá/?@]à!K@#<;Âw!C 3 ,!{#t $Ö¸ «fDÖ    @F  8 7 ;t$÷ 9t$( F (þ Oöÿÿ_^Ä@Â( Ìà ìéý¯é[¯2¨éT¯áµé±¯U¡éý¯éý¯éý¯éý¯éý¯éý¯éÜ¯3_é'¯ x,óý_óD_éT¯1¬é±¯¥éý¯éý¯éý¯éý¯éý¯éý¯éÜ¯ éý¯éz¯ÒéT¯¢é±¯õéý¯éý¯éý¯éý¯éý¯éý¯éÜ¯ éý¯éz¯"éT¯Ñé±¯Eéý¯éý¯éý¯éý¯éý¯éý¯éÜ¯ éý¯éz¯réT¯!é±¯zéý¯éý¯éý¯éý¯éý¯éý¯éÜ¯ éý¯éz¯ÂwéT¯qé±¯åpéý¯éý¯éý¯éý¯éý¯éý¯éÜ¯ éý¯éz¯néT¯Á{é±¯5géý¯éý¯éý¯éý¯éý¯éý¯éÜ¯ éý¯éz¯bdéT¯ré±¯]éý¯éý¯éý¯éý¯éý¯éý¯éÜ¯ éý¯éz¯²ZéT¯ahé±¯ÕSéý¯éý¯éý¯éý¯éý¯éý¯éÜ¯ éý¯éz¯QéT¯±^é±¯%Jéý¯éý¯éý¯éý¯éý¯éý¯éÜ¯ 	éý¯éz¯RGéT¯Ué±¯u@éý¯éý¯éý¯éý¯éý¯éý¯éÜ¯ 
éý¯éz¯¢=éT¯QKé±¯Å6éý¯éý¯éý¯éý¯éý¯éý¯éÜ¯ éý¯éz¯ò3éT¯¡Aé±¯-éý¯éý¯éý¯éý¯éý¯éý¯éÜ¯ éý¯éz¯B*éT¯ñ7é±¯e#éý¯éý¯éý¯éý¯éý¯éý¯éÜ¯ éý¯éz¯ éT¯A.é±¯µéý¯éý¯éý¯éý¯éý¯éý¯éÜ¯ éý¯éz¯âéT¯$é±¯éý¯éý¯éý¯éý¯éý¯éý¯éÜ¯ éý¯éz¯2éT¯áé±¯Uéý¯éý¯éý¯éý¯éý¯éý¯éÜ¯ é¯ñ3ÀWt$,D$ kÀL   ÐJEzT$@|$0BG9¶ÀöÁ@tºèëºðùr@ `  ¹ D	:L$u ZL$d¿A@BE3ÒÀèù ) XNÐÆ@
 t$hÉ¶Â¹ 
 DÈÆD$G3Ò 9  8þ}s N T$XÉ $ÁáÎ 7\I  ;Bt	3Ò`;ë@@  L$G@LÒt' K@9u" §`¶ ÁàPRVèÍ ÄÖ@*`&|$ ÇD$ t   fff   ó /IÀ!Q ( _(|$G u ( ë $3ÒT© ) Á@ûCÂ@+ Â T! < øu @á@ÐÁâ $èCé*õa[\R|$\ Ht@  ( Ç { 4 ´A+ }X@AQu 'l tAöAE@u¸Aæë@3À  A^	yu%f¾A L·ÀPÿt$ Xè·üøÿ  @!½ÙY0!Q8 ü I n\¼@? µ @ ,!3 Abt=AÏG0óG,wÖFÿÐvötF  Ï uð¶G9!S 4"°B ``3Òø|8!
@HüÁéA j  G4@ F 
F`Æéuá@>;Ð « ?È+Ê !vFü@!òéz ! l ¿  %à»  ` µD$ÀQ (AÓ@átLà1ÕAI#o! G( aëWÀ fÆ  mè!Ò 4@luéÙg `@ Í +t$T C <À"@ 7tQ M@Ï@ámán@TàÁ@@t °uéE ¡4¢  A( , =!,ô 3@ÏD$@-É .#r DtP +8â. = `à§@  u!GÁ;Á|é ¡ 3CÚ9D$`  C <"Î `á < X à@ á?@Sà aÝ  !J` ;Â|"êpöìCéD$ éÐ 
a[R \cÙ Ñ 3 4$(tBÊöGE@  0#B$!Æe#E <£ "¯  \¼c 0Á@$ T"'B0@ý uã¬?Bã¬fâ?  ã® öC® 9 n
@PüÁêB4 u#®!?#¤ @$f 
$@ÁêÃ¯ð¾»@Ð+Ö !IAü@!òé£ a  Õ¾ Dk "L$C+ ~ ( Aq$"tW ã $ , Oä @ V@å@íáá H !Ù$¸éù"õ r `@ ñ à  O	tU à O@å# g`!ðàÆ "k <à{ÿÿÿé_ ¡C¬ `¤BaCcº ê@¬9DC. 6 ,"1 `ã ¿ »t[ ã/@»á,L@[àÁC2AQ@B÷#+é¨ «ãÈHö@=çÏ¡ì_ Yà£á/_@cà¡!k@¤Al;Â)¿!c 3 (!#Üt $Ö¸ ÁfDÖ   @F  8 7;t$m÷ 9D$  ,@ û øöÿÿ_^Ä@Â( Ìà ìêýê½ùê3ê±§òøêýêýêýêýêýêýêýêG êýê/­ïê#ýLË$À/ÞD$@¾@Ð/î $ \T XSÖ;G/]/Ìô~èêýêýêýêýêýêýêýêH êýê/åêóê±ÞêýêýêýêýêýêýêýêH êýê/Ûêéê±wÔêýêýêýêýêýêýêýêH êýê/}ÑêóÞê±gÊêýêýêýêýêýêýêýêH êýê/mÇêãÔê±WÀêýêýêýêýêýêýêýêH êýê/]½êÓÊê±G¶êýêýêýêýêýêýêýêH êýê/M³êÃÀê±7¬êýêýêýêýêýêýêýêH 	êýê/=©ê³¶ê±'¢êýêýêýêýêýêýêýêH 
êýê/-ê£¬ê±êýêýêýêýêýêýêýêH êýê/ê¢ê±êýêýêýêýêýêýêýêH êýê/êê±÷êýêýêýêýêýêýêýêH êýê/ýêsê±çyêýêýêýêýêýêýêýêH êýê/ívêcê±×oêýêýêýêýêýêýêýêH êýê/ÝlêSzê±ÇeêýêýêýêýêýêýêýêH ê3öL$Wt$(FkÐLD
ÑJEBEzT$@|$0¶ÀöÁ@tºèëºðG9 ùr@ `  ¹   : X
uD$d¿p@
BE3ÒÀèù 9NÐÆD$G ! 4ÉÆ@ ¶Â¹  DÈ h3Ò =  8øÂ T$XÉ@	t$\ÁáÈI  ;BtW3Ò`]@5L$@ &	(|$ ÇD$  6  @     ó /IÀD$,Òtz|$G uY M, ël e e L$G@`@h .9u µ`¶ ÁàPRVèb ÖÄAO8ékÿÿÿ@3éj  v3ÒT© { ÁACÂ@} µ T! < øu X @ö@ÐÁâ w$è1pê*!Ã Ä	t$\R|$\ Ht@ ò, Ç { 4 ´@ë }X@Afu 'l t@ÊöAE@u¸Aûë@3À  A,	yu%f¾A L·ÀPÿt$ Xè¥[øa!ÒÙY0!¤8 ê I n\¼@? ³  tFAÏG0ÇG,  wÖFÿÐvöt      Ï uð¶G9 ï 4"ÂB§ ]`3Òø|9 þ
@HüÁéA :"@ G4@ G 
F`Æéuá@?;Ðe j @È+Ê !vFü@!òéJ ! l@É`tÀ7 D$Ì NàÌ }àÅ!K @#q"AG( ëWÀóÆè!¹ 4@kuéÀ!N@~A +t$T 9 <ÀÂÿA\ JtT K@Ï@!d NG,áb!à <àÁ`   ±ué%  3Cm8D$lA» `É	 @tR 8á÷á* `à @ ÜA+@A;Á|é   9D$` 	 w <"`¯a X à  Bá.@Và!*@A+;Â|"»pö¬C·D$ é 
b`A!\c§ Ñ 3 4#Ð,tBöGE@  0!"t$\Æd¿Cû <£m û!g  \¼cm 0±@$ T"
B0a?Bãzá  ãs öCs 5 b	@PüÁêB4Asco #A $$@coAÁêÃoð#A@<Ð+Ö 'IAü@!òés a!` ô ` Aâ@ÂaÀ S âà $äJàÏ Mãy !³Cy ò@quéß!ZCy Û @ffão  D	tUàO$âXà!Üãt DbK <à{&}é? ã~ !4þ ) !þ"úá > W!Ñâÿá,>@ZâþACA)AD"÷éà   	@7Dà ? Yàá/?@]à!K@#<;Âw!C 3 ,!{#t $Ö¸ «fDÖ    @F  8 7 ;t$÷ 9t$( F (þ Oöÿÿ_^Ä@Â( Ìà ìéý¯é[¯ÒXéT¯fé±¯õQéý¯éý¯éý¯éý¯éý¯éý¯éÜ¯ éý¯éz¯"OéT¯Ñ\é±¯EHéý¯éý¯éý¯éý¯éý¯éý¯éÜ¯ éý¯éz¯rEéT¯!Sé±¯>éý¯éý¯éý¯éý¯éý¯éý¯éÜ¯ éý¯éz¯Â;éT¯qIé±¯å4éý¯éý¯éý¯éý¯éý¯éý¯éÜ¯ éý¯éz¯2éT¯Á?é±¯5+éý¯éý¯éý¯éý¯éý¯éý¯éÜ¯ éý¯éz¯b(éT¯6é±¯!éý¯éý¯éý¯éý¯éý¯éý¯éÜ¯ éý¯éz¯²éT¯a,é±¯Õéý¯éý¯éý¯éý¯éý¯éý¯éÜ¯ éý¯éz¯éT¯±"é±¯%éý¯éý¯éý¯éý¯éý¯éý¯éÜ¯ 	éý¯éz¯RéT¯é±¯uéý¯éý¯éý¯éý¯éý¯éý¯éÜ¯ 
éý¯éz¯¢éT¯Qé±¯Åú÷ÿL$@T$ÙY0|$8 ê  D$\¼   ³  tFAÏG0ÇG,  wÖFÿÐvöt      Ï uð¶G9t$4ºè 
D$`3Òø|9|$@HüÁéA :	 @ G4@ G 
F`Æéuá@?;Ðe j @È+Ê !vFü@!òéJ |$l@É`tÀ7 D$Ì NàÌ }àÅA6 ÉóG( ëWÀóÆè ì@kuéÀ!N@~ ¸ +t$T 9 <À @ A\ JtT K@Ï@!d NG,áb!à <àÁ`   ±ué% 3À@8D$lA» `É	 @tR 8á÷á* `à @ ÜA+@|A;Á|é!9D$` 	 w <"`¯a X à  Bá.@Và!*@A+;Â|"»pö¬ D$ é 
b`A!\#-Ñ 34T$,tBöGE@  0!"t$\ÆcR  <£m û!g  \¼ ,±   T"
B0a?Bãzá  ãs öCs 5 b	@PüÁêB4Asco #AAco#ä@ÁêÃoð#A@<Ð+Ö !IAü@!òés a!` ô ` Aâ@ÂaÀ S âà $äJàÏ Mãy !³Cy ò@quéß!ZCy Û @ffão  D	tUàO$âXàAÐâP F DbK <à{ÿÿÿé? ã~ !4þ ) !þ"úä W!Ñâÿá,>@Zà­CACA)AD"÷éà   	@7D!;? Yàá/?@]à!K@#<;Â)_!C 3 ,!{#t $Ö¸ «fDÖ    @F  8 7 ;t$÷ 9t$( F (þ Oöÿÿ_^Ä@Â( Ìà ì@V3ö |W@.FkÐLD
ÑJEBEz#ô@C½¶ÀöÁ@t#xëºð Õ ùr@ `G ¹!æ : Xu"d¿p@
BE3ÒÀèù 9NÐÆD$G ! 4ÉÆ@ ¶Â¹  DÈ h3Ò =  8øÂ  úXÉ@	t$\ÁáÈI$®;BtW3Ò`]@5! @ & ($ ÇD$  6  @ !û
 /IFA,Òtz$ G uY M, ël edïEL$G@`@h .9u µ`¶ ÁàPRVèò÷ ÖÄAO8ékÿ!ª éj  v3ÒT© { ÁACÂ n µ T!fÚøu X @ö ÐÁâ w$è¡é±¯ñéý¯éý¯éý¯éý¯éý¯éý¯éÜ¯ éý¯éz¯BîéT¯ñû *Â$À/PD$@¾@ÐIÊ \R.XjÍG /> Ã/*\@ \ -t@*¢, Ç*+LI´J LX@@Hu 'l tJzöAE@uQ¾ ë@3À  O±yu%f¾/:
L$L·ÀPÿt$ Xèeçéý¯éý¯éý¯éý¯éý¯éý¯éÜ¯ éý¯éz¯äéT¯Aòé±¯µÝéý¯éý¯éý¯éý¯éý¯éý¯éÜ¯ éý¯éz¯âÚéT¯èé±¯Ôéý¯éý¯éý¯éý¯éý¯éý¯éÜ¯ éý¯éz¯2ÑéT¯áÞé±¯UÊéý¯éý¯éý¯éý¯éý¯éý¯éÜ¯ é$¯kÆLà   ÐJEzT$@|$0BG9¶ÀöÁ@tºèëºðùr@ `  ¹ D:L$uD$d¿p@
BE3ÒÀèù NNÐÆD$G ! 4ÉÆ@ ¶Â¹  DÈ h3Ò =  8øÀ T$XÉ@	t$\ÁáÈI  ;BtU3Ò`]@5L$@ &	(|$ ÇD$  6   ff   ó /IÀD$,Òtz|$G uY K, ël c c L$G@^@f .9u ³`¶ ÁàPRVèÇé¯mÿÿÿ@3él  v3ÒT© { ÁACÂ@} ³Tt$< øu X @ô@ÐÁâ w$è1Õé±¯¥Àéý¯éý¯éý¯éý¯éý¯éý¯éÜ¯ éý¯éz¯Ò½éT¯Ëé±¯õ¶éý¯éý¯éý¯éý¯éý¯éý¯éÜ¯ éý¯éz¯"´éT¯ÑÁé±¯E­éý¯éý¯éý¯éý¯éý¯éý¯éÜ¯ éý¯éz¯rªéT¯!¸é±¯£éý¯éý¯éý¯éý¯éý¯éý¯éÜ¯ éý¯éz¯Â éT¯q®é±¯åéý¯éý¯éý¯éý¯éý¯éý¯éÜ¯ 
éý¯éz¯éT¯Á¤é±¯5éý¯éý¯éý¯éý¯éý¯éý¯éÜ¯ éý¯éz¯béT¯é±¯éý¯éý¯éý¯éý¯éý¯éý¯éÜ¯ éý¯éz¯²éT¯aé±¯Õ|éý¯éý¯éý¯éý¯éý¯éý¯éÜ¯ é)¯  ÐJEzT$@|$0BG9¶ÀöÁ@tºèëºðùr@ `   ¹ C :L$uD$d¿p@
BE3ÒÀèù NNÐÆD$G ! 4ÉÆ@ ¶Â¹  DÈ h3Ò =  8øÀ T$XÉ@	t$\ÁáÈI  ;BtU3Ò`]@5L$@ &	(|$ ÇD$  6   ff   ó /IÀD$,Òtz|$G uY K, ël c c L$G@^@f .9u ³`¶ ÁàPRVèzéT¯±é±¯%séý¯éý¯éý¯éý¯éý¯éý¯éÜ¯ éý¯éz¯RpéT¯~é±¯uiéý¯éý¯éý¯éý¯éý¯éý¯éÜ¯ éý¯éz¯¢féT¯Qté±¯Å_éý¯éý¯éý¯éý¯éý¯éý¯éÜ¯ éý¯éz¯ò\éT¯¡jé±¯Véý¯éý¯éý¯éý¯éý¯éý¯éÜ¯ éý¯éz¯BSéT¯ñ`é±¯eLéý¯éý¯éý¯éý¯éý¯éý¯éÜ¯ éý¯éz¯IéT¯AWé±¯µBéý¯éý¯éý¯éý¯éý¯éý¯éÜ¯ éý¯éz¯â?éT¯Mé±¯9éý¯éý¯éý¯éý¯éý¯éý¯éÜ¯ éý¯éz¯26éT¯áCé±¯U/éý¯éý¯éý¯éý¯éý¯éý¯éÜ¯ 	éý¯éz¯,éT¯1:é±¯¥%éý¯éý¯éý¯éý¯éý¯éý¯éÜ¯ 
éý¯éz¯Ò"éT¯0é±¯õéý¯éý¯éý¯éý¯éý¯éý¯éÜ¯ éý¯éz¯"éT¯Ñ&é±¯Eéý¯éý¯éý¯éý¯éý¯éý¯éÜ¯ éý¯éz¯réT¯!é±¯éý¯éý¯éý¯éý¯éý¯éý¯éÜ¯ éý¯éz¯ÂéT¯qé±¯åþöÿL$@T$ÙY0|$8 ê  D$\¼   ³  tFAÏG0ÇG,  wÖFÿÐvöt      Ï uð¶G9t$4ºè 
D$`3Òø|9|$@HüÁéA :	 @ G4@ G 
F`Æéuá@?;Ðe j @È+Ê !vFü@!òéJ |$l@É`tÀ7 D$Ì NàÌ }àÅA6 ÉóG( ëWÀóÆè ì@kuéÀ!N@~ ¸ +t$T 9 <À @ A\ JtT K@Ï@!d NG,áb!à <àÁ`   ±ué% 3À@8D$lA» `É	 @tR 8á÷á* `à @ ÜA+@|A;Á|é!9D$` 	 w <"`¯a X à  Bá.@Và!*@A+;Â|"»pö¬ D$ é 
b`A!\#-Ñ 34T$,tBöGE@  0!"t$\ÆcR  <£m û!g  \¼ ,±   T"
B0a?Bãzá  ãs öCs 5 b	@PüÁêB4Asco #AAco#ä@ÁêÃoð#A@<Ð+Ö !IAü@!òés a!` ô ` Aâ@ÂaÀ S âà $äJàÏ Mãy !³Cy ò@quéß!ZCy Û @ffão  D	tUàO$âXàAÐâP F DbK <à{ÿÿÿé? ã~ !4þ ) !þ"úä W!Ñâÿá,>@Zà­CACA)AD"÷éà   	@7D!;? Yàá/?@]à!K@#<;Â)_!C 3 ,!{#t $Ö¸ «fDÖ    @F  8 7 ;t$÷ 9t$( F (þ Oöÿÿ_^Ä@Â( Ìà ì@V3ö |W@.kÆL!¤ÐJEz#ð@#¹B Â¶ÀöÁ@t#zëºðùr@ `G	 ¹ C : Zu"d¿p@
BE3ÒÀèù NNÐÆD$G ! 4ÉÆ@ ¶Â¹  DÈ h3Ò =  8øÀ  üXÉ@	t$\ÁáÈI$°;BtU3Ò`]@5! @ & ($ ÇD$  6 !Rã ?!û
 /IFA,Òtz$ G uY K, ël cdïEL$G@^@f .9u ³`¶ ÁàPRVèü ÖÄAS8émÿ!ª él  v3ÒT© { ÁACÂ"°, ³ T!fÚøu X @ô ÐÁâ w$èÁ	 !$À% D$@¾@Ð@ \R$àXaG % Ã%ì `\@ \ -t@ ò, Ç {B´@ë LX@@Hu 'l t@ÊöAE@uH ë@3À  Fyu%f¾%
L$L·ÀPÿt$ Xè5õéý¯éý¯éý¯éý¯éý¯éý¯éÜ¯ éý¯éz¯bòéT¯ é±¯ëéý¯éý¯éý¯éý¯éý¯éý¯éÜ¯ é)¯ à1 óý_óD_²èéT¯aö ó¯_Õáéý¯éý¯éý¯éý¯éý¯éý¯éÜ¯ éý¯éz¯ßéT¯±ìé±¯%Øéý¯éý¯éý¯éý¯éý¯éý¯éÜ¯ éý¯éz¯RÕéT¯ãé±¯uÎéý¯éý¯éý¯éý¯éý¯éý¯éÜ¯ éý¯éz¯¢ËéT¯QÙé±¯ÅÄéý¯éý¯éý¯éý¯éý¯éý¯éÜ¯ 	éý¯éz¯òÁéT¯¡Ïé±¯»éý¯éý¯éý¯éý¯éý¯éý¯éÜ¯ éý¯éz¯B¸éT¯ñÅé±¯e±éý¯éý¯éý¯éý¯éý¯éý¯éÜ¯ éý¯éz¯®éT¯A¼é±¯µ§éý¯éý¯éý¯éý¯éý¯éý¯éÜ¯ é)¯Ð   ÐJEzT$@|$0BG9¶ÀöÁ@tºèëºðùr@ `  ¹ D:L$uD$d¿p@
BE3ÒÀèù NNÐÆD$G ! 4ÉÆ@ ¶Â¹  DÈ h3Ò =  8øÀ T$XÉ@	t$\ÁáÈI  ;BtU3Ò`]@5L$@ &	(|$ ÇD$  6   ff   ó /IÀD$,Òtz|$G uY K, ël c c L$G@^@f .9u ³`¶ ÁàPRVèâ¤éT¯²é±¯éý¯éý¯éý¯éý¯éý¯éý¯éÜ¯ éý¯éz¯2éT¯á¨é±¯Uéý¯éý¯éý¯éý¯éý¯éý¯éÜ¯ éý¯éz¯éT¯1é±¯¥éý¯éý¯éý¯éý¯éý¯éý¯éÜ¯ 	éý¯éz¯ÒéT¯é±¯õéý¯éý¯éý¯éý¯éý¯éý¯éÜ¯ éý¯éz¯"~éT¯Ñé±¯Ewéý¯éý¯éý¯éý¯éý¯éý¯éÜ¯ éý¯éz¯rtéT¯!é±¯méý¯éý¯éý¯éý¯éý¯éý¯éÜ¯ éý¯éz¯ÂjéT¯qxé±¯åcéý¯éý¯éý¯éý¯éý¯éý¯éÜ¯ éý¯éz¯aéT¯Áné±¯5Zéý¯éý¯éý¯éý¯éý¯éý¯éÜ¯ éý¯éz¯bWéT¯eé±¯Péý¯éý¯éý¯éý¯éý¯éý¯éÜ¯ éý¯éz¯²MéT¯a[é±¯ÕFéý¯éý¯éý¯éý¯éý¯éý¯éÜ¯ éý¯éz¯DéT¯±Qé±¯%=éý¯éý¯éý¯éý¯éý¯éý¯éÜ¯ éý¯éz¯R:éT¯Hé±¯u3éý¯éý¯éý¯éý¯éý¯éý¯éÜ¯ éý¯éz¯¢0éT¯Q>é±¯Å)éý¯éý¯éý¯éý¯éý¯éý¯éÜ¯ 
é¯3ÒL$$VT$WkÂL±¬   ðt$@NEFFE¶ÀöÁ@tºèëºðùr@ `  ¹ => T
 uD$d¿P@
FE3ÒÀèù NNÐÆD$G !, 4ÉÆ@ ¶Â¹  DÈ  h ;3É 8ø}sL$T$\ÁÉ #|$XÁáÈI  ;Gt	3É`]ë@  L$G 
@LÉt'>u" c`² ÁàPQVèI')XÎÄ!@*!"T$9T$   ff |  ó /NÀD$0 W(|$G u 0 ë $3ÉT© ) Á@ýCÁ@+ z T < øu
@Ö@ÁàÎ (èÆ4i @ (Àt
¾Ba  ( @\vA ýzú  A& \t@ 0  3 (!Ü 4 @  \ Þ´A X@@Mu 4l t!u@öAE@u¸Aàë@3À  A_	yu%f¾A L·ÀPÿt$ Xè5 ) D À gÙX0|$8 
 @n\¼@? Ã  <,èÄÑ
  Ù\$tI`: Ï!FD$@G0óG,wÖFÿÐvötf    Ï uð¶G9!5 4"· 
	D$`3Òø|9!
@HüÁéA w	 @ G4@ G 
F`Æéuá@?;Ð@¹ @È+Ê !vFü@!òék ! l Í  ÍöÐ
@è `@ÍÀG #D$f@ãtT Và=ß!" GBëWÀ!$Æè!ê 4@puéË!¾ o `@ ¿ +t$T!r <À"@ FtR % á1o@U!s LàÁ`@u «ué6 ¡4  ÁÏ!4 L!¯CUÙ"É )@¢tV  8 [BÏâ!Êâ C `à¢ @¡7@A;Á|é 9D$`Cþ = <"Ñ `@  !È à4`Oà!;@A<;Â| pÒÛCîD$ é¿ 
aLv \´cØ Î 70töBE@t"Á\Æc{$3£ $"@¼à Ê  Có,B0è&Îã tK v"'! @~ @ã c_á ö Jã< ®Ãã  a  Ô ÒèVÍ"j z Ù ÏC o #Aý ÙtW  å ß"G$  íâ,s æ =ãã¦éì"ç rc¦ ä@ L#¢#Âk BtQBÂù O å
âþã	¡"Q @"d Mà )@~{ÿÿÿéN ¡D¤  ¨ADÌ!D#O%aJ#¯ $ ) ³t_  ]áDâ/ Lã*Bï#¼é@£ TÀ#.@ Ó N Y Øá/R@jáåäU!^@AT;Â)!R z 0 7#Ët (Ê¸ ¦fDÊ  &Ç@B  8'­;T$ }÷ 9 T)! B ú7öÿÿ_^Ä@Â( Ìà  éýïéïYéïÖ*é¶ïEé&ïÔÇæ Qéºï  ÍE¼ Ù ÍFOéýïéïÑÅ!4%Òæ ?éýïé{ï6Äã é¼ïfÃ"j)\#éýïé+ï!Â!Dã¯éýïégï éýïé#ïi/ óßæ é¶ïUé&ïä½æ Qéºï  Í¦Oéýïéïá»!4æ?éýïé{ïFºã é¼ïv¹"jéýïé1ï1¸!Dã¯éýïégï éýïé#ïy	éïöé¶ïeé&ïô³æ Qéºï & Í¦Oéýïéïñ±!4æ?éýïé{ïV°ã é¼ï¯"jéýïé1ïA®!Dã¯éýïégï éýïé#ïÿóßé¶ïuøõÿ%P@T$ÙX0|$8 
 Ef\¼   Ã $3,èªæ Qéºï6©%
 Dz/éýïéï¨!4æ?éýïé{ïf¦ã é¼ï¥"jýýÏý+ÏQ¤!Dã¯éýïégï éýïé#ïõéïé¶ïîé&ï æ QéºïF%
Oéýïéï!4æ?éýïé{ïvã é¼ï¦"jéýïé+ïa!Dã¯éýïégï éýïé#ï©ëéï&ù 3@t$(Àt
¾Bð $¥\v|$X3%	;Gzú3*T$\ \t@|$0  3 ( ; 4 @ \3w´ ? X@@Mu 4l t#É@öAE@u¸3ë@3À  S	yu%f¾A L·ÀPÿt$ Xèäõó%ß$æ QéºïV%
Oéýïéï!!4	L$`3ÀD$ÙA:É"} tV 8óD$ÏG0óG,wÖFÿÐvötF  Ï uð¶G9#H4ºè C`G9 F GCJëWÀ@ GÆ@v##4;Á|é"ô 9!È  = <#b `@ BtT  8à4`OàÁ@  +;Â| pÒÛCîD$ é¿ 
#l v \´cØ Î 70töBE@tDÆC»  $3·u $Wu$4¼à Ê " Có,B0èã é¼ï¶"j!Ö Ù ÏÀo!Aýf¡ÚtW @Ï@"G$!î!lâ,sáÝ PBnèa "uéì"ç r `@ ä@L$<@   tQBÂù O â*þ <à"Q @"d Mà )@~{ÿÿÿéN bb¤  ¨"èq!D#O% ÙAJ#¯ $ ) ³t_  ]áD@ ã;¼é@£ TÀ#.@ Ó N Y Øá/R@jáVäU!^aê ;Âw!R z 0 7#Ët (Ê¸ ¦fDÊ  $´@B  8'­;T$ }÷ 9T$ ,B ú7öÿÿ_^Ä@Â( Ìà ì@3Ò w$V -WkÂL±¬ e HN@NEFFE¶ÀöÁ@t%$ëºðùr@ `   ¹!à > T u"²d¿P@
FE3ÒÀèù NNÐÆD$G !, 4ÉÆ@ ¶Â¹  DÈ  h ;3É 8ø}s Û  ã\ÁÉ #$XÁáÈIH£(ñt	3É`]ë@ DÓL$GDû@LÉt'>u" c`²(ëÁàPQVè¹áéï6ïé¶ï¥Úõé%ï4æ Qéºïf%
"e Ù ÍEÀG"%×O(& DFK%Â D(¼ @æFfäÿäb%Tå² puéË# ofH ¿ +t$H¦ <d "ÅtR %áýé	Jà#¨ <à$ïFÝ @qué6 ¦?  E,è1!4 LÅ¤a:&?éýïévïã tK'b½ â½ç¿"+ J`3Òø|9%Ø
@HüÁéA"  gÿG4@+Ä 
F`Æéuá@?;Ð®#`@@È+Ê !vFü@!òé ¢j  %BjÆ"j z"déýïé+ï!Dã¯éýïégï éýïé#ïÉ×éïFåé¶ïµÐé&ïDæ Qéºïv%
OéýïéïA!4æ?éýïé{ï¦~ã é¼ïÖ}"jéýïé+ï|!Dã¯éýïégï 	éýïé#ïÙÍéïVÛé¶ïÅÆé&ïTxæ Qéºïw%
OéýïéïQv!4æ?éýïé{ï¶tã é¼ïæs"jéýïé+ï¡r!Dã¯éýïégï 
éýïé#ïéÃéïfÑé¶ïÕ¼é&ïdnæ Qéºïm%
Oéýïéïal!4æ?éýïé{ïÆjã é¼ïöi"jéýïé+ï±h!Dã¯éýïégï éýïé#ïù¹éïvÇé¶ïå²é&ïtdæ Qéºï¦c%
Oéýïéïqb!4æ?éýïé{ïÖ`ã é¼ï  Ï£éýïé+ïÁ^!Dã¯éýïégï éýïé#ï	°éï½é¶ïõ¨é&ïZæ Qéºï¶Y%
éýïé!ïX!4æ?éýïé{ïæVã é¼ï  Ï£éýïé+ïÑT!Dã¯éýïégï éýïé#ï¦éï³é¶ïé&ïPæ QéºïÆO%
éýïé!ïN!4æ?éýïé{ïöLã é¼ï & Ï£éýïé+ïáJ!Dã¯éýïégï éýïé#ï)éï¦©é¶ïé&ï¤Fæ QéºïÖE%
éýïé!ï¡D!4æ?éýïé{ïCã é¼ï6B"jéýïé+ïñ@!Dã¯éýïégï éýïé#ï9éï¶ T$@t$(Àt
¾Bð $¥\v|$X  ;Gzú @3 \ \t@|$0  3 ( ; 4 @ \T$´ ? X@@Mu 4l t#É@öAE@u¸   ë@3À   9	yu%f¾A L·ÀPÿt$ Xè%õÿ X @ ÄÙX0|$8 
 @n\¼@? Ã  <,è´<æ Qéºïæ;%
D$`Ù ÍÀG øD$f tT @ÏóD$@G0óG,wÖFÿÐvötf   Ï uð¶G9"4ºèG9 B GBëWÀ DÆè!ê 4@puéË!¾ o `@ ¿ +t$T!r <À"@ FtR % à1@UàÁ`@u «ué6 "J l"  ±:!4L$`3À@$ ÙA:É )@¢tV  8 ¨A2Ïá4á2 C `à¢ @¡7@vA;Á|é 9D$`  = <"Ñ `@  !È à4`Oà!;@A<;Â| pÒÛCîD$ é¿ 
aLv \´cØ Î 70töBE@tDÆc{$3£ $"@¼à Ê  Có,B0è9ã é¼ïF8"j!Ö Ù ÏC o!Aý!ÚtW "G$ !lâ,sáÝ Pã¦éì"ç rc¦ ä@ L#¢#,Âk tQBÂù O ä
3âþã	¡"Q @"d Mà )@~{ÿÿÿéN bb¤  ¨"è7!D#O%aJ#¯ $ ) ³t_  ]áD@ ã:¼é@£ TÀ#.@ Ó N Y Øá/R@jáåäU!^£#Ãw!R z 0 7#Ët (Ê¸ ¦fDÊ  %ç@B  8'­;T$ }÷ 9T$ ,B ú7öÿÿ_^Ä@Â( Ìà QSUl$VWù2Éÿäò Áå
L$fD  ·Ä ÆØ  öý ^`0 #Î Ét
~!ý À ÆF ;År+Å¹  HÁé¥ 	~( u:VÏèc_õÿÀ    t $NÏÁè
Ìþ  Pÿv8F0ÿv4FPÿR<ÆF(	~, u_Ð À~H`
N\ÉtF`A`N`\A\9`¿u	@ @Ê9·È ;@\@
ÇF`   ÇF\  ÆFT ýóÛÿÿÿ¿`ût±éäþÿ!H][YÂ¡HSV!ÙW~ÿxTÇâ¨AKùç  yOÏGDVD¸¬ø!SÉtDkÒT¼	ù )_	7Vjè%åÿ_@ï^[Â Ý@MkÁ 'Y@'ü  @.ç$à.áà@Ñ  :ÿ  ! AS@X µÏ ·ÂÁøá°IÉAD& t^ $À" UàÔ½ Y@Ö¸@Õ@Í  à
; uVjè= ©ÇÃTíuâ][å äà	@î @àîèø#Àî 7àíÌÌ Àt÷@X !·°Ã2ÀÃ @ UìjÿhÄd¡ ( PìSV¡¤P3ÅPEôd£  ñEÜPèjðÿMÜÇEü  è¼àÿøuKj  ÿP3À8Ej À J
Ìeèw6ßÿ ÆEü FÌPè4ßÿj Î  è& M#;Ãë2Û `è5YßÿÃMôd  Y^[å] Þ¯ ·à¯ \ ­EðSVWà³ÙETE´¹ðt ²#° ÇE@è½t ¡¨¸@£@M8 
é t`ét4@
Îÿé  hä 9
è+ ÄE¸ * !QZSÈè,êÿøE¼ëPhÔ@&ó*à&  & 3@& à &)jtèÏà#  # @#AÀJ3ÿ}¼E iÀx>AÿÁà }â tDx"}¸3öj$ºËèe_ùÿFþ|ï}¼ÿu´]!$SÿuLÿuHÿuDÿu@ÿu<ÿu8!A£´Pè2Á¤	EA¤ p ÿuÏ@ÿuèOn$Z +]Pð$üX!S	=Ô@FK  9PM è5 :VE  9 
 yØPèÛàÿ  hÄPèÈÿÄ$ô!9 hÈ` x`Àul@ Ì` cà  W@4 B Nà  @ 8` 9Àt{hô.MÀèåqÈ"mEÀ  `¡#  M@ègI ëNjh¤/`.ÇEÔ ÇEÐ  ÆEÀ è$¾Éà @ `@âàÿEÔ Pør@jPÿuÀèú¢É Ö a	E PèÌá ' ì Ðà&ØèÓ &M ÇEìm è l mØ è6VßÿÛtGl¹%bFEñAyjÿb·,³ y b½u
¹à¼èv ¹BÞ è"ju MèêUß è$èâ ÆãR _#SMð3ÍèQ- C]P $¬$0 qì@û$Åä ¡Ì ªãmùÜ MìEä Ó !A ð  èöx EìO0¸gfff+O,÷éÇ#ø  ÁúÂ ûÁèÂ& 3ÛÏO,E ËPè8âÿw8E³$; P æóÇ´ /aA° 	@ Æ@$ èn»É"¸  ,è/!`  !Æ	ìè»:éÿPÀ Pj"$åÈMéÿ4è­T!4``A¼ aã µ@[è¡æ M và e è)6t Æà ùÃuè÷éF`ùuè`õ;ð!wE ÿµà ² äj£¡àè11Ã ÌÿuäèÐ.#µØ )@gOHè^?óÿðMìEàQ!`' ÿ1@ÚèSæ ÿuìè&DÆâ	 AÑ" D$æ¥Aü]Â ¦ sâ)¢"àæ bx!ïBè¦·t ÿEY   jt ¢èÖ%`|"
  $øV%CH$øðë3öfE  `ùj  û ( D¡ìè10ÀÿÌè# ÿuf@ÿuè²i$E-ÅFpD¢Îjøÿ-¨%êC Ã+T£+  A%èófu ÇãC!à Ul$Ìì4# Ñá-#áeðù}¡ a¶t âÏ {! èwõÿ#¢E3è\3 ÇE$l-;  , #P $AèR>a u<ÈþÿuhDSINjuè<y Èh4K è.  òÈE,è")!,X<Bq Ë@5	è]÷àÿÆëè4 Ææ K jQ ÏRPèÃÑïÿ&H¦àÿ!§uö@ tlj   v & 4'þÄÀu ¤èáM@ºü Aé2#lûÈ¾ èÉ K, ´,/ é@,¶¶@fÁáfÈf @³E3À¹3;	 fC$3öG	ºÌK u3Àë v+ Ñøð,?fs$ù&|Ëë	s@BËÇC. è¨$M èÚ-ßÿE@àÊÆ"$át·AE ëÇE*!(¢Ét@n[öÂ t	 ëM·»@(¸ÓMb÷çòÁîiÆüÿÿÁæø¸ëQ ÊÁékÁñ Í"U	÷çÁêkÂöò@Ç}Æj'h $$
PÿuWè+~
"CáèP)E3M<Eéùÿ ßM, ´èñ8)ÈèØB ·A'ÆE<ÎÿR O <Yè `d V è&_!S &µÎÿP"e'PVèLü
 %A@*èå.ÀM,è h fáÇü!ök 7vFH ( -pèw;##Æ 2Å V"=8¤B=  }@ésÂ9èL@*)õPëÓ¸? ÃMÔè$O!­ÙA$èqKbo 	!éÂ@D`òÁâ ÔEáë»	ttô  Q è##$a?
è±7¡?A ßVNA<á8Má 8 Mu<èê] tF -!?!=@ ©û!0° M.,ê8  Á@M  -!,PWèð!¡"Wè@YM  V *PW)è¸ú
%ÊÀdúã d Êò6 µÈèK`Ñ¡èü9á zËVè½¢Azÿ2H¢ @!GPè¸R"b@è W ÀuE@E<ë)h <'#$è×"YM<è}R ÔØèMá  Hb¢$èàI |!¿ èau Ãë4¸KA¡Æ ]à5  5 ª 5 0Cãe$èi 52Àå[e4]Â%Q=Ä%Ë-¨4ï V.kW3tVWSè/"@× } Ùù+ð3É|$*¬	  U+rVFÿVÿ;Øw;×sBÆ% NHÈø@6Cï+ÐC+ë@ð@ ÁY$ÎHÐL(à  àà;Ê|×;ÎdðÆ+Áø|r×i+ÓA0y,¯ ©Ö+ÑêÁêB2¨Eô@óY@ìm @ì D8ð@  @E Y@ô@ @ø  E`øêu¸ \ ;Î}%+û+ñ    )@2­Y@ü@;üîué]!S YN1ÁAHÆ¨u51-3ÀÂüx,Â+ñ ¥ I  pÿ(IYIð)Ið@yì^Ã3À^@L  ~Zê4 ç¹*±)ö ì%· è°¨âÿÆEðU3ÿ"  äT H+ÁùS0 º!Æ´Rÿ'ñ²l*1DðæÒæúNÎFM+D°`N04¾O÷AX /Â l¾YO¶<@c,'} @2t3;Ðt/d  ` 9L  +þ  H@ @éí ¡pY{Á@AAÇl @ÿh  P @PÒ|!ù@B v@@R@jé¦ RÇ@@(Ç@@ é  Át4à½ @+@;;@ÉV|;;@|sLë1è_é$ tAà½j ÿÓ+ )Ôa a!Á Gá¹;ùP,Êh0ü ¹@úèÑ²éÿ¢oè`¾+á Mï ò"¢)¢WÀ B©¹!r FðÁUCÀ ´V¹À"RèA
 ¹è@	qþuU
 tÿvè"Ëì(­ Â¨  "î N4!¼àQR¹8» Qr à ß&}d¡   PäâßÑUð}Mu7ù ,O ºXB°])X'9P*u¸äIu9\ ¬  ) )3Ùº<3âÿ  9Oö  9_Bj4" ã ²cÃ)óòÁÇEPÒ(Tè3E Eàp+7ÊÉ  f	Âð±;Âuì4MààUìÒuDUüè¿ÑEº(«ÿëefnÆ[Àó^Ü ÉóXÈ]68,À°áØÂ G4D*@xT ÒxEc£	4¾C u2Màèø,&!T!Q¿¬$0!óþÿÿæ+"4 [=ÐPìD?h#±ó°']ð ]ºu
 ¼~*G A; ô /º!}   ØØ&Ï X5äZ äæÉ%QR,ò^È T .fZÁ ð`+YÂ  Ã%qEt2¿H !O4òè!+È V CæÉòY5ès W ZÈë9DÌ ' % E& Y ôM^ dáZ Af÷êÿábu U&{ þd!Øtþc uh` R1 Ó!Ä¾!VëÜmÿÿ  wôæLÁÈ(ÂëÁ|  ÆæÁø_«ð^[g¨  SU2|$ EÐAaÁúö|6·%<¿ ;÷t'ä-p%ëj?SVÿÕÄC3ÆT;÷uì_^]2À@m  ° và'o  i¿  o !àoÆ!% r é iàrà þÅä `®ô	MEuH$
=ÿ"iÚ A"æÉE°a- ¸¡- 'a' A1a+]/äEìC²cýEÜ#ð' s#Æq°ÆE BE%  SPÿl!~ LÇE  E"q P/zè@¸å%¯  -PÁ !Bèno'1ýeÐ$Þ	 +è2à"ëã© MR~Ò~ojì!j1Ä$ S$ BJ¼$  	ñOXW A- ÁøWD¸D"ü °aä ¸¡ä (Pia/Wó ßá ë å!D$Æ ! ` *t   Æþ![+^;Ãsj;L:xÁw_+È¸U÷é"èúÁïú;^u	/Îè6S 29O{ piÿB\Ó~Ï+×ID
ÿ+óO@S@+ÑàëHàK M@K~ÿt3@{×Á+Ðà- TW@@@ àF`{ a^°"Ý	[3ÌèA ÄAãÉ =r Cc3ÿ2Ûð= ¿rø3öçÿÿÿøÿ7Å;AÅm£ðÍ!	 íCò&{ü% "* -j_Ûu9pt¸P$t9huH0öu ' Ø ª 2ãû@ àp  à	QT$2ÀV3ö>1D$Wúú  !Gò3ÿæÿÿ!G ú!G À  + Á¡KD$!GBòáM&2 L!w<ûAW{´Á[ 7  ©É!_ xA_ °a_
9Pu(ÁW&°T!_ Áe Ò@pH­!  h@DF C9¸H¶!¦°T'#tB9Hµu:¸(G t1 RÇð(@ ó_ÂÆ@Ç &7 ÿ  Ææ@@u ô è ë _2À^YaÏ2Òq @ÚéØu "u Ûâu Â`.9D A' Á$ì
!l$$ ÍL$ @S t, ¢4Ò!! XA!`0÷H0ítÉH0 ± á'ÌôÄ |   Ya'Co M9¡+ ¸a+ N¡#!!	tB/Ñv¸à! )ûÇø@   ë Â°A@8)H'á@¨A@%# £ /&à   S&Ò K4 >ÑÛx[ÃË¢Mp"OâIA" Â; C|Âñt*"(N@ @j@D ô ¬ É 
qtUI<Éuô 3 @/E@8@/ûÿu^t  cÿ@0@\@_^3£â ¸ á  é ¸" À
A+ "S`
@ê Ä{@áâ  áT$ å°^*sW#A+Áø;Ð}E#vùwDÿ$\R @H¨ E¨àPè%QFÂ  T` X@ _ó@D$­øtÈÿ 3À ¸ «  T &  ,  2 A´à#¿L°Á ^úw.@l	è tèt uRè"
@hRèÖ!  ý`@nà ok|$ ^ÿ!btèA#`Tèy L  C©é#ïgé( hA"Æ@V  $ÄÂ   ! À Ç!w#/¶¦B ç(OÏGBê/,Ñ L2kÉxïFL+FHBMÈ}âFH# [° )á â¯ â¯ "¯@8'¯2À  X  âOcÀu < k3É0òúuà$ÛRy$ t
èÜü	 È %è"ý@	Á  k@ @o ã @s¦ù8ü d$4 (%@úÿtF #Â©&*
t¿ÆA$h ÉuÜ2À^!ç`7Àtð@7 9Pu
¿ÎH$.¥Ä¶ ç/°@5@¨  " @³Å" +Ð+ S @O0t@! õ3«j Á èÅÉôÿ0@MAq@ OZìdjÿh8Æì ,ÒÅE`VPû6
EóuÌEÈM+9lì(EÐEpEÔEtE9ËØEx+¬E|EàJ·=bKÚEè @	ìÄÆEó   6ØTR~EèfÖ@ è¤øçÿE+ækÖ	P  èþ0WJ	 èÖ,
 Eóñ|^M`<6<ed]Â  à V&F6
l%ãèÏ¿ôÿð5[ @*Ú
^qôÿÆFÿ0ï¿@ÿÿÿv
Ç`#³ `	3Ò#F!F(²$F"$F    	F"$$(ÀN0HÂ Ðè$Fù° M!âD$ øvUH6 §ù];u! $ 9··"¥àÁéF4$"N8( Ð@@¿ )  V` : =ÿ?.ý«    8 :@7¡é  * !øw:BGP$  Hcè
¥Qè{$
 ^_"ÊO@Cæ¿ dà A©8 !tQWNQ+ðè*ßÿ#ÇÊyA,Lù+Ï¸A¦;ÈGÈFQ;äpb]BAgd3   AèCßÿ îÀÀ à W ù@ é ãìçkàé$
 àQ¡?2?øá.C''á CÂ ÀB ¯¢tt"2â  É"¢"¡B"¡ 0 °  4 "½ 8 
 À_HÁÇFÿ  
°N^Â b ¡×À U¬$\ 'ì¤"|$% pä% Ä%  4W Pä*ùTMÜµBù2ÛEðèßÿjì£ÙÌVè8"ßÿ &è`,à`ÈÀá#ûÜPè/:áÿ(°5- H$ P@#	<âÿÿuðÏÆ/³èÞï ÿµH¿$ÿµ¼ ÿµ¸` ´ QW:`Ú@ØèPt 	Üè3ßÿÃä<U¹ @Á$Aô
$A ¥@ì ]A Q!1 '3í,ÿÆ!S ØWÑè3Ûå!G!i%Õ ãLT$Á"f KÖâ	f t+Å ¶f$ å ®(DF $-
Éu9^t®FV¶  	ÿx	9~© ¾/K  ÇF\ëÿu|9FDw$êPBJÀ$ê È& ÇDÄ	 fÇA ÇA +ÿÇA ÿë3É £$ÂÒÇ" & qH ¿ÇAF4@hAFAD$0AÂ :ÇAd 5)g( t%",N0NN Ûu@Ê¶gö' t _oYÂ#[S@	Âl  à ¾ì&Ï  a -ïtJ@<&Ñ ô0Å !!ÁF   !     $       PèJéÿ ³Ä$ °)v@ j`  SLoÃUV6|%)g Ë)c¤ð  f0) t$#Ïf®Xþ!W  $R j  $  0 (jÿSè¡õÿ$ $Æ@ >«$øïxo6³
ÎWÿR(f9h*u\6­ P(x uNÀ!M9H,u=Àx4ÿu/À $9H<(ð =9X0uÀ 9H8+Zïy!j 2,"» + Æ@)Ù@a   QE0F!öy°¼6ë5â×æ$"Ó!è [¶ðI"   C|$$Ao$U!F $<æ\$(!@ ,!­;è}(¶xíx   ,;û  Û  ÿ "c / !^ %ÃEßÿ`TÎW0Sg0U !,g¢ FèÕ ][_^Y#Ï_3Oªää@î !÷àî `î 1àî,eCb`ê	Étj j h$ ¥è"å)r¡\  ào -ào*õ@k_^*S - .d+A`+º à_á)¾ ÛA°á ¾ Í@#Nø· ÿ$,a@â !ºíf FWÁÁ^,- þ@®áà!µ !èà;²àWÆâàW à;3É_B £k`   £  Ã  ß  û !¦à  áG¯ a ü`èíÙ  à nào gè£ð!õ!ãâ$'èlÀ6 [@ àÏâ"ï (â ï  Èdýàèböm @wÀ à; à  
 wWèj`pCgà;_ à _  _ @Wèsn`c &æ @à;o à o  k àèÌ{`vå ¤R~3Ò`wþÿEÖ') !%îD   t9.TH<.Qrè2! &ý@Á@ `GÆ s ³e H­'è°2$í1¿è©
 à F;ï D z[À$! <	4KX<tòY@¨4SZÀ\sfZ5± UÒót)¸0V Q*4&ÙçÂ`ø4Ç%ëHÈ@$~
F< u	_^&ÔEÍ(¼@ vfZ41ì&}H+Á?Íé±@ (@
SþÿÿøN ¶HhDÒ 4  &c ! è>Ð#l$0*&Ë(R ,F_ (  0gò,W:/ñÿ Ä;×¢)útCÿt>út9ÿt4!£$Éy6ýt
ý|"ý¸p9;98tIÿtDÿt?À=ô |è]à ãíyò¸  * @* @* @*@@à*Éyt du0 º 1M}(ËUèßýòÿ>*j-W@Ã@Xòÿé Eýøw 3 N,Ë # è÷öò+ ý@: ) & P; 4`(è	 >   6j 1,Q $Ëè~ùòÿ`ö t ï!T Qà9 9 ×  . èÑÎ:ah!f `]aláh!h./*;Ñ5@wíÓ!Ô î(ý!¿ Æ !Ê, » 
'	Aäø«@ÒtU^Cóÿ NÉL« Q`£  ÀÏ ë	`  ðâ
j@B 4 $<Pb<Wè£*óÿ!³ . _!õx&¢  3Vx> tËÆ@> è{ûøÿ!å)BÉA¶!¾DY ~t\ " `
èUà%í@$ E`$ 7@$`
è0à$
Eüøw¾P`( @(`
èà(>e Lg ¶f W  Ï  à-  à6 Dj`  V!$ !Å àèðû!ÃT$ SN&7g,À9Q4tIH(ñô^,7ÀÆA0 ÀA8@`WÀ  SDÐÙWöxb#ÿè7vwVÆÎ+ã+à d`$áëÞ| t+VS0Qè¡UÊB !½ùs$=¼x!Na°$¾c À~ÅO iåK NEO ^W Wjèì
\Åj èâ	 Sà @Þ%¯ C¼  Îù!F @0Ó0 Áñ½pÓèq.Ú}à²öeþ ö,ÿ ìÆ@+ð@Lÿ.áó_ná?à' `  ;÷t-Ì .ÿ'tÆT;÷uì m&0 ü"d 9Höõ Ð6õNH ¤   $# '!xÁo!já æNÎFÇ =^Ü&w'j ;@ à%? '_VÖ  K9}FEèv'r øs4fn%WÀ[Éó'e§'e/Áw;ó]\ñ Q'd$@;èZ;@   QMU3PÎWÛtû/i|$;ý_]=Ä$!® ÿ}¿%_ ë
øOø@Ð "!Bq §"o áá/%nt ¶à!-©Sèì	 ~7WS,<íé7è^;àz ¤à ¾B3ÿ%ôFÚÞ ú1Éúÿ ¼` l$aÿÍp qÀt*"  "9ýN _Ð'Õ × Ú@÷°~höt: 39P ^` ¾}49®\  uJ= ÈVè#2 `m!1¶ ? Æ"m"Aq ó  "81 F@ Aí U
 9Può@(ùuÆ@0 Ó àây UW·|%é;=ô@FsSAÿ AÄþ92	þuSWh7_äh>ß !b SBWè¾h*Z à/^Üh ^[_]"nÌì 1l$$p R ¹)  ¹  !   (    ,  !0Ç$6õIÄ Blf  4\vQ×  ÿ  RÿPÄ ànÌUì4  ô *R¡¤P8½ôeð}Mÿ7è¨û  ÿuOèÝ³8P OÔè.yÈÿ3Àôå]ÃEH(Eì@¸jo Ãà'A  ¹¸B@% à+ÂÑøÁö 
 (È °t°ðÁáöÐ"B
ÁB#y Óà y&KyTMu8(»z tz  (@_ R!²S	óXÀPó\d$!7è,D  =é é àaBo!úB`sÂ  @ ÂÁèâQ8¤s@@ " A #  # s#@ À#@, Aà-Q -à  d	3ÒUVñW¾kÄ8'q < o+/ÁýDí~sJ[@<ÀDÊÑíuéF\	MG3Ò+©ü"Fì £Oé
;ÓuÆ@<ë   Bì AÑ|Ô#¬#ª/$ P+Á}I/ RB¬	(x< u3(6 @% Å@%È}7 àX C	_^ ][  `Xà TuL4~@ÿw<¾¸$4Àt1x!ÿ+º   ` <Ü#@;Au	F>B>z@À¸!_ì"2,SUÏ+	é3iVW+w@IEÜÂ-|ÇK  ëL6Ú ,å÷ @' Áèi |,T2§ÿy¸T÷ëaÇ <¸Ç!( Ü Ï5¶, U -D3Û-`  0À.$ fnÏ@) S5ð~ u·N*;Í !F840
;D$4ð@Vn,;l$<ß@V4Òy!h89N  Ë  óDÛ
(NL(ÐÉ FH#0VD  F ^Ð$°/Âv
 !#AVë\'TÌ]'d@6ôrBÿv<ÉN@RPjUÿv0,¸4Pè÷~,¦  3ë 8Pèæ ¶ Ò n'µ À = F#«  J@ÔÆFP u07B, u))É D&À @·F*EV$ÍU ¼$P!6<ÿR@ $0C;(ïØ!ÉAâÄÂûî Ì f DF? í àÈ$5@ÍVWñ(>ì= Ùèv(Åë ë Æ@Ü%=@)/Â 1` X D$ Ç d([ä *%ü "\%p "
TÜ(ÄWÃ( yÂÂ ÐVÓ 9 Ê "Ê(Ôh¤\Ä@84@8Y%¼ @kÂÃT _ \0B\Ñ sL$ 	Ü¶(Â (0!@(YÂ/é  Ð 
C`CXÔ T$@Ì Í`Ì Î HD$ .	¸&=i|$H"9jì ?d`7YØ)D   2 \ _¨ Ð ó!¯L$!  ( $èQP$b3Áv
 l A[ë`æ B)7  ] `à ] $  _k  \$ì `KWÒ/Ó%@Ô
Úë/Ùv(Ù D$"@ Â@Áv	`v ¡  (Ë g @Å'm $ !U! ¨u ^¨u  F -@3¨` V 6@&%G?(ôB ^!A `'`$èa ØvWÉÄ!-@÷Ù\@g @m`!®qþY !JfZø` ´!ã 8@º Á@º Å@º Å   #)2 º 5@º È#| Â %Bb`]õ!» ð!÷ Y5ÌÉBO\5db»Y5"TÞ(Æb Ö"c Ä ÈVË 2!\Ñ(Î!< 	!ðX5BÁ $B B`B²!¡ Y \È(Ç 
` % \C<ôó,Æ$· èDAÛ9±@"  y ó ú Tb¿)¯D$òè ÊZÉè×C3"È"wSò\Áà î!E 7"sèÎ ,"  LAZÐ )D$ò'í 	 -@C(Ý F ÐSe(â 	 à d# " Å! Ê & T@^Ø Ï  Ã! ¡4"|(Â 'h## à B . Ò! ¡ å  =YÓ  Ã  ãÀA ( A !H(]@#á0 ^ÄÂê ho(øâÈ¶«ÐHW @   ØF#'h Nç >KP K@ÿP,@O@@_ÿ`, (  SV&§W 1G_¯G Þw;ØtA'_'?LPè àÿÇG9¬  û|"SèÈõçÿ  GQj PèýA2 >(à  !T$#!IC$XF?%N ÐBÙ ÓBÙ% #Q %â !i Ã"=x0ZÊL !P #AXh"@ ^"r@, Â % uD I Dd 3ø ¤``¡ &Á`©¤` \ A¹  ë ± û Èc3 ("t.4"5"Â!ÊH#µ  Ï  D \ @#*YtE	 ^ (" %k  !@)@%Yó  ò   Q"¨%Æ X ·$ Y * ^%a` L@ÈXX¯ X"a`,;#' õ ^Àõd`¶ O%X ! Âï h   !@Ìa %%2á ÔA& ! !< Æ\| Oá P á@,á/!%  `Æõ!  A WÌ(ü  ¡ ¹¡ wG±@÷(&Ò I Û \$U{¡¬Yè AAeD! \!S ^  YA 4!a" `¦ ^ +&K Q@-Yç1Yâ  Ø  á #k!p`«Át "$ ^ X@  î èZ$á
'E\!.ÄA Uá £ áã !  ù §\ Bá T á@,á@b>  T\Ëã
(ð ´cEá §B± Z©oã + LHA Y&*&Àa"Yþ ! Ã& >Bü^ø%,  l@9C" Y!O` ê  'QY!¯Xùáz ^ 8 X cÀ X`¤  àXøZÇá#_`!1Eiã
 DCZÀ(D¹ /AY`$=Æö"­%ð°'è w FB-"@  &&ß
À;ÁMÁÈ  #ò,`+;Á|Aÿ*$ø æ#§à B ÙÁÑø$ . R%¸ ¡  #3@ à ] 5" ÓÁè=G Yg ò %@0  0@@ ¤ X ;@ ¨ !4À;ß<à	;   "@; ¸à; ¼ à; £à;(Ë zá ´ +@D Ì  z Ð 
à> dà>Î =`¸ È $ 7hËYT é M!è½:Z' ç ¹8  }ø@< &g ` ¤ë@ @0ïù3ö-8IðW&Ó;³à  |` N '3É@"È; `I¿[ tH0Zºà  }@$+Æpÿ·    À@b`#ÁHÿ¤ #G @)àG  #àG  #G@ÞDO!ç'T!Pë Ð"ÊGbª÷+ Á!{B@ p"×'+¨&Ø()Xt!&ª l#)#¬&)¬!ÝèD:F À 9)m 8© Z,i#``' HæY´ E gB EÔ { kYÀ'Á w%D + ³ vLC @, Op #Õ  ib÷ 2 à©9à s > "­Y@/-aFg`g @	 (t (àgà	ü Gàa@5  5 ^"ÎY^`ÑE`^ @	 (eâ  Fïek ^a  Å  ¦  ¾R#ö!ÏHet ®ÀLG(+Y(A,'Y(H~|$%Yð "Æ!ö RÅvEa6ec ^ðeezÅ!&"F R YEa ñ!qha À!Eu @Ä!+`X÷  ¯XðZÆAüÁÙH#Æ #¤"£à  h@µ W0D!1 p8B© ÈnA£ Ne( 
 \)  &w"¾,Ì Â#£N-°%N2L"GÄ01¿ VmuÉY¾ù« 6O3ö|: t$1F Òßm í=| B	E% ÿ  =  ,Ü@d Vª ó µBµµ@8 #?l @ ÇKê@ ÇKè@ ö `E Ê>}ÁÁùâ+JÊBXLhþ 2l &`O @qï9pt	@[;Áuò@Lx~B % %X3ö+® u G$(±Ì"©ëûuàÁæ±Ð Îº 3 áÓâÎÁù  uL·ë·  f3ªº 4ðf;Ê}	¿ÉLë3É4` !»@n *4K(h!/<o`@	
ÀxePèXÂðÿÙ\M!û ëSû@,uJp $Ïÿ 1¹LÕÉÿ ¾|$@}P( C;ÇDÎFÂëï'R ÉyÙKïnÆr. ^V/  D'Á/HrPi@";s	@ ÀuéëA a "2 &E b0ý"õ áýò6â Ç7¿BW(UéVÜ&BMHW}@I7ÿ³Ô ! "o0èëïÿELMTØ ÄEP»@$ uD9 + ED/+ELøtø&'ø t2»G§  2À   3öDµ!ZtPè¤Ú@P Ç @ Fþ|J¹vá I#$#* J uA Pë ^ .Îë cuA 4 0.#Èáÿ yIÉ 3DAtâ  .¢	@Áà	#3Û9þ  º'Z 3É÷âÁ÷ÙÈQèöÙ E Áán-Ï3 Å)97¯ 0 f4Ì   :D$ ~X48 uJ4 $!  PCPSWVèç8ðÿÀt*"$µ*#IE$,È°ëR $aÀ = A (àI I@þ `üëYP   M@±÷"2,;7[ÿ6 ò CA#Å`ð ;4e  !©3À¡¦õ ¢A¸    ¦Æö X!f#
Eo2  ªNGKa¼ ; 	 \*Z>q xap# |  ó$û ` ¶&*YE é [ øÌ #Å AAXAA\A A`A$AdA(AhA,AlA0ApA4AtA8AxA<A|A@ YADA¯AH ÐAL`PHÇATH¬ Ãx  (P¥@ÿP P¥@^ÿ`  (   S5èÙ@-@@ÿP@1@[ÿ`0@+Óá l#' !+A$è ©K`& É$, r!!3 'a/Ñ!é&rFrZ!fh!f"a§V±@ m!¯ Â¬2ÎÇqô@  Ç _@ [r/ $ÿP|#_ÎÿAE ^` ìJ9 ¡{Ä$"8 S$ U¬$@ VW¼$  ÿ~ÿl |`#¡ø
Æ  Ax»3ö90t%¹h 
èÃû	Y $7 `Fè°` ´ uíÆÿ 8  9Xup$@¸9Lûua  ( r9+|uR  ,` @ C  0` @4$D 8@%9¸ @9¨¨@HÈÿðÁ9+-3ÀëP`è« îsÿÿÿ3Ò¹ô¼@%ue@3 Á  >Á¸ P
Bùôt|Øéü Àú&¿ Xð$   4 iÒ@-²ü R¿ø ÆF²+ñ ID$_uó 7 8 7&XÂ+Ç°=¾à! a`º R AA  A  & < ZAj  L` Añ¤ ð ­Pº ª è|ú	 ¹üº 	R·u@èB($	[3ÌèIÙ ÄBO Ãb[@  U~ Ñþì mpÅEðVWPEôd£!I ¹ð!VÇìûÿÿ@	èetÂXÇEAk  "_3¹b_cù	 ð *! å Ï`FèE@µuê"mx!}f9xtÂ © +"yä~Eü!Î è# ÞMôd  Y<Mð3ÍèeØ ^@Û@ ßÇd¡ 'à	ß.àà¾dà
à 2`Ãèøàà Æ¯`Fèe@ÊÀß *_O]Àà#R9¸CKà è À 4@è Üàè:àè [é{×àé 
U¬$úÿÿìl)J?ê:Èàú !:ÁÚ Iàýb7úØu =Èx ¬ ÒAë3öè±c¡!ä .`çè~÷A è!W!ä@à ÿ@µuêFÿEÐ/M: P@'Á/`>]ìDMðùFÊuk³DZþÿ_!äþ@V öx0{ÏVèÎ71` 7 ]cL°$Á|8 dé@
sÎj è- %¢Cùÿéü  ù!â É`v ø v è = 2Ý 
A®C\$` M8Æd Çh   B@  j&ÇÐ `<| Ø  ?ÄÇÔ @ `fÉ ÖHèÊÀçÿ5P#ßE8P ª$Ñ NèÐÉ Rÿvè'ým)åE8 @p!Y4 ¡¨, àþ`  M@jQQÿÐÄé ù®@íê
@ ­` Þ` û` Ò` æ` Æ` @* á Õ ¡ Ê 
Çä ¨  Çq   Æ`Þ C ¨Gd"&PAèq't * ´ 4 ° 	@ ÆQ? M UÆEü 4@è< 4AWP`%ô!bÌeðPèÁOÏÿÿ³F `v :ÿ³´!>@0 %Pè`"Aßÿ³AËÿs %j h}| Vè.+éÿÄTMèãA P %	è`Ø!îèøH  «@
 Ð ® à!ýÿèûªH é¯a5CmÃ @sù"S  ùT  æPÿ¸Cÿ±PQ¢lþ Ws ¤Pè*@¤,`×(Ì@A(Î~@ "GA IèÌ¿"MÆ @BP  è Ì`#À¹ ! Öéõ	 ­ K lèñÿéà ù!u6»Aa`#uÿáLè°!é)!Va\è@ °é ù =@:#@EÆE Ô,#'N	jÿPLA'   'Òx5ú@}0 cÛD¸ÌK 
t'Rè×òÿM .! ÿèQ«êÿé5 ªúÿu 4èÅà  0@    ù@` @â"'M¸è«×Þÿ ã X#- '  ! Oà jÁâE¤RPè¸@v ¤"3è|²à(:Î H Pè á"b  º ANTy\E f &j "ß ¨!÷PèË@L ¸ L;ÁtPèÊkßÿ@ 	èëùÞÿE¸P pè¯ N;bI¶   èÊ  ëx~P' D o_  _ `_ kà _ _ j D@ >è >À_ O  F_ |à _ j  ëjì"¾Ceç 2!JÀñ I (á`BèÿàÀûQ©K$»Q!@ø%ß H bÆEâ
 S!¸jj"ú²B½è(® @PRÆAÙ¹ !_	Áàó¥jÿPÊ Íè=½ôÿº@ì 7+Âµ@?Eì½ê î +ÂEð¡/C@h·øöÿÿf
à Dà Eì·@ à ðÀÂú"|| Mè¨êA'"n"ÆÿèøÞÿém%-!«pÊ;ÚK' & ¡ 6 
  
: 
 pÆ  !zÀRÆ÷ R  Rùõ"Ñ TkMÔè½ÔÞÿaº ) !.s!ÁVèÖåAÁÔèþïAÁÔèfAÁÔÆEè$Éý¡Åt!w   !xè³Îß!ÛÀéø#IE^AÚ &= ! 
 P$ÉMÌèt'ÊÿuNF+[ù+ñE"Å1è6Ès# /' èºäÐ!EÍè¥H ½È # }@guÌ¾ÌY pÏè¯Cju&@°e`ßÿj@A P ¡WPè'4Eèé 9	jh<êHAsÅÒ!hø9@ 4 "-è¯ @  0n`è9y é½Ì  `j C`iøcS w 7 - 8è 1@Gè8ö$bà@ ä`@ 6@ èÆx@@@`@÷õÞÿ¶p>Ë@ëy_ßÿ4T Gtþ P! H` ÈèÚ Kj V 8èØßÿð(:öt@ÎPè§â ç@m P P@Wá×àÿ!:PèØû¡ðu% 7!Æ 	;ðtVÈè;g  ;") @©@4£ûÀ4 >'`Õðe` &  müf > @ è Ùq`MÎw@@¦è  ë J ¼`JÅvàJ J ±`J@ JèÒôàJ `J@ãè¸@Áè©@@²ðú`T"Ø %âØÚË!3Mè":%³¶ÉnvEÈMèb  lè£H }è t&ÿ³EÐ#º R ÿgPÿ1óLjëÇ_ 'è9ñÿ!#!®ÿè én"¡ù÷c« "i @Ñ!ËEi , @p'â ê!LìA1`,±&iì@EÎÞÿ@vHñÿ  Ô  × À ¥I*è« `@ c sÿèó  Ý ùö u( 5 x'° ³OÝ ÿ`ð ÿàêö¾ÿÿë"ù@/ 6! 5$ ÿ¢Ðÿà + éo 7¶P-EØ @i¤! ÿ`iS  ¨ ©* aè\öòÿ¬ $|' GÆ é %ÿuÌ@å]pÇ¸@X°a³ H|@p ÷Mìl@Eðt@ @¹8=x E``#Pì(| Äuil},
@ÇEx h(Q |!µ%ÇExÇEX 	LS+ý @f, èÍéPô@r!¨DÊMXÌ XIÊ&¬lõÃÌñ¬XÇEü.!t¨utM`ì ]ì & ¶ÿ»!4 tÿ³M!K ÿ§« ÔeÎ 
S=ÿ  w1Èø» G$TX6æÈ9 Ù«ð	ë`$à  |   @	Ã²; }3ÀEÐèEÐÒñÿÿ¹Nè(u®«NÊu Î«T@ ».W¦ï2 Ní0EÈ ¥O# S8y$Ç4 @
WS^ÿPÆ*¿!S S` ¨"Jïuí/7|SV5÷¸«ªª*W4V+÷ê.ÑúúfCÁï¸ }  ú;øOø¿C;Çt)CAL1Á	èÆÞßÿ¿Çf.Ö ÑçÿCW:;FtN3ÿUJ	¿S;Ê>s4À ~"-Ö>PT>É~ >l>ô+Õú }U   T8ÛÀAÇ;Buº]¼02SU@ÀÆâ6\A¡ÁúWæNÎFKx6ð\$ l°2À;  !ôT  ÷ eæ"K +Ò 3?ÿÿt±T!ètÛ òÂ÷Ð!@ë	@!SÉuÓü HÉj¯ ? P"à?@@?@D'@?2ç2À[Â `8µ?>@9ºP ~:L  Î÷Ñ!@|!@Bë	²@	°@°`ÒuÄ&ô1`Àt'f9xuÇ@B< 6`ÀuÛà  Ì¶Ob`V«å Quó%@Ä!>6\6Uð   ^Â¿×À  ,,!.  TVÃ\ÂT©??O`6 f6»\)m %5Ì] Wÿ/ú u @;]_×ë6ÎÖv(Ö $L&= A> ?ß ò8A èà/Ô 8d$v/áv(îéNÄ(ì7ì(>"Y-È e >]Xl7? (>AY J  ´Xî(Ñ 
p xÞ RXè(Ú @ Ü  é (ã  |  ê `( fYü`P%à`Xë  è  \î -, B/ý@ó ï~S X-   ©Lo ^R ý>RþZÇ e`ÍA À À @ @ ! D ä p Ø`²Xå!.vA(  H =@î(æëT(! w Ì Í 
!	YÔ¢Y× @Ù Ä 1 ¾[·a  	Xâ Da  à Ý/Ó Ú/Ùw9(Ë ( ËàY Ó  ñ  Óà] Ã B ò  ÀR\ðó^ n©X"VWöW% "O  ã é ^à"Z=È"ZóZôZí T@.(×aÿ¡BÜ!"?õ!êZÛ 	ÇZäò^Ð(  Ä  Î æò\Á Üf!=   Â@
@g Ü P  @à à Åà ä  1`W <)@@ à 
@f  @O Î \ø(Á!	 Â`^øZ ¢YÇ à #à@; Iã * ö/!ã ÖC ÑC Ñ k U C sÃ ø  C/ÇC úCéé$@"Ù!Ï ïaã "Ç X ã Ï  -`~ã"vã ß c-ã ç c@!Ø r ã IÃ õ"¬(îc ãà!é ñ DWAC  -AA!@ h|A§"­ @ CÜ/ëC Ú $(Þë%dÀ#%C)C% Ê ! Y£G"Y¤"W@ \$°ù ¤zXÙ  Ø  %@«/ì â/âwD(#Ö ô '£áÀ]"2 \!úDàa!H XC­ ÀYC#¢ Þ  â"3ã <ãV aUã ¦Bû!ãã^`9£] Xã+]ã#_ F'Û!# =b²ã_ ×C_!áaªãg"5Ãg!Æ÷ âCm ïæ*÷#æ÷`ãkæ÷ãm`Â"æ÷D¦÷ãQ ão ï!Ñ ùc_(ÙCFCr!èÃjæüãj 
Cj#âÞëUãZ C} ²ã)^#Cf áã bHã
bÀeã%fc^g mãf F÷ãfA+æ
ó +æ
÷ V 5AÃ#&\æÿ \*ã!oão `@qh!!& 1Dýd & d @E  @6  k'$h XW'fÝã Î@/ t@RÀJ@: B!`@èâ B¥Hê ÄAð æAðçë!!sDÖBðèÚ I #RHÞ&1HÞÈHÖHÎ] (Ö Ã U/Þw=(> ((BÀU%°\ù  ÓÖÀY%¡ X*á@ÀV \'3 ^ j=hNWö 
aãWçÁ>%=HÐ å5h&6 !¨ØAoaáhÍ¨Ø(ÊAÜç (Ò!PhÝèÙ h!!\!d&Ð)EVá o låQ p  `W'Ï)@@ à 
@f  @O ×Aû*!ûÈÙ Øû Ã b3@0% Èà @;Ù  Ohßì 
L$  Lo U"È%Lp -úTBb,|àv  =  {à ¤ì!ÉL  @1!ö(Ïh Î(Æ`?L¢ Y °"É(ö  ×` Ö`  y i2H *l!AÉX@`(  ø kM íÉSì Û IQìÛ éS! *ðbì/Û!RQ@¾"L Á`åã,ÅÅãì=Û P"ý¢ D äB= Yì»Û¨¨B¡ ^"KtcSDE1ZÉZ ó È"1$òL$ZÒ"=in /-(Ú@"$  DB~$q $Br±C?!9ßZ. c$/ -£õZö  è#  Á*  Ç%¢ È!ö 
#$    X ! -+¿P   Ï1D$ $ \$\ Xä Q T æ -Y÷  Q Å  @QÌ 5 ÈY @X÷@] X 8 . ) \@s  #z¦'`¥ Yâ  ð G`@{ ^@B Ä@, /   Á@
@7¦L`·à@ÊA$`­à5@@@à@@¸àk@@@XWEõ@@@@9à@@5 \À  ±r[  @`h \Î'#°Dê õ&a!$^  Yî8@H^î K@fà@^Ä¥t OåCo ì6  Rë,bå	o ÎeO"R&d%¯K"Åo òEo Ö`/ê åFoëSå
oë"SIrh­ YòK#èå)o ï Bë.SîÃ£$n3î Á ëPÓv/Ùv!Â -K=+X 
 =Në] 	 )I@$Y  Õ ©<&ý Y$>i))ÇFo îÇ0 )êÎÏ Ô"/áw@ël@a"²îÏ@e&ÂîË õ@oÈÔCÅKzådD9%åee²å\ û#WÅ\ 9Â Jmå  Ç! % ç%È  ß#Ô%å{e E,%zåý~å(~ XÅHÅ@ÅPåHED"åPH  !úåO TBê ¿!ãê ¿ Lê¿ Áê¿³eOê¿úÆ 3Ø%dË  ÊÆê¦ F(Î"ü'"q/ù#Têæ!"¬*Æ Y% !@Y$( T,4!+`Xl` 3  Îp8 L+p&o p."ßê è ¹°Ô JðpÔ÷Ìå
ê"ððÔ$$-êDðAZ·ê-T ùðÔ $A<åôG 5ßëY ] ¥Å{9Uå{ôG/" EðèK ü RôK@a"Þ \Nô)¯"Cà e!Q X-X@ÅÝO|"ª`Ü0J"B%#å] tb] %%*Ã8 `4Xõ x` É! @ªþ %Eûbi`"!CXå b / à! ¨ 	 ï "ê Ú%JBõJ[Cë a C(²@1jë
 $ ë%ë X p' #* ,  Í`!nÚ "Xñ %#¶*^ "O@@ ê &ë	 è ,¯È!5Bÿ  =Bê `G ` G `Ä  ë -@×@`ºà@@@¨à@@` à5@ "ÜÍÒä ([x ÞQp:¶ ßw' uC(ëëPñ}!'HfBâ$dñyHSà 5  ®WùCé \G®d  æ$#¢/çQÛ"ÀB¼QÛ@]"Þ \7NÛÑÛBÏ7y@à Z#!í Ú(Ñ\e?Cî_ Ý`
)d"·"ó((-1B@S bùY  ¢õ  1!ü 5B`9 ë!§BñcA`BÛ èbØHvH[ Ê"Û 	âØB1âØ d\"Ø@1âØ h $ âØ#íÞ l 8 &$. -Fí Þ p R íÞ!j llð8v )â ¹ t @ `À!à@Ó@`¶à@@@à@@`5à¯@@[íÓ@@@<à@@(¡¬ £n £ ¡Cc`kD"U X"çXÄ`^È'Z Õ Í à ô@7Îà @RZA¼à @U@}@É"àÀ ¡2  ´ A`k \î
h$© y ý î L@?à @Jà @U î_é8@Òé ð!\ çé21ª#)\ÁÇhÕ  ? fhM#§Ø¾X¤#¯ +o!ªQ!"èÍäåèý÷è÷ c^èÉï&õ"sÀ(ò¨"%óèò À  óè òèÔ  Kà ¥ð(Å#" %I$ Ê(÷ 	 õò3Í9 ((àeý \È ±° ` ¡¸ e}æeúdN(Ï F&® X NHêõ+æ$xèÞ`d¥ ($¸@7Ñ O@ÄdC 8HÒ$ × \HØzÌ  Ó$ü aXê6ùf'AYè V ©DÎ!U@¡f%¤û e  È#!  i fBi HèÍ!FÐ!è$ª'MÈ !1 (w6> ø è !$å B,$Â "W 0È ¨ , !~GR=¥ á"q!8¨ZÁÍ1¬ §a¬!ó râ \Y±Ø h B¡à )»  BªÀ.`ax`"dâ	ll`Z"
ÖQ"3ÂlöQ` lD+Z !Bx6Bp ï Ê\Ë  `Q FY,6ö\ð(C? épIS Ð"p1Á ñ©Iw!9@¤B]  ¯L¯  Ð&r@
 f`$ É(à5"h `@@!à@@G% «b» h  Bä  ¡¨1(ú § È( , ÂiA ^A^ çYÑ _< á r ;  K `C K`ù EÀ{ @Ø mY  Ak H !ª X m ^"6Yýa  Y  j ! Y$  ã¹@@ ò"c°ÿ'N#Ü   Û¿ 7ðÿ $ðçû¿ðÿ ßç
ïE"Ëç2ï"÷%O9M$EMA` ðÿ%ßÔ³ h)¨TÚ!è 4Æ !d$ P÷ûè  $î  Oë !Ið#÷Mï _& Yöx!{M#& `Ï£Y%àHÏ X-B X-2Xì!
ûHè @+È 
A) p>0 ã y å!0N án =_½(æëTm± ¯,GM¹ÿë × @Û Ä 1 À á 0a ®_ï )£ \?ï ÓNÙw9îq@Y1X \8µÎu@]K ò  ÀR\ð R ûê ¹CÙ  Y  ±ÿ!Ö%SBnpòZÿPC7aÜ#J3a ß3%À Spî!4Ùjapï 4e M[å'c«%^c© X$ÝBâ$Î \$1 %C¾# 	Vw%] X %dh02#7ÌGge¼e¸#ïDpe¨ Æ %aÎLh L`;F/(ê Fd·@_%kD°à
_Dá ñ
  éÀ_M> F \.ò$AF ^$ú X¬p/7EBRì ÿH Áà@Ô@@¹à@@@à@@`àP@@@X%æü &Ù@@9à`Mèç v°AîÐi÷ < ¹PW n 
pZ û`&E¾ ±f ã"Q!¢P"!ú XX|!¢"J A \çaµ"âmça~ Wâ	Í Áþá	øB>bÂb#iO& -0½Aß&e-q §Câ p!Hx "YÖ @*XúB"% -è]c â N©!6¶à@É@@²à@@@à@@`àP@@@Xáê@@@9à@@7 \b Ðg» °D9 `Æ`{A^.}Crñ00`(õ \ z X`Ï 0 RK@¹ ^(î(êp\ Å!C"_2Z'öàBÂXà %Ã"@h 8à-@ d`{àÁ	A^à@Ä¾@ @C ,8W? \FÃ©C@ïè ? T#õTÁ Nfè? Âà? t`Wö/óè? @g ü Ù? Þ~v Ùh Ffk!\Ðþ Ña|>'^ Y% !AYù? ù?þx A¨?AtÈ7_Þ HK/ÇH9úv%Èéé(ð(^6Ï4rY-æ Y?^!Þ& U]X-`î`¿ GJ &Æ X%@FM ]Î  ß  éA^-' YÈ; ç  ê `ª#  è7 Iþ
° X-q=Y©H!×/õ'x(îaj é6» eþ° y?B!Þ"cþ ²!3'F ù, =AAÌ Q J 'ÓG×GÓ&ÛAù*,V%dDm/ì Ä /Ù( ô N)îVEÀ]"Çþ¤Ù!Hþ¨( p8 ´ DbZh+0#Þè, '¨rnZ,åf  >Y" ¨(r(ø è:'³(r 8&1%(,F?!f"w%\FAF5(xHbH$sæ(=dJÆ=f'ÀCÎèJ AæHègJ èÙFÃ'Ñê	è
(<è·î XÇîÇæÇöç	î Xh)bA*,yQCEeçî X§_ç­î%'çDïê	eAÒgï%W çIè lxYT§EX@`Xl`çýèçýèçè b<ç èXmn$ #!¹``çÝ0%gÝP 'ú Ý \ $0®	@:±T`çß.*Gß 'ùÇåGõGÞìçågýUÒ+v 20/ X.eP7/ñN]$ È)²(CUs# xT(HEÃç	ô `"0/DÛ a Dòæ  6 #î6  "q Fð9! sî 1  0!iµà@È@`­à@@@à@@`à5@ ©§ paý¹td ©ò l 
 èâ	±h`â	 ð3H!Õ  p`â Ø)Ü!IÌð>   e^ Wá	× ¤`A×PØáÒB) ¨`.J'é X+BM÷b çö ¬`/RáÜ ° 0 U¶á@É@`²à@@`à@@`à`G¯Y¸÷L¡á  ¡Ù  
 ëáÙx`aÙ  W b±|`
ñSâA ´@eaR!Ð", a#Ø ¸`%á×!Ï@1 ¼ 1 çãª À "z!Íñ á ×0¨Qá!å-`,;"âã¯ Ä 5!¸à@Ë@`­à@@@à@@`à5@@· XÃÚ ¤ ¤; ¡D B@*B(`Mq I X`l b+DÿéÛ X¢¹ Xb 0@ý X ê X`×àñé@¬ZPtñ Ö@Çñé@Ê@hC9`Xà-@@@¢à@@C9à@@@¹à@@A·à@@A·à@ ò:` @-î&I  Ò<BH%`i$^ ò$ú| Ãà0¯ - qWä/ð"Ò ]0 0
(Ôë/Ðv(2' ã@ Ü@ Ø@ Ø$ô01º_jXÈ/YH¨8 ðgÇ	,Â·Àf;Â~
 o
È£ë(fÀy`^fnÀ[#\Ð ;ÅÌ5£ DXÅÈ`A#%u:a$^Èc7 X_9/«YÀ&"#Ã#éÜ@Ô Y%e ÐoÐ"&B/Èw'¯ó_0¥YPç 8`¨Ô`7Ø ó
¯ Z dao¬#Ì¡o=T(ES¬ Øáo;ìÀ*!Q G 5o í1e p ¡¡o Áo åA] æA] æ % ` Ã:Ê/Äv/%H&=Aþëp  ¹u@Õ@<æcCYÌ!H ü $±Z[1ÇXþs' Ü 
S° Y5rÐz #YTÉ  û!£ þvYx!U!u'D¹ !!@#ø Æ ,!oXÎ)ü  q' °Q}/èA7ï]î3$@N H ?@N@(UÂ "ñ .Âï LáIÁ dá Äá Ø¢ï!3½¡ ¡Á ÍA ÈA È!¡Afa à@2bYâï ¢ï ¢ï ¢ï Á¢ï  ¿ Bï i "Zë7B÷Ç`@ ë&âþ!¸YÂþ ¢þ@8 H A* Ü"vÃ	  ±@Jµã
ãBñBA "ö!¥!'Ãë@ PgÅXD`Ø$K|<XË&¾@! ¤`AÒ¬ Ë  Û  ÎH`\Ób`Yü a )%``q``B²X`Y¤`( vÇ@#@ Ç@M@ "A ± `@@ "-b/D$VQ<â;®è<ÿÿ ¯D$jQ"@  ^1 "W$ý  Cì]¦$ ÌuÃ'Ú76W \Ï!u\Øå %]Ú / = 5a_ Z0ÉYÞBÏ È ïCâ× A  @ Ø "ì>!Y \ 3\$ 9a	X` 1 à  ¶l là¨e  =w^ (`¥#¡##0Y w `X   Ô j "[X '¬l8 `,#¬L$z ±>`ûv
Dí!(ÜëMö V¥ Ð Ë@ | Ö$ í@ \!S"$Ö Ö Ù &LÀ_Xî/ý Z$%H(Õ# + Õ@)µ À]) \&´ Y=dàa7t X!@Àa_"  èÆ ^½$ Ü æZ+" $U$ (8^ñh¾ Y¶«YVtZð v¯!B 5[Ñ A x;Ì!0`   ZÉZë [&# -«.]:¢A XA ç Õ"c  ß J¡!¯&`|½NIF'àIF!³%Ð Ï@ÍV|  Ï1%[  Î!ÁBg Â '  eP $&Y÷ " a%v~Ì`p ) Q# sÄ  Î`!ehdq  ñ %`OF\O DYâ & ð"<`|@x ^ XÄ@,`/ (!¤=BB@@j `!% `Ä *@"À@×@Fà@@føà5@@` à@ "p×%Ôº (Fî
Þ/Ãv/ßv  D(ëëP(¢ËGF$H Yyt! 
 º¢Úà 5 dÿjý:r \cEC£  æE"åçw=azYÌà]'¨ \#Ytàa Ä"ÚC8 à Zc8 ¨h' ^ 'DJ#_b _ {~ S!&,"ñ!Å@J doY%  ¢à !!ÆÂàZì! ð _¤ ¢Ï!¸àâÕbç¤ÂÜâ#ØH bâØH Â yâØ=C@x"W"àB ÷By^¨ ]!q"Á)§(Ï  b p ÷R âÛ!X?ó 5Zí )â ¹þ	+à @Ó 6¶A6à@É@@à@@`5à¯@@[ÿ@@@<à@@ XÃ0÷±!ØA²"U X"W «O;à¾CÉfÜàCÁwà ÿ T![@}@É"àÀ ¡2  ´jn`k \*Î$5 \@} Ã`^ø!È f ý  ÇÁ³@?là@Jà %AbÄù  -G* cëgÿ ê#(ÕgÝ#áÃCúçÿ* é@! Í`! Ë /#M § ~$T àgGXGé È É ± LC£'s&k!\IS Yçû !} §û ûà¤ Z! å fgø L?@s è  `Y`X0p @)`  	=,!í YÇÿdfE¼ ¯ã/üGÿ àA åGÿ$¯D³D¯ç¡!`DÕ!Âç ÿDo g¸Çÿ'­g¡ _E û Z/ØGÿÓeI!Eoà]% \%Tè
a_ùe aew Ö Üçÿ â!%T$ $ÁE!Fç í ím#^!,dM3h!`Gíó^åx"æ!ëZòZÔ 6eC a((", Û 7%I"0gÿê()# ã 'IGô"aD Y'Ã6G­  X aA
e %cD®gXÏ B%XÃ ' ß cw 'ìYú  a%1VãàQ)PC %x !çÿ ùÀOD=O " Y(ß\ø ª`|@x ^  Xq`â "çÿb×G(ã"8g'ÿ çgÿ %ÿ ìGÿ¢ËÇÿbñ1Çÿ"Ö@à 5 çÿhj"å ßGÿ Ë ,"À]"í \#BñBÀa$, XJñ à ZHÀÇÖ |t$"jBÌ Æ@$ 'Ñ  5Ùb­§ÙÂÌxþÇ§Öb¯ºhB  ð YÈd æ"ã W Åbç ÐbÌBß!ø"¢ã*³âÜ \Q« â5"ÈâØEÀ MâØEÒRâØB`ïBàG Y,5"½ê@FK "³ §C³Yëh4âß!	èr ÎÃ@º a3çìAB@@ðà@@CÅ"OèE*##È ð&! õ  ÆÁèà @ÿà B0è! Pé'ö%¿AÆ "×"%!ÿ4×"àf4µ# pg]@t ¬Fä¼Fãá ¹Nÿ! LHnÚ!±|!HJ;F¾#ñ5*Kê(Î&Þ#XÇ * ©G2+ø 
 ¡G & Ùi$ Êk2D4D)'Zä >æ1 @'!n!ï1ªqøJX &)rD` p[XG(YÏ$\ Xá ïJq'G#«  ÈkÞ X'!à_æý$v æý é #ðÆý@{@"/È@
$3 ^ }Xø %>pB)ê öK!`¸à@Ë@`§à5@@NÓà@@CÁà@@@Xã ó¹	ào@Aàn @@ . ±%=u Ò!Ñ  ©¦3@ ¡F%AÃ(ÚÐa¤Y\M-á(Õ 1v«!>%AM¡ÔáËC»áË K**ìáËE9S!Ëû )! ^[ -è$ádDk!¤`áëDs@`¬à@@Eà@@`à5@@@Xá ±àg@9à@@- \ÁÐ ¢Íç ¡B\#È@*``{C %lA|p· Ä (õ \`%`ÏÀ0\É^é!Biö@ @q|à b ZAhà @@@[`Kà@@`øaà 5@@AQà@ÇLV-?Eê `  4+ì$iÉVñ¹ Bu,$=Æö û F$fÕ(6  §F,À;ÁMÁÈ$  ò7ê;Á|AÿZÄóæ"3$Ú&T !  ¬ y qà O +6­!8Áè¼ MYbl W ! Z). A6a 9 I L@O¨¤ `L > Zà> 0äa  ! 7D$ @Á8&Ð ¸`-YT @   è7ÄÂ¡3	L$ùÒ J
¶Ä ÿ$°  º!: ëº@º     ø 	SÁê¯T$V * Ü |$ t$`v!2} R2¶D2  
L2L2D L2^[*é À 3YprãXt`,ÈÉy7Ú	3É^[Ã¸ÿ ;È^OÈ  `à=@Î 9Àø}¸ÿÿÿ^
[Ã¾@9ÆOÆà5 6ð¹,À=  1}¸@ë
¹ÿ 4"OÁ`Þf Â© GÈ@½2 À àÀ  ¸À=  F@L ë
¾ÿ M``LD$\$ d
\
tQ^
D
[Ã`#à£ 4@£! £ÈL9|$!l =|t<L   A\ùÿ ¯!¡ ë  ò  ¯   à f !Ú  Ç   ' f    ­ @3à ÌÌ#c~L ® ¢t !ý
F$ÿ0~)@ÆNH$UNDFVTº#¡!æNDtd¾FPè t:èt uK ö F  \c
/Èr9ÆFPë3  X Ár!` ` 'v ë ÀFP~PuoN@ 	NÆFÉt_  ë6 8H/`uVÂ/{LÂÁ2Á ?F 9% /	jj jÿv<"´ÿv4ÿv8Pjÿv,ÿv0èòÿ^ä	2 À !+ wVs  ±?s% \@$"># ^#øè¸D3êDöàZ` S\$ X8#mt#@ @ÛtÿPSÎèE; ^[ ÿP@ 5Àà	? P`?@à? À/ ?õ: Oà	? `?@à? ÅÀ/ ? µÀà	?  `?@à? À/ ? uÀà?!Àùè±õ ÎèIÀ+èþ 7À"¿ÿt$ñè$ #u tÆ  l  t5"ß3Ò%FÀ~#V±Ð &x vHB%ÿÿ Fü;@+|å`@éË9 fà  àO àO^¿àO àOà?Äà   
Äà  à	?$FÀt
Ç\ Ñ&$é%À¥Á   k!
Ç@*  `Ñà àO !à OÕ8 õ Wa_ùBP@ÿPP@O@@_ÿ`PàSì"Í# O#f/O©r'5ë'C&°pTò$ 
 'H'Ùë,­è<µ))gZ  GTWÒ#P@K/Ðvf #h(ûLv3Ä,yY¸õ  _)++=ÿ  \ P$4'«XG]/ÊrD $Ý\Ê s÷Q.ÆhÈ§ý XH-%è´à  Á  O è  o\T VMcñ` $ Ä3r q6ÈsXå`#àt & Z¡àt ¬ Oè$  T Rü n°  " å åÁr	@_ @n w W)/Þà àº³à
k À Rè¸ Àc Ä (~Ãá ð)©á0ï L Y ß ¸áGïXI1!Ûaä! ÑLÃáè¶²à ao!H¡ä ´ ÁAÐ! àÿ $oyâ#ï L Uàÿ (@@ï  @
â6ï"é`Eà"ÿ ±à àÿ 4 Dè´ Àÿ 8 àÿ!¸bÄ"w*þ 
BY*Îë ²¬`Íè P *¼@)KºÇä"\  ?@, <   N+ï _bí2#£¢Â`$ ì`$=V!°£ø/ÄS) " 4 RÀ( %B S ãÍ ( ÅY\$S e0ùÉèX°` C_¡¡d c °` E/@G) ÀOe/Ã`h )h V N$à e*¸_%Uñ;¥ /6L, & v%¥@   ÿ'6 *)`L´[#´ ` `0 2 U(Á S¼ ¹¦C® Ä`\Ð`!)¯¼`¸ (FÌ<  "¿ c!SÙ ¨æÉW¶³R& j@{6  æ% Y%h nl¤@ X0@Yp, @-,1ÿèZïÿ&y$ Ù!ß !v¶S R!px%í  \$ X ÝæÀ¹Ø ßà ÇT -  !
CX+CT # @ #´^Ð ` 5&* Y@ @;  ª ^ Y@!Ë f$è +$Z Yjr &+@" 2ZÂ7 1.æÀ_^à7`'ÀÙ^Ø ( R  Ó@;!J`¢ [$Â ³àÏ('À0@· g ¦¡6  ÷ G yäy"^ Àx[ ZQ2@à@À ÌN·	Â;Çt;Á~"{òXÐëÓ"C `z +@£3ÉÀ,Þ,s Â !	ötÈB`;È}+@Â@1 `7_^CX ÉBSU#6Wt$ÿPN(X\$èï+æÿ|$ ÎÇÇ"} v i<øøu]E3öGøE Æ"2 Û~I3Û I ;ÆLÒu;Oè|	²uð+	 GìGè;È"@}FÃ;9%|Éë
Òt+uðuô+(Ç0Å0!Eu_^] ¶ +"ÇÀ =Ä¸ (Ötø@|	)é ¨Pj (ÌèQ¬6a¦ÃT$Â÷ØVWàv!0
úñ3ÀÁéó« æáóª@+ÎÖë@	!¯ù|ñÁîÆ÷ØÁàÈ)ÂîuõÉ~ú3ÀÑD Ê`D_^/D$K·IRÁ@ÿ  ¦ÀÉ / !#·à/J¨'À àOBÀ !  ó l¹¬ K4t*È¹° à ´ à/à ¼ à À à Ä à È à@à@²à  àA"àAà   à ¤ à ¨ à&AÀ Aáo@À) @/¡OE3ÒFhxü uP8 uJx u2x u#zÀú |Þ À­  Âà à Bà@à ¬ I áýÏáÏ VLÀ2Ïèìàÿ Ùó w%"FÖÏÿÐv fàuð-B<ÇG0 FÏÇG,   w 7FÀ8àHuð¶G9ºèG9_íuA¯VW3ö¸ #o97~'K¹ W  &Å~ @ fÖRLHèFJ¼;7|ç Fà?Bpà3? "íà3? x Éà3?CÂà0?(Dà?RL!?B´!Gá@ æ@á? à6ÿCxàá¿ W'?3Ò9Aþ~%VÁIw!þ v ILB;`#|í^_ú` à	?K*à3?  ýà3? !ýà3?E à3?Eðà3? è!uà3? á6? Øà6G à!¿Bÿ5¦tV u[ øwRÿ$l AX$µAXÂ  à à à à   Q +  8  E  R  qÁ+å;Èt
jÿj PèÜÈÿÂâUìjÿh*d¡! Pì$¡¤P3ÅEðVWPEôd£   2E ø;ðt`G4* N I~rëÆEÐ6´EÔEÐ 9ØPèÜau)üxÇEü F r PO èÞÿEìørj@PÿuØèýÁ PÄMôd ³  Y_^Mð3ÍèìL å]À·À  Q à +AWùÆì 0 Ô ø L¥ï¯@m  ÅÀ\ÁÛtS-B tûtG 3Ï°K¿èèÉïÿ 0	Î;Á}"ûtCVÎÏP Pè@! BY ;+¥|&tEà |Ç`KÁKH YAð `fÅ4@Áæ·@¨FC"@{N(À ý9×3Éë;È|Hÿô ¼ +V  B;ÈMÊAül«IÈÁð .ÀtÁ8  !>ÆAø:Ó Ý '"8Ó A ©B!n`	  à 	Aà à 	@«ª* 	    	«ªª?  'Ñ	«ª* 	  Àà 	   	«ªª>'  @    «ª* 	    	«ªª=À1  	«ª* 	 <ÆA ! éK×  ã¸ Â  Ì  Ö  à  ê  ô  þ   #     &  0  :  D  N  X  b  l  v   ./!QóA oI& -ßèb/ Xg ws WU×à T3à à? "`?L·m?àà?â.@Q= xm?àà? ¢`?MI xm?àà?<+WVùèb ?·D#¡·H ë SW@!Hè= $I`@@)ó2<90»~$rX¹I%Jn  ]  8h  8ð NGdèÐªëÿçË@ À/Ô-@/ à/  à
/ QY0 D_éSl/  8½@_ ½$# $& ¤	9_u	 =ûtt@_ÇG`À$ @ÿPw ÇGlXr.áF    0` u4ÃjÁà$fÿR7 /ßËä Ï (¿ (ËéuñÇpíeÿÿÿl$¿"ý µÔ(3 2D !# Yå³©ëÿÆpïuëRè ,Ac¡/ø 0ø 0AY ìÁ3ÉU | P	h=	9¤$!øSPtN¦VT`$WQÊÿP(øO+ì¯O õo;ñtQGÀtLPèù]ßÿÇGA| þ|2µ &Ýº¾Þÿ . ,_?tÇ t +ÁP/îG"3Ûa~,o	h.ít^~h.©~`ÿu>7j Sè%üøU ÍR\ÿÒÀu@@b  é$ÏU"wèÎá 0¶@U1 0Aµ U CÆû| ] .ÆA!;öþ!´!_^[ÈèÂ/©]Äaà   SCPW!G_!$ G Þw;Øt.á(Ð\á(û|(SèxNçÿ! fà[@ 4 SA¼ 4 W2¿## «´ ³þ  U#  ©Æ¨!WB?í  È!ñèùýÿÿ3À 
9Aõ~sË8 @%w3ÿò~¨ tB~ -é AÛuj Wè,ðÿØ!UPËè}à N UÿR0ËAK@A@ GAMÿ|¯@^@r ;`r| è $fRµ  Dn <¿D*Dhå^ÿUÀ $`å]à `å=àä)@_åà "{ Â !	 å  $åSåék 1J` ã¿ 4ã¿ 4`*` Àÿ ´ F á T@ À `áà t`áà T`áá  2 !æ) é 
` àß 8àß 8`*` U¬$\%ìM*úÈê
ú LåSVêþMèìT%M¬ø ]ìp+0Áþ3ÿ5U$sK9pt;fä *ºä 5m½%À ëÇ@ GÃBÜ¦Eè lx$ ;#> $Ò=@1 sVPè§âÿD=`ëÇ @=Ç`? |Ï <é#©½O7 MðMÔM`MØ@D+´MÜ l ÜÏâ}à4Áþuäöy	j è./úëVè¶  Mè@?+è `«Û+Ãðèy'F  r7y2øø@!vÿë|þ@}¨ò L°ÈÿÁ|8  ðÁ 6 #ÿëWEÇE @!¢PÇEeìÿ¼EÐE8ÇE8=#Ù	E\E<E  =&ç   èab	 í@ R
ÿè2^	 3ö; &Dµ`!: ©!?Wßÿ7þ|Þì{[B	,l@ ¥B4 ]å5SÜ%2äÀÄUkl4MRËâ WSì0¸¸ èÎG í ] ¼â^)C{K@lþÿ2áÀþ½$ <@½D Æ; ,ß 4!$[ Éu@*}FQÏ*
$ÿP`FÏ&"¶!APÿ¶ ì@&è9 éL Jò!(é¡ Ç@
 k;½@ Q!a!`JäX  fèõÀ:Îb:È `<ÎPWèÝ&(D ± ÃH@B k)L @Pèêªèÿmèï³ é²3"GÉuàÝ Û óL!AQ`Ï8wPl@ Pà'`Hæà-  !  X@, !<:>¼$jÿRlé/ L éÿÇ@
Øoá@!Bó x á<óÿA@ aËý  A@ðA¡ `)áø¶A@Aè)êÿé 2A!á `@Ñá	 dàÁ hàA¾l WÀuAf ]àP:­ l Ç$ $4j é @ú ­ a,@
Èpá,@!,"á,,@ a, #ºá, D `)á, ka,@Aèà(!,s1,(~!!ã ¿À #' Q"JÏt ! õbKè ë+@ x @?BÂ_ |`â vÁI àAI@A à !,@ à   à  "¤ @â¤ "¤  à  à  éP7l!2 ÷!2 ã ñ@!§ !  ¨âÔÇ¡§ 2a§ ö!á§ #!§ á§©BÔ@èh"!§Ë/A§u+Acá£! DÄ ÃPèyÉ é .
ÀÀþÿè	<éÿà ³@ ³F0 Gà³³³@ `³ Bà³ Ä V)à³O°@³@AèÔ$ ³  C á!!à·"S Ô ·â'Â> ØàÂ> ÜàÂ> ààÂ> äàÂ> èàC"! ì@â> "  íàB[é..AmhÕ!¬+éÿÇ@
`t;æ@!w !	 ñáw»w@ awÊø å  l `) æ7®Aw@AèÜB+-Awu=á	s¶at$] Æö O³$é^ @H&èû6â=@ Å!àÅ¥îfØ@ `Å àÅ L V) æØ©@Å@Aè­&Ø Ù:Ú Å Pà	ÅÂñ¶0 Á!P( '· , (o$re$  $ªUÿÿé S è4àØ@ ØDë 5áÌíØ@ `Ø +#©á  V)àØØ£@Ø@Aè=¬ Ø    Ø BàØ ½#H¢ð! ¼ Ê ì ÊÛÿÿéº+@Ê°ô UWH@
 pè@ ÔPâ MàÔ ¦G@ `ÔVö âs ´ `)àÔ£¨@Ô@Aèh« Ô + Ô £Cñ V ;ø!|u* ;¼%(
u  :Ô@@ Ö *w IKj Ãèß/âá$ Dï ÓÜ 7 j!ñ "
@Ca- @ Ø ``' äÀ4z$*$ÿ¶ø`
!j ÿ¶ô ì ?!s`7 è ``7 ì$@1 È  P v Õ @Ð8G¹`4 HÄ ``P ÐÀ`P Ì$P8!$Pè\b , ;# ×) ÿaèdìøÿéÇ UP\áY 2?  á]`áar ã!µ8"ÿkJ*¼@"*
 @«é¬óÿ ($ É"v Ó~j ú# \!á¼ Î.,ã  æA7 äÅË«C@è`'(%b0AÐÇ,@  Ç( 	 `	!z 	 Pè(çÿ-)2BÓßÜ#@&C K@!w A QaSDbJã	À,"Ébã®L_@ÊMÞmêm5áxBÃAxA!è@!x&Du8ä@%bÿ¶$)!M  ,×!+"Ú ;0Âé^ ;$Ü,è;3#&Íã@!«$À@8åQµ¦Å@ eQñ åQ V)àÀ±§@À@Aè¦%QÙ%`e Zö be@®  ®@ 4"B à fààe!# `, D 8¢  `D`L`BL jA,ÕÿÿéO  ·è/á@! áæ5@ aõï á  V)áâ¢A@Aè¥! Ê-E î Jàî 8`Ô4  î Ú î@Ò0  !á¹\!á | M0î ] áá@ Ò][ GááÃåÒ@ `Ò "àÒ 4 V)àÒ aá@Aè4¤ Ò÷#`Ò HàÒÿ¶H`·D àÐ @ ÐRÿÿé« Kàù [¸,á£@ Ð á£²@ `Ð Q µá£ ä V)àÐ>A£@Aè#s &  ñiì#vÏ Ì H+ Á D È/W!â"@È  (vèï0àÈ@ È àÈâª !'ä!)`&­@/V¸Jà Q½¯Å@`ô\í â  )àô©¤@ô@Aèn¢!Å 1 ° ô NáÅìÀô h ç@ô"d  ¢ `"¬2lß!@° ì a.á@!Xq Câö¡Ë@ `Ö  ;àÖ $ )àÖR¡@Ö@Aè2áéZ  Öê¥Ä^  ¸ Í_ûI  #v `Êv é Eàç Uq1àÊ@ Ê áÍ! ¤Ê@ `Êºë á¡ ä V)àÊ'¦@Ê@AèÌ  Ê ;ÓJ  má¥ÀÎ ± ¿!Y  @Ï ° ìa¨pù ¤ `%H¨Àga ¬Àaà Àd} )èèZ!áýA¶ ¡
ðR@!  ¨ `ááTê¸@ a£ê á  V)á Pc­@Aè#­ x !áæ@ Ü ¹ ê È A Û ì=!  ¸  @Ö&j Ú @ Ù  Ø@èÛ6 î  i c y+àî@ î àîUòî@ `î´é àî ¤ V)àî Ác§@Aèf î`î dâ  .Û × ð@»ì çaÜ ì aøaÜ èÀaÜ ä"¼÷ é! g ¿ w~àì@ ì àìÙì@ `ìÇè àì  V)àìôBò@Aè ì@ì¦ màð ) ð"j  ñ  !È ( 
`ë @ À#Àc Àc  Àa1 $Àa1 Àa1 CK"îA2@ ½[á2@!2  Ä |ãUÞ2@ a2 $
á2 D V)á2A2@Aè!2 i #ê0d!ÿ¶@ ¸! 0 Äæúö!ó - ; <ª#äæEN À àÀæ@ `ÀÓæ áóå± @À@Aèõ À ¨/JµR D*+ ÒwJèïY %  % kEPèèÿéq B*  ¤â	*Fô XÛ õMå'ÇF .NC!ð %b7aÿ ì ¨õ b è  )H ( LB" ÿÐ ä (âÏÙ\ èm.ñéÐ ±ü çmPé@
0hó]@!f  @ HÂ'h	`aè- `. D:÷@ X èÂ»ë0z9q gaAå á  #)âR ÎbR@AèS&x  ¹!è
!V aPáM ¤}õ³ !d@^,éÄA @2ièaA@
  á@! á!Û£3 <`à`ä àà D # `)àà-Br@Aèr%Èé5 B; § mâ; ¸  `êâ; ´ % ä¢; ° â;]!â; ¨ 1ìb;"j Hdh\  ý3¼ÿÿé!+ ý ¾³"U§@
ÀgâI@!= Ö/µ ¤!!â P F¼·@'aD 0áD 4 g)áD He«@Aè# ð"·AD  táDNx¡A â/ã }Ft çfFpÁ;á-Fl Há*Fh ?$è{:ÿÿé^ ¨"åè!A'@
 Pá'@!'"ß!' á	''@'a'óá âl ¬ g)  ¤`Bl@Aèå	!' È%F#M Rá#,] a#Ïá"0#B !b , ë ¯<·ér Uð e ? ë
 Ú% èý¾ôïý@#!SÄ^!, > å@`å àå  a)àå:@å@AèO
 å â&íB ù àé `æàäÄ`Ö 4N ¤@'Ì     2@$  @     @ìH 	!%§ö Àgö Àgö Àeö À#Àay |$ÿ¶x`
t ÏPènþ'K á)!j WÿµRö3	¹ßÿÿéÌ A áN0"áã# \`Ñ@µFTÃ# â@¸FX`
@µbF, æ£2#Ù$è¹A <!sH#áè©çð@"<(# ¼ã	 |6.@%+ÿµä CÿP0Fz@bFÆÞ ã, L .) 'ä  PèBF@Aèx"F +TT0$	Bëø:÷B !râ	X¡3 @1À¾øw!l A p ·ë X  \  Ug¾á6ÿEþ@UAêøw) 4` 4!N )#EX0 "© h BÉ/ éÜ-AÇøw@0 d à 0÷<á º`! Â@¨`!àR Å@C  !÷ K  @H tàH N yéq 3ÿBê½4!J@£<hðM#ý ø%È@Ä½Ap!Ý+[ ÿZ\ÏèxôèÿÇO;é7ÄBÜ@<hà èCàC,$`C àAÏè÷@C¸P C Ö BØ@ú<h z èÿàC-U`CCµ Cpø@CXR C `CÓø C ,è»àC/`C X 1 C,ù@CøS C N BÍC À@C wàC/ã`CH© Cú@CU C 
`CaÆ<hA¡è3àC1D`C Ð  Cdõ@C8W C Æ Baè<hpx!ïá2}`C:6@C ð@CØX C  BbÕ5h@;æè«àC4 CtL ñ@?xZ;ëEBºøwDh0A nà<5'@<  <ãí@<\ <3ÿbZÇE&é#Ù ¶PBY"æR7Í>ÿ µ@ÎWè½Ú .kÌ w
ä@FêÄ §/èÎ?2é31ÂþúY 
¶ô[ ÿ$ çO$(!Kå#¢´#3D1%*E° `eÕ ¬$ ¸P|é" c $¦èå@! 7Y ;à ñdÃ K$ a; `@.j PWÎ haè°Ù!å  n3åýE@KèRþé=ÿ5FF  @Ñ :Ø@ã Ayà3ö JÀ!!6!Þ!5Á+ ¼ `a+ ¸!+ A+ ö6g¸û óá+@!+ ' ¥ XÂa K!+5Ïá+@.á+ÔüH¦¡3|Ø@W ¡ ¡Éàès&ál ¼ ¯tál 0al@èEý!l  ÝAl ¼ ÆáylA Ì!~ ÿá¡ È aa¡ Ä!¡ A¡ T8Üpú ÓÑá¡@!¡;Ü ;á¡Íá¡@.á¡ !@ qá©ÒÖáp t ~Cáp_BÝ@[è4ü!p§p P%uáp ã ÔG· º GÇ@," îu$ C ( $aB%ç.:@$|à)<  jÃ^è2%@+ à %3@ à ´7³@ à=K à Æ  à)Agà* àñ+    Q úJè²ÿ:ÿ?!µèì9â@"0£@«Ã¦ ëFý@ iÐõÔ äºB) cà ©ÐbAÜ@Aè/jÊ	AÜucA«ä¶ f !ÛN*¼`g $aÚ aêÆö ¦.Í¡Ú AÚq!ù aâéc fx%Oè`2Mú@
B;¦³ õ * N \àõàõ@1`õÿÓ ` r ^Ã]Ë| `)àõL@õ@Aè5<éÔ@õ'7 ©1á@)  +à Sà rà)à  2xéG  y+×è%gèü<@  ,à  @ aåÒ á ì V) â sí@Aè÷1ùéº(ÅA ìAI o!°á ¦@)  -à¦@ ` Xà) åa@Aèj@ -  _à Âá¦@)  .à¬àËÑ á%¸A¦@bèÝ!  5A ÒAI ÕàF¡  /àoo@ a >àç Ka¦@AèP@  Iú  à
 0àânà±Ð áà ~a¦`Ã! *¼A@hDÐ0â3@! 1à Õ @ a $à l V) âÀ `@Aè6@ ù%g@ +@/&ãèá@  2à(@ `Ï á  V)à ädg@Aè©! l  @/à èà@ 20äô«Åç ð 2@&ò %=ÎZÀGôò^ÈfZÁ%c(# èçÎà¯ äà Fà¯Bã@^èù ¯ ¼Ìî_á áäAá ¯ 4à¯l<@ a< ZàâVg@@Aèl@ /  aà tà
 5àþkàÍÍ áÉà zàß! ¢/uBVÔø!°$èG0âã@! 6à@ a @à ´ V)á¦ cý@AèR@   G`  5èJÿÑ@  7àä@ `³Ì á  V)à @cp@AèÅ! )ÊAº÷ /¾Ý,áAÐ  8àWj@ ` &àá¦ Ór@Aè8@ û eP#vÇF7 èñ¹à3 <1k.ù ÿsýè½ËÿÿéP(ù Lèù(¨ Q'#n DHØ¤  )íE O  mP hè-/àÿ@ ÿ 9  5èØ 7¡@ ÿ dèØ T V)áÓC3@A	èêÿMôd-  Y_^M¼3Íè*0Õå]ã[Â h& ø. Y-  	Í/ ^4 ]G 5 .6 7 P? Ò Ç8 9 i: ; o< \= > F' X(/ë) -+ á øZ  ?ÃA C 0D ,F E â@ cQ $R ËS ±  > pY XT å rU ÿ V <W É VX ã QO ( cK sL àM ý ;@w 	
à4   =ÌÌ!¸aôY ¨QõÇð Â Ì  Vÿt$ñN¨ò èËÄïÿ#§ ^@"
S\$Ul$V %Ë Cÿµø'=ÿ!³Ë¶¤'ÛPÿ@F#j +ÖY@ë^| `¼ï @7  ©  <úV L@ YF1 	fnd$[ä&O 	%üò w 7-Ì]@?\%p ?
TÜ(ÄWÃ(!ÂÂ ÐVÓóXÊ "Ê(Ô( V\Ä ÃTÅ  È Ñ(Â [ \ÐW@f XÔ 4`\Ä`Y /Âw`6]Å3ö Ù   9a&~)W½ü!/ ËVÿ@#F;`'|ß_^][Âa@ /A}ÑVW|$T$aE(&iè $ËèÅ s@À!¨B¤v ! D$(á #   	 ÿÐt$È  6! !Ôà7  $à 7   ¹ 3 ( ð@nÍÀ  # Ds3D$,`-h   $ÿ¦  ÿÄ!S3Û9h H 9l ·`$»fff `á A DÂhÿ  uÀ¢ i Hbt  L@n h@Ü F ×Í ¥ C Sè.£ T$vCp ;`~d ~$ÎAU` [P`@£_^X  »aw HA `¨óâý4 `u@i l  0  ái 8 $à7#e 6 àk < !à3 ´`0  ; D$( x àA @ ' $­ìa5 4 A D@ <[D$8`C° N`3[ ;c # f á÷DÀUèÅ¢!xU Í¶Ø ¤Eâ C
`  BØ§SVA3Cc G@^¸dTY#èOZ@µ`¤^ G YdY{#ÌY¬/  Sè J­ È À»#R > ²DÃ$k$w"6æÒÁèòXÅ^$w^ÊèÉY@7D¤àe °àe¹@-Àe ``àb f bWÉ e$ m¢´`ö X +  C!_^äMÌÌ"Ý a:a5FÄ <$DtF$7u~0"Ì âÈ  `Ù\Æ@m^#¸à3@&táì  açÙAé @Ä#f¥ ¼ Cä ´ &à £!2 ¡þ& æ'] ØæU@^FæZ(ÜTÂ @!¿\Ù(Ã"} \Ø] ¦] Ü  ¦] ¦]"Ì/ÃF] 2 ] EF7è å!!áª°   .¡ªL"Ð ebòÂ  F ,À h nÈ!ÂñbåãV)9E"ÀGö XÄ & ï¼h¬   ' \êÿÐÀt[  ¸  g\<#_ó_Y@ p ×8`YCà@[Jè@/AK /¨aº ] Ø k¿¬ Xu>®$:   ð 4 <üøô #öÀ T ãA!i	SUVD$éP 
PMUè5§îÿ)I   èÅÀïÿ)9 !	HÙ[<ø§ R W:f	h EK'Ð   Pº7 ¹@é! C%T¡¹@%ÏÝ$ÿV : (KTZÉ  X$³Yp§"oZÄ 
 È`XØ]Aß ,@%KP -OD `(  Èà"ÁG@%j[Ä#~ `à/  C"FY "=é]¼B°@ H %ñ	á C@¨aw 7/Ø!=À© àIà
fL ~KDè!T6BøCA¤à?C\`MCYaà<Û{h=Ötjëj èñða`lQÏc ?  pà   ¶CiÏPè± à
ÿsdL$$è[ßà	g f "´çe   y @ ñ )oFNWùVOèÌ;ÞÿVÒtXÂp@Éuù+ÆtHÊqAÀ  Î#;QRPè»Ü ÄO Pè?]A  Ét $¥
j+ÁPQèrÈÿ "_^ ,G G$À&#à  &ßBÁèàh#s  %7-` $à 2|'w\ Bl`p  bàQ#x"#î,þ 2$C`Æ¸@,`0  Z#k ò# à#%D$%>ÁèøQGöYè]#¨É   9 KÇ I LIGIu`L > ¹à> ) Ù E  w@]H#= Þ ¥D$C T @2Eèåÿÿ!NÂàë@  VIVötB!øw9| W<u-¹ÌK#u
Ç@% ·ÀÁ!5D+6 PèiN w!®$KÌUìjÿhPÌd¡ . Pì4¡¤P3ÅEðVPEôd£   .]
MNù'!Hÿ$Pn%)&q j;7ÿPhe5MØè>ÇP 5  QÎÿP  èÒG éé  6  @6`6 P 6À/0×@¾6é À1 hà``1  1 )  ë`R  ø¤;` ý=`  ® éq"d #=*hX-`# Ù#,· éMà#ÀG µ#,V é;¤ÿ3Àù52ÀP RhD¥r *) éþþ *A Àr # f#8 éÚÀ#¡D t # B#9Â é¶à#  # # 	@# à#  #ú<a 
@# nÀ#¡& ¬ # Ö# @# Jà# Ä # ²#>_ é&à# Ø # #R'éà# ð # j# @GÞýá b@ ¦C F# @# ºÀ#¡   # "# @# à# < #þ;`û @# rà# l # Ú #âu  +uë-aº v `.Àè« . À"Ô"z À. À "ÿè*ÏGÝ @Ó$MôÓ837ð3Íèò÷ 37$Æ k H  z    ¿  ã Àl 2  V  z   .m R  v  Â  æ  
    ¾  í D/+ ñkäT   ¸h"UÆ`"£ à @ì (xp3À`8J+
÷Á@â~+
9@-u;ÇtÆ@K  * @`+Áù;Á|ÕIå¯eK  HzWÒ/Ð ¥v*}ë/Ávk-E /1þx#Âvó\Á¥H(#=%½X  ë   ¥]$ê (%ÄX %} Yð(ú@ 8  + ]l ] [¬9 m ¡  O¸&f%¡*þ%îèzK)ÀÉK&&@EîYO¶ °Jê v å@	|$ a +)~ÈÔ XIú A L ß Ê 5flN\@û ` ¼  ´ ¼h`Ä^È! Â` XÙ´&@A  PE(3P¦o^@ ®¤   _,²¾  ë  ¶C\û È`ã 'µ!J AV(Ä ë,äHkðYÏ  E \ @ Æ  tAB ^ (1Ô(Í  !@)@%Yó  ò   R&ÿ* XAa Y +^Î   X(t  ±XÁ!`,;`÷ú ¬d`ÄA0 y ;(  gE&è  iñj 3á ` N' -$è^@?;  (  @ "&@ à<`@®Á(  - AÝ(Nà A ÚÁ~ ¾ÌNoÁ\Ø  ®¡~ øag!y ùám(!: sÁaX(üAXmA |A Y!| rð(57Yl@JA Y!æ@5\ê A´ ý Ab3a ¼XñÁf  ­X÷ ðZÆáv!fIû ÌAW"ã Õ ¦cæãÝ |!>ã&Ý !û!i"öãÝ p ] ¶ å"ÂcÝ   à£ÝÃûãåGãåCRå@	#å  i"Ç!> ¬ºcå %B P u mÃå   aç \a Óãå#Hã	å`Æbq£å ü a @!Î ¾Cå!   ÄÁÝ \%WO¶Ó\ô  ¦Bu(é!c£Û è Am(Ç!CÂ"/ \#¬ ^ !é$Î Yï ò ( ^ ( pÌ@.Yç2Yâ "â\á âj%=Í!+" ^ â n î èZÅân@@B4 sc­^Y£ã  Q#å bxâ â !â& !­!`â1  s û¢Xt !¦â
EâA¿@	"  K"#ÿâæ o TmÂ $ Ma Ûâ!Ùâ&Â"0!m eLu rb *Ëæ	{(ð /$%@' \$Õf¤ýÄÛ$þBå Lm"Î(ø AyCYþ " Æ`"@%9$îdèÀCg =!k ù 6'· @&mYË |'t ^æ W ! iÀ&  ª  æXøZÇâB@ fes Es¸  @ ( kY1K V x#nE&X    î ¼ø+)Çk  ? 3# ¾ +  ` _@Þ!\Ta3 IC Ul®^ ' FC¸ FXw Ytn4aÈ;ÈMÈVtÁ/^%ÿ 3 ¼*,Æ =*÷#b @w$à¬$'$Ç( @ ÿP|KBÿV{^Â ÌÌUl$¤ì\.tàÍî tì4 2SVW®z Pîv	ÁE4}d°¨<ý]h¿lø ÇJâÂÁøç  yOÏGDD¸EjÍ04M8u0uè÷ñÝÿEl +´    ;ÁtPè ÞÿMLèñS MTÆ.è  ~M ÆE  ÇERs S    ÇETä }àuä]èè{ø [ x 0À  EÈ»V Mlt}| u	Sè´ëÿÄ3À8Etu)3É !`fúútAÀ0.d|ëx ë3Àÿu|MhQPÿupE8ÿulPSèiôÿ@bÄ¹OÀtB¾`Ùu#Ü-ø-bDÁM4Pÿ³A9ÿ·AHè«Së ¯hÀþu t.â5/Ù 
øuåMHÆE 1ô}-¥øÿtrD tlLLó¦ðÝÿHG4Æ/Ir/Ú P Ùßÿ 
	ËßÿÀu@6 P!è+Þÿ ^ ! =èHÞÿ} t!y ¸" é] e  !Vèøÿ!è®ù@8è 6 ¸BéÅ!-8 3`b¸ ßÿj!Ñ  AQÈè×ùàÿÿpET 
hàÄ;Pèbàà!  &è§@Q @? è¸@`(è ïS Öj#   >ÌPèj ò)Ïÿ %7N3èf@@B2ü	èj® R`LèJ`8èb U ¸%t é ®è3  / 
 6è7 2  @2 `8è/@2!  éã $ÿÿáÖá  A @áõøàáh@Å@áß áèÅ Y @? 1èÖ M èîàá  áÿÝ` `á  `á @@`áèá p`Lèh`8è UXU é4 ®èQ  mé ¶ a  ¼   @¼ 8à¼h Å@¼ÃÞ ¼è H@? 1è fMèaíà¼  ¼Ëþ@¼èS(A  ¼èÇ`é­ý/° ¹é0±ü `aTx ¨ h @÷áWhð` ( `)èj N@E 4è{ MèÃìà   -`èµ'@ ` ) @ :é@ éã èÀã p @ÿöàhHÆA8Ý8`)èÌ  @E bèÝ Mè%à  ýA;è` `  @ :éq0è}éE` ÔÀ E  h @ aà h `ìÜ @)è. N@E bè?` èëá; ! ñü@ èy&A;  `í`"éÓû N ß#é§ «ÀÀ§; ` $@Ãõá;%hø` NÀ@)è N@E`¡ Mìèéêà &  S`ìèÛ%@ ì` O @ :'é5@ A(é	@C/ ÆEÝ$ò@Àpßÿ%·t@ ³`t@ ¦`² *¦^ ^rÀyè1ÇA@@ë@9`}}t \,B3ÿÇEt   à&6âG_Ed2
udÁâÓº$µ	 u<ÿu,(2P| F, +@@I ë@%²@ `G @@EtÆEtÿ|u0»F±  ¨ [A !u'FûÁ¤&ú@ÿ<ÓuAXºèAX¾@6u*ÿ¶50jèJì";uà4`Y&ø÷AX 4itèÛ.'¸`J
t	jÿËèÉ!®  !Ø*è}
eBLè]`	8èuÞÿ3Àë/ $+ë  ) 1èO - 7`%Lè/`8èG -f÷Mô <3He\]Â  ~~'  |4;} º ©{ X à °ê` 8&Ñ3ÉÀOÁA 8*9uBWºA6'Ê6V²A§ÈA©F;È}+·@ÆÆ²@7^_BXÂ<`EÀ`eà *+WX" ø$=*U^ÁJ2  Y  @P@*î (*»,Á8«:MÂ Áà>ëÈ[,o ^*¶: M < DYÄ`h{¨à hsÖ ¤à LrÂ °  Â0Äà ì+O kKD+C2=tKd]Ú ó,9T©.i/Á{"¾H tÆ\ ¾ðJ Y#' H"+ @1(+<ÿP, ^Ç¤   Æ`- P /Âv &a5 +.3@@ZÂà+La8^@:Ô! ú*S!7óæÉÁèmÔXÅ^ZùYÁè¯ä - !jRå!¹ 5À@TÇl Å  Çx`	zÄÇ| 	 ½	@¦ @{0 ò"mq Î2Ò¾,0
 T$3ÒT$!:W@6úL"t k×D$¸Z¶ ti¸ z3ö+¸ Ñÿÿ~QÆD$#@¿pT-8 Â$éÀ,@IâJÊBLLèæy i.D F#;÷|¹@<!Æ"Þê   þ ´gÿÿÿ`¯3À ¹@[4¼>À*@¢]>¸ 	=HN!; @ýQ-Ú4,ÿP ) ð  t">è 	$F  r!ú a¨À+  @`â@À@vø0|Â% ú H G*T$#_Ò(Ìê3`Ûèñ$M.y âÁ j!Ý q è/'¤Ç¸ å¢é zÄHÁDd G$döt5d	À$3DÏ7Ù "z  üÇ7 `=$$T^$%à ãP@o3Ò"HÂ@`0%Í!F !0³ t@W 9`~"U $4 àN}Ñö ÓS¿Z;ó}Xóö~BvDôÀ ;øLøCÿ;ð} n uàÀà Oø 1ß+`#<_t*¿BN;È}4IÁæfD  ^vA\0ô@!;È|íÆB[^Â`õ!ÍÆ~!y@ 4@BÀ 8`À <` À @`? $À D`Or` H`,À L` !IÀ P  Âç:%#ÙW(»@NÆ`¶³@ èZè
;þtËÿP&a¹@%¾$<$Ê_¨$ó]{(Ñ% @üu"$¨ Æ`É &YeXt` aSu  p Oà /X ' a.`õH 4(t//L%$r  9¬/ÁrgH a2 ó3Àà 
@% d / %à"Tà  $#!ôOY´` ¶h X%vV|%b³ä%&O \óâ'1óâW&ä.òZ DYWD[vg vQù è6 X Yàgà	aÅ0àa@5 ^ À ^ ^GV T<`^tF (Ô/ S¨sÌ^VZ ó ã  ¦ ¸Õ %g  û 3óÕ(8 x×! ø® ð %"" 4ÓÖ Ä ¢ Ü  J \  ^Ïó
à! Y3úø¹à 4óÐ xËØ×øÓà  #ÑÜWÉ!(V_ Ñ\¿ Ð\¿YñøxYBá£ XAÏ ½á	¯/á£¯A£!á ³á¯S\$U½(E  ¥VWs¹%UFø Gv FØGàFÜG `äFàG¤`èFäG¨`ìFèG¬`ðFìG°`ôFðG´`øFôG¸`üíuÁØ sIA¸ BAüúrë_^]¿&2[SUV%3ÛiÆGù3íW3ÿL$ÆÌ @¿ Àþ|GÆþÁ,+)&îF6H7ff&_¿pãÿÿ 9  ø 
àÆÿÿØîuã f  (w ';Æ}iÀ@p¿¬`_;èÒ~& ÁàÅ¬·   7$ @êuö@ÃÄ¦÷À  %=¬!~%| "# l V(Â  +[Vù#ñ6  ,`#  (`#Ï  $`&]  Æö L$ÂHÐ . 
` (HO`BL  ^vsà  f' #³ 5{V¾_*½öÂtp dYÒ ÈeËXø`	,Â·Àf;Æ~
 %È£ë(f*{ Có+cÀ[%K \#÷YÅÌ5£ ¡XÅÈ`ì ¥#" ]#*F 5`]=l-ð öÂîÙ+2 X ËeYÆ =T  k Ø  ß f Ý  Ãà à Ùà@3 À  YÄ w hÍM%hXô`@¯ , ·´"|àeá(Y8¨HHÇ ÆhÇ` V !tt bY°'¿ ä`AWXÕ@à3à ß Ï@×  yöÂ    TFg`YÖ !pX¼`AY× àJAdöÂts "© hÔ`|Xì`á aé &"x!:WâH6 Áç Áçob È J7á^Â Sÿ=ÉÙJ#@@ÿP@O@@[ÿ`U$  ª°!FjÀ   L@!z$BÏ -¥ ×Àjæ@¡J,$Kì$ ºÅ J#¥YÈSÙV #L$xàª­` $ *"L Y! ¿ .   L "^èÏ' % 8$ <  @D$L2` À Æ;Ô"u& &Cu ÁP:#u X:-ä @8 | Ú|¹1 =Wì»@Äó¥`Zò $ »F	` `-` AP$E¿ó¥)\Dé 8Ù, P@*D$H z T!;À` X
`	 \ 0  ¬ T< æ"°D$D`¨!®lØ  	!&  )D$`@ 4.j` d@ 0À h@ 8 Ü /_t¼$ É uËèáM Ø1Wí)ð3ÅÆ  5=|H(Þ*u0}À#=Pn   à .k¼ ¶Ü/$L+¥v/Øv  =A»(Ýë,¬À Ó \`# 
#]Ô Y>}*ÕY@rqDÖ@\Ú üDòXÙ %d  L8 æ/Ì)Ò	/àwD(Ô(ì 3 Ô@àa"Ü\ê  Ìàe%àXé  Àe\è!ÝÇO=  ? gh! K»` 
1® Dd|£d ZË!r\$P X@ (> Y?¬ ÿ`( ` X Ü³\@ZÛ`(ï*a`  Ó 0 é ÑZä(Í l$, 4È!¦  Ä d$$ . %@Zöò\C0l$P  C $Æò^á  LL]\Ê > È!³  Í »  Ä &÷@  ' Ã #@Á(Ë 2 È`@JÃZÝ 2© T X YÃ  \@ \`T  L Á@WXÏ à [ 0 [( -"@ ^\Â ) T@¹XÆ@~`1à- 4à -?¨@n .XÂ(õZþ 8a` ë J \Õ D Ñ@´à r 8 D  Âà < !sx   
«t 
 l !QD$$ZÆZí! s »|` Y,µA Ð @*(Î a )£p )aâ@tA®$û!®!Â!!!K e-$ ÞA
 Y"tA³Á Î   $ Â ¤T@X@0 X 4á Þ !" X ¡Ala F@ÀN D N Æ Q@ Xa;à( ^ !&Â(æ@ H`2XÕ D$ L Å 	L$ Zü At$(bÕ-è]B  X îXt`+@b!(\Ð ¡à  L X à¢ P !¡± XaÐ  BK  B¯  £b-Oe  2 X`Q`ÇA$ X"@ \#ÑXÄ (@þ aU@@ÛÀ0 Z , ^Cv Å a{@iZB½à @ZAgà @@a©amà @@@và@@à à5@  DFN!+,ÂLKà !+/CúÌ!z$ö(ÁNÉ ÂNÉ Â&v3  E¨04 1g² 0v)$ÚÈÇ0 @ ! ñ X+\,  ( ( (ÐÇ@@  $º X+h@0 ,`H ,àà& ¬ là
 < @ n 8  z4  r  @@  à ,`H , À  m!aá? ° l 1á? H @  á ? D @ @  r  @@  à ,`H ,À  NONNWùöt~ t
~ u³ë2ÛG3Bu(*n é¯(ö3OuW@Gc n(Ût+Î@ÿÐÙ\`, 2   ÿ Äés AÀ8&{`/` Y |¸  @_Q) @`) ? F  mY?I	 c u"|Yô"àm ¬ B® 1  L$m/Áv:l 'féê A+]ð : § é×  ,`; $Ä@©/=	ÀtQÇ$  AÿT$     /D$  i@: 2  20 ²è¢Çÿ` + 5D$   ý S @4 Y àY  - `9  Y`" a6ÀY¿¡ YK4 ¼ / I ] O æ wN t " ^öuÙ 5O Ûuï" dGAºe  9 ÔA¹ Ðà .Ùîà 
"9  Q!¤P3ö02ÛWø=   rð3ÿæ9)øÿÃl! ÅâÐÕÍÁúá .yIÉADD9$ üT7øÀt! ¦9xt°P*]t JÀuß Xø@t, .9¸P ) 1 T@9¨\  u 9 Ô#/  9 Ô02À[Y,HÎ ÌrV±YÏW»@5Ç`´ Â:Cç¬	OÏGt!¥t¾è WúJó}TÞ3ÉQvf¸Qa ~7f8 ~0f¸+) ~! 	Qu ~Á@r @ ù@@|ÌëÁëÁëA;Ñ}
ëú  [
Ç@i@  `	-Ú&=@5}Îè4ïÿ¤ T ä *!¶!í!#ÅÎèé3ïÿà õà \ -á Æà õ!AæüNÎF||·-ä!© 4°ì@
 _ ,YÄ9Ïõ! ÿ\ <ÿ Y <È Z 	t-}8 Õ 	=Î È ÷@Sÿ`Y{Æ`5ÀPt	 uR» \uPt
èíS$?Äë>èS¤þÿ 	¹à¼è¢t @	è« Àf a8¸!)Z ½_þ/é M  Qt
¡$$u  }#	è t6èt u,Ç\"Ç` 	0ë*  `@@  @ @ Ð#qwI!æ*	x-"#"a Ð /Hb»xkÀ48ì ÁX  ë"@ ÿ  ½  t@¿H!eÌ Ö);xg +)³ n'æÉò,ü5èÆ l)Dp` ò(Jëhà ·D JfÒt. V < V
+È¿Ò;Ê}A-°nÐB@2ð Òró^Ð·F -fÉ`9 > +@¿É;Á}@ 5 È< 5 É5(n,·@ -@s3L Ó¿8 @8+Á¿Êà> B ,à> :  °+H8 ³ v Èà ³à}!@ùn%2  L D    YE] @&@ P`X`'_ºî*% `½ Ä t(Bo"Ç=Åtøt
øtøu!É à %!ÈÿN 6»@"1]  ~ *`  B; º y Â+}&`}+@@*»@8dJ`   `,=« 9`~à e»@ |` ë @I
÷Øj j ËØ ÇÜ @ èVtÿÿ%Z°[%Y %c De%0ÇA@%6:"ÂDÕVòæ"&$\üFt	0Í  +ÆÐ^>Øé¦Óþÿ@=ÌÌUìjÿhÎd¡ " PVW¡¤P3ÅPEôd£  ñEN}FEÇEü(N ~;ÁtPè×ZÞÿN E$ Ç E8MF4E<F8E@F9EDF<EHF@ELFAEPFBETFDG~LFPè¶èÝÿM$è® Môd>ù	  Y_^å]ÂP`ø  ìt¯ Ä'ö p&¸xVWù D$ 4|$, @èbVëÿi·Ü I B$Põ " PèÅ7Þÿ"; )²ÈÖ#Y
WÀfÖÁWoí´ ; 1>Pè7  7È7à87õ í1ºR[ ¸ @ uPb$DüìÏ"È'ñ"ê$ $`H/½ )ì ´`.è`2ôÿÀuÏèµ£÷ ¯Æ"²B A I*ª `.$ ÂcùY$E©4ÊD¦@(Z$ Y$,Á+Ð+Ñ3É"4Âbê÷âÁ÷ÙÈQèí¹ ðh )Üt$8èÝ D$,èÏ  dØ ÕÄ#ê  * 8 Çã\&=ðT©LÀD/Zv[ ªÔ ¾  '$ÏÁ3É`y-í OD$4%INþ0+ ðÆà Z tµ 8@<Qj!¼0tV@Ä ÉL$(9Aæ?"õ" @ 9;GÔD ÈèJs ) ( 4þÐ"% )r4À~T|$0D$ Ï  P$ÔPQ /   ÆP <Pèï!t Ñ .%ÝWÀ YK·F;t$4|À K #¤<|!'Ý0n#< x,3Ò  4 ² WZs ` ÿ AO0r|$h!t \  X¡X!=&F "/` p n@Hÿ T B xKlë TXA"(``LX'g`  Dà $dXW2Z÷/|$ ßX5B\! Ç4P";ØÈ!U`(7¯Pß Î!ì`" Ê(î(WÌ è`à SÏ2¦ÎP¢@& #à 0knÀ! 8@í  ã0ø_ & å 0µA 0âYulY%È]@v X ]B;ÏöþÿÿAUë@Pø3ÉÒ¢!ÿ	úr[Â% EHÈø@((=+Ð(P'"®4tY# [ ® Ê#E 3M  DÀ  $";Ê|Ç!Ç' >!x"ß ä P@!d"î ] ´ Ò ,$^G@ì&÷ ^ A EÞi¤ d"#L$Dh 2  Á ¤&ÁPèC"ìD$LÄ$°BË¹÷"Ë"å Zî,(k!+$P8LBä < 0ÿ°BZ$M    XWèýÃ@;dÄ$ M #kGs   @ |@#ÿ .	$ÇPè¾ ¡@ 
ÿ´ J èÛ(@%<Äe!,3Éë ½$ÈJ`ÍT$D& Èh ÓÂPQèp M!@lÀh,D$XPèS `j I\ÿ´`n l@neHÄ-ßà!j  M!%á7ö7 ^(D$$  A"Ô(;>Ðûÿÿ ÷ èî´A  èå Vèß  J D	PèÎ  NQ! ![å'Øçñaìx3À_^3ÌèA$ãÄtÂ&è!ËLBñW~$ÿ^u«Lë%8o'ïÿ~Pÿèu+nLë@+FLè«L¯ $ J $ø»@»@÷ßÿ#ý½% ×~! 
Êá2IÉüAtÅ+ÁÐNdF¯N`¯Â;ÈË@5	NÁ  t% $¦PÆD$èý?èÿëÆFpVF@4  !
Fd¯F`Vd9 t2F\"nL'PègÏÞÿÇF\ YAW 1|À	ÁæÿF\ÇFl  ÿ~Ç`¯Ç%®#Ãü@t+èýWNXèÊÊþÿà  à  è\  )@O° Ã ¦IL` Ì  
SUé3ÛVW½¬.þµÔ ?,Ó@÷3 -Y²  §F ÁNPGò	è¤ÎÞÿëèÄ²AºÇFi# ü# #   #  F	 FFF() $) V) v )F( ) * 0$ ,$ 1$ QÀ$ 0 # ¸` fÇFD  ÆFF ÇF4  fFHSÿµl ÎèØÂ CÇÆTû"æAÂ ÌQSÙUVWK0üè%"a{$ è|+kL3ÿ³Ä `~4¡KÛtEË@DÿÐ'/~h $FF`#Puj Wè
" QÈÂB8RUèÒÈ @;ÿPHèGÆÿ|¦@ Yá ÌÌVñj Æÿ  ¸ï  j/r¶Æòÿf¾K/u"p>(ÐOëÿA|èF .  3Àf@$Opè¯D   =D½	~MSÇÐþ  "D »@.dj	;Ã~3UW®@ú!ü¾û Aü"¨Íè£.òÏè·t)CÅÇ<;Ø|Ý_]["!<Ô R"=Ô@FtÿP4Ç@@ Ø!jÿÇ@@  ^A~#ï CïÙ3íº ì  AW1é&Í FG@É $ºÌK $V À/-3É+ Ñø#w  $Í *&6 f" `¿HÍÁÀyÀÁø³@Wá$2<1,t!q¤ê(éÑ oP3ÿA+©üÿÿÿ~2¸$mL@'tj Ý@ ùcÀ2 G`1Áø;ø|Î ÎèM`Vt~j jÿ@.j 1gèäÃ!ê   !»> jÉ®!6 ¸ Æ 3ÛfÓÀ·ø ÏÃÁøf¼F 5tàG!²   CCfÑÇÅ¨ 8·ÿû w h [oÏ !\b!O APA3;L$ %ÿ(E íÂÁú@Mr@ A5C a@2~ ~ \ `ÚuGÆ2ÿJ|ßBàÄÃ} ó ÿ A,E­ü_  À""þÌS  #
SéèÐ¾êÿ»äB±o \Kÿ ½@ T ÂAÉ|¿ "}!O$ 
è¤´t ÿ@`4Áµà6áú Saùd@a Að !ègÕ   Ú2S!dKúìÿ`XÀ~H`
%Á} yjt@ÑN² ÿp "¾·L$à µÿtà fÿEt¡ '
QÒu)A$Sw8Ö" 4¯ @A(è A,ì BAÑÑkÀ4 J0â R¤$û óãFD|,iÀB $¬^úÿ¼0Ô ÿÆ0 _úÿuÆ¤$cÿ0 ;T B uATÈ 	èO³$r`; ? 0gh>!   ¹@"ðÁ!ØÆ 8  °Æ    ¸!Ï A!í#ÿ¹  ÀaþÌSW) 4>'¤¸È-l!WèÃuîÿ¿bV* KA[!H`
Aéá bAd"`
"C·Aqf,ÍHf A~ @?")dà Gâ) Wb)ÎèPZEib* B6
W	ÿIè8RnWèZ@`âLB¢  "I`
bIÁbÃ !n U®,Ñ *À4iÈAÀ1AÀ 8H¼1aÌuA½ !`
@ êSÿ4¾ ·@¾¤ 
 u>öF0t8¾@ /~, )`#ÿv"¶SèTÉfÓ
VèêX V4$µþ&îÿ#2& %@g è | @@Àt#\ ¨5g	PèhÆÞÿWËÇ`@ èööCTañÉÿÆb2bEÆB5 b5BS¢tefFï éR?U3í¿è"5 v5·(  4nR#XtB8HÈÁù÷Ñ#ÈJ8¶@/EÆ;è|Ôº3{ ·  ®&m ?  Ù'AÁø¶èýu	ègL %(	ýuè'ÀÆ1:@;uÇ·bL ÆBFfÇÁù÷X« U]D°.ÌkÉ#ÃÃ Ã `! ^Ï`x É!R@­ @@@@9»cÄÀ) @9»Xë@@!@ Ç`I@  Ç`@ Æ ]`B ud$á£Á(¯;´@AöR ÎSUWÿP&jÍÿpèF½"É @Íÿ0è6 3Û3ÿf@ > Í "	@ë3À;Ø}ZÀ	Íÿtèÿ¼t (y t QÍ,D:À-ýèÞ   `2èÌ )ûë%~j è»  ^8Í_][@,ïìºè! Ã(WÙf'l¿ º$h *¼ HOx, t9
tBÀ,ú|ì$æ[Ãrÿþ}okÆ,¿$á +þ@4Ã÷H,@,HÔ·HfHØ    Ú    Ü  
  Þ   àHHäHHèHHìHHðH Hô % $ %øïu¤ nÇ@i@ éM(%Eà Vt$Q*`¿:0u@ø|ò°I2À@3M(©Ùès$'¥ ÿ(ÐõìÿU3Ò¹I  V"Ý 'WO×,½© ð ½ >3ö+½i ÿQ°C¢!ï @¿pT+!ÊÉ)ÁÁùIâJÊBc;Ò¸¬# t	fÇ
ù  ¸°à  ^  ´à  ²  ¸à ú5 ¼à  Z  Àà  ®  Äà û5Bõ} V`F;÷2!j"S $1#ø ! !ù1 àI1c÷ËÆZ"B Æ[à ®à ¯à 1¶à 3 à Và Wà ªà «à þà ÿà R$ùà g Sà ¦à §@è	&"*¿" ®+a_3É^]9Le~ != Ç!.#5@A;`|îÇ,»@ Ç@ !@ ÇH 	* Î
ì$Ué0&e µ@J$üððÁ^]Ä$Â SWè6$9D$,Ç @W P  4@
è¯Ýr Ä4 M&Ç,Pèl»rIÊ N*(Ü ~è{ªt  = ( e(P /åè8èÿ¨ò |@ý )`4ÇØ :@Ïè\ ëAf@E_&ìJÿ P*2(÷") uîMB#$ è9à Wè. 
j AÈ+jcu5 "] (C?¨ò+ Û-( 4,R0,è¶Ç( P£aX×ã_`9ã_!, \OÃäþ p/d/C!{É~¯ÁÁàPj ÿsüèªüOú3í»O" ï.7öJ7UK èyû($ð¨O)	_ Ûu3Ûö.eeî;ót@
SÿP+ýEÇý|´ÃHê ,° `oCr £»l* ~4»h`+@ £!@ ³ à­³d %èùû`°ÃMp3í R3ÿ¼, J.ó¼$`		´`	 ë. U"ä¹ú`¿¼Ì '(@ð@( `	 ëàÏ  ÎEÿ`|3C !.¸8+ á'`fÈèbi05á& IÁ& µ!  %å,C" 
è©Çÿ'z $+H;Øëý"~"<ï$§ÂJÄ¤ « 'S 8'Ñt
'kP03ÄÃc#$à(Ué# ú?ÍBdbL V+¬ (Y |9 W·@	!{ ã 'ÄC¬#c "kr'C¡.""ðÚã¡PèÊ·c¡ 4#8?cÝ ) ; 4 _$D$,  $ (Pè»-èÿ0§ôÕ! Tà vcÉt)i ±IIn3 ; P uH<èó! Î"­ ×­¾«C( 8 îìÿS3ÛÏ!XèPeÉ "îÃm!8Áà4BæÔa' æÔ ) Iú l#s l#iÝ!!Ç3í¢ ÿ q "vâøâ4â âÂfâ$ã Æµéy Ü3ÿ3ö@ Ï.4!?Co.,`		`	ë3<CèE÷î$Ð3YÈÿR+XGþ`|Á0z µc> ~df4o u@5!ª # à1Ó` Ö!U #	 C¡Ä}C ?'  [â ¡i *Ï¶FVNF V F 	F,
FN	NF NNVFN^Ê` ON ,	VVF F N n =@ 	NNF NN@~NàZ` à$_@E  ^àE? ß@}@è N@Þ å `å
F
  ò òî   ï   óN77 ¶@¥ ¾N^Ã_ àÿ@  þÀ/ @/ a/	VVF \ ÁA"!I!FNÀ<  à$?aÑ ä  õ× 
`ä þ 	 m!× 
ñ AØNF ! à ñ@èNF 	NNF 	NNF N"F NN`ÁNà Áà)¿ 	à¿ Ì"á±A&A´@dàC_!¢ ÑáMF Z ! NF NN`ÔN@Ôà à)ß!2á(ÿ!å!ÿá åàÅF Ò # ÆN F  	"N#N!F! #Y "â g £YAÎBs`ù ïW3ÿ·V·#	¯ÐÒ~RF?¦Pý@#ÒHøGPøPöHõ 	÷P÷PùHö 	üPüPúHù ûPûHúQ N QÑ;ú|¹_`l  9/ \3 Ñ,çÛy4æ Y/MD$U+ëëÃhÑè ÁýJ¶(/L©*È  *¹n1tT¹N-+¹GIÑÿë¿& 3ö:û9 (@7ÃpÅGaÈëËjQÊèvî+ÿu fF X(¬;÷|È%Õ  	°`¤ ¾Ì	ù~ù|3ù|~ù m|&ù£ @ ¥ |Y*møvAéøcv2ÀÃ°åÛ@ tòÀþ;ÈÀ@ÃD$à@%à  / c _Àéà/àà+@ ø@¯	ø|$ø|~=`®=`­=`¬
 «w   ¦@9 @à3A|$ °U ¿? ¿  ¿  !Oø  `a1 àà! ¸*L Ç` Aõ5  P @h  Â§` Æ  *à  _SV±IîX,VuU*üWd2»;@u=J;@u)¶¾Sø3Àÿt(t+m¯
9Yt@9 ;Ç|ñE¶J=*$
±_]^[Â @3*% Zï D  ¡" j V3ÊáÁúÓà2^À µ « t#? Ù>ßÇFMy r"ÒÆÆ i~ÿw8=n!µt0s
Wj6jeÈÿ@1~rKVÆ8 è= "àS >  V è(à 7Oào!w'`o!t@o ! oõàoÀ ^{»! ÜÏèÂ0¨Çëuð þào 1 o 1o 1 o àoSL@o Rà0o A o Ao A o ào"`o â">à-ß Q o Qo Q o¥áO f`o r à-o a o ao a o 5ào!F`o à0o q o qo q oÅ
àß"`o !Xà+ßÿ Aw,"¢ =@	t"sWh@	 w Màw2«4oB9 ày ãÿ I@	@	 Í	à÷ 	 5 "Âà	ù à ¡ I@	@	  Mà 
 5 à6 %@	@	 ÍàÿDÚ $2à3ÿ ± É@	@	  Mà  5 à6 Á I@	@	 Íàÿ  5 !?à3ÿ Ñ I@	@	  Mà]8 à6 áà @	@	 Íàÿ  5Zà3ÿ ñ Iÿ@	@	  Mà  5  	à
ì ¡¤P3Ä*BSUVÁ½ /*K0W  12t$õÿuNÆ :½À@ ÊvÿáÀê0*ÉC4ûrÒt9grÚÇ÷ØÀGÀ+è(±'ã|¬3u '¼][u3Éë69¨A*Ðù+ÊQ  2çPèÈSÁ3ÌèTÄ  (Iä? ÆkqÐKfÁúüe3¤<^äT Ù @ èÃ@ËÃtZà @[´IY
íx5;è}1WU5ª>T$  2ò÷Ö#ðþú#ÂEþ 6m a Í|i#  ¶à  y;OAëA1À	x tê Ç	3À8At9A)?Ã9A@à =!¿ y< 	@E uà 3à y àSà Ô#(*¡|ø}àC
UìjÿhVdEr PVW/ÅPEôdK ñ¹¼xè s ¡¤3ÿ@59ÆdJ ÿv¼è&ÿ ÿ6è@vDè@¶ :è 
`3vG@Ä;ø|Í`NÇEü  
 èÊÌs Môd §  Y_^å]áV¾»[ ¿ev f;ÿ6P<Ýó¦Þÿ^<4ëþ¼9Óèþ+ëÿ°¸_5+4ùP$5´ +J #a	¸ÝÿjVèÃBx¹Ì@é¶s `¤è¬ 	=Æ /
 ^tèýX Æ`£ ¸${ ¹È 49¹üºèHmt ¹Y{è.À	Dð6 =@ Ç@ 6 	  %  t:ís    ò  	`0  =@ &@èÆ`& @  Ç@ 	 ¹ðtéøsâ µ>D	l$óY-P%=@¨@% TÝ  5Ì] 
(Å(ÌWÃ(ÕóÂÄ ÈVËóXÑó\Ñ(Í(Â 	 Å -p ; $ÃTÆ  Ð Ê(Á f \È ` "\é ìó,Å.? k L@\Î 	$ =u?WÒ 9/Ñv `ë/Îv( VY&@²YD§@nXÈ@S c  M Ù ÃWÀ  U/Áv7)  @Ø@> Ø`4 Ã@U ?àC7 Uc;ÎÃì´'^£EðVWãù½@8_uE?¢Mµ\ p 97u;Gu G.ÁöÄD*¡G ²/Èw *DPèVBAE3É`D º@ÉÇGBö GÇGGw 7 îGà#5G¶Ü ÷âµT M
Á÷ÙÈQèü`PGx è«èÿÇ@
`F;½@{    Aû£a)P.P 0 Q7fnØ `[Af$è¥B@6 #EÜò A  "XZÀPQÇ$ ¡<J È6~
jj ò^ÈfZA¯À èÛêÿ t`= 5È"x M!å!ñ=Lañ^È 4 ò" À#= @ À @ p Ø ) "³ ã"
æ/Äv/çv  %@Ð(ìëP(Ì VÌ("À YBq Ô  Ô"d p"|  Äà 5 `B¹Xê  è `m Þ/Ã"§/ßw=(Ë , Ëà] Ó  á  Óàa Ã F â  à Z à@R ¨cC ^ eÜ #X} màZÐZä(òò`!i üò(!m
YÚZÿZí(Ï µH` \  Æ ÅòXá o l (Ç è!e Â(Ô , Ð, Ä , 
 3à   j\Ð!Õ ZYÇ }è t  Â]ä!    X @­@,(Ê ÊZÛ ! à 
  YÃ  YXÈ` X   YÂ X@ 4$d Ë  Í  ï U=È#ö  Á ì  Ø  ¡$	 _ ^$m`íb$ Á * ¯A@
ðZ é`
!VÂW5 ©@U`!e$@ À#YUÐ > QM", \ Ì #  ø Ð "¨XÄ@l^øZ  Y@¼CEØ#Û ó|à "Ë@à %cÀ3É b`´cå#eÆµD9Æ#i ÷"/#£Ë )d!Ìè( µ#a h Qj PèüÝ O3Ò+@@'h3öP É&<2 W"4å3 ¥X >RdL 	D  `QCýx$íFPVèôâî@;)@ 
!
 ¥@0 ë% å!`G] "'W;Á|´½@ Q `ä jY¥@Å~ ¿ I D$ ]Ø/ E!uÐ$% *#¥  XCíÌ E#Ñ X 8!YE&}$ Ô $!º@X°Cì@]$3 a= : ä $B#ÚX¥BB3Ò;e{LÐ$I!ô$E¹' /Í 4 @,r!·.E!± W!] Q °ëÇ° é%ðF+`%;ðy ¢ÿµA¼èbe¢gèü éMð3Íèÿ!Ýå]3 æì0SVé
³ÑUØE¾@ |ÀHHÎ3öÀMÄIðuà;ñþ&ÚÆ"MFT6zEìMÜKe]ðx@#ÈEè (µ  ¹TR @Ç@iÌÀéuì 0¹ &» à	K C ³@Î),EäÀ~[ÎWÿR(ÐB øu·J*Á5I4ë,o% |·B*µ Ý@4FNÂGB
Qÿc;}ä|¦»w±C B3É+ ÑøEÈM  ê_ ` ·H¿ÈEØMì°a ÁlÂÁøá  yIÉAtt$þ  ¾@Ï ãÈ3!|ÔEè#s`ÏPàç <Àç F àç<GO@çàæEèÿ@j ^;EÔ| ì-3ÉMèP+ÁúUÌÒ¢   àË?' !íNÈÃ@Ë]Ð ´A Ô!]Ëá AEð¡ëaMm@²"¸á -C5¹á]Ð;}Ô|£MèA ¨;MÌk#]ðMä ä;MÈx#-M"z"O èÀ,0uàMÜFmìÁ  5 ÿ"Ô"½	;uÄ})UØé5$| !B ë !è  #Eü(Ý#dèP@Hãl [CcÎy Ul$ìx-$ âãt Hê  t#~Pí +Ù]èj èÚ ³#|¤ q!r D#!xÿ kPTBJÆ
Z* à  [`( =HD:ñJp@,¶	PDVDpD@V@9`ku	@ @v9  >@@@
Ç@ ~*J@@ 	 Æ@8ÁMà.@D £b!AÇEjg3ö¿ü5=Oÿ¼@¡ t¼1@ t\ ¦9j ÆPèâÿ@Î28 -pAEÏòM"ù	82@Kt"Æ2@J`58èOqãÿÿuËjÿèó·÷ÿÿEÇÆTÿK4n £à D|  àr à r àr <à 1`à(   X º
u:jj ÿ´`Êèfoãÿà|j0E¬j'xÖ (`(=Ä3ÉÇE¬  ¸A@fÇE%üÇE´ ¶![ ¸   ¼  ÆEÔ EÀÇEØ  # Ð ÿM @!{  Àß¼b! uF
Av;
` ¨2  Â@ %ñ	z2;÷t.Ù!³Ý/;÷uòM  $3é  1$ºÈA ²Ä  3 @w 7é²à7 @!`-¬´@r@uÜE &×N#lVMìèÝ"þa×M<@<EìÇ@K ÇE;Ãs|;ÈwvW+ÁÁø@GÚuLÂ+Ã %ÿs@+ÙA7Áû+Ã ç d+ÑC:x¹ÿÿÿÂ ÊÑè+ÈÂ'·MÏCÐ;ÓCÚSè>ÈÿU OMM&,ÐÆ$"qëi u m NàmB`m+Ùào wà	o  ào  àoÎ  o@j   m g  g 	 õPè!TG! ü ÿ  è±!#]è!¢A,¡PaM²$÷ÁAh d' Sy1!« !§ A ? <ßAM¬H Q!vjè+#S eÆC{ #XÁTÀ!Bp =] %0
E]äuÇETV	 juèPÇE  ÿ¼ELÇELHBð]PuTEpE ØEZP  èñ M@ íÿèÂ } tj  !? ñú[Mt(î~ ex]Ãh4[ÿüÌVWù)`3öfÖ6 FèH+÷Á@i
~Z °·Ä ²fÀx6uÇ`+ ÿÇ 5 ÿë¿ÐJÂâÁø «Ð`Y F`ZÁù;ñ|¦_^p$à %üù2Û3ö- Gk÷Â` 4COöxàA	}±Ô Éu  FÀ]Ôë³ +ÃÀÊd@ËÆÖ / Òx!`îA+Áø;Ð Q  !`QÀu !¸Õ 5 uÛtC  B fvÑ|!vàÕ@Î 3A^ÁàÕ H@Z°È YúIá|"Â  ñAI	ÁøG·@=!J>ð@	váK ¸K=4 !Du>V·@Ü3ÀV+¡E'T$;Â5ªÆ@ç  (@N+Á!Á|Ý^_g¹U¬$ÜC7ì$#¶ j1Ê Ïñ ÊìxÇµ  !»ç¸ÁEÀ©Ú½, ÇIà Ç%§  ç çç
OÏGDM'êj D¸½0 3E)ßÄ@Æ	X+ÁûKÇâ %ú è J$ü ì 
 Iß]ÌèÁÚ*üè3&	kBÿHø}È;û R}Ø#® Ô S04¾u¤'Ö @-EØÈ:	)§UÜBo7¸<'Ð¶ d 6lF
$ N?Í ¶@8@<ÿÐ".:EèMÈQMè&pPè*í Uì¹TUU+ÊØù%s F4EÐBUìXCUÜ l duK¼#ý ;`t=à	WÒìà
W · á W OÀZGjÂ Ñÿ )#«}ÈGA}Ìê!ÞAvMàÇEà ä!Q ä 	 è¿¿ÚÿØ]*Ø3À%(}ÜUÄ3öiÀ¨ i(ÿ !ÊEÌ3r K ¹ tE u?9@¿t7EÜPÿs%JàSè`³ äÁ øa  I!ä{G8 l  rEÌÆþ *ÎEÜ@ xø|2ÒUó3Ò)ü§Ï"¬Jt y t u¯ ÉÂú |ÒEó}ì =Ew@}ä $ s  )´ BAEà@ ¡
;ÈtD!\1Qèãs.=Eà4YÎ;ðuìPèÑ` è@ è@< è¢ < @7 «à% 7   4éË vh¨¦Å°EóéRA§]À ME´uÔD#]¸FC¼PÇÀ ¾@ ÇE@ ÿ×ó~ ,ø &M%ÔEuÇ`àSöÖB°µ ò  `IÆEüÆj&j @_ èW&W@	Ì0uÀ;ðt-CBVIÓI"@ EM è''!(Eè6 1!  ÓAcu!2UóÒ] téÚ  $@ÞÔÇEd  E¨uØ!yu°E¬EhjPÇE`  Ø¨MLØ|ÿÿÿuÇ` ü ÛM.µLJE` Â ÀØ­ Ø M@è@Õ à#§@Õ Io \ R}Äî¯iFBéþ`ä ÿ@òÈ,b ¿Eà@ä Ð ä ÖTé@B@ÖØÇEM^ EA¼Eu`Ð @Ð`!8=#T9ÈE8u<E\EAu À²ú@²@èÎ ²]Ä!l`#³"úèÖ@Ëè­ Z@b àbâÂf1jjQèôêÇÿ +bb è@PèÞ`"Ç A è`AâÇ À? ´à)BË ?   <&q Mè F(u( ¥FI]Â Gö
ìSUéVWl<dMèKÐêÿÍè´ãîÿ¤ ½8 T è	3ÛD$ -´7öuj S -V8ïÿð-½?~ 3íë	1

HèL$3ÒI--t8T$u  <×ÎR+ÅPèe  
CÇû|µAð{*¾"Îè»*@ ÆB ;ça|é½)æ
 n  ]¡!Îg='?xÿ xç4 $''§7ç.ù}ð}%ÒutÆEëÿuVè»ÖÿÿE,Ð!Ú  §> Çæ äH@)]Æ(ÎAëGnggÈAë³];Áä FÐ4r£â+È2A	uUèMàdì/ü L¹±è @9$«+æë{¯!rnuf} ([`¿4XòÖÒyÂÁú ]ÎáùáD|,hèîm÷ÿMðVè%Qñÿ np ÏèGÊêÿO è"þMÜCUè °}ð;]ä| õ
Eìêmà Æ6ÿÿÿ} t!CÏVè5  9â åSþ ÌB|2ÛVW3ÿUµ$Ê¸`ót> uG1Æÿ@|äJT 't

txÿ Æ  uxþ$Æ FzÀîuÔBê QVñè§ëÿ¾!^ uMj$èOmf"ë &Õ3Ç@l: Ç  @  d\Ç@AÅ  O½Æ@  ë3À@Oÿt#U @	Vè¾êÿ^Y£wÀ ìSU 	3íWt$ "T&@Ò¾(-&|$Hÿ £ h x Ç#9  ¹[& ~upL > $_vÀ¹"!iÝ §\$$ûó¥ M;Êj6 é`!^À6à&(\#¤`tC 
@e;@u|1U f!ï c ª®, ´;ê}4 :$iÅ@ @È+ÕÆ @ê/ÇÇ@âAÄ#³$$@ÇàÁ- Ì£ÏSd¡ ùKVã	Î¿¼;ÿ è@Ï¨èöàÿÆEðÿuÇèL C(ð "S	 ÈÿðÁf5ª© @v
¹ LèBNt ÆâÄ"ÃâO Udo ®äoQVà	 ¹_ÇEð@èürDt3ÿ<#%@2Ò     ;Át¸M!= t uñë²NXÁÁè$:Ðu÷Á 2çt%"Lºêÿ3ÿëyÒt ý#Àøë]9¾È<ît	Vè;"ëÄ÷FX`3CF6gÿPF,"ìP&sÞÿF<~à ] ~<FXºðºèFXÿ`Y{Æ(&{ Ûtè¾«4Ú Çá3"ü W#$ #Ázîÿ- < "G  &8 \"øÒy%HÐÁú¯Ó¯×$"%óD$0&\F $F  (F$ ,F(D$4N^~óF,F0V4ÆFu
WSU! Âêf1Â,d`U>±A """x  à
@' d#r`'à@' ¬,R`'À /@ hV±@ 'A';`j Q=é>¨ÿPW ^àMÀO<S~¿ 3A;ÄP_@;àÝNH à$j` ¯  8 ¯@`dà$Dà ÀOH  O@à:O IáIè7	 U".áIè² úè{ÿ@  AK`& \b  '
[á² L${¢^A g ! ±IFh+Fd=}yF;C ÀA³ æ_á>
,ÀFd#FlFh!¹@ÿ.­t; 
:!Ó:%øÿR=Ä¸ t&ëWPè¬\ü_@ WUãÀF `!G)¿` !ò ^>=ÛVW±  ¿&)!ò>ýT$@, " ±NüòYà§^YÂè	Á"4vC]L$ T 3 ò0FäIu¾_^ â uì#Y $ SÙ<ñ#Í!CÇÄ5Î@  iS¼ +¸ > L$$yp A*³GæÀ®À º  Áa4`2#À ' `D;õtu!jNd+Áá i@8à 2ÁÎáh 6Ahág Ag !gDagëad~¿ad þ §	Æp;õu³Ô#ä®#Â  {/NàI¹àó¾à	!qø1%³(~@Û!eD$@ ü ` @  @!`  @  ` $@ ÀÿÐËÙ'ä$z  ¸  @+YD$0 "  "2	ó,È;ÈMÈaèÁ"%ÿ  Î¦(£B Æö  1LxÇ(!ß@   $Ð |@¿ÿ  c`Å `Ý` Å  Ó  ¿ `Ó`$_@Î ^]@@Ð(L ¢`ãÏnãÏàJÿÿ;@ à	?Ú®ä ?"( %åo#oåbàO)ðE@DnEÛ@O@@`y à D  QSÙVW¿0!-2µ³|	`)X)s ý$m#-m  C»)!~YÁà K  (ÆCÐÏ»Ä"3 t9»¼ 7 @@-$3`P³S ¿H`] `] @U ý @)`¾ QÛjWW0Ëè )Û[Yé%¾@I³Q5`O ?`O 9 Ð L Í T%~h tN` Ð à" w³WOyDv`y ÃÖÌê/Vé	MþìàT 
Xï ð  @#O\@T©%Z/0"ûvzl+(
4Áþöy	0	ð¼ÿÿëVèxÀ7¾  
-Pèeøÿëþ@}EðmäL°*nÁ|8  *tGQ@ =+Q ÿ á
èñZ-}w.7W0 ©@$~	±èãýÿÿ F`WMð|ã·ï G¯Îèy4oïEî}ìoH `  ¸a·Ø18 ð.O ~/Ï Ba < áà" ò "l è1iðu­A¤1; .X!o MîëQUl$ìpjÿh*Ðö ùìRa¯ÄEl/ÑïÊux!{ ! Z0]|ë /NVëÆA»oPèÊ0[\æ È^GMÄ/È 0oÅ(ÓuÄpE|uÈë$@4Áù7\ Mà
°nE|;Î-Ñ%ZoáñU:XÜuØ¿aú<;}è½d!ä(¿nî : +ïâÉ2OMä-m^ }|C©`$·H¿ØÚë]x/ÃË"Â·@nÁøïñt!St/µ` ès<+}ÆÇEwË÷Øè"â¾¬ 
]ÿÿT MÐEÀÕÿÇÌeç"ìÀtIB ¼ ¸OìÄN÷éÁúÂÁèÂ`*	{" t{# #Ï3üù&B Æ3×ÃPècâÿÆC##ïQA7Øù+Ê~ùC"ô   UÀ×`EÔ z*L,¹ÈèøªáÿÿuÔËè®y,ÄUÀ]×Ç,@ `[_Ì ÔÀ^MÔÉ
{!  $@ZÆE¼8 uU@]hè ×è7ÚÝ8ã ¸ t 71z] iË@ÈM #¹ <PøvèÏ}á3ä¸C  ÿ   )ûrÑ M¼Áè+Qãÿlû  ÿuì>½ÿ¶D`èÍm4e#´$#ÞMìÃTA!8P  ù{#´p =@C "W5 Ø![ø !é=WÃ;ß/o}èMä`lA"`8"V;Mà¨DB]ÜuØ"ñ"FÃQÔ"¸1=BÁuØ<@#MÄuÈBé ´"ÑÇErÁâ¢óBðì]äuè"" ¿BbôÔ} âñ V@Bâñ ÜBñ . $fIoâ	÷ÈÊ dMxuðÁC¢MØ"ø ¶@râøBõµVi¿pY!é Bê!4Aò%Uf! 3ÿÆ   
ÆE ÉK(¾#Ý B$Ì fBb U<ÍU~¶Ez" DE¸Ebd  â d@A	 A8B   M¤è·dS%ðE¤PWÿu6¸ ü  èÍðÿjP®!2nÿu¨è­M"-Mÿ° "'èmv?sMÆE 2ã."èËN 1E Gÿ0èj B @	èÒÝÿë#M@vIüèÁÝ` ¹@ 
 3 , = , l -×Ï/á¶A«È	f¾A2 }f`	@8 8ÆtAF í Ý#ÿèR f!1GÂT"h!rÿ"Î BÎ]Ð}ÔÛ>ÓËnbaÓà2@t t b @lMÜ;Û A"&bÁ ÞB]äuè"Á UT"»"" u4 o@ uÈj0h MP
³ (`(=-W]ÄÇ` È fÇl %'p @ Çt@  Çx  %8 ÇE 	   ÿ| ;Þ*m  B Ó FMÈ#+UÐ]Ô¾B§C½X 1!cæ @:ãÀM¼C í,ã	æ cÆ]àfôEèæ T N èÅs8ô C ÇME§$5uìÇE4¦@: 6@ y5u)1Y;ót   Dºi$Æ;ó$M@?AU È"²Ä  4 4¿Îè9à/ @`+ 1(ÝµP §E Z3 T#+VM¬èñr"PM@) Ã@8"p &Å Ü,± :5	 UØ;Ñw}>SÁùM¸;ÂuSÊ+È ùsG+EØ¹ dÁø+È R E+UØX"`Â ÃÑè+ÈÂ3Ò;M CÐ;ÓCÚSEEËèÝ9ãU¸-U K%®!B¸Ð#ªYzër z t WàtK+(Y  `\àx Ù$ý$`à!x @xÀs p 'J	E¬PèÍq!C!! ÿ  èÊA67_ AYaS¬CY1! ! ¦ #  ÁÂ "!ÂAñ7!)3þsEÇÌ`ÿÿy ³UðMè]àVBåS¿H,° ¹!  *HÁÊc[è÷ÿ P Dj' @D|Eä «ð8á fÇAþ  ¸AA C@J%: j6U 08èÌóÿÈE§\ ÇA åÿÇA        ÿÇ º  #å A=ÇA ÿÇA5I  ÆA(   	  ,   $  `NYqq ÿ(¼º@ v
Ç`@Y `	 3`þ 9¿PA HA ÖUF?ÁT:Ga! þ% ¨!M¼UÐA$:#è;MÀ@$1MÈ$J=%$ß G$A$ã}Ä$M;ù­û 9]ðËÿP8( "»t  -Ý"ËÆ` +!'ÿR8';!/~ %E]´u71aju¸>Dµ ÿ¼2EDÇEDHE-*Ô	HuLEhE"O1¤ P[ÛèÃz$A M@ ÿ  èv$¦Ï t1_ !y ëHh4[ßvÆù@}2B0DëÕd¸ø?wÉÿ|8 M<!NìF[Ml<îX<îepÜë@ LOìt,O ìOì0ì L pìL¢"·¾ àzüWÀA æt	BÀ ` À  ` $À ,` 0À 8` < ÂH&¬u9±¼!°À   ¹O` Ìà Ô ` Ø À) à ` ä À ì ` ð ÀRC`R4ÀQO`QHÀ B@  À  `   AÂ %)qº  Yk@% ð  Uìô3ÀLÔ ä+AMà<}Ð}Ì9M	X#@·$E+·m	þuÜþC 3ÒUèöFí  P*$#Mð°b"jb8 ìþÇE'\ ;-uÈìT H+&L~v}&` ºAø%ë ¸EÄ;XLX- A{" .lV (%EÁø¶Àøu
è  EäëøuèÜÿ  à&ÕÃ; TuÁ]G;}Ô|}ÐUèB Ü;UÜ"#9e àÁÃ]fnÀ! [4ôYPSøutK!;	¯ÁØ]ë :ÃGÜ?Áà   Hë uEìmðÀ%ùìÐ=!\\%þ¸ :	;ØLØËá ã~.ðA/ Ã+fÁûCÁã¾¨!¨
uXj0èP ð9Â!®$    öt&C	²jÝÿÇ ¦;= ö!§  ßÿ°@=^ ð@
ÿq è5`ß,Õ@Æ@	è Ô_ ;ÃÁ T j©Oàj   j Gàju@]ä @_Õ_ _E>]$å]Ø@gE ¶$ïdüÇE}cÄöHÇEH ¤ö	LuPElE Å ûä öÌuDö@ hÿèq&èõêGd '+Ñ3êä¯ p$¯èS$¯t]Âsê` =4!¼ EVW; ë ¸@u	qNü¹ÌK tHþ;ÏtÆBý À
Hÿ Æ%ONÀ;Ç@(   À ?  ) ? #Î($  S%|¸pU¬$< ÙìS½%E ÀåE ÅEÀ åHÑ(Ì %¶Ø ÛñDµÜ 
D'´x?(H;iù'xf¼ ~*,jÌ ò VÿµÔ ÏÿµÐ SPÿrèR aUð½à  ø .3Ûº + öff.<  @V¿|ã+¶x ~- [ 2@[jÿVTÿµ@§`Y ; Y; [LFÇ@þJÚ|´9  l  lr-G h"IUè"? ` i"? d   ?}ð G5}äÇ`X=½H¨¼ E`"N "N  è}K M@!sÿèNo @ußÇEð@»¬~ à ß@ÇGD°.~ Â $éÊá%ÃüAt	¸  +ÁÐGü7¯¯òWü;ðtbGø(8pðPèjhÞÿÇG2 »þ|Cµ   #ìè(ÉÝÿ 1 #} I{tÇ! .ÁFÐ îPÖGøMk&¦! Ç$uN Ôs!9c ì!9 6A9@¡9E8ÇE8t!*A:]<E\E!\cðÁ'UrCv è-nCoè	 B#\ $¥Bµ]Â c\  'ÑôZ Ø ¼ÂÇ	EðVWPEôd£ V%½|%3À 8Eu8Eu8E$äGÆ`þ@d $è¹¤èÿ¿(G µ F tD} ½Nìt@èréÿÆ`&éYJ lO@PÁb¡´çà   8  3ÉÆ `  ":IÇ`5@ XÎ.¬ p " z  "y 	Òt!BK@fNÃ:`O+ (ù 7à 4ÀtA¸D|t8 À'l -É;9!D@ 3;ª ?BÀ ;@$|ë`9µ@v * 9`lQ AÏù0- Æéû > ~ ä~ Âàu Ã ) quàmïë`<@®èt
@ét ]º   ÀÀb@ù}`îè/ÇÿÓðë> @3úu¶°¤ ?Áæ°@]ÁæÎ  ë`Î @ò@X  BAGA:éø!4 @Ú  æ@Âéß ÞJÊÿÊ!}P¨#ß'Þt'øtøtøtø Ü
øtøu@(3À8å 0 ãÉ( ÁáÈ¶b=;Ñ¾! EÆµA!ÊaBTRE®´Hæµx #æFë3)¼¸! `t`´`~ÀM` * I H4¿u 1T#óF c `# ° @°`;Áu/Àx?8ÿ·CL@<ÿ_K`° B·ú-F @!ÌëÆ`Î2ÀWÀ17 @{ 	Ðh  	à8`#õ8(0 µ@úÃOu_!¿Æ9 %¬  71|? !ãSþ#. ¿@ä·Aæ!°B£.9¸Aó.½@BÿdOv!c¿"½ì @Á@%#/ µC³@v;Ju#« ÊÃ­Q ± >DR `Û½t \A¬" ÏÆ@ èêÿw0+8  #VÏè8n ! ¶HTöuîéd  ¾B ¾ àµEY °uà¬ïéeÔ `?ãq 2!ãqO!5}a1è,#q ÈCkBãk¤!pÁáckáÉ£k`",`Ê@R  BA°Awé¼! @×  ª@òé£@ws÷jPÇ0ÀbªÇY¡    §Åa_F@ 4E E½< ÇE/}E¼`A Æ&£Æ ´k&  @W  èg"ìBf Fmþ$íýÿ&)}·Côë {>  â 3Ò8Ê Â,­CÞ cÒàÂ;Áº 'B
µ4 ½8 t&ÆF où )C!õBl Páõ  a  ûaPÏ !   ¡ d½0 Y, aJ8 * Ç` ¸A ½CWm `P ý Á jA@f  èqfMØcÆ#|¯²y"4r|· -4·µc¾2 \(@	 ä	%Î dá# d"Î#x >NHD}Dv,E¤h	È;Hu½g]Ç úR $ ì½( t-áR  !ªïAYèj áY ¨ 7aY    2!Y ¤ 	â^  Ü Ø ½   Ç` ÔaY à ü  `P!C ÁYFi!+ @f  èe!ýaW B^e ¡ : 3%Báo@'- |0ì eG¤(*O¼  uEd}5L;lj ÿÿgÆ-àA^Þ+×AÇhw@  
Q9@ Æ`@ `q @xø0|¿Bì  XtE£u<
*R 4tà	rÎ]Þÿ5A£  @!Ã i$ìÀÙ $äëÿßfÌà	ß Ð1àß a là ß@A@  ß Ì@5   ß`@àß|Ç`ñ " ø}GDFG-#å ¸iU D²F*ÉÒm !¢)ßEn))KÊ|óéU Q'¡DØEÚ @@ @?F ? - à? à ?  EKI©   ¾HáH1#Fî5f4@·AÆµ|"?Ét¼·B/&· Æà ' àh$ 6 `ä@Ü H(¨-ÿ$ä`1M¬%°(¹ö*` ø`@¼ ,ßa àk Ô jè6äæÿ`Ç·Bp  $é¢ #à5  à 5 °à5 h@5 l #à5 h à 5*åàk ¸@5 6 #à5 2 à 5 ¤ 5é à# à# ææàÅ P!éÜ)à5 Ø à Y  5é(àY ´à#&çæàY è@Y  #à³ ~ à Y   5é:àY Zà#,èæàY *`é( #àY $ à Y ¦ 5éLàY  à#âéæàY[éÎ(àY Ê à Y\êæÿé^àY ¦à# è #â- °$6ét #à³ p à YbëæÿépàY Là# î #àYH Y  #àY  à Y HA  Yâøæ'c Pâø Û à :MËàp 0B © #àp ¥ à 5 Çà5 x@5 s #à5 o à 5AÌàk È@5 = #à5 9 à 5 »à5 Bz  #à5  à 55Íàk `@5Ñ&à5 Í à 5 ¯à5 ¨@5  #àk  à 5)Îàk ø@5 e #à5 a à 5 £à5 @Bø / #à5 + à 5Ïàk @5ù%à5 õ à 5 à5 Ø@5 Ã #àk ¿ à 5ÁÐàk (Bæ  #à5  à 5;Ñà5 p@5 W #à5 S à 5 µà5 À@5 ! #à5  à 5/Òàk C. ë&7à5 ç à 5 © 5éqà# Ãà# á1  @Y @#æ]  & ãd v à p ÈCùæí Rà# T$­é¯à# .à# à@# Áà# 
à# l$éîàÜæ#àD¿éÓàG Âà# t$éá$ à# ì # åàG zà# @# 6àG Và#í G ÷àG 2à# ¤@# ZàG à#àî G	úágê"àûlï # ~àG Æà# ø@# àG ¢à#ð G ¢àG ~à#ñ # -àG Zà# |@× Æ GâV * !"V ÐâV  â V #éF÷àîû!à# #WéXà# ×à# ©@# jà# ³à# 5C3âV à# ±@# |àG kà#=Ó  »àG Gà# É@#?Íê #à#UÔ G ßàG ÿGvw)Ô á@#  àG Ûà#mÕ Gà× ·à#©Ö # ²àG à#5× # 'àG oà# Á@# ÄàG Kà#MØ G KàG 'à# Ù@# ÖàG à# E@× o GâVÓbVbë È á 6J­  èà^ ¤à# Ö@# úà# à#b® GøáÆ \à# î@# à# 8à#z¯ G 0à# à#° # Bà#ðà× @# Tà# Ìà#± G fà# ¨à# ª@# xà# à#6² G à# `à#r³ # à# <à# þ@# ®à# à#´ G Àà#ôàûµ # Òà# Ðà# ¢@#Zã
 ¬à# @× ä GâV | !$­ PâV q â V ó ^êÚ_¢é? #ç« ; à 5m¶à5  J3 	 #à5  à 5 çà5 ð@5 Ó<à5 Ï à 5a·àk 8IÇ  #à5  à 5 Ûà5 @5 g #à5 c à 5U¸àk Ð@5 1 #à5 - à 5 Ïà5  IÇûà5 ÷ à 5I¹àk h@5 Å #àk Á à 5 Ãà5 ¸@5  #à5  à 5=ºàkSéY #à5 U à 5W»à5 PIý # #à5  à 5 Ñà5 @5 í'Là5 é à 5K¼àk è@5 · #à5 ³ à 5 Åà5 0J  #à5 } à 5?½àk @5 K #à5 G à 5 áy È@5 @#(!è1åp@ð"8@ô)õã ä # ã Ù à m[sà£ C+ § #à£ £ à 5 õ 5é ïåÜ à#¡tæãñ ´@Y M #àY I à Y;uæ)4 à# %à# ç #äK L!éó&ïàY ï à Yvæÿé?àY Ëà#-wæàY ä@Y  #àY  à Y Ç 5éQàY qà#sxæàY |!Êé? #àY ; à YyæÿécàY à#zæàY BÑ åé á à Y#{æÿéuàY ½à# Ï #ág ¬@Y  #à³  à Yi|æÿéàY cà#}æàYD! 1 #àY - à Y Ï!Cé Yâæýbæ Ðâæ ò à : tàp ÄAØ À #àp ¼ à 5~æà¦ A´  #à5  à 5 ¨à5 \@5 T #à5 P à 5Bàk ¨@5  #à5  à 5 Üà5 ô@5èà5 ä à 5vàkVøé² #àk ® à 5à5 B | #à5 x à 5 ªà5 Ø@5 F #à5 B à 5Dàk $B   #à5  à 5 Þà5 p@5Úà5 Ö à 5Hàk ¼@5 ¤ #àk   à 5 âà5 %én #à5 j à 5|àk T@5 8 #à5 4 à 5à5  @5  #à5 þ)¿à 5 °à5 ì@5 Ì #à5 È à 5 jáC 8?¡é@# ÷X  &]cìL { à Lý[æÿéöæ' Wà#é\æãd ¤F' % #à¦ ! à YÃ]æÿéàYýà#¯^æàY <Cô Ë #àY Ç à Y_æÿé)àY £à#u`æàY Ô@Y q #àY m à YOaæÿé;àY Ià#;bæàY lCÐ  #àY  à YcæÿéMàYïà#dæàY C ½ #àY ¹ à Yëeæÿé_àY à#×fæàY @Y c #àY _ à Y±gæÿéqàY ;à#hæàY 4C 	 #àY  à YwiæÿéàYáà# á Ì@Y ¯@#âæ  "æ Pâæ  à pLæà¦ BÂ b #à¦ ^ à 5 °à5 Ì@5 , #à5 ( à 5JMàk Bz ö'à5 ò à 5 äà5 d@5 À #à5 ¼ à 5~Nàk °@5  #à5  à 5Oà5 ü@5 T #à5 P à 5 ²à5 HBø  #à5  à 5LPàk @5èà5 ä à 5 æà5 à@5 ² #àk ® à 5Qàk ,Bæ | #à5 x à 5êRà5 x@5 F #à5 B à 5Sà5 Ä@5  #à5  à 5Tà5 BÔÚà5 Ö à 5 ¸à5 \@5 ¤ #àk   à 5RUàk ¨@5 n #à5 j à 5 áC ô@5 8@#ãv ( #v ãv  à Làä &ªë à ç à 59æÿéåæ Ãà# å #êù |C  #àÜ  à YæÿéàY ià#+æàY C 7 #àY 3 à Y Å 5é+àY à#qæàY_éÝàY Ù à Yæÿé=àY µà# · #á DC.  #à³  à YQæÿéOàY [à#ÍæàY Ü@Y ) #àY % à YgæÿéaàY à#æàY tC@Ï
àY Ë à Y ­ 5ésàY §à#YæàY BÂ u #à³ q à Y !áC X@5 ? #ºC 2  ã " # Ðã  à YI.àY  BQå	à á à 5 ãà5 H@5 ¯ #àÅ « à 5}/àk @5 y #à5 u à 50à5 à@5 C #à5 ? à 5 ±à5 0B  #à5 	 à 5K1àk x@5×à5 Ó à 5 åà5 È@5 ¡ #àk  à 52àk Bc k #à5 g à 53à5 `@5 5 #à5 1 à 5 ³à5 ¨@5 ÿ+à5 û à 55àk ø@5 É #à5 Å à 5 ·à5 @B«  #à5  à 5Q6àk @5 ] #à5 Y à 5 ëà5 Ø@5 ' #à5 # à 57àk (LÚ ñ à5 í à 5 ?áC p é» þ6Öä f@"¥ê3c "@@* í  #¡dí u à w·Õà­ø  "ÿ #à­ ? à 5 :wä1 DF  #à5 	 à 5 K:eà5 @5 ×!Tà5 Ó à 5 :Sà5 Ü@5 ¡ #à5  à 5 ßà5 (!1ék #à5 g à 5©Ùàk t@5 5 #à5 1 à 5sÚà5 À@5 ÿ"Îà5 û à 5=Ûà5 !ÊéÉ #à5 Å à 5Üà5 X@5  #à5  à 5 Ñà5 ¤@5 ] #à5 Y à 5Þàk ð@5 ' #à5 # à 5eßà5 < éñ :à5 í à 5/àà5 @5 » #à5 · à 5 ùà5 Ô@5  #à5  à 5Ãáàk  !ÎéO #à5 K à 5 áC l@5 @#ãvU#v Pãv Ë"à L 5ðÇ·&è  { § à{  à .!wà . 4Bü x à. m à . Âà.mì I à. > à . c4» må  à.  à . 5ø .mÞ ë à. à à . ¥à.m× ¼ à. ± à . F62 ]mÐ  à.  à . çà.mÉ ^ à. S à . 66 ]mÂ / à. $ à . )6/ .m»   à.õ à. 5É .m´Ñ à. Æ à ] ;5 .m­ ¢ à]  à . Üà.M¦ëv +
¼·|"D uoà 'à VMëNà' Gà ' ,5i ~Më&à' à ' ôá3M|¥f `~ "! ¤`  À!9GÆh&¾ÿ¤ ` `BH3ÉÿµFê $Ïèúïîÿ¸J2 ~13öÿ@	v ÆDðÏ-èÔ % `2;@+|×µ|@@g7ø}	'< à'<ë GE ¶ÀPÿRxI qØå KÓA ° QóX óY»ó$ÿPÀ!ÿwÿ « 3A   P gðòòÿÀts ¸GÕu]¸ANuT·¨!L	fÀx:fnÀ¡,[ÀÆ K Ç  ÿ  @,§@   @ë 41 r@¡	0CÒÿÿ¿Ä,¢ ·¼ t	>+ó A³¨)êHø! $Ú $Ú~À%  â +ÈçÿÇFx Jéð à'Dçà '``'¸  ' È à'À à' È'c«   à'B_à O ðw°  O@|`'  Åuà #\çÿ  8@±ÉtSAàó  ëBà7 <à 7T`«°   à  à  ³`  ð: stM Wââ "Ý â Gâ? Aa3À8å!iÀÉ &SÁáÈ@8Ça©    @ ffAÖ  C,¸"ÚÀñ-zx#m ç 	y ÒA4 $Nx##éâ ¾ (@ÀþøX !á °!áà " I à ê ¨'p!A H0êé) à % # à %rô`%Ð² %  à % ý$ªà % ü%  GE Ý 
VèºæÿÄéÑ à 3 É à 3(í`Y > é© à % £ à %¢ë`%ø)   à % } à %|å`% !%é]@ü!U #¦%#t!eá  à ;p,`;è5 ; ö @à aGà % ú%hj % Ðà% Å à %-K  % ª à K  à %.`%hÓ %  à %Aåà % %ð!§
èç "/*!Åp< %Cà K - Xà K ¬%ðp %  à % \à%60K ¥ % ì!?à % á à K À%ðÙ %Gà % »à% J.ê@íà % à% .Ú@% w % z  %cé sà m -L !ø« ë[À Tà  £ x/éë<À 5à 44= ëÀäF U¤xI#íCÔÈFËH:é# 4u  à WLä`W °# éMûà % çí$vï`%T % Ç à % Á à K á °!é¡ à %  à % zq Ì@% { à %î$î`q 08¦éUà% O à K >,!S C­ / à K ) à %¸ì`% `&D éMûà % à%Rç`% @;4éã Pà % Ý à Kñ`% %Vé½ à % · à %fâ`%àH %  à %  à % ðKÀ % q à %Nà % º-þ ã`@ % Kà% E à %$à`% w % % à K  à % þK`ã®	 ù,¡à %(é`KnÑ Ù@eT Bëø:¡!¾BêøwI¢E q à EÒü`EðM  V BÜøà- C à -f®"ý é( BØøà-  à -`- z éú#mBÓøà- ç à - -JOéÌ BÍà- ¹ à -`[ À!7 é$ý - Ç@ #á Q  à -ý`åRësBÂ@â  *cü dà &eú`& p'ëLB¾à& =à & î& @#¡ë%BºøàMãígù`M 0 ¢#íG>)è ²A¡ÿ´  é"&6ÂþúY ¶¬&9&@ T  ¡²GÕà ~ßò`W è!j éAà % Ú!à % 	à% º à % ´ à % £HN éJAà % à%Íó`q`% n à % h à K ÷qpöUuà % Bà%ñö`K ¤ ìé" à %  à K à% ü èà % ö à % ½`K Ö à %G1à %õ`q ø@qDõà % ª 2à %	÷`% È#=é à %G1à %óû`% |@K dà%G1à % í`(nàKG1à % W ° ÷ éHIà qG1à % áEAèéò"2à %G1à %+c`qC<à %G1à % 5b Ø@½ ¦àKKà %OÒ`ã `@ à%G1à %	Ó`% ¨ Kë] ncJ [à  Ê ð!Në>P Ç@ TèÙ¹ßÿKéPÑ`?ëêÿ`^pT #<K RG/cBë3ÀJùuC[+ hë@9ë>kA` ?äôÿÿ¸!°5+N/3önUV-wxåòÿ+* ! [u_!Æ+  2N9KL ÿ!þ})-ÍN; ,$LtE$Ñt@øt;$­u-9( +ë#·N[ mÅtMÅ@1øtøt	Æeà.   ÆuÒ Ç  ¶	 èáîÿÈ¹NÍ Ò Ì3Ò Êètºòÿ`ÒÏVèÖà +`È`I¶À|
 El 1Â ` `` @G;@\ `6|¤Af  } <\`	 l~T K a&½P X t@èNGéÿëO@PÁ  èÇpçÿ¬3À`ëoÿ@Ëè@»àçê  ç À
 ÆD Ïÿ`êèîß ç A"·D/y_\ èSS ÿµe µ@W@PV9!`Eüè^Ùí ? | /ÿµ` Vo'ÿÐÈè ¶þÿM , è;Ýÿë(M¿ÈGÿtÈ"j@>à8ÇµþÿaE F`}ÏïVè;@²!@o! "\þ ò¢` `Üf/ow_&@f 4Bÿ0Q"¿ÿÿëFà f/üë4àd  "à  à°þþ!,@Î
Î@pÿÐÀtC¸ô)­ uZFN.@u%jh! ÿP@ÿÐÇ @ DÀB  \ Î ^t
°Dë(2À 	!£; 	ClA³x u	@J j w @Á-¨ñ
Ø qÓÎ `¶b@ÆD5Àë,à;ÿR|2!ÐOaþ1#¿û ¤ QÀtP¤/¬ÏPèvBÚ c$oÉtay t[4@·È+Ò0d j(#ÀDc R29©èjÆ! `/(bPd¼·Ð ; uà Âñ À|XAaÿuÏèò­ÿÿ}#º E  H!^ cv½D L tEPÏÆB (ÿµC
PèÖïÿëH½ $ t*½p@u! (@ôAoó n 3Ñ`A £ú@`ÃúliçÿD¶AC 0¹R! T­!  I#~Bu ` ºEg¢9t(@. ´`.Âgbt	ÿP; Baú|d ­!¡ÉÿðÁMôd0¬  Y_^Mð3Íè^ å]Â$ã >! .2 B ; ? T M$ ²' 	* `, ·. k  ¡  × " 1  g    Á  å # ?  u    Ï  ó  ) O d    Ð % <  r  ¨  Þ & J    ¶  ì  "  X  |  É  í ( 5  Y  }  ¡  Å  é ) 1  U  y    Á  å    Ë D  h    °  Ô  ø + @  d    ¬  Ð  ô   ÿ <  w    ¿  ã - +  O  s    »  ß  !/ '  K  o    Î / :  p  ¦  Ü 0 H  ~  ´  ê  1 V    Â  ø  f!§   À  ö 3 P  t  ª  Î 4 (  ^    ¸  Ü 5 M    ¹  ï %6 [    Ç  ý 37 i    Õ 8 A  w  Ä  è 9 B  x    Ò  ö ,:     ª  à  "S :  ^  «  á <     ¹  ï %=     Ç  ý 3>     Õ  "" X  |  ²  Ö @ 0  f    À  ä A >  t    Î  ("ã ^    Ê  C 6  l  ¢  Ø D D  z  °  æ E R  Ê  F 3  l  ¢  Ø G 3  z  °  æ H 3    ¾  ô AI p    Î  ý ,J ÷    ¹  è K F  u  ¡  É  ñ lN g 6O _    ô    ¼  þ :S ÊP ð  `   tU ¬  Ò  ø  N T K  j    ¶  Ü    (  $ ? J  p  ~  ¤ Q ,  R  x    Ä  ê R 6  \    ¨  Ç  æ   {GW m  ß    ¹ X +  Q  w    Ã  é [Y   5   0Z §  Í  ð    O  	
à4   =f]   Ð  ¬  ¾  Ì  U¬$Ü%nìRøjÿhsÑd¡%k PìL¡¤P3Å *HSVWPEôd£  Ù]ä, Eè6ù \Ôu8mZu80 t8<@3PMÈèHTèÿ   Ç)§  
MØùK42À»+Ò	 EïMÜ]à%Û7
  BÒm3ö'2u±P / lc
àÆ;Bu½@ 4PÓX}À_0ÆEïj]ÄPÇx@ ÇÄ@  ÿ¼ø 	}¸Ä]¼Ç`p=½@©\<`Mè`G P*mk)m  À C 
 è> Mð', ',5L(þÿuðÎè¯ÞÿÇ0»  G È 4 G /Û ,Ëà. S ,  ,MÜ]àÇG0 + 3 4  38 Áü)ìÇë¡:Â!Õ'¹UðMäiÂ@Y0ØX-@]Ü| ®<\ }Ô 4uÐt	? +(¸{X ! 	` CXgAJø Wÿ$t î pIÈæÿ Ñ H'³NX L > L NW a3@$YÇ@$é3àùÛ ?Xzà? à$ Ô@$@?@$éóIÇÀZiÜæ  1ïà? Îà$ D@$@?@$é³ Wè îåÿVèúíåÿé à PxÔ PX±àP }à$ S@$@P@$ébà Ø/ÆaXËà? =à$ ³@$@?@$é"àÌ ?Pà? ý":à ¤ s@$@?@$éâàÍ ? °6µà? ½à$ s@$@?@$é¢à¨Ø ? T#²éà Í@õAë°àZ bà$ ¨@$`Z $éGà @u@? Ì à "à$ x@$@?@$éà-× Vøà? â#á  @$@?@$wà -Ç ?Wà? ¢à?@$@?@$éàÕ ?W, ýO bà$ h@$@?@$éGàÐ ? @7Fà? "à$èÏ $@?@$éà-Ú A?W`à? â"úà ä @$@?@$éÇàíÊ ?Wzà? ¢à$ È@$@?@$éà ]@Z@ À7à? bà$ 8@$@?@$éGàÂ W®à? "à$èÁ $@?@$éà ]DF@WÈà? â%Nà ÿ 8@$@?@$éÇà ÀAZà? ¢à$ øÀ@$éà-Ñ @Wüà? bà$ @$@@$éGà}Ë ?_à? "à$ X@$@?@$éà­Æ ?Fà? â2Ìà ÿ @$@?@$éÇà½Å ? 0& Æt# àF à+ @+@F@+éà ¦A!A ¸àF Tà+ z@+@F@+é9à  èÈ`HÈ  èßót t@2àÔ óÂ@)éò wà ï Ø ï'¼`MW@ÝéÈà) >Áþ  à	þ  à U @+@·@+é@ TãAáõ @yáWèïFK   éX^AyÌ  ë Vèå  é#2 Ø9· ð@ ü@ `y¢Wè`  ëlAy  3 Vè- ëVAÇ@D  ýfÂ ÷ ë@Ay]  ' Vè! ë*AyL  A Vè; ëAy;WèËí@ Å )ÿ³@ã0È @Æàéz"0ÁþùYq ¶xuH   WèÍë@M Ç éL Wè 
Vè é;`;ì@ 5 é*` ú Vèô é` ¹ 
Vè³ é`Èì@ Â é÷!)Wè 
Vè éæ`  
Vè éÕ`@_Vè/@IðWè´ 
Vè® é³`!óí@ í é¢` b!Vè\ é` !)Vèû@!RÿWè` 
VèZ ërà/ëdWèô`, î ëVWèöã@) ð ëHWèä@  ë:Wè: Vè4 ë,JÐÇC@¢ßÿWèzè@ t ëWèl QVèf  !)Ü Vç !ÛDØË+8*=@\ÿÐ1h/3Û9¤~"uà}ä¿GÎPSè¢ C;`|êuÐ}Ô 9UÜ3ÉB_ Aüë _ÁCEèQËóX ó$ÿPEÔ;Øt;à@MÔA@CQà C à C "gP;t À Ë 
*ï+-7ÿuèè³3VEä+¿@PÿR0$d;Ët@ à `IdEh}°+óu´PÇE`!Å ÇEd ë í  }¨!Ku¬Ç` kí @µ @¼ $OE`Kê «ê+;M`ÆKçV+·UðB+múô4Guä3ÛMØÆ0{y$Æ(2Ö"j P ÑÎè?²þ$ß  \ Ø3 	@ý H ØÁÆK²-ïuÁ½MM   SuÌ ½ZÃ ux¬ðu"Eï3Ï@"Àx½M{ t)ºëUEÇE -é !&Iá 
E8ÇE8¨ ûa<E\`òlÝ  ò@ò èg ëMÌè­#é!È _Àó²[N>3Íè§ñ ¥Ni]Â jh ûi » àq ;j V \o   Ö k Vm     Ö l V    Ö    ª K ê  * K ;  { @S@  n ]  ¤   _ ë  Ö }p   Á    °  Ò  ã  ô      '  8  h  I  Z  v  Î         ® @sïQË/´à Ul$ìl/¹ °ï¹,¡¯¹Ehï¶ù}t3À]|ÿu8Exu
Û/"3/ÔèªDèÿÛ¯Eï¿  t9}ÜÿtMÜèå/éÿÆ`éÆM:2EÜÖ4GWçà  ¨ 3ÀÇEè,Ñ Eà8 u:î Òx	ÂB Uè#ÐUÜ;Æ rN@3Æ;¯Ð
CøsøÀÖ >¤ Èÿ/`"y tAd¼D¼ë3ÉäÀ;AGx}t CXNÉuÈEÌ}ÐtÆ ÆC` ÿO ë`Ó ÈÀÓcT;Mä i ïÊ ä#ÊäÞÿ  Ç+$d CP,   LKX2ïý@2 ± 2%-ÇCX + 3 \   @}EèBÃA	Ð:6Eà!	WÀÈfÖE`0QA$ * mI·FÓ|#4C_uØ©8 ñK2A*A9LxOÕ Ø@ÐÆF w 1 UäEýÀþoÞ ­$!/Þ\ VèQÞåÿSèK é Vè &ÏSèúâ  ~` `  ém`Nß@! H é\`­á@ § éK` l 
Sèf é:`à@  é)` Z 
SèT é` Y pÄé` » :Sèµ éù@à/ è` ù Sèó é×`èÝ@ â  é!¢ È@Sè¡@! µ` ¦ mSè   é_ÈVèu sSèo é`!  ÓSè é`  Sè} éq`Ü@  é`` Ñ!9SèË éO`   Sè é>` ¿ pSè¹ é-` ¾ _Sè¸ é` ] =SèW é`  
Sª»è éñ*Vèr Wà c é×`  O!Bè~ó N   é¼` Z B"ú «B k9 ` { GàV l é CnBÿ @Vè(ÜSè é¸`VèÞ SèØ é`Vèõ Sèï é`Vèå@  ëpBVè& Sè  ëZBoSèê"ëDBVè Sè ë.BVè4 Sè. ëBK¯AG º!ÒSè´ A3)s ä'§ ²@ì« àér 9ÂþúYi ¶8CJ àcJ ¶!âSè° éD Vèu 
Sèo é3` $"Sè é"` ã SèÝ é` ¢ 
Sè é ` ± ,Sè« éï!3Vèp 
Sèj éÞ` ÿ ,Sèù éÍ`@_Sè@!HäVè 
Sè é«`! Ü ÷SèÖ é` K!SèE é` ê Sèä éx` I 
SèC ëjà/ë\VèÝ!`Sè× ëNVèßØ@ Ù ë@VèÙ@ û@2Vè#`  ë$!#¬! )çÇ@këVè] ISèW AMðDà !UF« Ü*( @k>G*X@@k-3Ë uÜfD!ÓwÎSèëìuØ DMä3Ò¦\B æ X ÂKGëEØ;Ã+à	@)ìàC A@CëEð+G  ÆD`ÿPê þ;ËtJïw@ "+!
EèAF'ÈØùÿÿë Mà §\M1!®Á4    &ÉØ GRÎ@	> Uà@&tP#u|` u(@	°ë2À~`` hà ³@Û'´  I
yj ÆA ÿ6?5è:§KØà| K½@` uExÀt6¿K u Ø  kN`@ä  ÿ6@	 h,	,tÿt0 d 0  (;ÑtR - î!Æ!A'bH}Ø n}x6°Dy}ï u/è ¬%3É"_<ÿt¾À;ÂtAù|èëb`ëYwEkb  @ ë
ipi }Ki+f Æ8CPxD('È M@ èüj	ØèÒéÿ3ÉGë(S3öB¯>Öt*'Òt${,h(¦x uBLVäÈ 6"MäÆ(_þ |ÀOLOj èpÿ#[ Ô Hÿv[Mh+Àæå+Àel]Â fIx À  ¯ ï| Ñ  ß iz ð y   «  #  4  E  V  g  x      Z / k  |     @S@ ¼  Þ  ø   [ O  0  Í { ¥  Ø  ¶  Ç  é  ú      -  >  O    `  q    Ý    ©  ·  Å @së_¿Vÿt$ñ@@0ô@	@èôÿÿj *^õnÿÿ^!tÌU;¯ <"®ìB+õ øëõ@¡¤P¯Zëø Ù[£ Ì" u; Ð@8Ô +ýKýÐè¬8èÿ½@ ¸K±DL Ç"  3ÿEè}ÜÉx;´A  	×Uà;ø#\# G<#l?$C í ;Gøwk¼ Ü@¸ë(¼ ¡ :½@È GXj³uÄEÈ]ÌtÆ ÆG+¿° Y+Â K# ÄËÂPIëÂ!úÝÿ «Â G`í OOëÂîùÝ+Â;Â GÂ  õBÇ+Â àKÂûþ#[}ÜÏE!# ú)ºÇ Á#}äcÏ\ï t| t %A#&AÀ_ CåU 	{ @+« äAøº!|+¯Ø ÛµµâV=h t
`$Þ  ,à %ô´æÿÇGd@#énàK° >V<à> Kà% % % >@#é/à\¯ >V4ª¥àE à, / , E@*éé àF« EV3à
E ¿à,  , E@* é^ªà ã À ãÈv ÈV^~óÿ` Au}à (  ( A@$ëdà   ã`<VM"Yëë@à & ê ~`&V'à«e à ( Á ( e@&G`G±~á zAO`ÉDÊ&Æ	 ;ÈtÆ`3ö95sÓ }àÿ³´#¼	ÏVèÐ{ F;`|é3ê&äEØ3ö4Tú(´ °H´Ê/âÖQ=Ïèo 4,Eä;ðt<@BÒH&ä B @B)É`EáÊH@EóÑ7tÎG³@7ÿPhÿC¢G`£Ë}¼EÀ'ÜMð"Ø8 tsÆ@ëmsEhgM `!ç'MóÂG`}´E°   sÅËD=³ËsÅES¯ç h¿ Gh@&ÿ ü#ê Mi5C¸Mð# ;(küc»;ø}G²?# #àc¯»C 'm  I+t~#À æ'H SèsèXHáèG(q;ø|ÍÀð]Ô °½E#èoEu1ho!àèo`(oA!èo `!	+"]èo Èo¸ÿè oûsÚÔèâéÿØ%G3öEô ï -`ï'x ï!Òty t3ÉëÊÿ(uÈ"D	ñLñÀÇ Eÿ |º&ÓË³¤ Öèh!_EÐ!.èw FÊ(zkÝ(z ¥Fõ]Â ù w ½  i  B  8 óÌì[t ¡gÄ$Ø#LV´$ä ÁD$t$¾ä%P!½°^`$3ÌèùÜ Ä@?Â D1,¹0 &S¶è0|Uh;êWD$ÆD$FÊ  (X$Hl$$ó«3É\$@ÛtRï.	é ;LHA;Ë|ï;êuRT$3ÉÂ|3+Îÿþz!T	!pDH5Ï|$ ( ?x;÷uAÂù0|Éë	 C t$ |$"Q  q 4	ÉÿÑ¿Ä t¿¼`	@H Ü`mP;Êu\¯È " Æ   ËÅbïÏÿßx`Aóz!üZ;ûuAJ\!ì+Óé_2  	V  !	 !   (r`ÌP$VßPè0 @t@ÄÆAl  AH$!¹ " 0 @ @WÀ`4 @@ Ç@A@ !ç<íuB¯@ çPD Ó$¹¨0×è%òÝÿ./~ <n" N"m@Ëè%¹ éa@\$U%4`7ÍR(  ð"B(ötítÎÕ$Æ Aêuó·`söu#! @ &$ $`8é	ÎèÈ¸ 2Àé ^¯Be3À«B ¶ !{,UËÿ!  0  $"b Ò%* E@ÊX  0`Ð"U)(!@ B $@ ; 8u â R ëÒÆQ½@J· 
@^8¦ª ÿuPVè	/! ¶aÞL$$!´aº 8BÕ þ`#uÆ÷ØàðbAZ O g.È@8!c @ot]ÇLÀ@ ¿p!µÿtE!)
Æðx<3ÒP"î·Af#
9 t;ÆtBÁ ú|äë }ÁâL +Â`RBg gËÿ ]/C 8R(ÿÒ3íÙ\$4ö@ &Uÿ@
ðVE~NO9¶ÁöÂ@tºèëºð G Àúr@ ` :ËD$4 FG0:ÐG,¶ )  -@=@w!þ FÖÏÿÐv àuðE;l$8% ÿ`ÂL!AAí2ö@0 t,@° @XB¨t NÁ@u " ;^koËfnFXZÉóæÀòXÈò,ÁPÿR@a©(b A #¨K·äAE°à?c@@Z:ÊK¹dÒ
ty8uQ4$1+² bÁîVÿP$ 'à5@RÀ51/ÿPP@¹@d`V1\ í	ÒyÂÁú z ¨@|D<"E+8 Rè/Ü  ¨ ,". (Bä@ÅBðc3ø% ÃG¼L$2Û3ö8Dþt9±Dôt@#"ë ; 0 G @#¿U@T$$;Âu"qõë¹@; t <`D³ 1 BÓÍ£Ï;õ# Í+O  y!àYÿ±À%L `,VUè½+e¡Í¯D#J®` Å2èl$(0µ &A6dt@*WèÞ UNWV0õ  ·&º3ídùÆE±Cî"ã^eó 29Ê%çH Eç¬E>%  è 
*f AðëDþ ä`,x·$trÿv=ht$0è@µ!% ­ Õ	(ùNÁ²È ÿtBGÁ59¶Øûu 0Ï@ÿ°e,P ûà	÷9) #P$¯E))ý5CE»å	±sì%y l%Ã\$ 3ö»f#v< »($ ff¯'q 3D)¹ÿ´EXÿR¶@2F;ð|Ø 7Ae!$E<!\!f ¶B%ÿP¾ñOA@³d©öúA1 CqÎj snà@{nØ   » ó#g P@@HP Éò^#vY@¨fZÁóY §Z#D$PèåNîCü <!l 8"4ÿÒ	É&íëM¶R'S h Ç Q À  È  Y Y:!nÂ  J X@ ]@Yp a@ }L$@Àw l Z (/À]v,!oì!¼#~õ  ó@`¡^Á ¥$ÿR¾A»G®¨ß&ü !7 uA4Ç#îuç$^ 3ÖLCßÀtDÈu  .ÇPr@M°) è!_][^)tÓéÌÌì$ÉÌD$ ÑB0F« »!aï`  
H !P !3 ¿* ®`0¿,À $ ¡  .À ( 0À , 2À`e¿4À 4 6À 8 8À < \á ºJBã L"ÄÌèÒ$$Ã*·À ìPàïLSUÁÇD$TVVW!h( ·3ÿ %y [ Ý@ó @ ,@ <@ L£3öx6þ}1ÆÎáÁøº!n ÓâTuÆt¼ L$æ«ðGÃÿ|»3É`1@ Á )`83À | |@ø|óëLAÑÂù|ÕT$­ É#V *Ïm,üÂ5?|ëÂë #ú $\_^][!kÑA Pá  SVW'$
2ÿ2Ûñÿy£ ¸CWx#$èwGêÿ)Ì¶Ï¶EÊ("k  à&iCC¿Ç@@ "Á$@@, 'ÂøÀ@´`+E³VT¾@( ~;ÀK`   KB9`N}Â+`	À`# ` CFX;×|M@Gÿ3É"HÁh'V(@R 7@;Á|;@ @+à lÇ9`_}@¾@X`U O U@K)hÈ @>;È}+@	Â`ø``#§ ê 	-¼ÎèfóBµ_¶Ã¶É^Á[-$!AgÅÛxT¿d"íÿxJÃâV±GËÂËÁøá  yIÉAD9\  ^	Du9¸8Y $3¸_ (_°@e_2À@!ýÌÌ$\$ D$óX¸.ç  @T©$ÝT@ó^Ø/ð!=w 0è 		/Ãw2ÀÃ°¢WV±$  áÒÐs ^éê¬sj` ìSÙ+o{ Q#:SÒF 
 U&G(Vs(t$Wý;ò|+ò .#£S$ ;Â|ú@ m +þ3À#Íf3ÉøuÅÏ+Ç3öø@7%3í9k´ - Gë $9(©Ðíx;k}4óÉ~,£	¯Íë3À!½4 °¨ 83Ûÿ|6wüÁîFµ #ÌiÌBZBAB#AÁEÇ
ß;ß}÷+Ê+óeoRDü@ ò' #àE ±   \CÄ ¾!0@÷@ä@Ñ ;!@ L)¿CÍ;Á_LÁ^C][Ä/ã
3öÿ~°ÿrU#_ÿ;Èw;Ús=Ç% B=
HÈø@ß+Ø%ÿÆ	&ü	IBÂ `I,5;ó'ï ©;÷N@Ç+Æ#á|W`èÁè1â `ß"("9X+Ò B"jXA  @BBs A  @ a+@  @a2èu¼@g æVÇ+Ñ+Æ '
 $ NÁ@"ëéÆ B` U7ßtïÿÿ¸%ÊèÔWã(Òd¡   Pì4Å "SVWPEôdTè:Ü 3ÛqDQ´ÌÆâÿ"]ä%l]ÀÁø	EÐ"n}ì}77 Ø7:3Ò%0ªUèö2ù=¨ 3!O (EÔ9FH fh% j"EäE Pèï   Ä;ÇsK;ØwGÈ¸?à+Ë÷éÁ+ÄÂÁè }Eà;}ØujMÀèD"=EÈ}Ä] dØEà $<ið@aóë%@. . cà.+u ¹#Bó¥}=¨Ü Ç@APÿuäÎ@å}ìè£êÿô÷ÿÿÎ$	PèOêÿfø  ¹ C ìÇð >8FTEÁÎ  ú Çü  # ¿`0;FL|/·FL  @@ 0Ë øÿÿ@tè¶ X `f÷Ø !ë3Â+ÂÀ'À ê  S4`"UèÁàÐ; @!! ;!"#!ÆÁ  ¬!§;ND[  HMÐf ü   
FP`@  3À ØjxÀÇA#¨Ö0 $U | ÞG  o¯ÁMÌÇ  1!ûÇ$ 	 x "ÁàÂ@>, }V "VÉ@º+z Eð÷âÁ÷ÙÈQèæÄ  "KUàÄM@Ò9Eð~[}ð;EÐ}E~H#î;uèK¯ÇiÀ@`È¿@
ÆA@Aðïuå!9}uè!øMè L @A+Ç|«BMÌ 6ÇKø @PVÿR Vè` +ûb÷ï â t9{ØuÌGðjP1©  5¿Gø6 Ra PWÿV fëuÏ]ä3å k?Ð`Xâø=À vÿ8×= #¦r2öÃt Cü;Ãr  +-As û#À<ØSèÃI3ÀMôd,e  Y_=  D5(BÈU(D?]Â§%à ìS$û$Ë\y,ÿPÿÐt Î¶ÀPètÕ&ý1ÿP·ÀÎPèØs . 2@;/ØF+Æ@øt  @ ^%¼ÿ`,ñ &Þ57oD$ Ø=;WÀ0PfÖD$ÿ( âÄ  )¬   +  Ð +	h¨6sPè}ÇUì<ô nå p%¥ På 
	ÙhÃ;C` ÄPè4XÞÿ$EØÇ7í  PMÄè®PÞÿ  ÆXèÑõ@" 17  7»èÏÝ 4MèTÆ=j hXDiNj$EÄ 67C ·åÞÿ)®ó WiÜ!  8¢
À<PEìèçÁFFEø¸B á}ð fÇE,#U
1.¥w<ÇG{ @>&G&( E&MG@	fOMfGO@ »@, ~d3ÿ 	 ÷´ ~!Çh2 çVèJ0r¸ !Æ@à  )@ M  A"Ø :M;`|©#Zuì ëVWè9úßÿW;ÆtUè Ù Ê¾
 x !
ÇEH7èb=LM°è,îÜ !t@ `Äè ,âÀå]'ôèÁÀ`T3öë¬"¶ï ©áïì máññHmè©¡ªWCNKAªÿu¡úèäA¯t
¿$Ö é "ÇEì ..EÆEð@ ¬  ¼  Ì ÜVM 	üÆE èæäý!ðu!@q"èC%û!" ¶­DÊë 3ÿ3öÉ¸!ø øDµ zPèÙ¿`ç Ç   F-|áà §%á%q@]aN5aANèÝì!7 Çá7A6ãæ/ Þá/ì@Vã	ñM´è¡(EVAWÁ(M´Á%áâa%¾A%ëÿuE´ÎÿuPè5 ð,@ÇE´`§`@§àè5@§ Æà§`¦ hß 3ìè9q#Ê(Óè ÛìBÃ ¬ä  #Ú#¿¨ÞÙxI¯ð µø  hg( YÑC´b"hP¿ hàp j	j0E ¢÷èÁ¼%M èäB@¾3¥ !à èÝäèÿë -
ËPè®öÿô eÉuÿ³Ô#Aè»ÎíÿÈ"õ `ù u»Ð 4[@#øtÆEó3Bu  c§%° ³R' À tfAY·Ç·É'lf½² µ´ ÇÄ @ -4Â@Áø < ¼ %¯ÆfÂ ¸ ÿ*@ ¾  ( °@
ú uy}ó us¸ ÈÀëeÇE@G ¸þ(ÔÇE;c ¾( ÇEÄ,
ªÇEÈ 8qÇEÌ@5ÇE<¢   Ô Ø@àa `a $° Ì7E#5È }Æ¹ Sà+Èá IëüAÂMè,ì@Üº< `Û¯Ç¯à!J
}Á}L%AAN |H 	È½¬ 0   ½VÛà   uà  <` 3 l`Jøv
4Å$ IÂ¿À¥øç¥OÏüGúÇ\0RIFF}EÇà FWAVE3ÉD ©8:óÀ0:æ	|òEìÀë 	ÇÀ}è@A	MäþÇÜ >j©0MäUÜjRÇEÜfm8}àIH  A¼VR3H	P ;÷}ätÿ(çBç QU+ i³eþ ?FMjèÈÜ"Ðà&÷ÇEN(!° ¨#/ A0  "á $ÂèÇ4/¼!WMÜ+j O data V@V ß¯AÁî!«µp Ht Nì g ÇBÀø| a	}+Ñ;ÖÇE p OÖIô,(ìÒ~t,O `³0ö~KEE¸Eè÷þq U¸RVQ!±QP;tðîÿ6ýY]Eë%£&õ;0CÇ;Î|Á ÇUM@f«M m;Ê|  *`Ê Ãøw8¶¤ª ÿ$ ÇEì È ë& Erë " ë2ª ¸B8MóDÁë/D V / ² Ë5]ì@'©°j Q $$­è[Xþÿ  F }.Å	;ò}E¸ëØd¹¯cÇ!à1ÂÚ#ÔPWù*N@­a` al;Ê­+Ýÿuuj Vè'È DCÄOä¸ Ê;÷ùFÇF ¶c9~95F,EMHÈFÀ"ðÆÿ #V~% @E4DÎ *8M4à* |à* d*hMdà
*~. X [u`0 G±@à6c¿à6 Ä Å6 È 	@à6céà6 ô ,6 ø 	@à6dà6Wé6}0 @à6d=à6 T"56 X 	@à
6~ !h #h]Ãfsmpl]cè8óSÿu#t HuI>c¾"õ(TèÞ   & 3öèðpî(u+rE + (	 F+;ðrè}¨ÿtE°E¨Çò 'èÒÝÿ^*t¨r@^ @   E@aPÿK 1A¶#'AÃ  gTçO3Ù'OÚµFÛéË G½,µ»'l ¥GëGþf§ (  1  :  I     @ ÌÌÌT$V3öWB|y|1ú!;úr+Ñ¾  { $OI1Aür_^)
úA+ùfd
@ð@ ²2fïÈHÐLà  à àþ |Ô`= sà Ul$ìp(© ~è©ìdÈ¦El#õè£ Ñ.ãMx') ²Tì]|EðÁ#ïM¨1]Üôü
DEäT :04J¾@Ïu9ÿÐ6Ê!{¾LjUu 
EðÁàf¼0VD¶`   P`R Bn @-«"{ÿPH$Û É =3Û ?¿0T 1EØAÿ%¶Àf%@.À; @@@;  EäÿR@E	IÛyMä3À$gDEèë;ÙÃ6p àÇEè!`S CÀT :àT  <TLëàQ@@¾ J9Mä;Uè|;Ñ|;]ìG%<3ÀéY Ð]èÛ#­;à EØ3ÿPþU¤ÒUð~C2§à3Òa5 ýf9u%ëAà9D FEìu
9L EGÂ;}¤|Ö A QÇEÌ Ù#/)0@ Ô  3'j|AM  43k M&>(?`r pÁKÀ9}#û	ÌèÒ MìG WÁ /	;}Ø|ÐÿÝ R}ÐÃ"hàj SRÿuÜ2âÿu¨èÝîÿfnÃÙ_üMð[ù
j ÁáìÁL!]`ÎòF«
è¢ôöÿE`ÇEh NOÌÙ]dè\@uEè &Ù E` &<·Ed ,è6 %ÀëvµX[À]¨VQ  0$Wÿuð Sè	òÿÀ!Gà! PÀ! r !!¬ ¬"lÁâ ÿ´2B¼èÉ!EÐÀ="W Z@ø) $ 
à Gà ¬è@3Mð!
 Çá
 }á ó+â!D @¨ ÿ «AFîAAÙ]hèG@M]ØÛ~7O 5WM¤ÏocvÁÀÇ9|@5è@2M¤ÇRÙ3.^¬Pu;Ï4qE´E°f}¶fÇE+E([ÄEÊ ±!¬&1@û &·1C@5@CÝ  ¶ ! XAÐE¸1\ 	E¼ 	 ]`	 ½  ` 	 Y 	 d`	 Ä@= h 
 = È ) j 
 s 	 k 	M¬EË3À ´EÌPÇE°!û èüíý!	ðuEu¬Eu j   Bá <  ÿ¼6Ñ~EE81ÍE8¼=>ÝÖE<uDE\!f 6, Ý
  è@× w èÓ!G ° 0>a%&L1Ì?è]ÌAA`@¡a;}È ýÆEË#]¬0]3jMÔ¸«ªª*SÑú#]Vx=UUUÓB$Áà= ó0°)3ëÈ"=óMl&ôÀ´ ep]Â Vñ{ ÇE© ÇFa-ÇF54$ÿu:ËF³ÿUU ¢h4[ÿüWèXJ F_7pF°@/æ ¢à _   à_Ðàÿ \	°Áç>~çj<èá®`ï.Ìÿ%TÁH%E t:*HfÇ@;Dj è±à/tñL$/AÈÐë'Ñ C`8ÂàÌ  jLèqà3?Vj<ñè. BÐ!¤Ò ´J t!K ¸ J@¸`
Â^»ü  D «ÀtÇ <=QPIHÂauàäàÇ Ä IH9  ?  X@?à ¨à?Ç d=CpA#c @ £Hài  oÇ Ä<îA%; -H@-  ï @oàïÇ |à?@9  ?  ¯à_$A@IHà/  à/àÇ $>À¯àOàI   ¿ tAOà¿!/ T o@Gá/ / !ÿà /    _à	71  èÓ¿æÿ ¼ ¯!O áO O àÏ  pá¯  Á? x.Á/" ,"?â t ÿà  ä@áo  !¿á#?è oàO o 0 Oà!¯  à o ÿ X /àß OF¾à O / L à / ÏD àï |àhà?,à 0à? Làøà_ à ¼à_ ôà ´áà xà @à <ã à? (à¿ à_ à? èà|$ ÇtjjQè	!Ç:å¦;à  @é à @ Éà @ ©à @ à ,@ ià @ Ià V<Ã Iq;÷tfÎj ÿÆ@;÷uñ(ß Å
`  V@+	wNèÓ9]Førj@Pÿ6èì`üÇF)±~ÇF*9  r6j<jWÆ èÆ% ]å h  Áé¨Ûèÿ  q9IP 3üæ  yNÎFLL±^é£O÷@4$!`2 p@è ± ABp¨Â VJoFÆ@ NèMðéÿ~w08â 1/
VÏèèÌÿÿ¶.öuî_à K@  '	¸K u¹04+o @à _ q!^yÇ$þ `M*+NGF ONFG <¨N F   g ù!±l3¤ 
è}óëÿ Y A/èÚá/@ Há?@ àÜà/!@¢NA/@á/!ïùG1]	ÎG@F Ø+PèþÊþÿ Îø`nÐþÿ·À Vñ!^!Zÿ0èÀî".Êÿ @?Èl,ÚðÁV!O0áÆ!- A¶ Pÿ  û
1¦îÿÃAV@%´$,Q B@JJ`  "O Èàÿ (àÿ@ ¸àÑ H¸Á  uÆÂ JB@ óÐ~&½Áê`  ïÿv@ï
vÿvÿvè©n/F8 t5ë@0èDæÜÿ@¦à
/ y@/Nhøª;è 'À @¯ xà¯`?"4  urèPAf^Ù");Át!"è	íÿ à !ONDÇÌK!u  !n éêCSà @ àâ ? ¨B¡#o@â?!©c[ AbAÿH à ¿F@¿" 4#gN^-À @oÈßâ¯ /ÿv(@/v$ÿv ÿv þàûMý`B ÀB@?8ãà? Vq ó^BQBKBÀq ¯"òyBðWè~#«#FG 
NOG#¢NO G _N AÊ`  ?àï Ã@¯NôVÂ0Bèøu! ÇØ!3@ #Æ ë` @,Ày 3É@@dà_AO°ä maDÏ!F!PÏîë#p `NèpëéäÜ ï V$ßÈ!wäßÿq! ÿ!1 I@QMêÿÁ*` @ 0  30 BckãÜà!Ahâá@ ¸à@Á ? !AÂADÐè&à D Æ¤&Lv@? Èà?ÏÀ#§ + ó# È£ hC Z¼ sÏ3+Êè£	 3!  & #`h  QD{<ð eSr P G½ GÀ  OVW Q  BCfE Ab¥Æáb@Ï xàÏ@ ¸â¯ ÿ  ï"¿%¯ ìVó#o@ão@?Øçáo`,#ÍBBà $ïJÿr]8  ùUì7º'd¡B7º 7°·½÷·ÁEðuÞ~  ,
@ ÿsÈè¶1=Æ#3((2üuÎÿ0EìPè¸Y 
vèë H> Ä95 ü 1 ÿèH£èHÿuHF ª@@Eð @{ óuz Hòdå]è gà[ßxdt`ß @)àßÃàßÊ! à%ß
S\$UWéûA	uYVÿwÍèäA?si·ÇÉé· 4à SAl =  Êß t©^_][!UO°Óâ/ â/eðù}äEðW+òÁþuàuöó)\O_+ËÁù;Î  +Ú¹ ·
?ÁûÁ+Ã;Æsóð3_+_@ÃÑè+ÈÃM3É9]CÈ;ÊCÑ" P8èOÝÿÿu8ub +GÁø6Í]èEVQèöî ëQ , W<pÿwèRvÙÿEÄÆ@WP!\ è6@O )+Á ^ ÿ   Xð3@Qèó¶&J?+ÃG :³G_éû 8> <`MäP	èË 'j j è¸ô!üË+Èas{M	Mµ 39»È@WQSPè¶u  yE  v+ð % WEPBè# Ò !ÛOÄ, -3Ò+:h!+ñÆÁî;ÈGóötiEB3òI;ÖuöëZ @i W!` S#mE+ðSVè9 | Î !LðVP+ÞSÿ, ZÄ$U
;Èt!é 1$¡ *Â;ÈuòJYMà7&ö#µ ¢_ Ðâ_ $â_
+w]ÁþuZÅ!
W"`+ÊUÁù;Ë"`!´ ¸!©	+ÑÁú+Â;ÃâaW+Ñ"; BÂbh Â!"h UBhEì!9CÁÁàbgçgM+O mb^MèÁá7SQ!! ènéæ.JÆE !a  ' !ÀBm  Eè"QÃ@ ZE`$Ât q@"â
tØÂt~´"tM ¡ÁÁã"z	Ù_Oéÿ "Îây Q ,by>ò"y ÊBy!'sz!Â@
MÐ&,
MÔJMØJ;eÜË ÖMäbW ¡PèÖè ½ Gâ +Cq!BÐPS#5ès@"Mä  P@/ÁP þèÈøAë_"óòQ@| ZEÐ'" Ô-Â R ÏREØ+ó(BVEÜèa Q +"  V@L[Îæ9ÐPEQPèj ]u!Y4EÁæw0â
zg' ß5 ¬2ÿÔõ2 ôÏ ?  ¬ð T_òß °óï Ìà5?4à¿ Âï v   Pà ¿ 85à ¸à¿ dó_4 Øô& ÈáO l Ïà¯ o=ó7wöß À Oà /Ç pB IøÏ  à!Oà O! ô!àÏ!¿  Âáß o h ?à o / üà& T /à ¿  #?à!/ B?á/ Ç È ?Àß @@Ï $Y7 $ÀñâÏ ¤á  ã/  H@ã! (â&? á& ð @ßâ ¯ Ü ïà¯!_ ` ¯á_ Ï ø ?à#o  ào  D@oá?  Ôà? ¯ 8ã? ?  âo  Ïà Ü÷o `ö/ äÏ  Hà Ôà à@ÿá? ¤à¿ à¿ 4à? ¸à à à_Øá Àà? à ðà  à là Pà à_ à üáÿ Ðáß $øÏ¥" ìà? \à?  ç °à? ÌàO ðëï ëï ñ+Þ)ÃÁà+wèo
Ýÿ* í àVSÿv]ìÿvèh-# Fm£~+ø++øÿÁÿ+ CPèQ©+,E-¡ F-¡»F^,ôd*¹ Y_^l>Eì 3-° èM°  6k6ç  ¿Ôïà¿]SèÊ5J *ãì øÿuì}èVW ® Ç!9Qzß*¯N¸«ªª*+,÷éÑúÊÁéÊM  %5+È`"÷éj ÂÁèÂP ?ZÇ+h +P[ ×I`>àßj!Cÿuèè : 7`Ý)æ ÝÌÌSU t$ùèñ!,A7ØOÍÖR!jö/¸?àl+Í÷éÁúòÁîòí ¨O`@h7À@ ¬Uè®`piD$@!GiÆÀ
_^pu   SUl$VWU 4Jà-âa;  !; ! Àt" á87è!m!ý Å v`à   Us? 0áÿ"¿	k]TSè´"ºÆE47"}ìV" Â"¾³ÝB¸1Ã0+NBÆ÷é "Â ÿ.¡B#"â ×  D V @Pè¡ 7 F /Mêbçi¦Ýÿ;FkETÇ" :òâè 1 7b
äb
` ï Pà ïi]Ow òÁàò  òUàòÂ5à ò`Û¥ÀÛiE`hà!Þ R :`Þ?ãàÞ ß pàß ù!tè[£Î ØCÎ]è2@ wã Î7è@Ô G! #;0ì+Î¸OìÄNC(áÆ è1@;uìtNè¶3¯Îè Æ4 ué7`5 "¾ Î#ò 4à<PVègcF!Þ 4cBkEè`"³áæj4 ¸ ÿ#ï /7a9âaß à!ÿÛÇBÈ è/² è ÝP­àýÍÜ" _ ÿË+Î!@ú â Á@ú<;ótD7sNèø¾@÷;óuñ öCËÀö à8 öp`ö%ÃMì@Á#°EèÀàÿÿ@ÿìè/@ÿ áàÿ °àÿ æeÏJ QÌFb$8 V#É #Ñ% ~@þ%Ëgfffå ËÁúåÌ &#æ$@#!Ù @¥  A åÍ eÄ$ `åÍ  @Ý Q :%`Ý[à`ÝÌÌß Ðàßõ¿ñu5¿#g2goÿcÁ&º¢ë&ä´ÎÖ!î Fbìçs$ DPèà¡gpçðÃû$~çrõ# § 8`Æß Æà  Ï ðàÏç% @Ï<Å!§ +øÁçWè)Õ% Õ (=àÕèÚ Õ%$IÄ åÑå  áÐ @ìó  ì M!¬  èÍ o +Á(màôèg ² @`ôÞàôïÕè!o:üe¤ &iìèo 
`Ý ÝÈo 5àÔ (!"¥A÷éj8 â§äýÆ@î"oÝ ê +ÃFjàú â³ 8!y ÿ$  F C`÷§Ý ÷ï 0àïâ¯Xo ÿ%(#â¦åXÙ!Ï7¸ë ê(,$ER@Ð  Ð$Ç%Zu W$ÍVè7à0eh&Ôà2$áü@»iE`hËEìÀå ¯M µèèò. 8j è¯Ü ÷À SÙe)kÕs)||$÷ê(×;Çs]+3`&÷î¸UUU .+Á ùD++'íù3É &ºUUUÆ6êÐÆ;ÖYMÏCùËWèõÿÿé@Iïà
ç£ s _ @' Àiõà`(`@C @6à hà@F!à
 ÝáZ kà  @I²` A¯+¡¯ç²!a+s`(! Ã0@ Êkáá	² k )¡! Á!@7á! fàà @I_àÉcÀ@( /9ªáÀ `) á Á@7à ¶àI`âï@ùá ÐB_@' ÄNì@á> +( á =@6à øàA/â_è!/@@' ªªª
@à`(  ÁÍªªª
àhöã@H)áÈ8 @' !ý @à`( £ÌÌÌà Øà V)L$W~ÇV+Â9þ	;ÁsD+VS»ÿ;AAr Ã;jÁsä ~'?Áÿ3ÉÇ$vØÇ;ßDv}Ä	ÎRèT÷ÿÿ[_^/} Ìà @ÿF`ÿõ{+÷÷îÖ.¤ Á&³¢!Æsf+{Ô÷ï¸'¸×@á þ["Ã<1`Y3É!
 Õ@+¡@<á  ¤å@ à @ àd+;`oà +à* Ñà	Føa?à	Ç!@@) '(  A> á>`@-Á= Á=@;á=!øá=ÌÌ¸èDÃ   ¸ÈEà3à à/4à$,àÔ1ààFà ¨à ¬àOô0à/2à ào ¼à/ ìà/ì+à?,<à¬-à Ìàÿ à_ DàOÜ/à?`Cà á¸Bà tà Dà¿d*à/ Là ðàO (à.à? dà 4à¿ ´à  á¯ \á tá¿ à  â_ @âO °à àß ,àÿGàÏ <à |à¿ Ìà¯ á¿ Tá |à $â ¤á/ á¿ à¯ là/ Xá xàÿ <àO à pá Ôào üà/ ´àÏ 8à? Ðá¯ à äà \á ,âO Äàü?á¯ð9à °à pà øã¯ hà;àO pã@à:à >à Aà Xà_  à °à Èào=àO 8à (á èà_ Èà¯ à¯ à¯à hà_ Xà? àà °à/ 0áO èà_ Èàß @à8àÿ ààÀ7à à Pà 0à/è6à? xàä  à/ 0á_05àO Xà/ à (â¯ à/ Èà/(¿V3.ýWW(º;÷tT¡Üÿ4  T÷uê~KO<ô×íO	Ç0 ÇC  7ü  9T Ã§Ú` à o P o Töª@h  h ñ hK.Àh K1ã/r nàhD$2SøtNøtIøtDøt?ø	t:ø
t5øt0øt+øt&øt!øtøtøtøtøtøt2ÀÃ°H§ ^ð ,ô/Ù]älø 
KâMà0iMÈÁøEÐEÌÀy	/þjÎþÿëPèòÑþÿàT 02h!; èc  EØè~ 3ÉEÔ3ÒMð9Ü 	3ÿ3öé /»ì >MìMè6+Áø:ý~g@?pÞ+3]ðÁ}ð]ð¸¨!©u-¸	 DtÿEè9@~`ëÿEì9``FÇ;ó|À}ì]ä s3ÿë}ØuÔ3 èBðùt¹ V !ú¸@
EÐ>UÔ!¨ A <
EÔ;ÊMðMÁìA$ÀuRèü]Á W!+ÞfÀVjèÐ ë2è\ MÐ!91© ÉyMàè-÷2¦ûâÃù@}Eà¨ò LÈÿÁ|8  ðÁà	0bº` Tn\$UéVWû|2ÀL9Â ¶D$(3Éû\$EÁ-+0L$  , L$(Q $ D$¨""
QpVÿpè-2y ø L;þt9_u"Ð$8Gu ,9Gu 09t 4Ûê ïELì  `,  P!$«: Q @dðt$(F+FQ+QN-­BÁ-Á	ÂsúÿÿÿvíµRè¼éÿÿ-j (§ Æ T  <,VW ­ b<Pè `L$< 	$ÄIPèÖ4þà1@5ÿp %8WPèe 4 ,l$ (Ë ²  	PèZçÿ , (Ïè|åÿ°ábË`*jW 4Á q´ÕÿM°¡a¬  ìA/Vq	 b !;÷Þ 	@¼öÇ !>@Ó#ñP N
PN	èeÐæÿ; 
uÿF^ÄÂRO àO à O `O  N@O àO O àOSVÙ]s{K4WèëØÿÐ¹þÿÿC +È#G/N¨¦ÿü@C WBC@Àxr s@ë  ë `Ab `  @#ó@ë `ëyÏ`ë `%¯ àíÄï  äïD¡¤P3ÅEðVWPEôd£ U  0<#{}¸p"Ô vWEØPèQ  @#   @¡jPMÄè?wÜÿPÏÆ#³èÓÝÿ@&zEì , ÿ  %r>@ .ÿuØèpçffë-jhÈS@.üv`B .DYèE  <ÿè¾ L`hZà ~°èÀà ;F¸èQ`;°è@4ä3Mð3Íèûq å]ð¡U¬$\ jì¤ Ûjÿhðá* XÁ*  &'á.½¬ °@´ }à?!T87'/@  ^À`Kj Pè9RÞÿÀ 6Eð'6Ø]ìj&8MÇE &B@r è+·ÙÿEM¤Çè¹ öM¸au ­` Ì è¡  @)ðuðQ`IaÿpuðP;¹	èã U ¹T6>+Ê$¨" Oâ 8
EìuìË3P;Vè[@2 Ð`1CâÉVÉéOB?Eè ¬BU x&Å8A! ;Át'(¹
Ýÿ$÷  ÞE "I¤èE|ßÿ}ìØSÏèÚbFì ð9þ!FO~#NQUä!þ	{C!j   ³Â9ÖBPQSè	;uèÄÀu!ýUä;rëy÷M è$zq ©ì;0()Æ(E¸;ðtVÈè ]àEPAag}%"Ð¹ÖP^á!áèa¡èÿ@¤è÷ ! s@ ¡ß	;Èt1Qèj"EÄÎ;ðuìPèm @âÉ[B"Í-o ¥B³æÝÉ?u"æ=À vÿ iÀ(%= $Ýr.H#;Èw QèÐi { È kÉu 8#A#ààHü GPè¯  @Àu¨ h  $¤@`o  ÀoÁà=ào ` Nào ?  àoRªÀoiÀ"{àoðhào Ï  àoQjEo &g!>#K èèçÿ ÷ 'æ ÃàÈh!î  S(h<"ê @V°T IX ;Ât"W¸@
@	;û|
;Îv%ß  uà_µH >^L  ]ëÌ¹¸õ v=´ "æÁt1T&á'õW:y9xu
9pu9P<ì ;Áuë5ª )9$_H@ K@ uù  °2Éð°
3É<ÁÉÀÃ@ÌSU@XéW~#U~E6z  Z@
 *§Ç;ßBÃPVRè~Ö"<#;ßrw!CE0Pè` Ö(DÀt	('ú'¤ 2À@ k@ V±IãW¾\&  (à ï a ÏK 6¾á  yIÉAD| tpÇà" ç"OÏG@"|¸¿4Y   tGü+w3öÆ`*Ö)8U  fþ "}H4FJüH8
Â  ÓßÇ÷@)@ _^Ãcx@4|BHùÿ 7PÒx0ú+Éx'ù"H   @H   / 08 ÀÃ,¶Aà "NWE 8DJ  $JÇEm®;} tbSVO8è$xO$è~`èv O	 IÇG  ;Gt! fcÆ;wuîÿwèîe Wèè !¢
û;] u£^[_]à'ù_&ñótfÎ#2Æ@;ó. =I_^[ÃÆ àÊ` #'HI×;Hàï`L$VPq;Ö}°^Ã~2À^ÃPq;Ö|ìð)B;A^àA ; #C=;@|CT;@v.¡iUì(`Öÿ¯ V¨çüMìèrnR%± 'd!H ø
D$ÿ$þ -Ñ ;  ¾  é1 h°Ú;(ñäè*Üÿ'¯ë_=Ô@F@uhà èëhpÛ þ`+j(EäP@yØ[ß( äè)j¾
@` Ð à ` É4 `4 À4 £ 4 K@4 	 /é h Ü  4à 0  `i n 4 @4&: ëih 1 bà1 `1 < 1ä  @1 7à  0à1 `1 
 1 ²@1% ë¾BÒ@é  Æç ^Áf¨ü ¯ åý ¹  Ì   @ ³ @ O   bh  ¸   è'=ÔÄ$ SU¬$$ yãVWl$ ] M+Ë%ü   ÷é. ;:¶òÁîòteCþ3ÛxücòE#Á +;Pø#ñ 4Cñ /#Ù+#ñ &"ê  @Hô   / 0xä u;ËGÙÀ8ïuª n r kù î.ff e"wÈÿ|$$¹ !92Òó«3ÿT$öî 3í#?9D+j®t+L+  JeÝI%ä 3ù%- T+ú@u'|+  ~   $EÁÁàÆ|$ÿ~.TëP úAt 6 < /  u5ÁáT$$Î
 ô.a*ä +zÿ+ÁÃD++AA$Ç+%[   ¹ GÅ8!2+Ëa÷éá};þ ?  ñl$M!´
ý|Òâ-| E ;l/Î¿  `K3Û3,&+M!×U	ÂÁèÂts3ö%Z<0uFU-8Æ'©0HÈf I8AÈ@  Ø    èó~@0 ,fÖAø'¸ÕEÈOî8ëC g ¸] lG÷éÆ8pÜ;ùrb|Ã&ÿ[3ÌèN%wÄB«å0 Ud äìBÌ Å+%ä§u@æp!&t@½x N ÷é}üÿ$®	Ç H äE¸`ä
MÈfsÙf~É  Ø`ñ îEèùA÷²A·EÔ="Ð ¤ }Ì@	ø@}Ø 	  	}ÈBûw~}¸ uxÁ%  'ÈHÈð@+È+MÐ@¼Pè²½@0 ÐbMMÜ"FFM EÈ  @  ÇE`EØ © E  ©EèÁEME .ÖE°Pè\ Uá C! Ç¡;ØðB66aH|AB AN `+Ë`P¸Aå ÷âOPÿµ@(Sèq¬æÿ@ÌÄ,nØ@FN~ùÛtq+ûI ï]ÆÂ(ù^ÚJñk¢B +# ÷2öÃt«ÀCü;Ãr +Øûs û#ÀB-nè^Gáìfo1Éb %oâ S6oJU0µ<+C84 O+OÁù;Ès	G+G 3öÀt3(
K8W±²!®A"SB #8B ! ABFB0;ðrÏ(,,s¥­ o V*ÇÙ$±   U#ÒÅÍ)ýÐ¨4ÁúWá$³";ª ª _+ÿwVUS3³(è«º.	L$ WI èþo4tøÿt8GP èÛ~Üÿ¸B?	;ðLÆPGP*°$èÕ¶A'  # mß_] ¨+BD$_]Æ  `Ã Úã R  W£ãh((  èV\!aøÄ}ð¨H *wÆ(!ÎÇ ;/è´VçÿÆ  47×	·Dq 3Àë$ÂuEðP +3 IÿsSè¡Ó/ì Ð¹F+ò
FS¹ þ îh¡÷UìäøìL!ø2ÉVWL$!t,j@:þ%î &`0+@l!Ø{ "FÀx$È5áÁÁù N!ÃDUÂ@< @ ,~-DN0©* VFU#ÎT$;Ð "»ø`_ÁÏj Fèÿò5ÿÇ &l  	 fÇG ÇG#Â ÿ+  HÛ ÆG(       gøÇG    , %  $   0   '`?'î#ÊàØfH	  fH·À *W3ÉF*fÒG G ·ÂIÈ3Ò¿ÁGF÷%½ À fRÝ	Áâ
ÒHÐ ì ?F!Á! 	V~± 4Fø!6 ó)N»A³6ãJ'^WÀD$(3½òD$4`Dè}[!w=Ð*òl$@ \$0 'Du8  f/Ù W 	 é%Ö 	 °&=@Ã  Åu	 Ý 5(¨v5óG(ÎZÀfnm i^È X"9 óæíòYÈ éòXë| Ì ³ D%È§`d ;È(Ã . É . Á .áò,ÀvH  Ð  Ò  Ô  Ú AT$ v)?(Ä S Ð@wó ê*â D@ º©_""ë(Æ  HZ j^Á(Êò\Ë ^ Á  · YÁèÝ`3ÆÏ)wèt|2ÕâÛñÿÆ"{âG0" !a  "53Ò$Ø";& 
#FHÂë@â 4!@ A@#=F!'F!(AVaå ^!t  ¹!"L$  a±(Ñ!# Â-éGEFéK!4ÁóYl!ß TÀ[À qE! ó^O~ !æXÈ]ó,Éù%p;Ç FCÀ;~j B~èB!< Ð"ôÉ Þ Ç"³"QÇBC¼ B¼ B¼ Bc|ÆB#¼ B¼ B¼ B¼ B¼ B¼B$#& ¼ Fã¼Àx&ä	ã¼ 1B¿f9:B"B & #àMÈAÉBÇ+Fa ma¢HÁ '  ë~|a  $°#º%K ìÀpëbxCº  "^?è !!$Þtn"^Ùâ^yä ä ä	 Çe5 Ó"WÇG0!©  @¢ ª @¦IÖà¦ à¦yà¦ÜØà\¦B-6;³F~ùÿ:\FÓ ÂèZ` Vñèèa? Dæýÿ^Étjÿ¨õ Q(5t¼Wþp t:QÄäñÿÿ¹l 0%FPè p=P;ÁË#ÿ0ÿS!pÝÿ9uÆ¹¨ 0èÚq%b  
 t¹@è7âq Ç @  Ç@ 2P[Y À  ¸@
¹ütðÁ¹è 3è7s ¹àY{èþZÀ	º@e@ O@ N 	 ä % @y@è½á@y ì E  @ 	 ¹¤xéïÙq(Òà h ) @èÍÆÿ) Âó ®ÌT$V2¨u5äáþ	 ;ÎuC: 1´ N/6ô A(t	È`u÷
^Ãàþ;puÈ#'  @Htò@4 Y ì3$Ò3-± ªE<+EJ;ÈwEP+EL*@ `! 8!ÅM<P+Ê/YQRPÿ,E<ü!ÅuLPCPÿuPVè³æÿMP+Æ H`5à1 P@18Ä(Ç!0¬\Pè « |$ÒMà ^[;È|à HE]; ÂÿI4A29Q0u  KA0!9Ç @  1@!<@@@@@ .a0`\ #u#A¼@b àb@"L@@@@@`bÿ 5'eUD@eU@e  @  6@"O@@@@@ .`È  ÿø5ªo ô 	@o  ¿@o&(`  @@"Y@@@@@ . j` "o%±ÁDI v$$PT$è_þ [@ L® 5öt3VBì÷ÚÒ#ÐRèâÿÿÿNAì÷ÙÉ#ÈQ$ Î j jVèTÊcI7à V K ¹F<ÿGûDÁ pæþFì÷Þö#ðt5NàUàài dà iêÉ icTÁ,é(Úßÿ@»@ 	ì$þ  SRxUVW¹@'©X ÏÿP$è-ßí~-+ÏÏVÿR(x ufX*¹ !èf9H*r	¹ÿ!fH*F;õ|Õ!=3íl'Dì!º1Ø+Áù [É~{D  <¨!À@@s Ø sÛ~E.   òÿ@$à hàó|Í @ @R 2|QuDÇ Ao
3öè.ÆÿÀ~6A J Ê Þ¿pL"<SèÈIÏFèP 4;ð|Ü[áÅ Q4X f!GqÇ&)4a	 Íè5îr Ø"Y x  tf|$%#Íèªór =$L
 > uL&èÜÿ>?. C!Òÿè[ööÿ4fÇC=Anª ¡  ¬ 3À  ¨ ¸ !Ç 
@ Æ 	ÇD@ Æ¤ @6 ® @cÿP" ËPUè$=	 SWUè<.öÿ!+BPUËèÉÌÿë"0·=4 =`¯   iÝÿÇ-· ÌÆ!
û!0ArYÂãl  á/4ÖA/íá/zòA/tNá+Ôa+è[öÞÿà	ÎU<Îm-àÎúàÎÌhà	Î\ÿÿà Îà¿J!ÔEìà¿ºñà¿ ÄÀ¿ë?!òá;¿­,à¿ :à¿ à¿"WÛ+Ô@D HHó\È/Ëró_0-z-ú@]T-ì "% #Ð(ÂT©@   'v+ð Ñ-}w -Ì]Kõ-Ù b Ã#DÕ  `!÷À DØíäC $3ÿi6ÿ4/%Z"¦F3ÉÒ~;-uDAÀ ;Ê|ó3À?¹è]s,_2à0 z Do@9 1À9ëyC!èt@ë²¾c"= <§ ¤i~ëà& @à& 2[#HPSè¨*I2VSèM& C>àx$ ÇÿRvÿÿbNiUd>»C$Cy&Ýx t @ïÍè\ ï 7!8~ àUè%ÀUèÊàUèõ#`ëuC`{@  BÆà'¸dltAÀfAO ?ÁOù[ `¾6 Wá~H@4 À4ë9× ÄáDUèc)¡DUèàÁ 3à ÁWÿÿÁA3{	ù7Æ·Ö%E2BÐÆð±;Æuç&¿7Îá"@Æ%ÿÿÿ¿é   @È`$  $ÝÁþæÿ?  ÞÁã&ð Ê@0ÿ?Â 0 À+Ë , Â Q 7ôáötOètÀr îuó=~+Æé$rdêAÁ!Ã ?¨ <t<zAgÀ @®w7bÆo÷ÂGPuÊÂá+ö± h ç'¿Jâ5_Á^é rS¯<¿Vd¡   PQW¡¤P3ô{!E;uD9Uu?ÿr>E|Åè©"@"g>`@-óc§*Ôô&4$Â ;EtXx Èu<Pz u@u(Ð	töëP`;BuÂER`tíUQEðÏPè4ä+Ä  Wu¨MÁà	u¡0 U`ïVjÀïì!óà	ó Ù QMEðè;@ Mð1~ yyë,@¯tþëUz;Ñ  Úquw9Huxë9u>ëW´9u" ( @Öë!- ×@Nu
àþ '2D  `U	t
ÖPé{  ð1¶3  3 B õ 4Pë^V?»	;Quòë@ir> »B@$r a@ P ÆA  £ P BEðJ@B HÈy#4 ø@;xCD ¦ ¤UìuèuäÊ  «;ùur8¯ 9 uÆA #	ËVÆF èÕ*å	Öy @-xu	  @ts .QÆ@ ?  %±Ù@:FA L  '@V !è5 VëRà	nÍ 3!¯ ì@nu 1@b³à w§ `bv}è;P$ÿ"è}ä"ÆGyGOP£ÿ0_7è® :ÿwèáD7§GÄørj@Pÿ7è ¾kI62  'ÇHr?ÿuðÆ è§@9C 9M#öHC!ãH Á*  Çá7Õ åáanAÍÙÿé7 Ë££ ã/ÿ}¦!#ö     ãÍÿ 7ãýÿãLÿ "ªã.ÿ #Ëãÿ Vãÿ  3ãQÿNtÿ @ãÿ ºãÿ@9ã8ÿÕ åãÿ ãEÿ]£ã¦ÿìL"UVé= Wèº3#Ý F'Ú{(u C& ùëT$$GÛ Ó¤gH sHE 9XG;gÜ '8§ÜU 9uÇÝ ÎgÝ Ï@Qu*? ÈFÞ ]ö
@( Z'Þ>`XtÎJërGÛ1  /F£  õ@WQ'²'Ù S'¨ç
Ù CgÙ  Pà PGÚC9 ¡§Ú CGÚC'Ú'×K{Fùù '«E çÓ 'W Ö2½t1Ò,Î@& ç	Ò ÍÒ¹"}ãÒ @-çÒ t`ÔçÒÍè.#ãÒ VFº b VëVgÒ 'à nú 3 !§ AÃçÓM³x» 4@ÝGÔ|$;GÕ '	  gÓ
sNè{jÜÿ]Ç·6èè¶· F· ~'· FLàG·6SÆ èñ< ZgµL$$¶ED$ -[-Àç­ÍèÕ Àã­ ò  Úé` £'¨  8 W@r?ÎÆ ½+øjWèBï ¥ (L 6 y>_^ w :` "ÿ S"ÿËsC4~k3fí"Sþë ö ýë:¨"¾ Ì 	" @,u÷*ú )dj@0 4;Ët{M i;Ît0) L :f/t"8} © ñ v  ;Ðu,D$(8_p^]Ha!Ã9\$u`Jàà3B`j@7  `] :ë`Kz*Ë z@m   ¬ $ óC;" ¸ uçòë ç åD"0 ð êsa¿2Ð $9	F;u7ít)Õ . -r@/Ð@a@ÐV`ðà£@òàa! ,~!Å (,qw.Av _ ) _À!÷;x+ ð ç	pt÷9FEð8 "=: 8Pàèþ"ßT$(Ä;×tJGBë.Ét9  / @Pè*Äÿ ±$Ç{È­ÎÇGPQ _0^"Ì âT Q * "ÆD1 EPÿvÀPè"N9	D$ÄFð#^Yà:` µíKMäÇEè1È	 èDÄßÿÆEì$ësà« ! x^n
ç»÷ÁTÊtÑÁÊ  =/;Át×ÁuØë _/èÛ?0}.W 41aMÍ @t ü5 èÛ3[ Æî[÷Ul$ìd/T×àÔ ,®aE`!ïPEôd£ R ñ3ÿ ^ 	 ÇEØ  }Ü}àF<+FZ¥ Æ {"=$Ivh4[ÿüPMØèÌ³!á}Ü3É¸  MðN(+N$÷éÑÁúÂÁèÂ× X3Û%ÏF$ÃxM¬WHùÿ eªP2ð~ úyÉxuùpH   i@dH  ] 7 8UQPN"Qx9H|DN@@8N|,N7¹@ `¾ F Á7=)GÔ%z	 Ø È`Ó ÍÃ8ÿEðàÓ9Eð.%MØ'ù3Û÷ï3ö×@øúÁïútÁ9GFI8;÷róEØPèçÖÿ<M èlê!x
 3öÆEü.·jXèí6 ø #}ä$^ W¢ÿWÀÇG!	 Ç<z;ÇG$MÊÇGW¦ ÆG 
 < 8   (  @ ¥ÿÇGH   L  òGP3 ½ .9U h;Ásx;ÐwtøE+ú"ÊÁÿ;ÈuX+Á<TøsN+Ê¸ K?Áù+Á ìý!"óq+Â¹ÿÿ ø3Ò :Ñè+ÈEð;MðMCÐ;ÖCòVè'É@s puè$oºëe q 4 l Uà l Kàl à&l / l`i9 ì F2ÍM!e;óDMÜa¿]Ø+ËÁã¾}è?#zÃ_fnCøMÈóæÀòYp!LEÐèW  j8è35 ðA¹uä%MBEÈFÇFA¤ÇF O  0   4  @  $  RP  ,   !¤ö2F($0F(KÁ%ð <ðt'³(2Á$2ÁF(ëN(CF))XF*KüE?Û<FPOè  È!u!VS²F?A;Â|
u'A;FwIÉuèE§ÇFK GP	 $'+ë" <äN1Ý$  1ëw  @w#/mè(ö ÎA_]ØEl#m è>y EïÇòèè Û)MàaáÊÁéÊù$Uvÿ8Í ù  "!à= )r2öÃt Cü;Ãr +Øûs û#ÀBØSèÃ3 ! 
MlèÍBq EïåRM`3Íè{8 ed]Â èÀ/ØÃåZ lå ZðSåZÙE]uÇE · j#Ý 1²   ÿ¼ ÒEÈÇEÈä=Ä]ÌuÐEìEÇ
P  èY!:@ ÿ  èeU 3ÿ ÿ #ïtRjGè@&:T3 Ý!¨=uþÿt\  âÂÁø;Æup ¸YGWt	¹F¤ u° "æfMð!g7 UDæp¹°õ 8t
Æ`66$gZ` h[ *4è²_' &÷CpS_:u;Z:^uÂÆÛuä3ÒëÒÊ[Òx 'À>nÁ'Â 'õ ê]Á Xæú (!¡¢æ÷}Wè_e;k!#ÄÀ#Îè:Þÿ@ 	 
h »Màè¥9+EH¡øTYÿ$ä0 h¬¼ëh .ëh@hX @<háÜÿEÌÎPè]lÝÿ#
 à%éèP@MÌ  è^#6N¿Ý(Zü;ÆtP 9Ð  & ]`& à@J  =VèdÞÿ`¿uWè@Þ  Àt o³è" :Ãâéå]Ã aÇ@aà2Ûèý]à$ r $2Àà	?fí/ @ ô  æ  û !`  Uvï Ðáã/ u:e!d]EÀè² )1Vè´c ç EAn¾Ý!Y ¡A,üja<3ÿ_MÄè8:ÜaP 4Pÿu@äÎÜÿ¡ÝÄèÇßÜÿë5MÜè½7!	E!~ !¦Üè­ &EÜ Äè,?Þ! Ü  èÐ\@,ÄPèà  "5uNþ"! À ÿ$µ4â!ÄèF fMÀj èßB Üè8Ü@ Ä iè&   èZ u T  T¾ä%{M¸QïA"ù+ÊE¸M¼)¢PèH-q jÀLèi !4MØ`L­
F!K ÂTbÁ_÷#Ï>ûþô ]r éÆ ¾Ü 0©E°P@É g Â I	E´E°Pèà,àgèàg EÀgìaà g  W`g@År¦ëah$M%*TwvÅA°ë$à  dëhB% Q	j!± Øa¿¬A&ÙÓ	 Ù zÀqu!7´¬Ä@"AUè[ÜÿGÿÖ(X2Ûë!
;ÃCuËèÃÌÜÿ³ë2Û .èåZ@6èÝ`èÕ Ãë	 ( Z Qãe-92e-Ã2 @       Ç ,3 ?  ]  R C0 Q-.S-õ	UéVW;Ú}$ü
Ûx.jÓ-à  %
$;Î  ö Éx,ñÈ3À><IÆÉ.m)¦  HÈE<+E8Ëÿ)  6Òy)¸ÿë; O  
r/u8-P Pÿu<Vè¦[%«M<+Æ+Î 7)í-D
;ÁûLøëÏmWÀy] "@G
D]<+]8ÁûK \ Pà &eP e ePæÿ+Æ Z@@(.IØ \Ëÿÿÿt@ûÿt;;û7E8 î 4¸¯ .$!;Á|;D$$Uè;ÅkK$ç @' G"Q;û~Ø_^]3À[YÂ E `
!`&89"Á"}%½d6 ¸$P Ã¸`HñÃ¸`NÃ¸G!Ã¸	` 
` `KÃ¸` ` ` `IÑÃ¸!` "` ` ` ` ` ` ` `'Ñ ;(ß  ` ` `)Ä '¥ Ã3ÀÃ ^ Ã@¤5 ª  °  ¶  ¼  Â  È  Î  Ô  Ú @+@ à  æ  ì  ò  ø  þ   O 
  .  4  R  X      "  (    :  @  F  L !Aâøw øÃAÎ"@ ò Ìø@ ô Éø@ ö  Å vÐAÁ  ú  º 7v¼A¦ @' è ø@ â  0õ bÚÃùwyÿ$ä7á5Ê á| VAv ¸+ê  X@! á x@ o  u  { @             ¥  «  ±  ·  ½  Ã @3 É @ Ï  Õ  Û "º` ¿w+"»8 ð&b â	ÁbÇ ¢ + `  f  l  r  x  ~ `X  ¯Øê ß Qé=ñtïý)'ty| 	ÀtY2!«t!ÄuL`ÉtBÿP/T 9à  `#ì È$ePÿ¶ Aè±<s*>è`)íå^`ÿ¨¸}ðüÿWjÐÈèýÿØ*T=!#ÐÉt3à |	j j ÿPO àPÿw x@ $ -@` (]Adu
¹à¼èZ
s é	G ¦ABKH! È°!¢"¬ ô lA<A@*`  QEëÁUV53ö+k3Áý%Aÿy'È Òtm¿Aå;ïwdKGB±FR\ÒuêëPÇKß"!Áù¨ò ç7Ü
yOÏGD5|¸üT 	Òt}þ;þr OÀN d Q è4k
CÇ@½  A âSU5\3Û ®ùíy9·`ö3»   9nu3 Ï@Vè$ÎØv\öuâ HÃ[Et$þ 3r	 %¬@ ÅÀÄ @½ ÆåÀMÍEÀ¨`ÀÀt+9p,ß `µÀuñ I^@zPèh%1 FawÀ @ÌÛy_ YÂ VÛu$OÉ!ûG<+GFæ;Èö @8ëDwL&ÎP  "<PVè,SæÿÈ&Ó'9ù@@ Æ`/P+ÆÁ`?¶@9Xª@L$ù ¶=&	Ø< @(^_`@,à 	 0à 	 4à 	 à 	 à 	 à 	  à 	 à 	 $à 	 à 	 à 	#'¥
·À÷Ø^À_÷Ø` ^Á&s =  G  Q  [  e  o  y      ¡    «  µ  Ì   		
a Ul/ Hä-¿VWí	¾ù<!¸p.î ç@·v "ØRhÿ"7ë#ç °@!è4ÝmêÀ/gÍYßÂÜÿjhÐ2MÌè -+rÎ#ï L è±ÓIó Ì /qÿèâP+£ tðY  t7MÔ-°  7  èy7è± 0äÏD¸ hZ ¹xY* j*ºàè¤, lEà l#@Mè2 FVè¼Vk/ "*À¬è] SåSa<  ? á? Qá=ñÇERC/Ï s 
 è þAUà ß  )@Õà ® Ïè6B!MÏèÏÜ 1 Çå±à#_ Q"ßÇD$ b èm= 1D$Y! À¯ Èà¯ì0¡íEðñNùuGÁ¼"ÁAUa. §AíÀì n·bÉtQ  ¿èø1Ý/395C·`% À+ø%B6 ·@HèÍ@*â3«Àb3àLÄèì*Üâ3}Ñ!ÆMÄ!;"2ÿè®NÜÿÇaî aî?j W èµà 6 ´ èFà6 w 6hÐ0BØèjiÅÿlâ TÂÖ@f@ eÿèçüE/"T¡
 u=ÇèÃ·!iMôdHÕ Y!l¥%lÁ~9ÿ$ÁSUW(&oíq H, 44;;ø] uZ»AO /G	9{u_Å]9 $&V%Ö<Eö>ÜPDõD$è¥wàÿ"SA (@@(è F>  ¥:æN;ø|Cu^#;Ar9Q-bÇUè(j # dtÎ%5@@èJ @% $`è\`*u(ëfS % (@%(è$à% V`%tIõöt:ð;Ç5F;Csv&«èÆ^_ÀÛ"´  À $,zÊu
  ,(v¾ q;õt`K  ¿`Kr6;õué f±S Ûè¼T@Êt¤ bà^ _G E!à SÙVC<+CF~)]rN!a 3Õ|Eu^&¯!É 3É! W"Å{<S8+ú7½G!AÂ;Ïr'Èÿ@3" Á@ÀÀr¡È)Sè. DA×ÁBÉjÿj QÇ%,#àL®  ^9²Æÿ Ûâ@8ÆGÖÐgÕúæ%yNÎFDL°^#§ !Y*DwPÁ è3 "X¸e5  !oÙýÿÿ=ÿ$R w^j 0w*+C&x` Ã #@ û ú:1 Ã+!Ãq . x       ÑVB<+BÁn >!nUD|5uà H^AuJ<+J8'äéxB8f¡oê yñ g`+ Á@ ¾ Ì ßÁý  5	 aKÈè±Æÿ Rà  ´àæ°à Ìà Æà äà ¦à èrd¡   %o $åo Aø%sÇEÐ ( ÇjVÊ·e3 Éå YE3j,e^MÔÿpèûxÅÿ}ì&Gfet5Õ}èUÔCUÔ¢I¢G"?: u3ÉëÊyÒÏÏQR$Ô Þ ÇMèùr0jAQÿuÔèÊÆ%Íëj Kâ hÈS R`ÿ1$å	 åÌQj*: "ÏOöJF @è$rD(= ã!Ï" SBä âä Wâ	åT$D°*¿ ì+"<;Â$TL$ Á_^[Ã"s	 þ}VVà0è¦gÏe J/ÿ´³@'~ ÎìÿØ@ûÿuVè} (ËÀ_EÎCáÃSèj É >  Ë`³ä U!¼]è $ T U@ UÊÍ@U@O·A (4èc(+_N E ·@1 èF_^C[ÃeÃ_ v`*!'À ì,B Ñ1æ3ÉT?º3À2½QLFWl$;L$$!²D1<¦4.,[f¾ÌK "!Àë  + Ñø;ø}D`¿xÕÊÉyÁÁ-E¾ âzJÊBMLèE S;ØLØGë h  / ! !±ÅAè ¦ @ ¥ý'S'}r+ñ ÂCÀì$þ  SUVW¹@	 8Í)/ =ÿP$Ø3öÛ~%/ÏVÿP(x u	·@*;ÅOèF;ó|ä@/' !) {b4P+Áú!; Ò~s	Îÿ _QÁ@ 3  m·À3Éf;ÈsA@ !IØE ÍWàs	ÆOðGëuâ ý`t@ýA;õ ENõî@! |_^òcV±¨: ~ t|F= à=äÁèòX$Å^(ÄòY¡x ' %è"==:Y,À : À :=V\àW Y¡ *f/Är!3ÒW%à5÷v.Ã$ 0
Ì÷Ú^ÒB!z3Àeb¶D$} Àø`w"¶´I-R¨ @;Æ :¦	  	:°    ¤  à à' à>àEçÀ @ 33
wi ¨ÀJ`¨   HD:í-ý` Hà Là Pà à 0à 4à 8`-Ã 9 f E  Q  ]  i  u         -¯  M¯!ï'O.öyo¤"¼%,!P` Á/¾çèP°(£ð% _A³.U@ì|(KË !Ã=Ô@F  ¾ @z )é On %¡U8,Îèe/tL$jh¤ª;Áè´ªÆJEÈ #ª=G 3Z2 [à+ ¬ + à+$Ià+ /à+ ´ + \à+V0à W à+ ¼ + 0 +°^Ä\¦2Àæà   ä/»  $1#ý#Ãè$1í~#!³D/ Rä/ Ã$¶F;õ$/ -C¾3ÉCµä
/ ~ ¾`^ä1 B$|D1èËä0 L$0íuã $`u1Ì ³t8	;óLÞ`$> A@d: )û@&_^DØ]1¤Fà  4mù`ý3öè¯óÅÿ48Aff3LF! Eì¿pL&|
è¹þÿÿ%»OØÏFè| 2;ð|Øft" Ã&jæF"_Vñÿ0?{+Fj Vh'  RPè +Ä@'À A<+AJ WK|Y|*ÿÿ|PSY<"R+Y8Vq8B 8ùPÿq9>gBæÿ+Æ&QòÃ} 1tA¿
9yt@KÃ|j[_Â !@ÌÑWz3÷ `#SÊ V@ O#~kýFu* G* '*;ù^BÇ 0OÁ%ö *z<+ø,*¡ ÌA@4'¦@ÌÌó$lQó$<E áàè]FàGà è½HàIàè-Jà èKà Íà Dà?à
ß%ª3Ò=,í o ø#& RÝ!J\ èrk ó'&=WÉ/Èvó\È]ó,ÐÂ&óXà i`B d B@=¨à-À ` è _ 0à_ ±à_@1P8`k  à 4àh Sà là pà tà xà |à àP`eeöþÿ6Ew %ÅÁþáº!W Óâ#T°P÷ÚÒ÷ÚJâ^`3 &  NÉu3Ò`!oÜ 2(gØ ZÉnXÈ9à }!¸  à16\Á(Èà Øà ^È(¢ (Å,Ñ`b= >u&`~ `~ À7Ep97SÊÿ`&MC`
ÍP Ü  ë  ú    Z  w  Á  µ  © BQ 6  "<à 	    ' Ä»@ %MG8;G<K1_ÃGP*G83Ò$ 
2S_<Vw8+Þ$½D 6Àxx;Ï}=ÿ^GNÏB]WÓrà^[$)å O þó¿<¡¤Ps¿%ÍPEôd£!] ù=Ð'Î	uu)¿[ý [Y»uéuhà;ëh(Öèîmñ9Ô ì!ú.? è  ÆEØ EÐÇMPÿ4 @AèC
íÿEÐHøwF#exT ÇF" ë= ! ë4 ! ë+  @ " - ë  @   	@.N Bb¹]Ì	;ÁLÁMØPj ¸PèRSÌÿøA÷t;Førj@Pÿ6è6n®~ T  S rëÆWÎÆ#>. E=r`:u¸èú`;}Ð Mì<ß` A.íØèÜÃîÌ [ÜÈÍ ¼S }        ¡  ª  ³ B@  Q-é3ÀVW.åí]	û¹A+DøÿWûÂDÑDÁ0HGPáþ&ú PWVAø÷ÙÉ#ÈQè3ræ-ÒÄ D º?
ÙÛKûDÊ;)ï @¿  ; G/ 6øèÛÙÿV;E@% -N[Y % 2Ý@	@¦à  CZø?wÙD &Ùî à Ùü!Ü`@/   àØwà ¨à/XMà/Èà D"WàO`yàO tào $"uà/D)àP9à0²à 0àOø	uÁ@"Ç$êB®@4ÿà éà ù @ÿø
@/ à / 
"À/à  Ï8Ùý ÿì\ãÏÁE°%TE%`°@ã!Ç]Æ}(>E¬D f¹o±tµ w@6Á;Áu7DXú@|Öjh<ÏèøK7âàçà -ÝèEtÊp0M¸@,QM u¼ 	´E¨QPÇE´ÿ  ÇE¸     ÿè0g) 6L X!ÂE )UA
]°j jÿu¸ÃDQ#´E¨ËVPè¶Mï4õj E¬Ë2$u´   u¨ &$æØu¨hìPè	åÿÄZkÅ8ØèCåE  u4 H > H ¼ Hÿu¼PèS@JE¼E¼ @Mh´7@J+[D ëfE¬_õIÿ$ÐZ$¼Phpª%( @`
 x@
 5`
 @
 *`
 @
 `
 @
 `
 @
 	`
@¬!3 º  à ²¸²äE és+]"@!¼á#á# ¼!	L!	à¾@\Pèüà V a V 9 VA	 [áj
!TW P C P}¼-h  ³è¡_q éä&4h;  @ Õ %ñu2MÁ½àúKà`é
"øuDE 9ÿp8³ ¼`=j   ¾ ;Bá!"aB× ¼`BPè¢ÂÊÿéÊ ÁÂ¶  2ÀéD }¨l"R| <U¬WQ c :	$Sèàe é! " y j(aHHó\HDÿp8ÿp4)ÇM¬V"Q+ X/üM° x 9$   I ÐM¤QÕÊE¤M¨"iPèXq/ÏèðÇÈâE#v
öD&{M 8à7	MMÀPè  7V ; Ç_è½/FMÀè Béh7QX V  a  l  w     DA? fä? 4ä?ù}Ô($5VSè£!AºÆF9ÇF$; ?3ÿÇF@  ?ÇF<   ÇFH  0;"¨ò EÐÂÎ 
äo.G-yÿ$oNL 'äf
f xèÿtÔMÔF'ÙSÿR`GL.FH !ç"ÎLu(/ 4$S QÐEÈ#ÂÔÆF8 ÄÇFP 0+EÀPÿw0ÿw,èT=!ÄEÈ¹XÙ}ÄÀUÀEÈ+útEÔÂ÷ÿ*Àë EÔ[ÀMÌ!¶"FDá»Ìj  nAõÂq H;è	¦~ÆD Çµè®{H ì(ã"ÚØèf?éÏ Aåà ï ¬áïæ/¤f(&0}F*]}æ# æ
#]B¦#"¬ P!Dhh$PèP_Ô@Õð;Þ¼!Cé3è°}õCJ@{) C!ñ(Û@-é| pèu ; ¢F,=* uE ¨~8v0f× Æz¿ÂÁøòÐ¹Ë;RÕu ø|û +ô!Éëÿv<M¤ÿv8ÿv0¾Pè]:!öÈÇêÒ#o x  !á#áßM #PèAÝEØ;Çt2¢r@j&¥ØèÇ|`è W"à	ZèÙyAÔÔÆ b!ØÀ5Àè5y uM}¤ (h=? @'d QèYÆ%¥@ÄFæmC' )Â Ø XèD( ¨ èXÞ$o © Øà P=Á %$G µ -¢TëÃVËK 7¡`Àèó"GBMôþÂªæá $qìÁ3Ò25 |7µb\7  "[22$Câ[ &â [))8"L'!¿G!Ù¸28wØ"$"!Ü~,*½ J½Ç+&F ÿ@ $   ÿPWèº**2ö $ 8À - "þtj2$$ëÿv4"jW!U%¯îFeFDWÒ& NFÈY #ïT$/Êró_0§7M/Ñ@]T/Î .3~&AØ(ÃT©@   ' v 	^Ù/Ów(Ó 0ÌpO@P` óPF$=ô!~/ 8I b Áà_@vÙ   _ JN$ÆF(TçÂ&Ò  `¡;ÙîÀ	$6/ ðä/ ,æ]±FÎèÅ~$ÜÿXÚV/Úuhe>"èDHFë Ì#G#F èU#SÌl-;ÇEÔ BB$>ÌÎ!¦  0Àt!S%®èò^æ&êÌèZ) ØèÛE ¸! ë-èF  ~ 
ëùujÿWS  >fÀ`'t¸þâ	±/± AôO L"µÿÿ|CTD", BM E1VôEè>c (t´Cê cT;4@!dà 	ÑVJÉxEô H*ñr74G~Ö.u>¨k#^IÁ ¡Áÿx444,P9pþÏì0y t6ÿqXAHPA-ÛL$è³#àW4)è	@A  ° 	 Ä0 lW@à ±V3ö!ÿWE4é02þwG8WEøW #y	hZ  ;Ètd¡è©Æ;¤'Ì@j	h\&< èD¯`à y  #T$Ru DTÙýÿÿÇ#ÝÿÇ ÿÇ ÿ=ÿ%*KÇ"'ù&#úÇ.K"o`6éY" 
 ü@/  w @+é; ûà @ é  ( úà ` éÿ G  ù ðà éÝ`
Õó@à¥M÷ù*à¥@$é³/ ò@/ aà¥@é ñà  |@éw ðà¥@éY ï Jà é7`
×ø@à¥Qù(1áK@$é/ ÷@/ à¥@éï  
 öà¥@éÑ õà¥@é³ ô ¤à é`
Óî@`¥  Ç ù, ¥ Áñ@$ëj  í@,   w  ´ @ëO  ìà@ë4  ëà@ë  êà Ç  >1(|: |ÉÆà  BÇWö¨ $n¸à~ÜB  +Ø ÷éÁú	Â=±Â;ð@(&ÏiÎ d `#øDf <¤¤h|¤ H  &	I_^Â@_^ò8AÁp fZ=Ð  (&À(  à 9à  àI4_^@`I5 W
Àéá_^ Y¶I5à0I$à (à ,à 0à Hà \ '³èÃâDÏ   =@`í i L @@I`à d `? Cà? h #? là_^Ç!â2 %Þf ì g   #  1  ?  M  a  p  ~      ¶  ¨  !© Ú  è  ö    (  Ä  6  ]Ü	
à   à ¢q ¸M§â¸: Âà ;à /à Eà >à Jà (à3Xào Oà ,à -àEÿ$Äw6!øw*1züi#Ê@ Ã $@$p@$Y@$B	Ã3ÀÃÈÿÃÑ . Ø  ß  æ  í  QCs¼F Q­ÎÇ!*Il£Æ èï+5Æ^õSÙ3ÀUVU® 5_k	ýõ®GP®PG'ì÷ÙV±1]æ+a3ÉÛµ±éí_^MU³][5µT3À'¨¡ÞÌ¸$ðá_Fÿáß $$à «à/I¿à pàFemá|k!@!jF@&@&@&há  Q . X  _  f  m á%?öîPöîD[á< 6ò!8á=ÌÌÿx³d¡ ùU_VW«*ù +EàPè.{Ý!¢uªØ;ÆtP*v%ÜÿMà (ÿèF"ÜK%oÚÝÿ*Ð2ÀêåJy V2ÿÿ°õY  FÈá
ül!@!jFÑ@&Ð@&¼@&¨á  Ñ . Ø  ß  æ  í V±ä1¼3ÒWF+©@¿~$&1Ã@ 9¸!t B+6%:©;Ð|æ_#S ^!P_Â@®ÌScO Ð¨2ÁúWæ  yNÎFD3ÉD°°@} ZÀz)Ó |   *ïàA+Ã2-@ È  ^8.s+K ô@@ Ã`}èl$!£Þ A.¦1³à)e  ¼/¼jY/ ^<;,Á M$^+Å  :+Ît~ ut du k$uØn'h|'Á@"WÿÐÂ*ÎT*iÁ@à ,)7Á@à )øÁ@à Ü(ÀÁ@À2À`T ¤(Á@ÀÌ Á@À G  [  o     !ÌAHãÝÂïH¯âï  ¢íEðâð=à¼6 © j ¹@èeq W¨A3À¹Ðxj	h8<  ðé ¿;;MÔ# F è~íp Y°Y{0ß8j@EØ¹¼ Pè%[EÔ¹@6 Ph¤ Ç¨  : £¬ è-  sÐ1 kp°ëãh	Mð3ÍèDö #SÁAÈA AÂìo2Úä QV¡áñèÕ5Ï#Ùuã×C¹ÃQu¶¯~NPè8å
  @@ÿÐ$8h¬¦!ð  È$OMð¡!ÉtÿvOg!è|ì ë3ÀDæýä+ p A§uC¹@èícA£t5¹¨ è	r!±u* $t$~q Ç  !!W 	@9 "p Ã*³"$à â/ è@Ou&¹@èe¹¤"%è %ÙuWá9¨ô!!B"ZütBZ!$bXèø7Åÿj"bâ F7ëBF à"âF ì PèLF@F Ô ÇØ  â £Ü èæbâ	Fi¢Féa%ÂÁ¢( B6 Ââ/ lâ/ìL¢0#Oÿo	ñu´è[öÿºTÿ¿@UìÆ?C3Û¢Éÿ9Ð k ± ¹  ~M¸pÍfGü%x þAE8 °"¼M¼ ÀhàU(ÖÿÄð#_;ÆtxÃ2Ô &h`ë Çô÷VsFÀt(¢EØVPÿ,ÄëEØ] #Eè?gEì©3@<©5r6Æ #Ð Æ#útH{Àèªg`{ Z;øtD8ßè ?ëÇ;é G a¬E¨ 5q"s<*x S  a4íOèÚ0'kà
g Bg
u´CM¸Ç ¡ÁaE!M ;d«7BUì!vAv!|;ØB!ziû`6Ç
þrSfAz*@Ãü ÀhìayLH· ß ¦;Æ§!Â¡>MØ@=Xçr*öÁSAü;ÁÉ &+Èù¾ 
ù#w} ?Í ì ü ád°j@PA°ùe!a°!oúèZ£ýÿATQ	Á4s!GéÒ!Rÿ8AXúr#½ B ¬Lãý'  E$ Ãz` QV-­ñ+'H#
F÷÷Þö#ð3P N	è¶LæÿÐ;T$u#ª±ÿF^HY#³@2Éà`Y 	QUéEd+E`(>Vh !õ 3ÉSVWXüÀüEd\6_ C`ÇC>²@lÇC     "c@     $!ÿÇCM Lé  0   4  ¡$< @£@CDdC ­À ððû IÈ  KC 	$C (C !#¢4 ÇP u8[;u<Vè%A! ø3ø E8$	+þÁÿQ!¸@1 (8'4è Nÿÿ >  Hè0y}Ã!]Y.ä3À`&à  ´õ"ì3 S@*£(V0S(;ðt&9~|
9V|9N R6;ðuëë  u@ u@t\ Ä4 ê PÿvL80ËV|$7c ÿ0 ­ Ü è²ûå!ã ¹"[CC(sh¨¦ÿü@!AVB Ã-IÂ ÌU¬$AìÜ DjÿhÛç Úì´ Å­Ø !ô$mËôÙ]Üä µè $üô@u .@	 ð -µ À!ª	MàM`è&%ß`&¶`Ç%  è ¬ V èG2Ûéë"Tux3ÿ+ut3ÒÁþ8Ö!]t+!@Àt)ãAÀuøBù;Örå]ÜWl"Zè>Ø!æEx3Ò+Etµ@"Å&X ÇES4 &_U¨ C"Ù2x3É 	Ø]3ÛMäffÝ¯ì  UäÃI@Âÿ3:@	=   Â#ÙFÁ- |H6ÖDºÕ D +ÚÃÞu¨;× y 	âú ôv
Æ¶A(à!ÌQ(Â$ð<ð¶Ât%AeC )Uè#' 	*C È A YÁÇC@" âXÂ+ÌÀEà;ÐCüOÐUèU¤;ÐL 
 ¤ ºBÃ8! 'Ø È!]ÿ&a?]¨!P CAOMäI!M]¨! &á"z!{BútArPèç8	> .`øEØì"K§";ÄE<i Ð  E÷ °E´ÇE¸   ¼   À  EÇEM{ O¥    x ®| *EEEKd+K`Áù&v  
Þ  ÿ$¼,¯K(¸$I+K$÷éÑÁúÊÁéÊ9SMÈ]ìè¡U   ´èÈS`è¿` @hè³ 3ÒÛt)uì3ÛE¸MÌË EËASB"¢ â&ó3Û"À*Å · ð+ÐÁâ`/ÁÈÊÂÈC;Þrê 2c^-d Ð ´#Sÿt/ iv8; ÈA  
Ø8¿Fè  ó~FøfÖ@0;ÏrÑ!¡é°"é`<0à)=3É!ïa,!4á/ÂÁUS@\ öã /K$< uUE¼+E¸"0;ÇvHT$Dúÿ~#,¤9T;Eè}+ ¸G@ÍD`ÎD  @ÏD0`Ð ` Æ8ÿEäÁ¼9Eäz" éCu`ñá*.@ð è`f n iàctf3öÀä 7 äU¸+?x@æ(ºG Ê à&Æ èàb9EèrWByNQ   èE ">{+ÇPè4@
U¼EàM¸PÂ#Ç+Á!¨ PRQÇEàð'+èî?ÖÿUEèM`% ¨@% ìÀ%èÐ@% È %h@!Æè\ãIV$E¬½CÕÆEó.ó ¥B¬M è_Òq*c CPèâÐr)jJ{`@'l¬ÿl(éiÉ)&JëI@3©è 2)èt©Iê r FÃs )î v 
Ið¯â@Ç`Vl.Ð   Æ`   ª½ø 	/EÄT"u+/°P X  $G\@¤5 `@Eód µh thEÇUè  jPÇE0Ú#¼<( @LE8ÇE8¨=,
uTE<E\#z`P"¬ELMØE PÆEü  èo]Ó èG é;!pKs(ÄMÄC=ûUÐMÔ}È'[U '?¥/å)$¢;Ît4;>ÏEMÈ1ñ  =FEÐFEÔ, F`¹ÇF'T@i©@ ã ;ñt> 7$ PèAý,8U à49>t> RFEàVF3À E 	 >3òÏè@>E°K0M°C0C4PE´ "PèåyGKDMCDC=EPèÌ@aKXeÉCXC\PeÐPèª !(¼}ó t
"_Ëè÷#Üÿ 	è¶à# "³ë 	2Û n 
 !e¥PèlüÜÿÇEs:ÇEGg    7  +  +M  C`(æ
^E¸ ( (´Pè`(æ
¢EÌ ( (?°ñû@zfìá¼¬¼ç5#)iè¢ Ãëñ³)¸I1¹ä ¥Ü »]ÂYs{ ÷zÎ` ¬  é Û| Ë @ê ¬   ,ÿ &Úü4è3O¹@ t @4Ë;j è ß!f ð!eöuÃ D4Ô T00
JN ^40 cà ìu JÖ W.ÛQÙÄÆ fL­{8 ?D$0*ì 02K¬*æÄ;Çu
7wwë|8{	tp;Gu@p;Gu@#  C VÇî P¢Èè+É N$Ä_0ÿKÂ¬õì?JñW)4N)%ÁfnÀ GóæÀ+  \5YH%=ò?¿ LÝD$Û5ÿ© |¸s²çE÷çÁêiÂ@+ø@ ÿêuùÿy.
`#+Ï÷á % B&øÿ`"~_^Äíï kÿpÿpÿp!aÿÐ »à!!JÿrA÷ÙÉ#ÈQÿr )@ÿr¶B!¥JP *ÿÐ D@_ V	p$Hÿp H g	ÿpÿpÿp y À+@ @/j !!PQÿt$ÁèfÏäÿPàFÐà`j<¬à\  @?@u@@" à" `  B ¢ à"@ïÀì L ¢ í 
P  	@Pàü  ÿP8*ôÉt4 T uþªA8Ø  ý ú |/-ð  x"I!u#;òuàÁë;rB® JB®N;rB® J4ÿ@ÆRQÇA¨ Ae¨èw< ':^ yÉAûºþ Â-³"uòBàþHì÷ØÀ#Át%D  ;xð Ã 	}@ë@à $uàÎÛt_J[iB.;ñu ÀF÷Þ_PJ Ç&#q°^xQöt	  "òë.oé" Pè]%¸ <DÉtÁìë3É9y} @¶Ãð_ >¦° W`U!É	Á_^[H7Û:àïUV(³OHõUâþBø÷ÚÒ#ÐtKC_!	Ï:u ÙY:Xu2ÙÀÛuä3ÀëÀÈ,ØÃ #R!Rà Ju¹Ö `M#E øá   ÂFá
 ]á ! apú!PèE!T$A Ò!Âø!Ò: © É ©H:O@©ÀÇÉà©y!@{á> A>`}!?J_^]a?@"£Ul$ì|/ÙãÛïÙ !ÑÏÙEx"HPï Öñ¾`12½G ÇEðBt
¸@é¢ u¸Æ@"=Ô@FÔþ@)oÇo"0!þWÿPéh`2¼ÆEÀ/í Ä'èUãÛÿ*È@èö(hÎèáÐï6Æ j8ÛÀ)·ÎP5ÿèÊñÿEð!³ /_  /	Eì]äjè ªh$U×®ã$Èègî øÿ» æOB		jj ÿR Cé
ØEÜëËÿPÊ (`ÿPC70YØjhØÏÿuÜSè}r'ÙÜSÆ [¾Iy/Áä*nÏèg ÐEäÎÎÆ8ù fÇ8
 è5hþ8¾ ôÌUþÿJÏPè.0=Sèï×'_]ä"+ 9ÊÃT@ è îû¤ ù	)®!:èÜÿ!LéôG¢_!u  ¿$Ä L@^ uØÇE).£3u u*IQº9g 6 aè¼áá èÿôÜ ¥!"
`Pè0ÝÿhÈL!ÅÆÄÿMtÄØù:lAjQÿu`èìPÆÿÄÛ	  *ÝICÖ++ü GAÑèo5a<@x tjjQú
ìèl4Çÿ}ìE*pS ú¹ îE` > 	À¸` M % aÇnÿÿ¶øM`÷ßÿ÷ßOè²E { H 4èy 0tÿé\!AE¤`5±ÆÿK
è
Þ ´,ÜüÀM¤Ãè£Üÿ@Å Ý!!MèèSB@Å L # `= s@=l!W è£AÖ Mè è¶bÆ!Qè^ D#èS@
 M`?èG@EL . è+ G r 6Q"ºLdÝ @&è  &Ø#YUèRU¤Rb³Ed`9ñ ¿qè Md FøèæÜÿ0GM;ÁtPè¢t M¤èÊ 5è^NÅ N ¢ AAèøá MdØè 2% 1"¯<Í#¤4ß W Tèn 3C¬ ïÿ3 b/#µè²hÜ Z cë' ! @:c[À `)cß´Æcß "× ) m¢H9Ë	Á|8  ðÁb¹èèöAs u¢ò#°LEð.ôd>Ñ  Y&PMx3ÍèZÙ+/e|]jÇÀ  )Ù4ªt	%µé."² 	Ç  fÇ@$¹'tà  à/ nà /ð"à/ ®à/ !à/ îà /  à/ .@ú`¿Ø#à_ nà /%à/ ®à /)à/ îà /ø$à/ .!o¿ Xà/ *j7)_@èe 8K+<È(à l a¯à/ õà/ &à/ 4*à_H'à/-áIøtDøtQøu)Iù 'úP) BLÿ6èðÁÄ$f3ÉÀE*^@âm'ç6't
 ¸ þq àoB o ào@ ¢Ýà<o" o ào  àBoC o ÀáO@ àBoCL o 0ào@ àBoC oÀ¿àß@ à.o [â
CÌ o Pào@ ào "¢ó~@2á ANª âàoD oà¾àß@ àBoDL o pào@ à!o V&ç @ èj(0èòÍ)­ È(>#µ   #µF6¶A!F A -À@ 3=iÃ$0u, @ ^15Ç%ì   u$>j( ³ Ì ]$3Ç  ^ $\@ä [Dë '½aKÀtÔ P/m^Çåaà¿ 2 aàQ¿  ]à¿E{ ¿Ô¼à¿@"¡ÌUìjÿhÜì ÊQVW¬Ç*ÜE!¢
fEjP8èPÌ á ð!¡uÇ£.Â/G%+õ/ 	NPMðè\·T 2ÇèA_v 3öà
AÈ !. áÅà=AÕ3}7 z  m
è§çÿjPVèêË! !àà7uKuE&JEFy!-¦»Á-  äAìàp1à ¥ Çæ¿àì,T$4S\$<Ul$8>vL$D;ëu:Ñu
]°>;,Â? ¶Òý\3dEÐl$4¶Á3Éû>¡<WEÁT$D&a T"è P)aD5@D$4"£   $   a , / 0 ¨-B"Ü+ D T$$PÿssVè1ùåÿ?³D$\`@Vè@!Û C;øtL9ouG q@8Ou> P9Ou5 ÎT9u-?~ 5 A !w¼äG#1 #(B X *S@ PUè2  /J/Gì @ X! ;à
XEL\¿ Ö L RLPjè^ ¢ @Â XJpÑHRèÂöçÿ@ j X>º+øI+ðçðæðùñ!HG GDPG T;÷vVGPWës` V tXPè1W@ '@!QË 0x|Væ,ú o`°èíÕäÿ Öá ÃÌ¬õ#ÀtÆP-n êî
ÌVW97;÷t\?2ON$è¸®Ýÿ3O8FuA8b	x uð`	 .À	töë"8O`wt;p3	ð@`tðð;÷uª_2À^Ã_2^ÃQ1ãWÿ(9Z>"òÿ, 	VWRPè"/j h Ê;SQ!^ êèNÎ ` $f  U î  aúè0 ð!@úx5ì1) Yàà UdO HäOì|¡¤P31 ðñÙ]Kjè6e ðü,ýèÉ#þÿ¹6¿Ç^	#Å Mëa/ß3À¿  E2@ãÿÿË|8 t|0 tt0ë
7è\;í"ÏM| t< 2¤22 Û$=ÎÿP;ót@
SÿP0} 8îÇ]@ jÿP s|û@@v¼¬~;,~8 	 ¨`	.`Ò~#`
À~¯ÂÁàP-U´¤ (è<!%Ç@gÃÁ ] `Y êùV0 /E¹5·A]µYÅj/$Å !!»> _òÈH»7Ì]Ð0é _ÙrKPQèEí/?ï ü cÿèé }!@.D!ë O!eä×-ÿ ðMÿ%hEÈ"Õà éKÓ>S'À 7üè8 lïýÿ^'Ó /t`\À5|$À9ÿÿîJ` "mÁ@ùQf8:óæÀÁèòXÅ^fZ $ÿRH >U¬$ Ôìt-+&ÚÞæ Úì80®Âp  â| WÀ¿ &! ,!Ç(@ Ç$ 	@ Æ@	, f½ Ç<  1 2  	@ Çüh@	  à  à 	  	/û! & èìÐÛÿ F Æ3×PËÇEð   è  ºï ´   ¸   ¼  è`S2O » @èìP¥`OPèpøÝ%¡ $j2Ûéè!0èÄÇÌ Ü#RFÇ@vÇ@up @þx ^ Æ  F"´@     $   ( !>ÇFA? ÿ#d ö ShX7TPÝæ@A9Vèþ®èÿ ÿÃ  Ø"¨ &RKÇA A A y  	Æ ÇC C C C ;ÇC 4ß]ìChì93n V 	~Ï}ÀSèu ¡&¼þ#³ËÛÿhaL@!èsS¿Ñs@ P!¼è&¿Þ1¬"/3Û ]ðè¡ û!å è1<Ý -ráèU ]M UèÍ ` èª¨F 6Ê³@tÿEèé h$´#ç2xÞÛÿ? ¬ 6P aß;Ýÿ%åS  7JB!ðù+Ñ)#}qA`Î;Ñ~B	(! REàU1¶ B5j [>¶u	÷ÛÛéBqÛu
»Cé¾ ,¾ 3Pÿ4&Lø!×;ø}5ûé $ ~ 0  UäúOfG`{ ù'P q@À	Ç;ùMÜOÁ*EÔ%4 7Eß¾2 hEØ   Kb*#Ø;ÁuF;uÔ9Uäë?ÜÜ;ù} ë3Û;ÁÃ]"ÿë ùÃ!  àTðø!xM¬èè` ¤!4èÜ 34mðî Áèá ]ðé#Ó @!jC" PAò¾øÜÿh$M@èâ^Æ =@#ðèEE+#Å!C¾Ü%{X"\ E PCèþúTKB d=`  @"` ^@MÄQ$øH?Á? Ê3ûMÈX@NèU¿p$ü PK	è¦?4l @F
ør@jPÿµ@-è:vcEPèLôC  !£Æþä@«V!?é	 »jXèRÀ&¹  N 
(ì  ï2ç'iCîxØ fØåÇF0GÍPèWû  È#A FB© #ÖÞàæwí!xNl b4_ 2}ìVO$èÈª$5XèÉ¿EÐ kO$@¬àMà Ô!iàPèÓÕàôìE´^Üÿ`| K |ÿEÌ QèÐ@#â Á@#©c÷&}À@, À+ØB! Ì$)$ñ  »äñ Wä!ñ ¸!$áäö ä	öHêDö_á#Ü ÷#7~A|t0 uõjèt¾ÁT!ÖÇ k m @$Ö  !ÚÀFÐ%¥,èÆ%&¼Fs@!èxnå&@" èÿ¹að#A@ Ø  Ï@7e( D!üè, _
 Zè£E 1@* ­k: p ¥¬ètÙ#¬%CÕ `|Â6 ü¥ % %$å:aå m± Då Í  å  ¿ å  $Å  $¹e å Øå Üå	 Üå Øå Ðó!{&h È`Ffè¼@a9Ì"jDFPèÀóCS '¤yG ?»$r	 Ã;øBÇPhEQè)ZÆ$(*üöu;ßvÎÿëö÷Þ¢äé5d('ðé Q#ýË»Â¨" "¬Cý®ãý dBJä Óö@¬ÄPèÒÑä èóè üD@;°Z 2 M$I$èD¦D ´Z èÂ@0"äª~bÔ2ýcþ@×»cô  ²ãcô PcôjÝ"²ãô ãóºÁJ!Fãó äãóÂ#ó Xcó@ ýèjãó@cv¶aì#A} Ô "ï@3cï 0Cï < [
 Vèãï½ª@BãïÕãï `xÒ2 ÷£ï ã/ï}­ Dãßïàï!{#ï Ø`CïèÌ@aã	ïÐï#ãïBCï9Vã%ïù1ãïÛ·Â¤" "¨Cï¾ãï cïBJãïãò@¬ÃïPèâÍãïèå üCï@;ïÀV 2£ïT¢Cï ¼Z èÒä 0#ïºzbÐãïç·ÞGä ( ²ãcï <cïzÙIÁÏSè¡è!NPø#ÁèÝ¾#º ¬cº@ ÈèÉfãº@ P@ÙP²`Ù%Ä@Ðy h `/c· XC·  X
 SèåC§ *§@· 
 ç §ÌÑã· `u  UÃ· #·ì
Ä ,: /ÊÿÌËOEÌËÀ© Iã¼ Ð&<ç¬ Â ç¬  $Ç¬  Ç¬«ìÏçd¯  j¤è`C¿è C¹ '© ¿KÌ>á?ì ?L°Pè³p,¶ÇÚ!ÒPÝèÛë++î£ÎÈ'Å lTç±7.cÁT!ê Ç`"PB Çb9@  Æh1   W à;@zèû-`;'íÇÿôl F"cGü Î 5'üÎ³ä ¤±ä &[`\D B4
 m¯ì ³dC&PÎ  èdÞÿ¯ à fRÁ	î$ä Q!PèÉäQè±àÛQ@QnR 2¤QDQ ¸V tè@0$Qhvcg,@@³  µPÉRP0 VQ!Õ
 èêÞÿVè¢RÞQÝT6è¼Q hdÂ;M \"ècÎ M #èg ÿu¼E@$ÿu¸ÿu´ÿuÌh /Pè­@H   ;Pèª ³Eð/"Ehð`$ d`$  `$ `$ èà $@Ã@I ?à$ ` $EPMÄèd0ôj ÉEÄ %P ¸«©!D  Sé`¯³èI`	èA@Ý 6`
D¨èKß 'hè@`
Lmè5`
Qè*`
Eè@
!` §@ SµèÌÈçÿÃù¶[T3Íèx¶ ¥THô åQ=<Ê¥SÙV9¨u&èY¾> C0"³6¹KËè>@Æ^[YÃs3ÀUW3Ò3Û3ÉðÇèúít(4à 1`7×pÅ@;Åu;×t`'ÀuØ_]^3À[YÃ_Å]@Puà
 èÉ½   ÇB     ´@à )pOÀ3Ûà
 Üà` ìà#|cÄ$Ü !+U¬$J!2(p 9Xó8  /K v5È`	] :Ð &4Æ`   -Ì] - X ;â»^  ö&¤  Æ@èÓ =Ð@Fu@t ¯~:  t5¶ÀPè¤
 ë*¨ò  	   q ¢ Zë¤õ º¨ @WÀVuWy 9ÇD$\     `  òD$d  l @ p  t  | @$ t;ÿqXAHPAP$UÓètÔßÿ6c!B #@ S 8   @ L@|ë! @ L@	 l@	 #D$\ 9ËVÿPXV"ßRÿÿ3ÿ  , R 3öÍÿ:Û,P$XIPOéWPèeAu]A$ >Á$ð<ðtZ;ýuFë÷Áæ
jÿjÿVÿ´$¤   ® ±  Q ~0Ãõÿïë(= #!Í `Gh"jQ!þ7Ç´$  0ÿPl"	,;Ç|øéUÿ%Ã  E*Yéÿ<9$¼$ì '3À Ïv$ ¹[3Òó«E+E Áø<î (5Å '¦ïE ¹VV0	AD$H  ¹@t}3ö&P w |bÿà?3É,3ÒÆà?«Âø CÊ3Ñø@Æ 	Áè#Å K#Å Ñuÿ/  @c° _HF  Zd ÎÃ;ðr  v BàÀ;Ðþ=1 0 (ÇÌþ ®  ý 1wNAIB$UË#? p"¥ " <    P   è]}üÿ &èlöÿjU!ò ô H
ËPèóòÿé©!ÿ#ò!B
Áé
EÿÁ#¢	3ÒWÉ÷ñ`qð¸@;ð(ÙT"zGð"û\$f/Áv EÈ§ò^ØíC e ´ÿ;õL"»GõÆÁè9àÆó9àù Ý(È 7D$0òYË(ÂfÂ @L$TèÍÿÿ#|T D`öts>8|$<f~Ò;Ñua`DsØ À;ÇrQ+Ñ@¸ (<;Ïr+Ïë
¸© J+ÇÈ  É ÉÁé@@yÍ:t  £Yh Û@!p £^Áë$ ²<! |Vaa@w<èË{ü)OËèkA Váaòÿ³Aì ^!R ¡t+î6G+Ì»D´ nDä	3í3öÇòÿÿ@}B@!_|¿\_Ç@èf? ~;ùt
ùtùu, Ñ	!É}ÖÎÁúá`G«È	iFþCj|£@C @C 	 Cc!×93ö¤%;nxÁ+øL$Áÿ3Ò3ÉÿCr#@Â;ÆwAÐ;Ïsp#ëçÆ+ÂD>yf-´ N	y
úÿ&ë!³ÅÓàÂ Æ · ø`·ÕÓâ`»À8 u ´}@^év$O Å|$ ¥#3öÁÅF +ÜBü r Æ R`K#Å  0@3ÿ$`è	h+êÁý'ÓW@Ó Ç ÓAÂø;Írëë@HÆ+ÇPQu	èÿe þw=0 À34n#æFÑÅ'" ¤t °Æú  !ªVoìÿ_ç ^% ä 
][3ÌèÆ­ ÄG=GA0>"OøÿÿÃÈ¿Uéu%èµ> E!H hEÍèµ> ]Y ESVu(»èº\$5<ø%_»`5uh)Çu; t,á ?à+ à+ â@+uÜ)r`i@¯>/ W#°F;øs1;Ïw++ùÑÿ;Fu	jÎèéÈÿNÉt-fxfF_^ ­à& Âà & $ à#@gÀ ào:¼s2 Wp"©;F q7â q  q * ¸@p pÀ% à %à!Àj` à o hùsP;ÇwJ+ø¸«ªª*÷ïSÑúÚÁëÚ;NÀîZ$#ê~ÿt[DG G ý[à 6 #@6a% @
GAGA`.`- Uì?$RÞd¡   Pì?ÀÅPEôd£  ùOu;ñsk K"Úd+ð¸1Ã0÷îÁúòÁîò;OÏèT% µ_köT]]ðwÇEO/~twK@MìF@FDPÁèóæÿ+ÞvD3ÿ:óëNàP P`M ì J$k@J ,`J ðàJ ¨`J#Â D(¥àO	GTMôd < Y"wå]"4!À  ¢á Qá ñ!Z];ÙsN!ÂÃwH+Ø¸OìÄN÷ëAáÂ @»~kÛ4}}ð À    !ÔbS!-F­ÛNë.áÀ R41 /#â@/ 2@/ /	CPOè C(G(C,G,¶C0G0 1G1" 4àöï âàïáü`î}"± a îÇw[â ±	ÁúúÁïúà¹(%!ûVUUðÈ Á À  1Ð
bABIBABAJë>àG àÂM!á ?aòÉt"âÏGAGÁPè
¿Ûÿ ñ àñá çã K`Í Eà Í#~àÌû! ÌV · A`Ó_ó~fÖD@½ k dyã z È@2cz  ,  +#~ãx  à J` D gfffA] àd` =@¿_@B  à )F!9 A`(Äà àáK× á  @2`á"e & 6%+ùåvÚ#! e3çð~ëà ½à  â5GÂ5%Ç áàÿ ha b!$I÷ï×)á hA`a mA ý"æ +ÏA È!DÈ-»B@     "DÈ0"B0!­ 8á­ @LF,  a­ G > @ > G = @@= G@< @`<à»@ ãÏ&Æ#Ïøs5ga /Fð ç;6*Æÿ!l{ø#~ ÕC~+Pë#à) @)À' $££Wè»c ãÀ ¯2ßæ åo S!ÃwM%o
ë ê÷ëÓÁúá u!÷iß %wBåt TED¡çåt = 7à 1 Î¥t $@/ q/%t p%tpè15# c@F`pæ`)jVt$&þàþ-; CSWf¯Ã öÂí!râþãþz;ßujR$'öu"
@.    þ6æ éGÍ;puðQVè H8@, 7`à 4  à  @`PèY/Mëb&$öu .à1à fë=;p c ! 7àc  ,Á*â_[` ^ táQS*A A1 J;3! 
!# 	 ";ù+: 
 ,i	y uKÇA!Z ÇF   "ÑQ9pVK¾ !I2q) ;Âu
ë, tHëH P )= QP. #xuÒø Xz î 	 R @u/Ç@z Az ,: 1fSP@@$Pè~ NÄFFÃ ¨@¯' d  B ; %  @B `B9,
D$(PèK  é 5@ñ@ùàõ `õ àõ àõ @L !3 xàõ #à ã ÀÜþ6/ !d.ëyà "á åNá	Eá@á	 4! ?"ÇGaD)Ý5%QT">B:ÇB 2 «aV*ÏRFSNÓ ~AÊ Ù 	;ÁÑ !  H +ÃÛtH'M 8Aqu2!!} ÐÁ¼ 09b"®`_;ñu¬Á+ @H@(YÃ ê E8;ÊtJf»	1rò`;  !r@äWAæ  @PèO!'ë6;Êu 7gA`7 à7' ØÄ  [àÅ` Ul$ìt, ^åì(¡¤P3ÅEp+ì}ÜE|LEÔ,ì EØEØPjèdåÿìT ] ]/cuè ÷	+
ÁùÉa!/1°3öÃ$3%uì]ä¿<³P- 
@# UG0@Ò÷!tf8 uAÀ ;Ê|óéã $è$   z3¿    /bÀ¼ 
Ç@
]Ìûtû0Æû ÆE ë	oÛE} wW;òuPÂ+0 5sD-¸ÿ1q+ñÁþ+Æ F+ÑF, ¹@ÂUàÑè+ÈÂ3Ò;MàOCÐ;ÖCòVèÍÿ ÿ*¾uì#ð!Mè0$wMHÆEó  ò  ñ  XG]äFA!uàþ Û#p !uè  è¡gB+4ÿ&[¢@] UKCUURÑMÜ+ÐEä §RQPè³å!¥uÔ"&37cE}Ð] ÇE%Õ	  j]ÔPÇE"  ÿ¼EHÇEHÈ=%ô}L]PElE'6 $  ;YèÞ¾ Mè¶º0" ëh4[ÿü·¨%;5@u =BC$è A!ï  ! #+Pè´ÜÿÇF"#ÊÇF`VÏ + ÿ  èã³Üÿ°ç|Mp9Å² etèìS&Q  $ÜUVWûB¶1Ú3Ò©@"8¨$EÂ$=8D$,u8  %r 0CT2z PVÿu ,èãÅ!? ø!>;þ ¾9_ 2p,8G¦D$49GDt 89à Ø(<öº@\$PC£M 6 | 4COIaåÿ8!< 	0Q+QH!ÇJRè¼@p @ Æ .  'Ä 4@Wÿp ?DPè[« =` Ç # H@# H #Hÿp " T7õ 7 #Ä(!  0Î hD-]|)æÿ , 0èí¢ä!u_^][<1Â W /4PMèc\ÿà #2À %di ÿ~Zð SVð	¹¼ÇEèZJ èÀ ß)Àð]3ö"  û äDhH+d^~z@ f$L³ÏE»l!;U=ÇâÂÁøç  yOÏGDD¸`N  7²Y,;ß@&å	;ÐtèÇ,#`x FÀy;ñ|h0ü ¹hY{è%,æÿ ÂbÚè´7ß>	ð%/ +(iT$$b;Âsú"Ývã9"oéÿÿÂss0;ût1\ 4	Æ¡> jSèÞ_'>_^[ ,!roQÁoál/ï Lût! P µ    &ô
ÿP,jSèÀ[àÆi o ÈæJ dá
Þ q}#â ë#é     ÿFMÇF  ]Ç	ÿE¤E¨ÇE¬ $¡ °   ´  `©E¸E¼ÇEÀ   Ä   È  ÌEÐÇEÔ   Ø   Ü  àEäÇEè  C¢  ð  j$Ç ¨>§èê&H@¼èKô@	ÐèCæ@	äè@}} @¢@@q \uE tEP\«è<üåÿë# Î'T Ì  ¸ 
¤PèÃ^  høª;TñgÖ1ÞEè ~IMäPèó®%à©EÔ ( e<MÐPèÊ`(à
íEÀ ( (¼Pè¡`(á
1E¬ÇEü=lE	M¨Pèu +á÷Q` "`ï ðáïôOeðH:
ìGÈ+OuC¯	;Îv+ñ° ã"Vsê7?ÁÏPè¤	5WÆ%Ê     G#ôW+ÁPRèÃãå'Y %+G#K+ðÁæwàVMìèSâÿj!Äèë ÇÀ ÏàÃ/àÏÙ]ìsuË"ÎÖ+÷ê2R Ê:>Ê;Ïv0·CàÞ Ç Þ;$Q J@á ÎÀá÷éÇà S S êVè@ê Kw+ ñ÷é !ÂÁèÂ+øÁààq@ùylçùêàù ÿ 0à"ÿ¸$I+sP`÷îÖQ1á (+ùKý!­ +ÇÁCá!é¡
jA
Uá
KAÑà`)â!ù K0 $a%á ÁààA@¢}éá K $Ã+ ¢áìL<ë " `%T#Å ô·:ÙMpUlUÜÉy2Àér=`
{<¸@B +{88kù£Ë;øäwGøE $>DbèEÈ$ÆÇEÐ!E$¡ãÜE E¤ÇE¨  å"E´E¸ÇEJþ ãé W$» ÆDÝ *. Ìè3)V ¤è*¸è! ?ÿt )'	EÐMèÊ° E¨ÊÂ8 F;÷râ`%"e×Áâ`$¼ÁÈ@' È 'ê}t%( Êuà ¸]E@¦utXE* ¬%] *}>íÊ}EE8ÇE8ÄuLE<E\MÜE! ÁE` ÔèW´J è/° éIíEÈCeß/"Z
ðMÌVèDûÿÿV@î ; !üÄMèB: üBc ÂPÆPè@#Ks !MàCEèUìMð}äEÜUMÇåMä;Ît4;>ÏEMäNÒ =FE9EðEÜÇF`ì' ò n|%´;ñt> 7%» Pèæ¨%Uà49>.$ > R 3óE0üF3Eú  >P8~ §@>!	K0MÈC0C)Ã&è%æ  KDM CDCH  ¤%ÿ`´KXM´CXC\ ¸Pè\ *
E¼ ¦PÅ&  E a ÇâxE¨ ( 	  ( X `( ¨ ó"¡â¼"q ( 
( ó§@Qã
 EèÇEü @ +&­'+ Ç +ì	 `,Ld]Â¥ó)ySK URsW>]Ü )ØOOö /Ø
 )§`  D$ /ý&Åu_+Ã;ïu*ù *[Ã`[)äà  o 0r!ÍY
aÓ	áÊ=	3à3 _8Ïáþ;Ñuçþ8V  !Æ_^Ã@þ;PuRçàpà  àïOX4àï àAï Bï B@a¥à"ï @ãàï @ï Ýàaà ïy8 ~ÿq4I0èèÿ@à kNNDè¯.± ø$ìVÿvLóF@¶F4,OóD$@ <`
 F8 
$ÿw#PF0ÿ°È1èÎý7HWèF@M U®®Uuª_`@ot$Wù¤*WÇ"¶ @ÿÐ=	÷GX    t@|$@à# @ # T E@à#&¢`G ,$W@à# # 
@#@à#  #->Ü#h@à#  # -ø)¸ é ÀïöxAÆM|MÁùæNÎFDt°0 "¦´¬ø#Õöu_°^#²7ü |$SRWèÖi%ÄØÄÛxB  + ë? àx ¸÷ÚK+t 
ë! "uà"* +  ¸}åé3ÀF¨ÖÙ[_À@ 9» 90ÿ@9 Ü@3à~+Ø 
9 	 9[;ùÀ9 [ Ò"J"P"P/Ê@ Qb[jÿP0`"{Ð(DáZ` "¡=Ô@F1á$éBPL$ùLåS»Q:-ÊYÿSUW3ÿ$ä+(Áýl$í®@7Áà$wVfï ?`0/,¸Ô,#¾zx!îtð!©	n~uhÑ¸ ½   x <ÃÓàD*ht`¼$.ø"ÆöÄD{6 ÊëWÀàÇ@ jKjÍèi:þÿ X  A÷G;7¬f.^_]0^ÂLà Uì)ª ÞéªìSî Á'}°ðüÿÆ¤;þÿÔþ)3 u)è!.j.û Lë è}ïÿ+çWè" ÄÀtWÎè¸£ñÿØÛ ºë[¾Ø I G$O E^ÍtPQ )þ©ñÿë9Ä @ËÃG"Ëj *òÿP @	ÿuðÿPPèøÞO×³Mì!!L {)xïýÿF¨ EF¨  °,ÐÿP'ÿw$Èÿw èKr ÚÓ
ÿPëÆ  ò'=A»@?LÃì	­¡f&·:ÔÀu
 !H#øu@ 	`á QgW 2x $ööyFÈBG !Õ9Ht@\ O
ôL$_^Á]Y2Z2u$Ï@@Pè$_±ÀL SäM\$L°û! !±ü20ûÿu:"¾ ( "(l$$   SU m(ÏVèb ,¶%¥$ è [à @ = î 9 (#¸ ##Ã©"tU?@Vè C±à E ÔàA9U  !B  ü3@#^9Xt`zÀuñ@là8 `8 `6@dj@	Pè¯ $Xá#!!ø« û
¶|ß ÿ$L   !H(Âà ,à 0à 4à à à à  à $à   ¿  èýÿÿ «Þ ¹  Ç  Õ  ã  ñ  ÿ   À )    7  H   		
!	 _BÛuk7Í8;!¿G<+G807;È*@T$ú#juQÏè#.ÿÿ_[Y 
G8úu ²QKQ  1  aR;ï-]VÛ!wL53P Pÿw/Îé®åÿ8JÄ }À«#OP+ÎÁ1 Á@;Z@L$ù` @{-E [@ùu1 p ,    @QR Ê è!_ U#[w<+w8Áþî* 6"Ø  #Ïû`jVè  hë!@þ
°ûu
UVPè -ë [$USPè Z DyÈ] `Èÿ+Ã=ÿÿ  }nàf ÃA f ¹!#ÿ+Ë@m7¤ ^$u1à{¤,ÿÿëà u  <àu  uA@y ¿Ày f4Ê bàrxT!Ó   r @c.ÈA#Ã·À#r5ý`ä 
8`è9@jýuRVAú (@l @âRU@¨ü n J@n ´Àn^ÌQ#UÌKé9Fã =LaÛy0Aõ "ãu8BÇ8[ðû Pÿu<Vè/­åÿHÆ+Þ*&ÁûE8M<WP+ÊQRPÿ,E<ü i ,-Ú R,P@ W ,@W J V 8@VVèÜ¬ RU8+Æ!4Ä"c'àYM4 9PR %b/Þ ,E_Àx/ /	;Ãu
[^M%
 v;Ás[H^&n`;Ãs;Áv@ [^`DoÁ;Át	 gélÜV¶!  óï#¨ä Hò@ ÿ¨ð @"#`; (@)&Ç   #_^F£`#à_ JAÀ4à_Üw `; _é {`_ à #à_à¿ ¨k@Ýà_0§à_à¿\MÀÝà_ ` #à/¿ È*wà	¿á Ì #à/_ D%:à_ H #à_ádyáß h #à_áß t"{à¿+/à0_ $,çà_ ( #¿mo0Uøu2$!øZ}
T -DÃø[u,e èP-Þ9a$ @	2À^ÃWøu -VÿZ~ ( ' (ÿ[u - _@*¾S _   Bà #}A8ÂÃò Á´ý  ;Èt
jÿj PèÆä @VñNàèÆÿ N0^à Ò Cáà  '(ßw(Û è($üçèÛ DG± $ÏHHà Là P ¿`* àÉ  4à 8  x   £  ±  ¿  Î  Ý  ì  ø H£  H£ Ì&GÒÀ²#D!>¶ 	ÒuÀ 	 úà/ !Ã/  	/  	à	/ Á$Ä/ Å 	/ Ì 	à	/ $/  	/  	à	/ A$d/ E 	/ L 	à	/ ° Û/ ´ 	/ ¸ 	à	/ 0$/ 3 	/ 8 	à	/ A#Ô/ F 	/ P 	à	/ `!;/ c 	/ h 	à	/ #t/  	/  	à	/ÀSÀ/ Ã 	/ È 	à	/NÀ/  	/  	à	/  «  	/  	à	/ Â!û/ Æ 	/ Ð 	à	/ !û/  	/   	à	/ B!û/ F 	/ P 	à	/ ±!û/ µ 	/ ¼ 	à	/ 1!û/ 4 	/ < 	à	/ B!û/ G 	/ T 	à	/ a!;/ d 	/ l 	à	/ !û/  	/  	 /  % 9å$¿© é$¼ìï fn$òè]óæÉòYx!=èÏdÍW ZÈ'ñ\ òóYÁ)`  ,HV R@!  ´À!@+´.Z â$µlE! *¨¨@pÌ x[É 
d M = §@ X g_Âó]Ãó o@ào æ`)`oà)@à w Úà wàä @ä:Îàä( sY` ]/ &=! `v
Ç`  Gà _ (ò ¿@ `!@à àÿàal²Í!i À@rAiàf ø!Cf@áS îÛ&¾AS[ 9Y;á/ ¶ A@á ?â
 a àá Q dffáá@o`©õFÈ'*y@ }A4A@¿ ÍAÆò h!e ê@: là pà tà xà |à |$ HÚE2B  uh  ÀPh.[(TÛËs" ^ þ 4ò}Y8ë /EæDP«ð @" D àDH àA àA ³à A2+ßî ð  #³  ±í   E  Ä  æ  µ  V @àDì /  ) 3 #  4  E )è#íNÎ (ûc~37)t*~ t "Ð   c¡/Èw#ð]#®(È!ÜÆ<:@)tFëFTz*ýÿ@t
Fj-F 	é T!A°¤¡ àø?w ! qD  2À  AªXå@"~@MÌ$Vÿí··ü&?`ÀVà?M7ýà?Nà3? Ø&ïà3?MÜà3? X'à3?Mà3?M|à3? `'?à3?M<à3?Mà?Fé@â?D)à?  b¿@à?P9à@9à?0²à s c@è@&/#vP ;&Öàû@ `VD2ñ?WXçèPõÿ 62ò;=ô:6 s$? Q¸ M1Âà Ã=0F P aì =  #Ú P IFìdhN F(S è7À$kt!.^x @I(} Àg#| Dh`l`p`\` ``$d`(AF,T  Z 0àZ X  _;ád¡&7 Pì\!â¡¤P3ÅEðVWPEôd£   $Àu 4¡Æz$èl_p  96 " èªf Vè~f ½ Z@ÿ ¦\@#@ÆEüèÖ 9Á Lè×f Pa¤ \lYØ ðyÿRëÆG´0é@!'he5Qî t4t¾'5 ¾;£ ë¾ Ô Màè«w>  fÐyp@%r @Ôè¾ ÆùìMð3Íèno å]¦à  .¯÷Â^&HAXºèAX  @à >wÀ# >eÀ  >[ G   à   à¿ Há¿ V¡ºáµñFp¡ EGH°zýÅÿ<! ÁøYð p@	Eørj@5Hè\ãÅÿÄá" ^A Ã&Æ°õ × ÃÁ"Q¸ëQ+Q÷êÁúÂÁèÂà V5ìº:< <	~çÿj$Vè&iH¼Ç@!±L  ïvÂ¯à
ï5ÐQ&N	 ôèdÿÿj 3¦vèâÅÿjVèÀh@eÇ@/ d  àÕ@¤o ÷á_ìH¡aCáej$è8`O<} ¬ u$V	ÈèèÃæÿë3Àÿu¬p	£@ÓF÷ ##
ÿ÷ÞÇE¸,~;ÇE¼B±öÇE´  #ðE´ _¸P ÆèDÉåÿ;E´uÿF2 MÆ ß¸4<,Ü!â`: ]÷ÞöàA àA²@~%àAÀÈà <-ÝàA ~àA LACàÅ <àA \ACïàAúÇàÅ lAS½àA ¸àA |A á vàA A óàA 4àA  A+òàÅòÆá ¼A àA °àA<»bQ àA nàA Ä àA ,àA ÔA %àAêÅáøº`Å (àA ¨àA  )Uá fàA äÅ *àA $àA ðAVÖâÕâÄá d¤ E${E°$b ;PI$m¼ èÖwÿÿà# à# @# ²à
# à# @# à
# (à# @# jà
# 8à# @# Fà
# Hà# @# "à
# Xà# @#þvà	× dà#  @# Úà
# pà# !@# ¶à
# |à# "@# à
# à# -@# nà
# à# .@# Jà
# à# /@# &à
# à# 0@# à
# ¤à# 1@#Þuá	 ¨à# 2@# ºà
# °à# 3@# à
# ¸à# 4@# rà
# ¼à# 5@# Nà
# #r¢« 8@# *à
# à# 9@# à
#ü¹à G A@#âtà	û $  k =@# ¾à
# Äà³ >@# à
# Èà# B@# và
# Ðà# E@# Rà
# Øà# F@# .à
# äà# G@# 
à
# ìà# H@#æsà	û øà# I@# Âà
#ä 7 L@# à
# à#/ü èzà
# à#7ð èVà
# (à# O@# 2à
# 4à# P@# à
# @à# Q@#êrà	û Hà# T@# Æà
# Tà# U@# ¢à
# `à# V@# ~à
# hà# W@# Zà
# pà# Z@# 6à
# à# [@# à
# à# \@#îqà	û à# ]@# Êà
# ¤à# ^@# ¦à
# ¬à# _@# à
#;â ? @# ^à
# ´àG @# :à
# ¼à#- èà
# Äà# @#òpà	û Ðà# @# Îà
# ä[ @# ªà
# ØàG @# à
# äà# @# bà
# ðà# @# >à
# øà#=n èà
#á g @#öoà	û à# @# Òà
# à#Oíè®à
# $à# @G à
# 0à# @# fà
# 8à# @# Bà
# Dà# @# à
# Pà# @#únà	û `à# @# Öà
# là# @# ²à #h hx è-ëþ©8h¢@ @ àQfh@ à ¤@) ¨@îêà > ¥@ ´@ Ùà ¦@ À@ Äà §@ Ð@ ¯à ¨@ Ü@ à «@ ô@ à ¬@ ¼ pà ­@ @ [à ®@ $@ Fà ¯@ 4@ 1 h°@ D  jbè 
h±@ T èà4 hd@òéà ) ³@ t@ Ýà ´@ @ Èà ·@ @ ³à ¸@ ¨@ à ¹@ ¸@ à º@ È@ tà »@ Ø@ _à ¼@ è@ Jà ¿@ ô@ 5à À@  æ  à Ã@ @ à Ä@  @öèà û Å@ 4@ áà Æ@ @@ Ìà Ç@ L@ ·à È@ \@ ¢à É@ d@ à Ì@ t@ xà Í@ @ cà Î@ @ Nà Ï@ @ 9à Ð@ ¤@ $à Ñ@ °@ à Ò@ ¼@úçà û Ó@ È@ åà Ô@ Ô@ Ðà Ý@ è@ »à Þ@ ø@ ¦à ß@! à à@ @ |à á@ (@ gà â@ 8@ Rà ã@ H@ =à ä@ X@ (à å@ h@ à æ@ x@þæà û ç@ @ éà è@ @ Ôà é@ ¨@ ¿à ê@ ¸@ ªà ë@ È@ à ì@ Ø@ à í@ è@ kà ô@ ô@ Và3ý h!O Aà ö@ (@ ,à ú@ @@ à û@ L@ à ü@ X@íåá \æhd@ Øà5Q hp@ Ãà @ |@ ®à @ @ à @ @ à @  @ oà @ ¬@ Zà @ ¸@ Eà 	@ Ä@ 0 h ¤ð Ð@     hØ@ à @ ä@ñäà ) @ ð@ Üà @ ø@ Çà @! ²à @ @ à @ @ àZ(h$@ sà @) 0@ ^à @ 8@ Ià @ D@ 4à @ T@ à @ h@ 
àZ,h|@õãà û !@) @ àà "@ ¨@ Ëà #@ ¼@ ¶à &@Ä½è¡à '@ Ì@  h(@ Ô 8èw 
h-@ Ü èbà .@ è@ Mà 1@ ð@ 8à 2@ > #à 4@ @ à 5@ ,@ùâà } 6@ D@ äà 7@ \@ Ïà *@ t@ ºà ¶O2  .·è­ å7â¸h:@.  Ç@Xíè~à ; h@h !èià =@6 ¼!L Tà >@ ¨@ ?à ?@ °@ *à @@ ¸@ à A@ À@  à D@ ¨@}ëá!  E ¢hÐ@) Ö   F h°@) Áà I@ ¸@ ¬à L@ Ä@ à M@ Ð@ à N@ à@ mà O@ ì@ Xà_hø@ Cà Q@) !: .à R@ @ à U@ @ à V@  @ïàà æ W@ 0@ Úà X@ @@ Åà c@ P@ °à [@ d@ à[øhx@ à d@) @ qà `@  @ \à j	h¸@ J j
hÌ è8 
â à b+b"wV°  ) P4|"¨ ìÀ& à& üÀ&ÝàM t ¶à&  À& à& 4À& hà &I3àÂ <À& Aà &IEà& DÀ& à &IWà& LÀ&óÀéIià& TÀ& Ìà &I{à& \À& ¥à &GÔà& hÀ& ~à& tÀ& Wà& À& 0à& À& 	&¾';"&@ ff( ªÙýÿÿE´ ³"3Øh@6èõC \¦ldVPÇ>d ,èþÝþ$î ì ;yÿø<Ø@j<ØØèÆ|ØFþ&;I~§¾' f _ +à_ °`_ à_  èà_ #à_ _ `_ ûà_ È`_ 5à_  è>à_ÃÅà ¿;@¿ `_ úà_ à`_Õá  èÞÜá cà_;£@_ `_ ùà_ ø`_ uà_  è~à_ à_ `_ ) @_×øà_#Ãèà_  èà_£ÄÁ (;ß ¿ ) `_ ÷à_ (`_µá  è¾Ûá Cà_ 	_ `_ öà_ @`_ Uà_  è^à_ãÃà ¿ 
_ `_ õà_ X`_õà¿  èþÚà¿ à_ _ `_ ôà_ p`_ à_  èà_ #à_ `_ + @_Õóà_ `_ 5à_  è>à_ÃÂÁ*_ `_ òà_  `_Õá  èÞÙá cà_ _ `_ ñà_ ¸`_ uà_  è~à_ à_>=" + `_ ðà_ Ð`_ à_  èà_£Áá 'h@_ `_ ï@_¬E¬%?Àhè`_µá  è¾ØA Ôå?j@%?ÀèCà_ @_Môd@ô Y^Mð3Íè*L å]ÃÌà Uìjÿh/âd¡ + PìV¡¤P3Å ôdS jèÛF =ðÄuE¿  öt0j èÁ  Àuÿ8FN	Eó @äPè¹Ù= ÇF í  ë3ö5ÐºÆ<Ì äE´ÿuä ÏF÷ÇEàL÷ÞÇEO ö#ðEì HàP Sè½§]$ìuÿFàHE`H àLE < O÷ÞàA {àAD¿A `,àA 9àA]àA«+ÈÀà÷¦àÅ]ÛA àA µàA]ùA àA sàA^A ,àA 1àA^5A 8àAï¥åÿáÍ^SA DàA ­àAD­A TàA kàA]·A\ÐáÍ )àA]ÕA\îàAç¤áEA dàÅ ¥àADA pàA càAGwA |àA !àAGYA àAß£á $	Aì»áI àA Úà A à [àA à A à àA Dìd½Eè$ ¨ }-vDû  PèVXìà# ´à#XyèéUà	# Àà# @G Åà
# Èà#  @# ¡à
# Øà# !@# }à
# àà# "@# Yà
# èà# #@# 5à
# øà# $@# à
# ¬á  %@#íTà	û à# &@# Éà
# à# '@# ¥à
#  à# *@# à
# (à# +@# ]à
# 0à# ,@# 9à
# <à# a@# à
# Hà# b@#ñSà	û Tà# c@# Íà
# `à# d@# ©à
# là# e@# à
# xà# f@# aà
# à# g@# =à
# à# h@# à
# à# i@#õRà	û ¨à# j@# Ñà
# ´à# k@# ­à
# Àà# l@# à
# Ìà# m@# eà
# Øà# n@# Aà
# äà# o@# à
# ðà# p@#ùQà	û üà# q@# Õà
#­ã ; r@# ±à
# à# s@# à
#  à# t@# ià
# ,à# u@# Eà
# 8à# v@# !à
# Dà# w@#ýPà	û Pà# x@# Ùà
# \à# y@# µà
# hà# 4@# à
# |à# 7@# mà
# à# 8@# Ià
# à# ;@# %à
# à# <@#13¦ Ð+æ/^¦/ ?@#ÝOà	#^ # @@# ¹à
#^* # A@# à
#^9 # B@# qà
# 4=L # C@# Mà
#^] # D@# )à
#^f # E@# à
#^u # F@#áNà	û^ # G@# ½à
#^ # H@# à
# 8?t # K@# uà
# Dà# L@# Qà
# ¨áÓ M@# -à
# ¸à# P@# 	à #hÐ jSè7Ê-æb	hØ@Vè%à ä@Wèà ð@Xèà ü@[èïÉà G® Y\èÝà @]èËà  @^è¹à ( h @¤ ¤à 0@N,èà @@ ¨@) z hP  Á ©@ e   \ hª@ Pà h@ ­@ ;à x@ «@ &à @ ¯@ à @ ²@üÈà h  @ °@ çà ¬@ ´@ Òà ¸@ µ@ ½à Ä@ ¶@ ¨à Ð@ ·@ à Ü@ ¸@ ~à è@ ¹@ ià ô@ º@ Tà ¯! »@ ?à @ ¾@ *à @ ¿@ à $@ À@  à 0@ Á@ëÇá  <@ Â@ Ö hH@ Ã èÁ 
hT@ Ä è¬à `@ Å@ à l j}èà |@~èsà @èaà  h@J Là ¬@ @ 7à ¼@ @ "à Ì@ @ à Ü@VèøÆà È ì@ @) ãà ü@ @ Îà°  @ ¹à @ @ ¤à ,@ @ à <@ @ zà L@ @ eà \@ @ Pà l@ @ ;à |@ @ &à @ @ à @ @üÅà û ¬@ @ çà ¼@ @ Òà Ì@ @ ½à Ü@ @ ¨à ì@ @ à ü@ @ ~à±!O @ ià @ @ Tà ,@ @ ?à <@ @ *à L@ @ à \@ @  @òö2ìVt$WùWGG PFPè1Í9ÁT$O0
G0G4PB  $ODDGHûÌ`50OXXG\ à Ä _^Â ÓcQL$Ul$U ;ÐES\$T$Ûu @ÒuE   @|$ VW0X 
NxB3eJ\$ 	_^    3Q@A@?Pu  Ç!/   @Xx   h u   []Yô/Vñ÷FX    t¤3À@ a	ÿÐÀu°^Ã@!(t| ^@ !tÞ@#û@ T3u@À À@ ` ,09@À ¢` `
@@À ` ` Ü2@ b:r2À^àÏ Utÿ [ôÿì  ¡EðSVW/»µ"Gu¾Ct2Àé¢!;ìþÿÿjPèÏ9q5	Îÿ0èCr ð 2ÿè¦)p  64ë 3 u-¾  t$j jVMÈè0#ÆÿØÛtBEÈP<è»r ë#  Âèq `&@_ÏPèID0øèx|Ìÿè­Bp Çã_^[65Ïå]Ââ ª`  S"J !äC!3CÀ@øt	øE6WjËè¢;>ÂhTM ¶Er j  ­@  dFr FË+FÁø@PèR hÀ5¨  F FÎPSèJ! )3ÿ)ÀtFÎ¸  <:·  G;ørã_^°[ ¶^2À@`µà Ï ¨áÏìDáÌñ}ÏEhkrTMEÌèîD µOÉt
ÿPEÀëÇEÀ!vÿ3ÛÏSèÌ@!F0EÔ ¨SÏèú hÿ@Ä Ï`?!Ïèå ]Ô¸ 
ûÏGØSèÏ F$~EØPèrB,xÇr ¶@fPè$ *EWi zý)Y©xI	ÃvPöIvÝ j@ g <À [ j  R F(¹`øGÁ"8 Çè9 Fì`Èy`#@ 	8u¶ÀPQÏ@2C KàØè»¨` /vÀØ ¢e Ä éGhÄª;M°èSJÛÿ@¬ û$D è³ RÀ³ § `³  M´!
Q@ A$eù+ÊZ ù ÇÈMÐ èq@,EÐÏ¶ðVÿu´èàB ËÃ a } ÿ tÞè|eÛ&#ÌWÛWÒò]Ä(ËóUÔ	 GÉk ò%x -Ø]óA,.ÂöÄD! Aò\Áò_ÃòYÄòXÅè#U MÄÐÊUÌÁé¾ ÞfnÂóæÀ $Í^ XYp``XÈ MÄ%"ë
ÂÎÓè$v@ÉÀPè ÆUÌCîöÞâBN¶ÂPè Á2 t  jA k@Aï b ! ° h Á@, è!Ç Z 
^ÈfZÁóXÈ Þèu3$ðÎÁé@D &@;  @   V!_   MMÄÃ a!G 
a"M@kA¶A)AE¼ 
*E¸á!ì4á1!.Ná
yA èá ` Á T jX Å K@   B ÿu¼ 	 8 	E¸!£ ÀA£Áè!ÅA¦!$ÀèR ó!¯	 "=Ïó,Àa  6j ?ø@ $Ièï !Ã!!ÒWÛ!uUÔ a,I 
a,j¥ýÿÿh /ÿC´ r@<O"°"î$~ j ÀÿPS X V  	   PMôÛàå ÔG0!Æ%Ô å  àå <å]Ë}¥}Ìèà? Î K@u  ÿE ÈE È#LCºËÇEÔ"± è¸@'WÉÆEÓ (Ápöt ëF!û#!YLXØBmè2 ¦ È#Ár MÔQPS@0EÀèIF3$ñx@ |=ÑËè u$@Ëèy@F p Ë·@&o â ` Y }ÔÇë 
EÌ x  JÀN 3 %#7Ëè* $!e)@ ¥, Ëe, ÀÀ1ºrå
ÇM%/ÉQMÔ 8èV> S EåÍ£e/`© ¯`& ÔE5ø@¦@8%nGKsÀª  &"ÂËè  /`¨à¥ f@@ÃÀ(¥ ¥å× Ë hè®=@Pà§Å×ã¢`§ nË  j øèÿ .%Ý3%¤¿N(MÔDÌ
<owK8MÓtÿu 4èÑ -EÔGEÓEÒÆEÒ P¶F(PèÈÿÿ 	 )I:!, © 'G}Òu  *@ @&Ou¸"YD}Fë,!"y *QAHÂ2;Æ
uAL;BvQH" B#\EÀ"¢â XC6 Ðe¨Eµ ¼å° E"¯"ä	 Ëdé<!DU¼Gå¯ %¯ Ð@u¸G!2Ô*ÁÏ ¸ j/!! ¯@BÒ ¦ #yÇ#ò#|#ðuÈ#ó W $ J ä;,#dä@ IßU, ,T|$ô Ã¦t &t Í`Ä $ eÿÂàã@ÃPè`_^][Ã@MÌÌD$P t$@èSÆÿÿpÿ0ÿàÄ (  ì@ *b`¾QõG ®HÆ% í!\ Í"UMÙ %* } %ÿB'WöHMG, OQë%@!ñ O$V`f/Å U`r.¾¬ 0 u"Åë@x"%¶@3ä/ÿé@@| Å %Ò=Ì$Å  
¨G[!WÀ/Äv(àë/çv(ç&5%\%=ÁO ,`,\% TÜ(&#Ã(ÔóÂÁ ÈV(XÑ "Ñ(Ì("\Ä %p`8ÂÃTÇ  Ð  Ê%i _ \È [dÌ `gì\á   Y ,ÄD$  Á3&Û@å@õáQ=Þ"ê éQU3í  JUÎèÑ!ÀEO!³O$ áÅ 9ÁÅ AÅ@ÆBë"¡ÍáÅ!@#@ê!Ð] F< r @5 óiYx(=I`% U È 4"9&¾ `&v"O ÍÀ's$¯çi B°T$ÀÂ â!, J" 
 5B:B% èB% îB% î! -B% ¢!%V\-b)"
TÝ(Åb, Õ" Äâ, Í, bX-â, Æ Câ
, Fù vÂ, é  ì"$ Å"$    A1VÁ0"ø ¾/Ê0,÷AA ä Aà Aà Aà Aà Aà Aà 	Á îu^-èX  qÏõ 	 +ÆÁàPèI+Ò ÐqHÒtv3ÉL1RötlJ/Í )	 +ÁÂÀtL0× ÿ  !Pé	?@Ç@   Ç@ÿ  Ç@(   ,   0  Z2 ^¹ 0ÿ  A@i;ÎrÂà § UpOpdW" P©l'ôd£  è  é¼%£å"`ß º!m W0l Æ+øáÓâ 1_3À@m	Ljèê#^L·,¼u	T·2
 y  A tG"`
uõ_Q à«@ ¯ãÀ¯ì0òàµMÜ3Û@ ¸@]ìÁÀ yEä±@Uð}èÓÁúUà`+uG7!>f¯^ =@¹Î- æ èY7d,_ !}ÿè<Üÿó3ÔUà]ì TuðÇ *  *!³ÈCMÜÇEäÑÀ  } ûRzs Káe#®ahïfÚàï àïÑ Ï1ì`ìþ! ÿa à@eMìº@ó	uH\²Ût@à ß{ 5`ß+ß y8Y S`î ÿèº; ßßI`aM@âÇD²C^%`X à 	àÃ!ÛA¸  QSÙb. U'ÓÍÅ4U !""7B4 @¦t	]Èÿ[Y :"_«öu
^à W3ÿ'3©¿;ýtBÏ`Q DÇÓâL$ L@Ju$#G !ÔN;Hu
+#v Àuê XDG PÿA|®(,À|Ç ` ½"¬$d!ìE7jÿhNâ  ¢D°!§ãF!½¤!1M"]ðwè(Q"ü;÷V!O Þ@	 >@	¹Ð£:uÒtP:QuÀÁÒ	uä3ÀëÀÈ$ã!µ ÿEðU ç+Ñ¡ID
ÿ0óÆ;÷tP Y Doà^uàZ S ÀSEè ç ä hPèöÊÞÿÄ3u!fUä·Eè·ÊÁáÈt5÷ìfÁâfUèfP>@ð I)%  &Ñàÿv ÿ/ÌìÄ ßA@O ù#ó O Èá!@uO!è'`Ûÿ K@H °H  á$/à  @ E ÙX,@T [T  Tà(íàO 4@O O  à:O 8@O[Ü!= ¨à"O >!¹FàÓ!±"µÀ!gA0" I q °à"q ¯áÿfA2;óu V É­$Ã #kMà.Ù3 ó EÔMØM PèXp/pìð%;þ~#IGørnN7ènMÇG ÇG 		 rëÇÆ ~sFÀtPVWÿ,LRë
Ç8< XFGFGÇFN 8ÇFN6Æ%DùNÌAQÿu è~BkQÛÿ,ÿç _&) Dn3Íè÷ ¥DÅvä¯ ä¯ ,ä¯ èÄ¯ ÈD¯ ì¤¯[#ä ¯ 	D¥Þ]Ø!i]Áä*² ìä²U/d¯ Ä["ä/¯à WàS« Üä¯FÆä ¯ $$¯ Ü$¯$³ Ê¯Eè¤¯äf(#l@ð l "² àä!b B V¹@¸;Â`ï]ó:u9FX@Yå äÛuÞåäuH_EèC!"àÇ@  éy ¸À#: 
:&. É&.J:H@IÂ&1Éæ.à	I!¾ é/ I¸EQà Oïìÿ¥ èÅAÀ E!&E AßæÎ¥ ì"|èZeMÐèÞ Q  ÿ3Û2'ÆEüEàSEÐhÐ üPè AÅ "2 IQö `o:!G>Q:PA Áa Òá dMà ¿ à ¿EàCû@|;uØdV  z èâM#]ì"
÷DeMÌ5$$bäa ÐDtDaöDa èDa;þt~ä]7ät]¸`~Ak @Ôä]ä].?Ñ3ÀW¹I9zó«Æ_ì)ï1e ) @ÇD=µ  è&"g YÃUl Ñä )7¤#¢¬eðÿuÿu*? ðª¬uNM  ì! 2eÿuè ` Æå%* jjÿuèÃ`ô<¨ èÍnÉá V@§@èR`gVM¥ > ÁÇC" ÇBj÷ÇB`É? .VB.OBÆÇ#B  A% A`% ^ w!@ ì øSUV?è$é+ðÞÁû\$Û =UW}7	+ÊÁù;ËÐ QM ¾ÿÿÿ+ÑÆÁú+Â;Ãsh4[ÿü+ùÓÁÿ3ÉÇÑè+ðÇ"CÈ;ÊCÑÍRT$èÈ"¦ ø z , 5	ñVQW|$ ÿÓ 0þ 4+ðVPW`8M+ÈQP>P  M68$E $+ÁÁøð!pE+Áj PQèkaW!0  Q_9Y/	ñE^M ][#¢Â VPRÿg b  + Áã;Át;ÊtÆ =S§RQPèRÈ*P].,ÀAAN­ ðâ? â?.EØU+Ú!rAn RAnO&Ú+ÎÁk @¹ÿÿ!j
ðEèÁþÁ+ÆámWó+Uè!Â!o
ÈÂMè3É9UèAuÎCñÏVuèè!t - +!ìVQP¢¹ üJÆEä ÆÿuäWP"¼Bµ!ñ W!96+Ñ! / A+G} Øa} Gá}í} MF&Az G!zÙGã	 :ÿuèÿuìèµ7c¿k Q@@VRPè(@9é Eá ¤ !¤  & è""¤A¢_ài!ª` BöÆUKÏ%è;Èt2Ü 	   2¯4~6ÿ  uâ2ÎÂ;òt"EÏà- Â S úàS+Ö!¶×_^ÃÌ _ #3 D¶_3ö+ú6ÆÁï;T$Gùÿt}VUÿrS3CJü¹fpÈ k;ÁH@w;Ês2;Å Ís*Ïáøf'©fþÁ BÂ  @*' ;ñuÝ&¯+ÐoFK8³;÷uð][@¥à @3ÉUA@3í+ßÃÁë;|$GÙ$F B× ¶!Aiûr8GøØNøÙ;ð 	Ïs$ÃàþØ 
èÈ  Å ªÇ;ëuè\$;ëti!5 ¨+þ 	- 	 =È§<jN? $7(Þö4rÂÅ4ÔE!4 Ñ46! Â >w Âv  Ð!å ! p·Æ^_][Ã! @Àñ@ï  ïP-+ëÅÁíW3ÿ; èGél ïítiëýr<C ë è`ë é`ëËs(Å@ë è`¯èøï Ç`ïÃ;ý ï l ïýt+Þ Ñ3èi]öG@ýuêàbÏ 	Ò+þÇÁï;%  b; [ESÿr0F øYøû;È!ÞsÇ I¤ÆfQÀbþ;Ðué[;×t+ñ@B@ C;×uë_Á^A+ â'bÏ VbË`ÂË"`!áBÓrP aKB@fÉk#yA@ ¤Âs0;Í  Å!G ¬üBÐfX"ÐÂÐ@AÁ ;ðbÐ+Ñâ 
F" CCÒ`¾÷uê"ÕàÀà`¿ ^à¿@à¿ ^à¿Uìäðì$%·3ÒS]+Ù#¢ V#£B¶MGÚ#¥ C¥ ºAUuC¦ q!Jb$ ØA #	aØ)L$!Xw
;ÁsEB 9 #s8)° Ù"F@0#Ïè("ß ( 3"á"Â"XBä|$uá n ?6  
;ût1+ÎMff!¬ï 1 Jèóe;MG 3"y F 0ußÆNpå]ÃE 	"và  ìBY +ûÉó¢ ycÀ@ýT$$U#z$+ÝVJ3Ó 2Æ ~&àè u"á 8Z{$wYè]DwnÎ9=XÅ^;YÁ  È@`8 !·Áè@ÇT$,F Y )=/¶ Ê X 9[ZÈBÎ  $L$)×D$@!T  (ùÅ;Ç\ÿÿÿ^Å]_HÆC  	Á àMÿ @à4ÿ d!ÇÀÿE» ÿ%~ÈÊûYØ]à<ÿ Q$["øAÔ+éÇ9!æ!<E· ;+DGêíIe'Ú+ÊSE» WT$ 8^-¸WÉ~;Ïr+Ç;Ès	!  ¼&»BA&|nÀ!ì Àì b ÇFè©cE¸Y@Ñ a   5 ``A\È Á ZØrE;ÙsA+Ë P< P é"vXÍBX * P XàPC8  ½9 iBËb:	"> 
?é@á;Å"AC8Â]YB?  Â<   ²( VåY¿YÁå¿@äÿ Yäÿ¿D+Ú$ø¤÷f ÙDô ""# m (rYÖiølÝ gîsDf Ø`ês6H®ü@'¿'·
%³È	JIR3v Æ)Y@ IføuÓ$à+G@R&~^G!fûuè^]&¨qè pàb¿$qà	¿@à
¿ ·\1Ê Åà6¿ á@ Yà¿@à¿ aaYBø ÈÀÀ çááb Xà¿@à¿?b8XáL$ Ã $;Êt:{LÖAø ÷ é+Ö $æ;Êuåcö / -Å  / =ä  / @)ÀéuñÃ@KCMVW+ñòâCÑî.È?+Ï.¹+ñï .òË/¾34ðèïÿÿ`G0Ô  VÿsèÆðd Vñ`X+>F0?;Fu=¥$ N OG(a¹NQøø;Â/ª Ñoª OªQ.-òÿÿÄ #ø Õ_^ðÿ @oj N R2`  
Gèê] ì`$.÷8E  U1¬ °à !&à! j (   (!I @_ } 	@_  ë@ SÙU(pVÇ6¼  ÇCfÇCq§u+u /ñà<AD>»ÿvñwWVè¸Èÿ! .UðC}E +ø3W!opå 3_7 #_^]Ã[<Ù@A,?WùÇ  ÇG G` q 8à
qVèG@p /ÕÁæVÆ/æj 8¦\!=Äw\º@d Us_äÿ/ó_ñuì2x§ÇF FÿtCÿ   àüè, ÿußF"ÁãVÃ°ãFWÿ6èýb 'ÚÆMôd0O  x¸3 *dìè´$>3!ÞA[ó @  !Íì!Æ &3 ¨.zA!îÇ  G!áI AÇA  A=Ût#Mf/ÁsÁ!0ìhxBs"X H5(ðWÀPfÖ"%èËZ u/ Xá/`Vô	ù}Ð@¯á·è'? +ÐjÄ O8 ³ O6(©(c Þ(c ÛÁ w ¶%I$\ ÈÃØ] TÓ(ÃW/1ÂÁ  È@ V*²XÁ&	Á((Ç \/YÂÊTÌ ÁèC @GE@:óEÜ;Èø"êE!ù é
6Eìò©1@ÔÝ $è!ÄÝ]Ô ¦EÔèâ*GMÜ+MàUÁ$sÐ+ @å  ¨àç Â çÀU,È n/û©   Ò_ ©_^ÐTÚ0WÃ Ë èÂp3àè ÷4»!ø $ Ë ð  ð R VM¬8èµ7ÿw6Â ¸Vè"qM è7{u¬#u¸V3^è9r Ç $!èk@q"B@^:A äÇEÄ"X ÇEÈ   Ì  Pÿu _Äè;Æ!M 3H+E@ÁèEÇE &   t  öágEPEÄ/m^ÈEÿu& "M¤èÄô ±EÄ2UÈ uÈ+ÐÂ+		Áê;ÆñGÖ ÅÒtXúr;U(Ñeü%Á/ Y"î&½@RW Ð;MuÞ Ê(Áf!S X6t ½ A!ô À&uì# ¡gQÁE ¯Mì0~-p^Ð ´ 5 Ê ÄM¤ Å  ÂèGõcàÇEè ÿ }à Ká
E3ÒUð4ÆB
":
ÐEðÁ+ÐR!S ¬E m ¬ ÄVPè6÷!ÎuÜènp"$M !ÜèÐú!#PM!cÿqQÏèKèÿÿ¹ËÌÌ+4¡ùwBMÿG %AHM &Ë)E¨öªÀvu,ÇE  µ!æ ¤   ¨  U¼#EHE¸&è)f²ï H!1!sÀ!	!1 Y!B¬g;ÂuÝE6cðÿ5Å I!èÑ!;Eàô&A!Ç"èñp"Üè	 ä ÄèÞ=q 
 Ä ©EÌà© ©M¸ À Áø7oûu`Ä&+ 2´+ÆVèãÇåqEp%	¨¦Ø6 Ìà Vñè%Djj%º E5(  hñ4´R (Fö m / Ç# "!XæB&$6&%G&å9¦ñ_Æfµà ì E± S W) L$Q(­"¯+ÏÁ8v!}Fç
CèÛ9µD$$A³%ü ?Í`- ;ð (!ÿ6@<è¨·Ç_^ÄÂ&{G¢  lG¥ DÀ@`E  Î Ô+@øàõè[@L$ {Pÿ6ÿ1ÿw'© T#ï fQM!)Àmà:o ëCwà	o$óào Uh æïV¡¤Pû}ñ!oMä+`çEð! è@#¥E%Qÿu%4 ü  ÿ0!X"9 3 àuEä@æÎPèö Eä' 'ð+È"¨ùQPè:sbÀèb§aá8 Û á
Tñá Éá çÿ ñ¡Eè)2"Pj Ï¡"Eèâ M@ $ÆE#ü%2a4È O!¹#ýRÈQÿ7ÏèÏã!2ã	À ` ¿ ðà¯é.ß LißêÜèÜøÇ% 0Úý )Ò'FÁ »#ÊWSèÂßÿû!í@#ätiæ,N)æíÓæÿI6èZQp¿åêSVé	p=ÿÙ"l<¼3+þ,¨}Ü}4H 	Ca	SK+ÊU"U;ÏÇ+Ö¹ÿÿÿ9íÁ=0Çsë¸:SEz û Å ì[ÅìCÈE;ÈCÁ-4 %EäèÏ÷A þ } +#Sÿu+;Æ<0WQè· ßÿ!	@ ÁPQV5,=lÿÖ K]Q! PF Ç;£ P  ,C4õ MøEÿ CåVp# M;Ö  2C'K ù,Mé
"6 j;Çäÿ;Çío`(ab÷O)¯Ê+Èas|M4aÃGx%QBª à@ E?b  +ø!Ý!W SEà.M.3âÿÞÿs3ÿ '	Ä M+Æð8óñÆÁî!+G÷& } ZEàB XI;ÖuôëjE  `ú " \+øEWR!M '  Ü !'+øWP+ÏQ@ AU(=<(  BEà'Ö¯gw 0Â</ðMÜ#@Eâü  &\$-~#iV+Â'V7aB+S»ÿ,ïÁúÃ"< Áâ<+>ÑÁÿ)®_m Ø?m ß"1mÎRè¶êÇÿ;¸,ÛD>$, Dæ¿ F<æ!¿ *Ù%|3Òb%? 2( ù! £AQ×T)ÙÐB/²+AðÑræ&õ_f] Õ@	 ÷À  8ãÙ]ì3ÀÇâ3ÿE!ú#U,eäEüE0;p"/È;Úsx;ûwtMð+ß?s;Ñu]C"aøsQ+×¸!cC +Â Ki +!Àz Ä `MðÁÑè¹ÿÿÿ+ÈEð;MðMÜCÐ;×CúWèz$WEäUà Eð+ s!ßëh s n Yàn Mànraà#j "à	j  j !x  ü2;!!t]ìéø)êh4[#÷üGÜPÎèx1"¥#å Z »aÕ=ÿÿ%z 0ì .*à=   r2öÁt Aü;Ár +Èùs ù#À9ÈQèò)| çOå ¡ï áïìCæårEÀýAÑ M2§ò 
} è`	  	 Þ 	uöÓ 
'/xE$Å ÇEä _ lÇEì  UÈ.RPQ+¦è W*2ÇE % mQÇE   Ø   Ü   à 'jE$hÿ#ª¶E&ý N !$,G ¾Ai	u EØVPE äP,èC` ´P0ÇE¸ *³u¼ÇE S ìZª îjÿEÀ j  S  ØPM´è¾1, Ç@ÇE¬ 4  °  BÙ  Ð   Ô  j,õ Ì C 	 ? ¨ C"f ÿu ^Pè^B@  &PèR ÄMÌè§ÌæÿM¨è`Àè`è`Øè`è`äèw 3ÀåÃ¸yq  @' O 'È"ñ£Ã¸"Êà
$DSÜ!s\ò	ÄUkl$jR ðâbSìhâ
_ù';BuE¸!ñE¼è2I!. ¸!-  ¼  aEìÇ,!9¸ÏPRèð!-s ÿw!ÿuìPè+îÿÿ"$ G!8¨b%2"èI@KáÓ¡¤EÄ! !Ð¨èÝ
 §s  V SPèmê!"­ð/æÿ ò&ÿUþr8ÆO8³Âïydï Ðußï Öo '?YÀÁ$a/° Ö3GÏ  VðZ/È)!ðA"U MèÇãpè2.Eè Û.*]Á@òâ ÇaMèUÐR (	 0% POl$  ÎÑè@Pè>@2ã Çì!o±O Ü 
è1¹ P Mè G2R5ÝEÐÏa.¨ÊAµ(E / à! ne()I%(,2-ìQèghåMÐ%C  Øàìf`! èÑ!NÆuèèÕ /X!³1ï[ º   !í à 1¨è£ /o 1Or ~   ã&/Xã[è	__(æêß XålÁ&½¶@!0Þæ~Î2êP$=òY5è\F_ÝÐ3Ò ÀÉ3ÛU´]¸U¼!SUÀ3ö]ü]u u¤'ªu¨}¬}°@Z(=</Â!W)â 'cI ÁÁt  Á3¤0ÔXt )Ð1 %Ñé(3vMà@ Ð"`) Áý. ,Â×%W@ ØTÅ W JE22 T
Q?!ú;Æs@M;Ú 9fûEì;u¤u%$Ã«s'Ñu  «@jUØEì -#X /  Hçë$@0 0 zà0 *  q 4I m ËÁÆ! Eè@ Ð,	<M¨  5à }°¨è)@P}¬ mà ¨7 0 Áë%@,j ®¨èür ®`,@[À1 +@ 3u @þ\ÂÇ.$ Û! A</Ø`F!õì;Ã@ ´à]¼´è@`]¸à[a´Ût2   '@, @´ènà
, )$Ey¾EðÃ XMÀ"0@ ÑA@æÓô´ ªÁG%þU´ =Ñ `9"à/ HGøé%¦Ýq!E¸Àt4ÊB Ë)Á $PE¸j,s  5<àIEÀè`?   ?[E E`A ;!yE  <Ñèj £à = _`= ¬à=E¬i´P1¼ ,ÛSèuÓÿÿ¿TEÐ%ÞÏ+)` +ñó(@Î.×SBEP`: : : 5 Ï 7à5 ¨À5 @5 È@3øÿài@gKALÁ ¨~ °äâ	b¤~  ¤àîa  ´ ¼à ÓÀçÛ,'Æà  ¯ ä¯ `ä¯ñuðÿ*ÒMè¨äÿÿ! E'y èD>' ÇÇM"EèèÓ7G©M$xèfèe$w     ¨5%Ú j&eè*¨ÿ6M èÝ Z U (P3¨ W, ¬"\&à# VÇE©^ ´  èîî! NJèx7÷] #'SZZUi(ª$óèo(5nEM+ÈQ.å{©VèøY &#)7HèJ GVèd@: u   _è6@8}¤ öã(PSW@ À"²¸S §¸è$Ù  @RØÇÇÑëà hÎ Ç"ëÆE)ÿ@Ã4ØWVGÍ¼èÄÑÿÿ@  1 ÿuÀè®  ÐÇEø¨ÇEgÓ"?à% E@9Ø!CÝEè'u + ÃA¼Áë!m+AXÝ^:	@%àè@%Øeà:  m < yû(Í 
 ZäTÝÝ]$ReXÄ]¼@³ °ò,À(Åç Â0y
ÃQMÈTÐVÓ )&Yùä%4  Å9ëÃT:X \&@\á BÄÃP2<·Ð ö}Ì@À hi÷+u % Ò]½èPVMÜèÍì 9MàÁUÜnEì"_PRQHîÇ4è6!­!«V1ìÎè5"pE"
ÿuÜW}ÈWèÞ@G" 3ÄVèÆ'! è
¨^^c&(¥Ð+ÇAWèF  Û@Ä+ÃSè.M¬ ´ã¿ ÀXÇ M#15Qèø]`eM5 à ÝÀãõ £õì"(SUV!ÿÀ3ÛbèWg0L$!	9YMgÛÚ"^Ð!pT$	+;ÁtfPB&Ú :\§;Áuëw6þ 'òY!ÜDW ;Æs&úyWè+éÁý;òuTÂ+Æ$0sH+ñ$þ+Æ H +ÑF3ÖpÂT$0Ñè+ÈÂ3Ò;L$0ÏP!ÖCòVèkj@@§O! Â "¤2Aëko;õuVÅà qJ`q+ñàsM°+éF sÅ3Ò`qÅ;Íàmýi`m`ß`sG&}HF¶2iCG;!LÅGT3ö "1Üø+ùÇÁïSFþñ"2Zÿr6AøøYøû!';Ùs"ÇàþfIOÂÆ;¡ À ÒÁ;Ðué;×t+ñ@ú1I#ÞQÀ,SAø;×uê_^][Ä%ûð fÿ àåÿ Dåÿ]M°4uPèß#CMÌ Ç%ß  è@eèûr%C}°+j WÿuÌ!çPè¤T%s M#P Ô"%'l+ÑRQ $Å \@'å  ® LVèÈÀ[­è@9MÌ$Ä¦[ Ôæ[ÎZ) s`£ 3!ÞÑîFVèwcÍÌÇÁæ÷ 9;þt(a_!Æ H$½ûïÆuÝD	uÐPWVWèë% ` ?  ëMè+52 è&Á!F·pË Q'&íBè*<Ð +@ $~%ÿù2Þ 9þ#ç ÷ ·VèÂÝÿÿ$ÓPèµ ! º F³qp. j,ú ä&&VèS!]!\  #@v!q $È Ø!~ À_Vè@#á Y T AVèn@æ õ @ 5 p#H K ÈähtYY CDM¤K$BE¼PEä=âC|EÄ  ¼èÒen
EäÎÿuPè"5Mäe ìàe e# } àåOöX}MÌ2!òÅ ÛÀ ° ¸ ½: ÀÀå3'À (çí¿ L»-°#(ìôd£ ¯ MÜ#>à
]°U¬{+;8¨§ Çó¡øKÐÇ"¢  è¸f+$MÔ  "ifÏ"$  n	U¸Ç E¸ÑèÁHMÔR8¨E(´ Fè¸æpâ`8MÄ þ@-Ä;Ès0ÑMÐ;Êw'ò+DÍ;EØu`|èB@uEÔ $¡ ) lñë@  " `X $dÆ /À#+ Ô } ÿ È"Õ P@r¸è-  W"è$Û"uÀ2¹VÿuÐ" +-ÿ3è[× }ÄM´BÌ ¢Ì U ."Ì ä 'èèÚ "MÜ  I¥Én$1]äj(G´SVèzPË8,Ü#ïª"Ë"Ç SÂÈ 9@ }Ü@!Oè =Vè¥@O$"èz / Z |ì+Ã#*xSè±VDE¸@E´8pæ	."]´ó}¸;ßtEà4Z 3h" $%;÷uæ%?ÛA+Î VPè]-  +û Ø$[?®èm@Ú E@Úd«îm ÚNj # äy«Qè¸OàáÈ á}ä*Ãª¡ V@!1,!! ¨ EVèÂÀ`Y  3& ì#&bðWèÏUá ¦"@¦Mà §Qfã	® +q rAòEè9§ àè]Îc©; ¼(¸`Y-?ÀY À"Å#ä ZÀñ	¬ ?ÀãMð3Íè-à 1S Âã` SÙV9ã
0 @ÇC#A ;3tqWe¯ < >"«RNaN	ùÿÿÿwUÁá 
wU¨uFHü#?+Áø3­ø#w3ÁPèØÚ?À5UkÇF    !b º  ÷;;u7S Ã¯`  S\$ËVt$MÝ0èV+@Gçù Ä =9#^	T$W8+ù+Ù§¯ '¨ \#þ Y). X #÷ ?`M;ÐrÚ {Âd¤ Xä ÿ¿#¥`@ Ç W?øs8o ä+XÎÇ7@ðaU¡èá#Æá¥RíÂ M7ÅÇHÇÄ$&Ïwèa@6Mð$, dëPÿv$>Pè%ò`w ØDÎPècÖ 19 Ò">Mà+Ê%¿#RèS³à
Arÿ  àÿtSVþ	?ù}Ä' ´7åöHèiÿ> E¼& Ç ¤ÏèDL(]¼3;ót>G MQã% F, v%·E#& C&è6Ë Ì 6#;óuÂ`CE!YU=à%JëÏàJ  s !U@wPèë>Àjæu"Re± V`#,K BBBÂQÀøUÌPÿ2 ¶èÈÉÿÿ3ö3À3Éuä ´M u¤EèE¨3;é [ç}-*	EC3Ò+CU
EEU&>? *D"3 E}ÇE ì Z\ EÌÕ  }NØMà ? ©
èß @4Ç>ñE4^ èw ÆEÈ!¬ÿuÈVÇ"èÀÂ êEM1¾øQV+þÇ P'gV}°è}Ìd¢3À%*3Òfff¾/Å "ü12Ü2vEØÑ@;Çrã "{@èôÞ$uäÐUØE´Ê;ÚÁé" ÂHØ#ÍOMtX''E´;Æsy+¤u}èjt Z;÷u[Çì [L+ñl[)Â¬Í Û.;+ùF Á¹ÿÿÿÇ3YÇ;ÏM <êÈ¢](%E¨u¤ r<ðEèETì p@°Áëe t l Zàl Nàl nàl 5à l \($`nöhE<ê 'bB%!"?ÑÐEà;Ç![M!{U)¸&\@úuaÂ+'mÑR+ùÿ+ÇmÑV4+ÑwíÓUìm`MÒMìMá	\A	} }M"*!ê . ¬!	#;}ìuj&Üè\`È@+à %kÎ!®MÇ  }G &º)E* BÝ/XNd{âÓCUÐ# B Õ#;Ðÿü" !EÄ@")ë
PQ!VQ"3è	CÁM #x/G Á4Ð	.ÁöÄD{AERæM¬PQ,R"èLPúE# Q 3[  &+ø(=i¬è'@$"'} Fø  Qòà W 9à W V < G èô$f 'Gø`M _PW@ !, U Ñ "u;  õ7=¾ÿÿ¿õ7 õ7î` @õB Õ÷½ YÈ&à øõ !¢(]ðàüLa¢!?ñ áM¼èÆ÷ÿÿjz
¼èÊ æÎ'Mè jG¿ËUGÀVCè#  l$3É[Ú]UW~üÀÁïG½"õ  $b$ÿóBøR@ Z$%@Ð@ ì  Ø@ ð  à@ ô èïuÁ_;Î/ÞÈ¦/ "D @ & A@Nø;Îrê/¾]|  ìS@«$Ù;'ä~1Q¿,;G ¶CúX,SàYÀ:Sò"4È§L^Èfâ
Ê7| ,à/À:r
%)b} ë"¥ \`	(ù9I,É9KBK6å!ùI(;Ár\GÒe _^0¡Â \w"!FI=PQÿ73ÛV/+1FOù$>Ð+ú±JÑGû$ (ù F!;R%! ô@ÚHZ{Ñ+Ð\$ 52ABÁê   íeâÁên» ÕEåT$RPQA P!	$fÖL$, 
è#ÀÄà ±ÌD$Ç þÎD$èb*à    àèB !Öà  ß Èèß$VW®-{®{uNPpI ÀÆfpÀ,	EàþsXEè® P! Ç j!¨ @iÂè²MEMÐ!&i!®!	MÔHMØH ë¨#2ÃVè<Í#º}3É% Ç>#$ú# G'~@T<ú(=À¨}ð . 2°ä Ò;Ðw	9:YÇ 2	;×wFÿÂFM µ ó~EàWífúà<¼_X5)=?\Gøf\Ô(ØfÂÝ6 Þ?PØf#hAÁA! È@JÇfþ]VT 0 Í 0 Î 0 	nÀf^ËfYÊ Ì à3à/	LÊÁ;Ïr ß;Î#w ç CDÆlh  ß(ã@q@¿ Áñ!Fýq&¨òU0`"pHÁ#<  + 6 É g 9&*X}¥ @'YÌ 7X!·Hð d | @5 2@ò É = à2øÆà1 Î@aà1F"AÆ.%à fÀ  Ø'Ó"ÿ"<u'=ÎsR ² ªá!!ÛnÉÁà	  !d\ û Ë ÀÿÊA%& Él` Ð&­èÊ i*ªl] Øì]½F>ì]Ú£#äøìS1ÛL$3 #CWQËC¾"b  $ +D¾G'#Ã Ç+*úÇCnLèTÔ #]N68;ñt'@ ¼[5/ÖG×)X( !ºCø;ñ4_E$ZCn à? Ä\à  àSÜ:<äð/Ukl$ìjÿh èd¡! PSìHVä
³<BèF- ÌqgñÈ!"UÌuì,±}ÐVR	+úS*'¤Zÿ2ù)ÃEq ¤º Çpuè.}ÆEä2(äÆRpuÐvÿuÌÇ,B}¶@c ÐAïÌæÑSPÆ 3+ÇQ @${1Üè¢· *}Ø&YUÜ3É+×)Â1Çê;}ÜGÖ"LYúr<ò(ÑæüAÏ"#$F$NXÈ@"ï "åuß  Ê:áf#ÒXÈ;Êt!í  'ÛYÀÀ!ù@!+Ý K6¨êIq½Î*{"u ^"÷	^K)M°èë'î(M°E°"¦òQÁP*ªÿ6ò%ë¸ÿp*w°ÿ0 °èÁAE '!)SõM¨Cõ
M Àæãð l$ìl"Eéâ ìÄ"ïÌw"	ÐÿutÑîFèZÆ$uxT  ÇRèE !&|¹EXVPEL@ÑXPH 'Aî ´LèÇø`Ø` *âÐèÑîtc^Lè¤¶åÿ]Ô!Ø]Ð3ÒÁûNÌCÿ2:@uì 	-N+÷@]EtEÐÁþ! $©  &X/ËrDjíB@UtràXèPE``t #÷PlP@Pè3GM` ¶ *·oEhm+ = &vVÁà= $`r2öÁt Aü)% +Èùs ù#À9È7*ÈR«ÇE`!y#" d   h ,1 T A_è¼íÿÿ¡'QxÿÿÿQÈè`¡ T ¡ 
¡ \àG¡lÇ ¡ T   X   \  ¡ L ¹°`½Q¼ `Aõ `Çèþ ¤!i ¤ !d@ºÏ @ÙP%ùè­	$Ed 7+E :è*4 FEE`,;j;XèûHÐ	øMdE+M`2 I ^QjRÛ`èÜ  Z L   Pè± u ð}   "E$Pè  Ä6× 0  AU 07 <  @  á ~ !~ 0¡~  g `' ~ DáG~íÅ¡~ <!o!w @  ,Ã!2`± y 8àGy sÀy 0 j r 4   8  y $! y ,àGyùÄ ó $ j r (   ,  y  y y  àGy Ày  j r       y  y y àGy Ày  j r$Q@   y3füy àGyÃ¡m i@rT EiÃ#J#, Üc$D@Xè£ ØC  Q#£# °èUÊ# øã t  C X Pè­Ctð`: ¨:CÂ ÃÂ  ;# ´ H C (w# À  @ é S<#  @ v5! `!  +8ß$EåB®_Â¡+ À!*!$G/  È !¥ ´ u2 ¼`u:¬Qè<g£ÇE´   ( ¸  vØM¨/ °à/Ô; / ¨ ' ( ¬   °  / / ¤à/ ¤À/    (     ¤  / / à/ tÀ/    (      /S^ %3 äà3 @À3nµ ÇÅ Ç)¿   gCPèU%!ßF & GNèa(%x EGÐ '  H E>è( ,!àEd (A½ / E ) #`< $à< * $P%Ý î% 9D +@9 Þ % C,P 9êÅàv - &J ±<@ë .@< ¡ <M ö\aºI:¡ æ@ïã$
/`/ À/ãÀC¼"°`/é9 _äj $_Z`/ ¹À/å 0/`/ À/å¾ </®`/ YÀ/æh H/ Pâ )À/ H!" L   P ! T/`_ù8 ïè
GM#Ã 83õÙ ÅÀ3p% Çø­	M|EÜPèÁ¿e  Ü ;+"¶Ö ; d! D$+à  hÀ B  8à  G  M`  \)üÀ\ , i à ÀBÃ  z tàYí7aMè  Y ð ;Áø$1 Ò ec  ; hà; ±À J¡  Pà  À I_  \à  o  ý
ê TÀì8[el]3á.Öà  .ß,:ºêì: ø!÷î>E+ñF,àÇEÐ #!Æ Ô  p+0E9bµ   ÇáH+Eà)Ò7O,ÀÄÿ+å*(Ïè"-à¹%ßb^6aR3Gu,/1F¼ &Ä @-±Aó Â3A}ÏG+ I P8X Pè.»MÄÇE} Q+j¸  ð4À + F® F®  k@.| :"È @.  .V @ V@»`$! ¥ à¾Û5`¾Ç@B    ÇE  búñ$@ Øà2 ¨ 2áUÁDMÄ b / Ìà/ xÀ/æ´ÇEÌ e @õ 2"nGÜà5 B53Ò3É3ÀUèMì2½  ×3ö+½@ß/ù õ	u}äÿ R/óß@'!ð-ÁEðvd3ù}äs7%º;Ð w- +úÁÿ;Èu!MèèâÓÿ2WÉUC-º 6ëà$ ½à$1Á ª F ;÷rF§MÄèd.D   »:ï"dPEÄ0F È ¾
PÇEä3÷ è©ÿ r" Ð/vPè@à"	EÄ ",½E¬ GÐèlF4¦Ô   ¸` V !òAÂ - AòCÀ@K ¸!Y)EÀáVë3ïè ÇVM¬ > 3 ´à3 ·À3è ÇZ!Zm  b@ 4#r Pè¤©l g   `°¥Å ÚÀ¯QM @³¿`ÆB  @À@Æ  9¼#+cu $Àèx Ç½ z)ZÀ/ô2 öèx Ç½M nK_ 3 à3 ÀÀ3 ! ,~« ÇÁàöp!ãPè$£à ùAÀPÁª «$T AhPè;%!¾  9 Q#ó $!
!÷á ,Àá
áîü1 ÷ê  Ç¡îpq  f5x àý Â 9`Ð ÿ ÇfK  	@* DÄ "È'/XèÏDM  Ã @Ã   Áú   # @# «  ap !@# ü?³VP( { 7"Pèªê9M á / ááôÿ0 üáôâ	T ÏÀ/âTI¸ ' äá& À3ê¤ Ä òd ÜPè± êM¸ åju  Á*vE¬ *è  Á*Q" Û%º!  E@}+Pè¡`# á¶  á¶â
YÒ/¡,âY ¢À/âY@ò éJ ¢Há2 h 9a"D"OHi  	@* +à;üþA; u!¢$1Q4!RAü» @  n 2#QCEèeºÿá \ 3  L A_ -àG4Q"¬@D ·`DE A 5 ADè# A V¨ 6@# ó  PÊ &7P+Èè 7â§É¤.¡Jä
8â§À/ WÀ/â§À/ 'À/â§ @ëIà5ñ-a!a!lI¿  	@*  >AJ>Içà> ²À>@  ) 4JÖ  	@*  >A> <!sà> sÀ>@  ) 4Jô  	@*  > ü!î >à> 4>UÈ3ÉuÄ+Ö½BbÁú7f *çï%Ï)´A7$&Æ 4;Ê5~MÐWÛEWT5È~¿-°p   I(âM:8Xâ	  á  Ê  A)ÊYÂ  !:Q&å^á(Ä [ "(XØv(Íë 
 Ã@
Îë(:q ` Åà Æ@ Ã = £  .ÈöÄD{ Këd  AYïà5 	à 1¸H6ë3Àf@mw Ãv © TºTç8PTÇ àv;
J÷EÐ;] oDÑè TÐ<NLÐè! ò YÂ Á YdÑ  àùdÐ=\¨àûDÑIsàÇ fÀõÎ!|\Ðøëj à4 LÑè rÙwAi ËAi îAL ë N ÅaD '`#ðTç °þàû 
 kLÐø"8×"fDo+ÇYWèÍ*c#%ì"-%è"ÿ d  ;M¿à  À D  âÃ pÀ D` òÀb OÀ IÈ   +©À 1  M*±+À ö@.Ì+ÆÏVè í
êç)`åKèyæ$Åíw<J,rAN $"3\P$=!§!A[5èï	#rYÀÉCAD$Ý \  ìVñ=	pÅ	W|$ L$Q=WÀ+Ï)¡:¢ :Ç   ÇG`*ÇG 	 è;·ÿÿD$$ z D$Pÿ7`-ÿv:«=Nÿ6@<è¢¢H7	Ç_^ÄÂÀVt$Wù-hÐ+Áú;Öv+òðG_^Â s7Æ+ÂPè
Q7 WÆÊme&° à- Rèß  @46 +M¬+ðÁæw= çÀ  Un àîìú×eðù}ì VÈ+uÁù;Îv+ñÁæðwá]ß@«êÆ+ÁFÉc¹!@­ÿuÊÇEn-@·W+ÁPRèÃLK@³ @³ @³  ³àTMìèTÑ=9?=áàÓT$3ÉVB2+Æ!«;  'AÆf8!ÎfZ?A '+ %;Èrå_^"!¿aÔW}_+8áâ	 â5µ íF3Ò+Ã _ E-  ¥¾ ¥ÎÓ$! ÈD Âes Á@
Ãë%=QÐB?d+/F;ÑrÐB.¡[aÂ ¯0_ëð _ìtð\~-ªU  Z5 R \EEPÿq Pè  ¸N! '`¡ÁÁè ( §nÉóæ ÄXÅ^ F &W@¦M¼F?\Ð #![æÀ 4 & `&Aÿ#tàUÔà  C Èí M& f³p#¡èR® ÐføYxC¶XÛECîE¼@ð(Cí \`6  E@GEÔè @(È3Ò  @E/ÿM¨}¬UìU°@ U¤1M UÌ!ÊUü@Ä0&¹_)æ;Ç#ê;È #wøEä;úukÂ+Ç øs\+ù¸%N /ó+Ç $(+Ñw#Õ#ÿÂ Ñè+ÈÂ3Ò;MìM¨CÐ;ÖCòVè2#ÞU°}¬  M¨uè 4Eä&   A}ët } hà} à$} à} z ! !pNÇ!MA- @§A/Ôþ"GÇÑ;Ïtè;Ðt ¬ 
 #Â(  	uâ÷+ñMC¬Pè¼§ 7MFu¨ÁèMÜ3É;÷*Â 0u!m GÁ0#P?}à$]EuÜEØãß $Ã ]$èîù M
EäÄ@ÝÆA¥ Ç&uØ ]Mè}A "² È"² É²¢ÙA â	É##Wÿu B± W cM" "èI¹CÕ@&  E`@/ Wè/,Eð`AWèF 03É&X æM@2 ¼%è&¦ ·M i.+Ï ü}$EèMÈ"xÔ¢!+ tDÁøè±  è3xEuä Èèþ° ÈEÐ+ÎMà 6M3Ò$	Áñø+ùwÁî%Gò' #c	BÁ;Öuô"¿3ÒIzMä! Ç!(ÀÁïcÛ ýd } ¶^ÈÇÏð+ñÆà J ÏM´@ Ô T e B 	I`YEÜ!© Táf#Ø]@#ã Ý $è^ Ý]cñ Ì!Ð@"DÆè âPEÔ  ¼ Pè×A=ÄE!(e Á)ò¯!Mä+ «ÏPÿ,@_E´Ä -@j ¼(ÃeE{(!1'W= <gr*öÁ Aü;Á
 
+ÈùLù#ö"¤ÈQè\§»úBàEè@!ö!Ò;EÈ3C0" E!EE)}EÁm;ø6GÂ ÇEÜ9Utz}rU /]H4%ã È B!;Èw9}Ès6&¸Çàþ@6EÜ #ÂÀ'QÀÁ;Uuèëh4[ÿü%Ö1};×t+$]!°@/A¼Aø;×uêM!+ZX$ïa+vÿ8á - 2!- t a/ r a1 s !3À9A5&¦a5"× `*P;ÃÊ9àÅÿ!¬"K}ì+þ ÿWVèÈ êG" Hç4Sç Ù]äÕ»ðU##jÄEìE#?üWÒ"#UÜ0;ðt!ø#V3ÿ^#O+Ú MÌÃÁë;VGßÛt-¤X
G$ï;ûuô` U4^&c#BB ".;Ð ]ì+Â!O "ËubÃa]&<sS+ÊMIç ½ +ÚyÁû¦MÃ3ÒfLÃ;ËMÀFI×CúWè8,&IEÈUÀG_U"t&û$(V' ~  .&ës  w dàw Xàw Eà wÀ+àw MC¼À|!ÝFC.° " Ak MM*Âw Òë Ð]ä6 UÜ;3#"	òYUú./@Ñ!9&ó~ N6ü )AEäÿHN t)Ã aUb³wtâ ­öÁueb§s^+È#ÓrW"wRB£ ÇFjÄÇFº F$  Vèr  ®UÜ Mè';ùiÿ$ è ÒDS×`sv'ãpà 2öÂã2Bü;Âã 2Ðúã2 úã2ÐRèó¢£2ôd  Yª#,Sÿ ¦âÿ âÿ
]kÃXPè|Ûÿ&0M_8ËEìÛ¥ XÓkØX#* ð#- ÇÃt|8Kè¯Úÿ@	 (&®èt  @ èf Ã 
KÇ H-/ @( QCÿ5LÿPÃK(Ç@   Æ@$  (àC@ LàEì!hU@ !g8¥ì;Â] 
Áá		D
` 	ìë/ áiÃ[©Pèi àA ô A äA å iø@% -ð}Ü   · EÏó%qE,nEì @
èèd Op!!/ !=à 7 è3®Úÿ / (ÏjS''   9D$@ KHà]Ód ;T&ód ` N-  ) è 
)
 3 ) èûò 1 @flÁãjSÿP'+ äF ]áRä;ÃáRqO EáO áO["çPè!Oø}ðÿt:3öu%&1E  vÇ:¡I#±è×ÔåÿF   ÿ .;órØ*[âîAä xàiÃÀ
AßàiÎ@$Ïà ÷t à$ÈRâo
d¡¤P3ÅEð!)(²ôd£ ù&EjÇE  0xE;lh?ÿ¼JXÈÇEÈRE)uÌ}Ð"ù(õ! 4=aËèiÅ MèAÁ(ïäMð3Íè¢$­ o#/ÈSà QV à(XðèÒ!@%ý kÇ@q;èêy Ç$q¿Ê (Àü Æ 7 º!o#Ùö IÆ M@ÇA~âÇA`½êu+Òà´ ^ ¨/à  /ß()(B)A        0  0  @  @  P  P  `  `  p p(Bi)`(A^ `(V¢ `(° ° `(À`(_£ `(CQ `(ð)`(  ü `(`¶  @  !`@$ @J@,`@N@ÁbþáÇ (a!;a  (`ð @ñ B `¶P!@  Q`@T @X`@\`@``@ÁI âHo ¶bo n¶"(@C÷@ @`@ b b§ Q2¦t$è3#FPEÐ= $ 7  Ç(à 	 0à 	 4à 	   	ìOEÇ< .  Ç@à 	 Hà 	 Là 	 8 	  iÇT% .  ÇXà 	 `à 	 dà 	 P 	 Ô`cl- .  Çpà 	 xà 	 |à 	 h 	 à`15 ` Çà 	 à 	 à 	  	 ø`1 È ÿ  ?ÇÌ 	éß9èDÓ @Ð> ` /qÇÔ ÆÇØ ÇÜà 	 àà 	  E@ Çà 	   	Æ":!
 ¤ Ç¨à 	 ¬à 	 ° 	Æ´@	Ç¸@  Ç¼à 	Ð?    à 	 Øà 	 Üà 	 Ä 1ÆÀ@	) «  ð   )  0 @ P `  ^YÃ¥ÿ Äç/IôÇCZäÿÆC ÇC 	ÿÇCk[³¤@¹jÎÇM"" BÃ@ Ç "¥ 	E]@	uìèJ¥ÚÿÇ@;ÇF$  ÇFYìÿÇF  »Ì (ü  TÏ}ìè@0ÌL \ G0 G0 G`0ÎfÇô 5 7 O qI¤  B fi  ÇE  ` !Â@ Çà 	  	 ÿÇE©@ }  J¬ fÿ5¤*¹,Ï@` CX¹A"@B*öF=&úÇ@`é/N Ãæó¼¦õã ßSø hQ'ù=Ô@FÀÀ'fÆAÈ  à / #-,Çø#¥pp x$' x  Ç(à 	 0à 	 4à 	   	  7Ç</ .  Ç@à 	 Hà 	 Là 	 8 	 `1T7 .  ÇXà 	 `à 	 dà 	 P 	 ¤`1 l"@ Çpà 	 xà 	 |à 	 h 	 °`1G@/@1 à 	 à 	 à 	  	 ¼`1O .  Ç à 	 ¨à 	 ¬à 	  	 È`1´W .  Ç¸à 	 Àà 	 Äà 	 ° 	 Ô`1Ì_ .  ÇÐà 	 Øà 	 Üà 	 È 	 à`1äg ` Çèà 	 ðà 	 ôà 	 à 	 ì`1 L!Ç  B°P 	ÉË=ÇT 	ÆÍ<è¢Ídáv ` ÇÔà 	 Øà 	 Üà 	 àà 	 äà 	 èà 	 ìà 	 ðà 	 ôà 	 øà 	  |@ Ç 	Æ@	Ç@  Çà 	 à 	 à 	  à 	 $ 	Æ(@	Ç,@  Ç0à 	 4à 	 8à 	 <à 	 @ 	1ÇDà %ì H Eì X Ç\à 	 ` 	fÇd`
Çøo {  Çüà 	  ` `)0r` @ P ` p     ° À Ð à ð s`Z    0 @ P ` p     ° À Ð à ð to   0 @ P ` p  @u`E P@ @ð °   À  Ð   à 0 ` ° p À  Ð  à   ð@) w`   "¾å 1ì"ÿ%JE¦äÇ&à"0JH D&1@ "m@	0ßÇJ@ è³&æw¶@ b Ø@%  B Ü Çàà 	 äà 	 èà 	g6  ÇG@  Çà 	 à 	 à 	 à 	 à 	 à 	  à 	 $à 	 (à 	 ,à 	 0à 	 4à 	 8à 	 < 	ÆL@©Çx@  Ç| 	"  
   ¤ ´ ÇÄ   ¿ÇÌ`	@ ì 	@ÇÐ   ` @ hÇ`@	 h`	@; pà 	 È	%) 8`	  3ø Æð  @ <@  Çà 	IÊ@ Çà Ly@ ÇM@ ÇM@ ÇM@ ÇL@ Ç4 ;çÓî Çç öGLNG D@6$@>@	 (à 	 0à 	 4à 	   	  7Ç< .  Ç@à 	 Hà 	 Là 	 8 	 `1T# .  ÇXà 	 `à 	 dà 	 P 	 `1l+ .  Çpà 	 xà 	 |à 	 h 	 (`13 .  Çà 	 à 	 à 	  	 4`1; .  Ç à 	 ¨à 	 ¬à 	  	 @`1èC   Aß ì 	ø<Çð 	ã=èÆ` ° @ Ç´à 	 ¸ 	Æ¼@	ÇÀ@  "* Äà 	 Èà 	 Ìà 	 Ðà 	 Ô 	Æä@	¬+p`F"à)   À à  ( " p  ° Ð ð ) @    `Há LHü    P0 0  p Ð à ðH`>     Æ N@E` P ` p     !3 8«g;!3 	#pCóaóYa4Ð å |  ã sóC X-¿Ð@P$2 E  Ç(à 	 0à 	 4à 	   	 Èb<: .  Ç@à 	 Hà 	 Là 	 8 	 Ô`1TB .  ÇXà 	 `à 	 dà 	 P 	 à`1lJ ` Çpà 	 xà 	 |à 	 h 	 ì`1R`0 1 à 	 à 	 à 	  	 ø`1Z .  Ç à 	 ¨à 	 ¬à 	  	 !1Ç´b .  Ç¸à 	 Àà 	 Äà 	 ° 	 `1Ìj .  ÇÐà 	 Øà 	 Üà 	 È 	 `1 ä(@ Çèà 	H°@ Çôà HË (`1üz@@ {   Çà 	 à 	 ø ' 4`1 $  Çà 	  à 	 $à 	  	 @`1, ` Ç0à 	 8à 	 <à 	 ( 	 L`1 "]  d;  	å+E   	ÆM<è¼ÂKE` ` Çdà 	 hà 	 là 	 pà 	 tà 	 xà 	 |à 	 à 	 à 	 à 	  	h à *Â  H!  ÇL ¬@ ÇPà 	 Tà 	 Xà 	 \à 	 `à 	 dà 	 hà 	 à 	 à 	 à 	 à 	  	Æl@	Çp@  Çtà 	 xà 	 |à 	 ¤à 	 ¨à 	 ¬à 	  	)I °`
Æ²@Ç@@a© Dà 	 H`	!,)À` Ð à ð `   @0  @  P   ` ° p À Ð  aà 0 ð @   P  ` p À  Ð  à   ð °  1V }    0 @ P@) "7  ° @=,  P eÿï÷ ÿ÷þ~ ÇQq8ü 0`êÇ¨rtÎè°¡Ûÿ`@ =|	ÀtPÿ8°=7+ 2 F}Hé Ì4ÎQñÇR>è\ÿKuRZèñWæÿÇx>;^Ã ) ¿ øò¿9¿¸	@{ K´¹Ió9:||9; m)º S Ê  ÊEðÇè 'u×?»JLÿt /ÏèM* W / e@/»< =  R"j ÿ@ E ³K  ¿R!PèU}¹ Ç9"  ÆïuãLdèr²,0 A³AAY}üÇAo&2Çá) =Av Ç Pÿ×á sº@_!Ó Ð!{S`c ¬5¸@ cÇàcÅc Çà]ÇA²áìòß¿«d¡    P;ú	ùè  L@¡    ÇG@bvO@è8@ `ðG@b~GD!e ñ Ó@ñ G+c@7(   I4  ë!® I (ÀI(èî Ö@G(ÀC ,àC , 0  0  C @Ca/GÀCèª`C GÀC àC   ÇGBã¡VOá½Á ·Zn4P"¡²á  A² à b!¢`B0 @cË`ã ^.\z>.ÏèU@üK¢ÇÈ'TãÇ2ªà ø/$à ¼(âàVñÿPN$ÐÉ¸ ±
^OÁ¯D$ÂÔà Afn [À*O MòCÏÒtAÇ@@ @MÖ  @P@@@ @Mêà  @@@ @Mþà  @@@ @Nà `w@@ @N&à  @;@@ @N:à  @@@ @NNà  @@@ @Nbà   @@@ A  È a@PÀ@ø` À@ì` À@à`à G@Ô` À#@È` À@¼` À@°`  À@¤@¾eGa­ ­@@ Aà½@@-eV`- -@@ Aà-@ ÃBOè(ùÿÿöD$tj(VèÙEd 7&"M "tÇB·th&Vèµà#ânOjæ Oh`@@. à.@/æ¿ r5f¿1Q FÄ LB£Vè9àL èXk ( "  ` à" eà @/8là/  2ãVèæ~àòà,  @/ È  öahH$¿Vè¶à/ Hà_àH@/ à/Øoà À(vVèVà/ ¡D7  %à0à/DWà /õ}àðà/Dwà / Åà/!h :Á @%= ^(ÿPÇ^  Ri d&: ÿèt×+·ÉÆñ Çò °!YÇðhñ  ÄÇô  ¹F)   `  0 ° S   T Rú@ ?)@ w
@)Hð)° \ Eéuß 3  A3À `J (tQ/Ð À  @Qfs¨)GÇ@h@ Çô o ô o S@ Ç@7@ ÇÔ H@ ÇÔÁÇô ¿à Hî@ Çà  à 	@±@ Çs  Çôà Sª@ Çg¥  ÇÀ   ÇÄà 	 Èà 	 Ìà 	 Ðà 	 Ôà 	 Øà 	 Üà 	 @à 	 Dà 	 Hà 	 Là 	 Pà 	 Tà 	 Xà 	 \à 	  à 	 à 	 à 	 à 	 à 	 à 	 à 	 à 	  à 	 $à 	 (à 	 ,à 	 0à 	 4à 	 8à 	 <à 	 à 	 à 	 à 	 à 	 à 	 à 	 à 	 à 	  à 	 ¤à 	 ¨à 	 ¬à 	 °à 	 ´à 	 ¸à 	 ¼à 	 #T"Ç 	VéÇ 	  	  	  	  	  	 h`Y/EÇ`à 	 l@	à  dà 	 x 	 RDÇpà 	 | 	 @0  t 	O wØ  Çvè  Ç×âÇK·@ Çx  4TD Ð  ?)C CÇUÅ@ ÇÕ÷iìfÀR$WàS º@GÇX@  ÇD@ Ç /)Gº Gy @3%T§,£pCÇt`D@	§@	§@	£À '£À 	£À 	£À 	@ÎØ¥ YWÑ	  Y	  	 @ð Dß ÇaA/Ýä>SÆa8 =@¾ , ÁDVL$ÇD$E+W3ö úY+ÂFBýQ* ÆiÿYÄ*$Pèe(    Ï+é[ÉÙ Ìó,Á ÀÀþ`,\È ,  , 8 ,ØA(é-åÙÃþ|L$BÁl$ {x%p_^[%ÂÃÌé ©'GÀ ìD®	ÄD$@Ul$L&BM±W¾@j ÏÿP(x ~_x ~Y¾ô F uP3öV`9p~!S N?	\´Fj Ã ,) >;p|ç[.Ot$`D! Ï@	 @ÿu@Èèá¬ýÿ ½L_^]3Ìè¼{GDÂà­+? L!qø A}b|  ".Ø".Wíó^Aò=Ø]!P'© 5L&=Zà(ÇòY%À#=@ `\ÄfZØ % /Ãv
/Þv(ÝëM(Ó E`(Ê 
 $  Ë@(Á @ =@ Ã  \Ú ü@XÙ à [òXç kä/Ä ^	/æwH(Ô(ì / Ô@àa Ö\ê  Ìàe"=Xé  Àe\è ö Ý!FT$D$A0^E ó Ó è¸@
(Â 
 Á ï È  ·  ³`X8 !  @  À   !FÈ!V Ðò^Â "  6 Y >   #µ@Ì]Az  B½  XÂ ¤ ?YÑ  @/ÂáîÌT$VñW<R¼¾KëuÙî_^Â T®(¥ <-`[E 	È]Òx7 ¤¾L,R J«  â D É AàóY! X XÚë(Ú(â(Â!9  " Äa\ËWÛ@ ;¤H)`T Y!YÉ h @Á(!©A­ Q@d]!v(ð  Å & õ >¬Hr ¬^ð(  Y _ó (!QÉ/ ¢v	`^Áë(Ã3 
ÝvH/ÜW ©@Á Y!GAKYe@þ@	,ÀvÀIÈ¸]À;ÈO RÐë{!Çà ZëN/ã 8à@r)à@"" @A"Àë+@O ¨!ràq $âeYÂQÎ  Æ`XC{@F óEèÒ _ÜÈAØ!÷À  Q!B ÀxHL$Q QP2²2AH5Añ "í  !!\ Ö 	  \@p Ð t! X XÎë `5(Ö( @#=ª\Ö'' .!×YÒ .#ç Q!Ö Ï aÎ ! È"÷à`!bâ4@Y b Y - Ç  Á`óYè$g ó"vÄc#¼d$v/%Dv(ïé7í*úìbP "Yî  -Xl@ê@ÐYXï(#JYp}$AXè"Ê  ¤ Ü é(Aó% t ê( SÄDY%à² ë  $P X$\ï -ÈRAYn^ µl$Ù! Y.Á®á¯ a¡  \@}¡¯ ¨á ¯!pC@Þ X XÊa¯c× Ñ#$ÛÉx:I 6¤CG ¬~ÿ ª#Ìe. %èY-cä êCä#áê|$@, Í ,#R À Ñaõ Û (Ëó!õó Ý t".Áú@ñæ Ä$T$¤@	È ¨ Ì ¬ Ð MU$L´ 3W	À: ¸àA ¼àH Àà@O!`{ ¨# ¥x _#ß@6ó]@ÐÀ'`]@m!/Ãw(&º:  f@N@vaö Q%Ø`:'W|! ÿxF'åP PWè@n£¬\$ %Ú!{'á üBÄ%C°G.XÑaü`5(Ù"ä!ü áü á SGáü XéAüá( \Õ î ÜQ6ß r#ìaú'ß Q!5Áò_0%. óAúèo1 ­   0B3 ^!Z !`(Ø !Ù\`% èXÈ! d"?èê#Ù . `Ø"_^Y&ÏøuhP) @è±üÿÿE_E& MA1'Î q iY8!ì EaYÁ$SÐZ'/Áv'`O %p%i@ ë*ièl98`luPj@i@èC m Ø`Ã sè]ØL _ y#tWvZÉègÇ ' ZC4 Ô # @TÙè`[$À ìSÙ!jW3!: +O"-^"-!	aÞ c¥ U*V³ P7~& íxbMË@$PUè05l 7À?\$   TAWbT ¦"T[!2â\'îBT `5  A"¸ # /  f H!ÙBQ YE å"A Xá@8%ò"Q\Ø$+\Ô@à U &$<BIâE è)÷¢E  dâE Û!( "E !}@% èÆ í Xbà óa3Q`4GÆ;øÄþÿÿ^]!_Køc«@ QSU¸ìÖ{V+îWf3íÛ~Z3öflEÕ;Ó}@xøD>OÎ<t$yt x>.AüöÄDz D>.@{,u;Ó|Ð'± @ë|²`
À k=Ù{|+Ü[YË¬  "VWKÉt(j è=  è× sÎ=L,ÿ,hè¼:Ø  - & - @-èØÖ , 3à	+ @+K  ,@Zâ@Z èª@-s à	. a .-&à  DÞF(%§@Pè: &F,ÇF-  à  `0ÇFyfà `4ÇFyyàìÛÿÇF4 IRÍÌÌW¿"ê 9=¤~GV±¤ ÎW-Cx ~À P@ j­<d«ðÿ@@&GÇ@-s)ü`E|Á^_@Y  &©M=@M= mCB$ìSU!|$(+uè½ ¸4Âÿÿ.Ñ $ß +Ç4> 1$¹», ¸8 ½0 +Ç+ß +ï¸<` ¸@`
 O   Bü1Ð='¶*Æ` MÇp@ `à  à	B &Êà
  à  à  à   à Âo=¥àd6ÿÿÿ Ò(¶Lc hx¤ Ó@¨`@¬`@°`@ < ´ @¸ @¼`@(0? )`(@@Ä`'@ L À _@#dÄAÏAïBA-@E@!w@ºö   t(¹  u`/ `/7Æ`)@bà  VB: B: !# ¯Q5 ½`(U¬ @ v Ævx;Ru$Rv¥.QVdXH·R­ f#7føu¾F u¸@¥¶f¾@&u E FG(o ,ÀRä vöÆ`;;W G 9	tzSßp" QÌ+Þºvê(V±@ðI(0@Û)v»(A6Æ{Ç(`)0#*êuÆ`× `ê `Ò `ß `}[_`YØt Ë@l`@h`@Vt@A?J7 _¡@Lá SDÀ@DÿÐ'æÎØè(Gèÿ% RDÿÒ:ÃtN   Î`"Àt* MÀø@ÿ¶@ÇYË Ø$q4^[!ùà@ ÀÀârýÿÿ3ÉºÀ %ùt$ù=Ápp Æ2@Æq"Ç @@(ÂAúT|Ë¾d )Bèãr  @D`@`@H`@#%  @ @@`@`@`@`@<`@ `@$`@u@²@ Æ` ¾e  `@@ Æ`  0Ôá8  é;) @ ì¥ ,Cd  ¸¼"¶e Ä4g%l»ü»   ½   +å ` #¸À
 ¸`
$×   $ E¯ %	   Te¯ Ea¢ 0@ pe¯ :à	e¯@E¯ Êà=e¯  e¯à^e¯  e¯à    b$&à ÂÅÐ@Ià"#Ð ø ," â] ¼CA£@À @Ô`@Ä`@È`@Ì`@Ð #ì@Æå  e¢ áðã¯¸Hã-¯ø)ã¯@@ ã¯ Â,ì3Ò¹à %>¼)úC³út#³Ð!
' !L  ÎÇ0@ ,ÁBùXh|Ç¾° "AHáUL @P`@T`@X`@\`@``@d`@h`@!µ  @  `@  `@  `@ @`@`@`@`@Cæ ° @ Æ`#æ ± `@@ Æ`  ²À@@ Æ`ä	&Ê L%¶M~ÆÉ É~"GÑ I+X	+ÐÁéA( F2)Dð]B íõDSUÙJDVt$W» Ï*N hT!ÈÿR-vÏUV ÈèTüÿ3öí~cWÌjeöx7Å}H @¯Îë3ÉVQËÿPà%.F;õ|L Â6¦® f /Fa.8ÿP$'û @fs W ¢,@¸ @! G ;ørä_~ÿtF FÇF2o ÞÎ^éØyÛå BìCb W,OP$'ø-aÎS0´ÿRà VOÿ¿.] !x;ÙsKN$ÇÉUïOé¯ëÉOÁC¯ØÉOù'$PA¥ +$ÆI¯ÏQÅQPè¸D Ä`Q]VúÿtUÿNF ;Ú=N ;Ñ~6-
F;Á~+ÂÑø Å;Ø~íF$ÎÀjOø ¯ÇPèUÙÜL«Ä$A_^3À 
 + )@5% ,à(&@ÆAC¤ì 4 ,g@Hy AW^ÿ`?bà <!W /@à/(t
èwoÜÿPÿPTSEZ· W!ï ÌthPxPTEÆ¡"ú [Ëyw\Ð §óY8=.ë JC ÒZÊpõÇjV@   @./¼]7G;4 50 ë-`À~#Àÿu(`l)`93
Ê¦Im sR 4H`éÌ)X Yû \i¢ .¦ =w  _A hrG Yið ¾ ¶^Õ ¨8,  ®^Ñ MU  ë+ ;À+ Y`q +R¯à +_(@ Ã N _ " _Ò@2ÀR_º uú@&%Ì!'vl \6­à%_Ì`% \à {[@§à { Æ@ÀT_y .J¯ 6 Ke  ¦_² *  >7QR {u@í  E _« * U ²u_Í(@p@6@á "_Ô *k1@:|\ a8à' 0`à'\(`à' 8`à'A=W1ü\$`à* 4`à * Ç & ,`à& <`à & Å\ `à# °`à #! \¨`à# ¸`à # Ä n ¤`à& ´`à & Â`&Ã@U ¬`à. ¼`­{]:\M/7ý l±0*_ #0cS	5¸8'7 
 Ma %t44 =üfB'< H`6\Ø.Õ y Do  F Þ  Ø@ 8!c+Y<` X!,@n mÅRz T@0 @`Y¶S Mü(\% /¨-ÿ r3Ë\Äë	/øv BjüS@@XY´  ;.ÅNwzW@ DàdT  ]ý@7\g à g Ì@g ù`g'ºY g5ûT `> V5Xcì Y@ü @·;Õ `
r ,à  ,`.Å6hX=Jù$éfnÂALÁ[5à@ ?9E^k^ZÂ\ÀaàYX ¿ iÐ`Dà  r!!@|àl fo ;à l!¾@pàl Ä`\àl Ô` a¾ AÎ aHzü`
`õ! , @ à  *à àõ È`xà Ø`À[\AÝ/ëa¯!ràõàl Ì`\àl Ü ç>(T6Ä3NVW,q B3[!iÐ2&R$ (K$ ¤ ñ(Â+ðIóøP < +Á'| ð(/-Ã(b>EÔÆ"ÝÆ(6ØéÆ ,  ÁD(ÝYÌYÚ\O À 7& S  B<rÌÆ$Ý<7Æ 2>ùÑYÓYÅYãYÍ\ÐX9:ÂÄ)BðÔ)Â -Y&:sMA tw   Æ!f @È  @  ¶@@ ("ûYÌ_  ©@  ¹"YÂ[!Yò!¢Ø]>Xñ(;§BaB=Yû  î  È  ý"4 B¸@B)iëéÛoéü   Q`íDáD8K A@Ø!{!p !¤_ì W &!  7 rË(>F\ÓTÉT@
!  _ÄÐ%óQé/Åv
  Gb ë#_ ^DÿÓ3É(î =YÛW>lX1Y¿Æ#é,Â  _hÀÿÌ/Þ LÏW¹?eXÇ9ÈvZ!\ Ê¿u É$Xv  M¨ÀAQ!?ãXÅóXu `+Yø"=^§#^X[ì 
  Â:f  "° @s $èx 8²3w8®Q,¶ )$Øe Ùèñw  ï@} 'a X\ ]A q!{  ¨)b %Á  /Èv"=AF ]!i`% @ 
"I^]@@ `!óà *o èKØ2é°^Ã|^Àj´øt°Ã=¿%c*ë@ W,q+ä7	 ~3x ~-K$ì ±/3JLx @¬æ_2À^Ã_@sà #:à Ì"à!)Áàà9´ 9¹G u3ÀÃy u÷DÅ ` à / è/!3Ò¸@=yß9t9B=Y ñ E 1
ÀxõÁâ;ì 5}ê@ä 
¶DPè§ qÄ@c öÂtBH
¯ÂÁà@@ 3Ò8!@!½¯Ô Ð¹  	@@Ð &à<  yÿtAÃA,ÊV¾A¬OðÿP3Ò÷öá>Ì¸*  à ü   ÍHøwyÿ$< ¸ÜQEÃ¸|M@ `8 $¬  à` ä` è` ì` ð` ô` ø` ü` R@G ` `¸; G$@M P` x@e Á Ç  Í  Ó  Ù  ß  å  ë  ñ  ÷  	 ¦   ý        !  '  -  Ú` #  3À/cX¸  @\)àAuÛ×!:!%¼#30f&=YE$â  Y@ =# <O +{=dC¾Ø,ÒõÀ@3$P Y'XC@Là7"j(@#  /_I Y@  Xmdà3 \`kd*( |Éð\Ð  Ó À§ à £ÙîÃfç!7  Ü K   A"ì,$<.ÅW¾@0ö®õp¼"g PPÄÿP"ùÝûûÿÄ3ÉÇ"®@ F9CÞ"á!`$ ! }à5d)êSU®(# 'n,
 	l$4\$0T$(ÇD$8 ,~ï3ÿ9¾ @kO®S7 #$Ø_ Ç (
¿Éx\D$P`Oç $3­ {` \$ ;#! Ú 	 7 ! ` `(' Y)Âa +XÊë(> Ú&C!O`A? ? 'Eü  e@I%}\â 5 Å _ Xâ@9(h ? Cà 	ÌAà $_ É*° Ài´XËóQ&÷ Y+ Y*M@?,Àà Y0! ÀøLD$8;Á|Aÿ+ÈÇ,?GÂÅA 8 Á$ê `[CøÃ;GÊ?	1ä0!qÇCZñ  @>0 ÉxT!?  AD  aDß÷áD  í1» Ä!áD< q óá< ¿!v ÆAw!E N\ÚYÉBa »á X'y-±áÇ;Â! BAýaÙ +_,AÇ7!# UÃ"µ  h Â!ï (!$Â@B!: (B EøÅB ;Û Y¯][_^Ä,ÅÜ  8#?W]¿è® jì !W#ß?±8< 33BÇ$)\O?jè{À(8(»`(¸	@(q=
@(ìzà (P%(    Q Y@(Háú> Q Ãà(h-` à (ffT@( 6@Q  (5#M ¾@£îÇGÍÌÔEWÇG *  #ãGv ÇG <ÇGD)8È¨åBü DÈ)DÈA Âùÿ 8|Ó À,DÏ` 4DÈø /!8!0 BDÏÐ? , ` (`  ` 0`  =üP!A!Ë$ !ËWÂ fÀ '"$#K° Ô D -` @` ¤` H` `Q h!j@Q < àQ Ä 'ÀQ ´ Ø \ -` X` ¨` `` `Q !@Q T àQ È 'ÀQ ¸ Ü t -` p` ¬` x` `Q !Á@Q l àQ Ì 'ÀQ ¼ à  -p 9`  @?   e  Et  ` ¡M ° 
ÀW    `@@( ¤ 4" `& ¹(ß < ´ Ç| @ Çxà 	 à 	 à 	 ¬à 	 ¨à 	 ¼à 	 ¸ 	4  
"4`°#ÿèfE#Ì #º # mAò' / ;%¹3ÿ#ã  (GAýQ ü Ç ò@DT§F+Pèë$ó $«)áØÈ= ë%[ÉÙ&<Y*,Á #ÀÀþ`@ \'ª < ® < - '" Ø`)l$  £Ù*j@ÿwÿ , µ A%¶   + K  äD$$&Ë [$è³2  V£¾Dm ÐZE "$X ö ?!   °TE Y'n AGxÆ #ÇGNA¢è« à<èÁ©à2¼`pc¶\%¸ÇGh7¡>ºD M,»àPÇGl@ à `à dà æ!w@¾d%=!ÿ   @" 	Be%cÕ Ä  +H$?/	v"«.@ R°{¾À " uÇAfçÆ@ë ÁQîêuÀ!CÔ"* @DÇ°@6  èí½Á
×£>èn³"É  'ÐDØ=Aà©ô]7© ´@9!oÐ $(G`) 	p)G(  )G'AAÜá) -ÕFÿPFg 8Ë !¼ */&A@ &uà Æ¾p?FÏèl}&  &Ç´ k@ ÇAî&ü ' GT@C,fsnG¨F!ÓMâFJxtC& / /#U     â©@"l{FJ Oà(P7` à (#@QË¡Å@Q &à( h! Ià (    Q\@&Åýsà zG(P`£XùtA (Ñ"Û@Q Ôà(O(     Y@²@zí@£ «à(°W` à (Ú±
@(ÇK÷@Q à(È_à(z­@z!°²@( Y (àg$W @k-*ß ÇBL"DÇBgAÇB!y'HB @¾ÇBC9  ?} f*¼  
ç2NØÎø xòçQ §Q!ì§QÎü %Ð'Ð, ` (` @ $Ñ$ $Òw%è $SgN p 0   &! Ô ` ` ` D @Q  àQ ¤ ÀQ t   °AÉØ @ Çà 	 Hà 	 ¨à 	 Üà 	 à 	 Là 	 ¬ 	à 	¤ [ `  ` P 'ê"¸@§  à§ ° À§  ä 'ê -$` X` T È"Z@E T àE ´ ÀE  è ¼ -(` ¸` X @? ´ à? ¸ À?  à¢#6 A ì@àq@S Ô §y , Ð \ P#Æ@^ Ì  ^FmfhYÁ(' #Àf  ð D 50` @` `  h@M <  M E À ÀE  ô  hP4`Hed B¶@E l$àE Ä ÀE  ø ìb¾ 8` è` h @? ä  ` E<  `l "Ew  üT;"' 	²íØC ± È Àk   ``@Ì Ç°!n@ Ç#Ð®Ga?ÇGP`gM@ ÇgTDÍ G)$ÔGh   ÇÈ   ` @fÇd%« ®D!è"Pïè L E(lè  < - èJx3Fs?\£G ,   ?x. ¹Dóäï	Ç  øC`%éuï&Þ`'gì fH«Y` AHÃxdAöB¨ !¿@  `   G¼ 0 3  ?Ç\	è ·Ç¼   è1­hÐqÇ8% /@m  !à	àÇ@@ Ç@@ @C  Y(hÇ`   h < *Êå=Æb  @+  À+Ç`   ?à! à!@  à! à! o@   o @ È> Méêö¦(0D9 Î+TH<  @    7  P  `   p °  À  Ô D(Ø !e  @ !µFèØ¨Â`/ /Bèú 62ÿ¶RPÿP0^èð¨ït$¾ #@(óxtB(ó !'â/Ýh4ZéCGâÝ$&Hk(] `( 82}@( @Íw1GâòÒGâ và(P#` à (b|@Q/]@Q Mà(h+à(þo@(®'@( $à(3à(¦ÛÔ@zuØ@zûjH];$ @¨]@
HHl%Eè_ !\H]mè]@$\è/_ º#%XX× èd ° èd!q-(d ´ %,#ö <, #Î ,°'è $0H Ô( P EÃ $ %½¥  Å p 0  	 3àõ$È` Mo  øà @3ýÀ`úàûà üàÀýÿÿL  4 p&®  `T`@t`@  'Z"H´ Ü'0` 8 '0` X h"C@æ < àæ  Àæ x`\ )A2$^A2 ¸ UA2 < X \ '"l@Q T àQ  ÀQ | À A' -H p` h "@E l àE ¨ ÀE  Ä`E  -L ` l B@E  àE ¬ ÀE `¤"@Ý\@Ý ¼ U@Ý @   ` @K   ` QD  `d ¢(   
Àc   ``@¤ WlÇZ´B²<>ÇG@W|&6Ü"ì¶³ä  @@¥ Ð 1@¥  !¼C@ gøÆ #oÇYç 	 èí%AÇÀ %  ?èÜ Ç Ñ">Îà2ÇÔÀ+v< ÄÀÿu ÈÀ î  ÌÀ Ý  ÐÀ <.W.gh G_ Î'_@¨ç _@@Ñ `§_ à =¼ ç¸ NÈ\cm @ @- ,#¶ ù´`° ÇÜ ;  èÂ°ç]³§ ø`Y  'K@Qàw j @q@ Ç@u@ àwèÞ%´ Jýð5Ñ*É *É IF1×qáññßæÿI$Ä"h Îñ×Öå`4 é<Æ1®1ÕÙ±Õ 1Õ| ±Ñ  " QÑ[1Ñ &´! |'!Q$ÆåANè¦"PáÅ fé/á]Ïò®áÏ èã¥áÏCp8Ð@ºJáÒX¿âNè=Hj ÀGÈHGÑ(z Ð ( @(à@) @(ð@)0@( "  @  P  ®!hÆ  ( 0@ ÈèfÑa¨  ì4ÈVò?Ó¾Èèß òg!÷' ?ë\E(þÈ~Ô °p¾Ð è¬à> xà>Ð¥@>8[Ã   ¨ï¾Ð ¼Ïèìkèë 2cêJohë¾4HpZHp³b(ë8:(8SÕ`(@k_Hp+ÖHp à(PB(!'Cg¹úE@( Ñr aà(hJ` à (  #ò1Ë¡E@z 8à(Rà(\å¤@(+@( à(Zà(©@(æaà Ì°bà(@9÷@£;ßÏ@Ì ½à(Èjà(·Rº¬@( à(àr(.~îQ¢E¶@( kÀ($x`ïøz`0è¿@z¡G BÀ(` `. 6À(jü@Q  ((@J@©á@
iá0/òA x"µIáDéáä"qÙaù%éÚ @ `Fù Ò?"`é Ú D %'  ¯,   @ (`   %N$ '±§   -Ç à !0 @ ø!wd #ì è` ¤ @Q ä àQ $ -ÀQ ä !ð D "m(Û # ` ¨ "º@W  àW ( 3ÀW è '(Û )9 -  p` ¬ (ó"®@E l àE , 3ÀE ì 'p ¤ -  (` ° @?  à? 0 -À? ð !Çt @  	 @ Ç´à 	 4à  ôà  xà  xà  ¸à 	 8 *Cëøà  |  	à  ¼à 	 <à  ü  \ G  *¡` À È#§@á T àá @ 3Àá    ¼ -  9¸` Ä {E ´ àE D 3ÀE    -  9 ` È (#@ ü#¸àE H 3ÀE    -  9` Ì P%F@E  àE L 3ÀE   D -  9@` Ð @? < à? P -À?  H P -à$Ä` Ô Ð` Ô @Q Ì àQ T -ÀQ  Cá$ %§ M @p@G 4#Õ´5  L0 Ø @X ,  X)e )^ £Ö X @À`   `; 5 `;Ü`@`#@5\ ÇÐ |@ ÇÔà 	 Ø 	Ñ}0· Ü 	¬eW3A0P $à   Fb `À    @GP`ó©K  `s3v °'B  Æ²@Ç¸ ño\4 ¼ 	³ÑCó$ÀÛó  V3aó  < -óK8F L   ?èWÃrùP .È] "Ç`  +°Ç Ó^2 ± 	è¨Hk3×W!6   hÇä ÎM@7ÆP&¢Ç`@ Æ@)èQ > <ÚÂ@Æ` Ì )d àÇ`  "   Aªò¸ äJ p (  4j 0sm-  D í  @*h­  ¬ 7j£´`Bû'@¬"@ ¨ ¤`   A t 3    ¨	è¿¤ë2?è,£Ç|aQ@g  "@ñà+à{Ç@{@ Ç@@ <=C \Oð  RAs 
   V 
 0 
Bý 
 @ 
,[@
 P 
\î  `  D+á¹ úó¥Çh >  ?Ç$ 	ÀJ 	@]CÃ@Ç@Q  BÇ Tã%   	VÖ  D 	  BÆ@	Ç@B"£`.êï ¹@G u¹@n u¹@m u2ÀÃ°à. / ´R¯u¹¸` 8 ¼` 8 À`à8 ù$ÈL-ÆÒ É~$T$I#+ÐÁéA(YÊX)?®BCëÂÌ& ? *,%BN ¨!Â,+è$hÐ^ÿt$èiSÅÿÄ©/è_!]\Ø"mKYDX 
/Èv%E Ù Ãó]Ì]Ox ` åà Uìjÿh=d¡ 3 PQSVW¡¤P3ÅPEôd£  ÙC}øÿt.{;Ç}<r-À;Ç|ú C$¹ *ÀjOÈ /¯ÁPëà¯ÏQËèu¢ÚÿÀu43öÿt,ËVÿP(EEðÇE\ÀtÈèûZåÿF .ïÿ;÷rÔ3ÀMôd j Y_^[å]õÒìH!LWÛ!)- ©@ùA!]a Q I  9"D$8 	A`
 4@
/!2  L d$< T$D L$0v7WÅ 
d$ I " !äD$  !Ç  @[ d@ '@> J/Óv	WÕ `Lt$#</±YPR!´	WÍ/Áv.ÃWãz	.ã@{	(Á 3`AÑvà_Ü L@I(Æ" Ç'FþL$ `6` `	 , I ¼ '³` @² @ù |' @5' $ - P`.,è¥<äÿ g!Y ] S ì "ú â \ ¤XL@ Þ þ °àyL(ÂWA aà	}0Õ oA8@3  # àw@è-wT$8 wA» D@g\A­ \>GXT@\`É G@K D$8(ÃÀw$`  @`  #£   n@2  `JD$8è·;`í d@ óD(Ä T$0 t ì # ü `C  Ì ä e o © @`  b@Z@p L, h@D2 Dà v4è@v l!d@²  < K(Í N , ÄYl$% Ä |YL$T  5  d@Yd@\È  ì`;!ó µ !® ("é "!®l@. e Í "9 ^ O" e ,ÀI "  4è :äHb d = TB, $ Y! &MA DaN@T$¡@ +D$@À!g ø X ^ Ð   IAø \À?! ;  4#X 4 D 4&d@4Y¨¨`TÄHÃ#ïWù3Ò*N$  ÓÉò VfÄñ;ÈOð)·FÑ¿@  ¿`> (	Ð=  tÆ &X   EíèûÍ !¯ëe ÿu6%pA0º( (@0@)@À)HðWôì @4GEë&`Søu @ ëøu
'@P$¼Ç`³  %ö~&ÏVR  è]I"@\+ÎÖ ì  ú  ð%!^j  ' /ÿ·A è9 _ÄÂ&t!/;3Ò Ã 7W@' F)G IÁ z  A,ùA?ø)¾@ ` j¾x't tÎè´B) E Æx@ë? À~5Àÿ`u* g   (5ð(= )y Ð@(à@)À  Ç`{a ÿ¡ÎW Å/m  n+Ï×`À`Ò  ÀF!
·L Dføt t t
 J]"~ N"Y8§ u,¥ J[É 
 AK
%Ì](ë(Ô,Á'V$^Ð 4t !ÄWDæ(ì 	u(Ó3Ò9\x
~L|$ÇÀ	1#qÇ9ax ~# A  NXÊBöÀ$/_Ë aÌ;`#|ÜBÇ >ö ;`K|¾¿`Ù H e@¡	ÿ$@C ÿ¶d ð Pp Îì Ü$¦#¿Iv`#®l  ` k<ï@$è-ó@	F¸B f`pó,9;Aë%3Àëa )`¾@ ¸Bí 0b ]}`¥BÀ7k¯LFø/Bqv* Iv!  ( &ë/,@_Æiê^bÀ   fB L  ¼  ¸ ì¨ ÀÄ$¤ $¬ VW ´$¼ 
ñ%0t$XPèÄ;"¿b·¾| yJZ %   	l,   TC¼DB½ @|Ç+ $;Á"AÉ÷ù +Ç|$$+$  !\Á   "l@ p  ¬@$ ¥ C@A? M Â@M[À3É"ï H"0"4 H @ à 9Bu» vD$(!Ò -B¿ B Ê8,  	<@*y;ø ×OÐ$;Ê]@> T #|$8  T  @ì<Ü 9E$a,!& <Á% À
yHÈþ@*,   Áá ³ 4&	\DlAA^@òAO@A	 Ae¾@ÿ   fH¦Guh¼"l D+DF2'0BÜ |'t|$L@¢! d'2 þ¿8`³L$T$(¹^4dÒ J È  f@²# Ã&ÈZG_à #±cÀ À9ZÉòY°!n7ãÈfZA´Ô T¶`ÆÁè:E	 +ÈÎ    ÒPÓî`°x ) { °`+ ` Â@1 â@1¶ÀÊ@2+È ë"Ï :XÓú% ÿÓâ)`'ÿÐ  T!ÃGz@& E@ÿFÿ# Xõ e$Á#Æ á æ F@ Y*«  þ  Ö@ \@,(î @/éJÐ\5Be Ê(Ö `u(Þ 
 Ü`Î"M*ú \à ) á ÝJ½ Y(A Y *\à  PT %$  ã *Y%8%°=@   ÛK¯@)FY ´!<¡» BP A» W#- Z+. à !¿¾ÇÀE!Ç áÇ A(ð²@áÊ [!hÐÁÌ²x `+áÄ Éá/¾ ó ¿!¾ ÆAá¾  Î@á¾ ,!N@0ÿDDOYÆ(î!¢IÀ¡Ð $AÌ ÞÏÜá»)Ã¿ _ dQ áÈ!óáÈ ¤`Càaà X!¾ c¢Bº  ¸T©9z¬uÿ#hÇB¬ÿ  /Ô"%v	ØB¬® Bü*c$0 0ae$å"EXåÓ 	 ý7Ç@DP#Á¤ãD$, <  < ;g   Dû3 |%$%ÂA#p T»$ü H D@;L$·ú`'%ÏD$8Hç@$ ;ºd "æ¯ Î§'B4èÉ/&ª fÒ
_^3Ìèò ÄFy)áìfç t  ñà 40èä4 4eê Hý f!% ÿÌ"3Ò 	¢ù\Ø ¦È N~!¨ Ü à9EÕ  DKÊ-AtÐ	@H 5C+Ï  Ar!  Ìf 9 A `S ey   4  ÀQÀ (# E~!F ð!, E "Î àI@4 X@M 9@!@+À!àVà! Y%Ìà!` e Cà!x ÃÀ;@- @~N! Ygð P%G¤@  V<Và4  Ç,¥ ,7T0 Hy	TÍ;Áuÿ!× Ç`"ÿ!5Di ;gà@ #Âv` `2/Êà Ô`ßA¯ B"¥@#k¿# !Ø#<  ;(þÿÿé§@CCc´" (» |,³ CÀ@!"OQ%ÈR ÀbR¥áâ P roDø¤0¸ i«3ÿ"o9h$@RL$ b  ¸Aâ2 #!`!L $h b\
à /)Â!ÉAÞ@4a  `8 @á÷B*'S O0 M`. sF£TÃ!· ¡·!a ]  Gáá!P;ü! ä $b LC A!6 $! Äj ¨ #$jD2äg0èa+.7+h $Vô 0ìDV/p Ç)p    !ËDnj+L,ö`â¤O-ìZECµ=h^E 5 ( 4 fþo|Jd Ö%)HÉtTnû;ð*)!¿@  @6ö~2 Ý (ï! b ,H¼]Æö )r*Aâ-J"(ÒË e¿VI$Å 8`#('øPì " L$6ù'¼Y%=>Çè Z "ÐÉ    @H(è½k XKC.( ä /à5òZà íU@i!">ð`I-lü ('5&C(°^ÜZ(2Å8ò^È*" É  gÞ!'®@ ³  ÒGBß 0!ÌPµ d@ !$<·g!f0!/HòClMH+þ >1ê)$ 	T.ý p7viÎÃ/ÂÈ U/âv4fYÓë3 81z(Âèæj@Ö °(Ð@@B h@X`Òã !N    TA^ \Nâ7ëo$|j/êr ]^ÓëF  ]ZÂZÑAF È !Êè[àl WFªà`@r!jà  p D`p Up X  Ù !OÆèF<ù"ô!> #0!c'7ÿP@"àÿP 
 
@ 
@DF w/ÍCO X!"h  a;±B	 à¤@a!#!Tç AcDAÓ·@# H#P,  ·@JÿP0@j TÿPX ·B à.óÓ ã ï , ¯`²"\ (l!y(Ê!¢!EÀ!W X#%"r!ÄÂ(å "³k«çë(ã/b(*2"×3¸\ô 	t$r('ÖU¯`3 è"z 
ïë (è D(û ! ý 0l$3)Ø69¾AOv!r@A%$º <!SPÁF) Ä F"ý   J @"à4± " <"ÿ Â|$H E ã & HÖ+"7êv[W(Ñ zy% Ó D LYÞ þ E ^ * _´]@# "ÀE÷ êë^`ôF `<c)f$@W $Yß ^ à S _ \-<&;R@= @5ªa L$"x!C:S)&7 Þ<W9KB²<WVÂÈDÁB1@àbÔ G!aÆ¢Ô[ d!É a;¹A ! !Ô !¡`p!wAsâ\Ó!ãKnH+ð" âá#mFù¦Ü Xõ\è$Ü DæÜ  ì@èò?JöSU¬qÙ3ÒVñl*5r@\$Ûø#;(Ú'UWµ{Çô ¿Ô ÿf¼>À 
 t64° ½F¾Èv!ó ë!T­]@ QBN$WD(ÕGÃÿ
r·"ÁGÉ )ÿP !\$`zë;ØOè@±í1 £ cR3É5Q  VRÃD(A;Ï|ðÿu¾  ~FB1!æ,ÿSV}Lø(<P(3Û@Xí$9@7~hl$(l½6I @2» QÞ  @:@`6øÃ÷|$$Òx;W}O5Ã~G¯Ê të3À@×
CE Å;`a|³!ë@àÖ (  Áâ r<D$ÂÂBØ à h@à é # A: j UT$tR 8RC¡I)®H+ÝA|Õ!îGeAòBí k _Á( àÜÇ@ ó [4w ´ %Õu
Uè"- tÆõ  ^][-Ì%MÌBìhVW&§tñ Et$|"× lDWè' DkÀK© Ô´DÔ´ E= !¸Â+t{Á"¾ HTID$ T4I Ê@   Á6© [BÒ \[$& 8Ô[ ("¾o: l dXAo 	 T nsÔ^0´^ 4T^ # A Ú T!j X' L lä!V ? @$ Hªâ Ð]Á%"Ãô^(ùÁtY<4Y41S¦1TY3À LP9o¨ ´&ê j ` ¢8 L y | s	ô <· æ0­â0MÊeõ0@h%¦%Í4FÕSÀ'4KÀ=)àòY( ô# dÒFô% h!? hôdâÿÔ l!t h ½@&!\ôL  `2F!+Ü(Ö%Â<EYÐ(æ!ü l Ô82rN PP òM *`!KÍ©GG/X0®1G4ò/º¤  o  ;Ç@ ÿ  ,LÔ25Ï` o	ò8bõ#Á-` f ý¢¨c @ò(P@B};F*79 ¬#D"l L"t \-R$ lL&> \"L;L$4ñü'Ð#3 d X$ T²$ \Í¹ " tÄ]Wè¦Ý hDà QS& ²"ñJSèÄ$  M!3ÿÆD$ 9f*é B¦-°XÃCÞ 5¸  0 U­UnU-)Þ Z) `Nf/År.  ðr! 0 Jm7 Årðr yë^3À±~TËæ? 9@!á @© b '  @V óg#ï `.|»G&CÃF ;ã \0!]%b !G!Á Z*s_^[YJì( 3^o{!´&¯E#<'Ñ W§zù;Èý1ì!J¾dp (  "@­q .ÁöÄDzÎÆ`è®@K¾e`* @* Ø 
À* @*`èk¡ R  G&Ê p #tÆ[V>ÄZÂ"Û	 èÖ4 ë`(ô>À 1 ¦A`ºH>¿`~¿ þ¿ ! '>9`~»@J=C^»@
@ þ »@%ÊEE}ÿè÷(e¿Ý·:à&ý
· À%û _bÌ 2AèÖÜâË@ ì@ëé¯  ¹SÙI±\@ V"ª If.À])Y C W)
 fnÅfpà  	"­æÀ!{ò"<%¨-%Á»ð S ò@Ht( - Gm@$H`EÆ`  @ É"ÌÈÀï 2³< 1¥ ?(À/=¸`ðgE3 /nÐ ÁA  À ¥ þ# ò#%þÄ ÃDl   Àà|Áù|¹""K9¨^]ýjR 7H g½YÈ=½ÁPCPèØ6$ ³A@¢D$pPè"àóÿ»@  #sÀ¶ÀPÿ´$@,Uè(o »H) «@@!à,+ÿs6Æ ÂD|%Ð ¥&fT,@|;Ç|ñTô#.ú g+iL#O ¹QEA$3 ³,â æG °AP1!1 n$SæÀÁè!Å^1' MzXA 0, È!¥L$,ÝD $èKZ1ÄÝ\$$"D$$è è3ö!ÿ $ »P3ÿk4Xü` Áà M<m8EüL´l¿D4´CÈ´^VF;³A|Å S ÿ`D$° EUP>  ü Pè9üc 3ö9`)@óD´lD"þD´, ' 2G  8      ;@o} " p "   0 ÎÉyÁÑùEÒt`bB$`x$ tH 3mtU!úP 	 PèÒþ ëb$Ëtà: ëJH  Cà¡¾ 01<­    WCµ´4èX!` OÄÀt/z t Pèi  Æ1ÿÿÿ»ì"£ & 3ÿ9b^ eÎA,©íý !ýr**¼,È *"uÿÆÒ 4²;Ðw;ðs4Å% ª 	ø@õ+ðPÌ
YÈD"3#XÁ;Î|Þ;ÍAQÅ+Áø|lD¼,Õ+ÑêÁê,ÀB@ v@ø%0"x @è@ ìà @ðà @1à5	ôêu°;Í}#@oÊ & (³à &A;Í|éG;ì%!Ì! À~+Å`»CV!D ¶ Â[~73ÿ"" ,Ó"»B´bÚÇ¨v bÏÂÈ ÌâÄ ð SÂÁpPU"Ç ¼ PèqùâÇ~@3ÿMook`dD'Ç+¦QPb"[V F"||Ç"?lËl%ø,èÝ"Æ-&EÊ _ M EôgìÇ ç@"Wç Ì Æ¾ E # .,0 #KtÆçD- $ëëkÇH <çH G%æçO@:+ç$S`;³t"u#P	uÆåC  TZ çm §m$èOG v "@zÇm  Á%ã"Hj / ÿn!q èkGj a]A_S!`${F¸  ô Pð UW3íÎûèÒÿÿÀ»  pzPxø)q	 `(ý  @:PuG© 2%ÀÀ"Í Ä¼ àÕ %$z  !)°@ aÜ )HÝ )@Àt' ÖÎìÀÄ#³T$ L$*:1\è¶â ¦Åÿ~ -  !@   (èûR!g|$+ß ºÿÿÿ_]"« á64!6[Ä¡7À ìPSV`/ dËl ;hèT"Øo3Û0T W Ó)«!®	\ó=H&=tà lm 5°,UWn*t¾ 0FÉ,3 (¢S;Ð!ã4ÊOÈ &0;ÙM (% "Ú  0 E  
,Ã%!jyHÈþ@P(!e/X(y83É9jâß ' @\$fï ? D!EYD!QóMxÐ ª!\@YL@XL@' `*0   /Y ¨8rÃv
/ßS	åëc(ã ã(5QY%È]@ÿkÐ (YL YOa åuÁYplU^Xào @
Y@` X.aXà  â © å  O9Y (Ý'Ã%Ú-s @Õ%8UE ÆXA %%tY`5X% T`)q\Ü  J ^ @£\NH ë ^`·G U`? 7+ÿ+`+2ù@äG!Rà,  ,,  ,4=  SXG@Î,ù\ ++G3C ;Ö>$!Ò  ö  <! HÝ C#"ÇB*;\$0Ëý (BU(ã. ( , NÚÄÅÇ @6 3b$ o 5 _- dã-hè- Pã-C/$V0,Wc38ùÿ·F?Vè#&	!ü!¨W ©B wG¾!c!´a÷!$­` +´G"¾JB(Ú+HÆÀ
!î Ê!³ Ø . .` [$; ^È/¸bÈ \7$/0k$;s²@	ÁàPVè£ûÿ#ý$b(   ¿@ ~Y £Cª;®D$$1^#T @7~%Æ+Ö B[A¿@²\´ ;` |ã#q $$(À0% #Î(;@Y|·n$9@~j FK GW!» ,,¦g  à o -¸ø @o  k Y ÿB*sÙà w Û!é $ {(B $K $@N ;`i|¯3Ò s : DT#Sw/°a~  X Ð@;`|éB;| C Ñ(¡zÜ~EW!} f$Â @(3Vÿ2X¢  U  F15@/ ;`D|Ì@A·@."l PûD4ÿ8A¼.û3öKhÄ  	 ]*A!u0ü	 !&5"låHR8]!Ô  D·Wä ? !1`Y 	`Wt} $å i O|$ ? îHr @ n#¶!Â·t (4@`!"}½@#À@%pØ@´`. #Bü!ÂD°@0SYAé 3m4sb!¤Jü7é>à5 B$¸à6
`à5$Áà5J¤à6!à6èà6%»à6,!ÄàÚ<«à6pà6#là6´à6!á{@Cø$Ó!õ ÜAÃaÉ ! Ã¡²À%  Aa°à%`! B L d`&A¡à&a`+ & ¨`&Aà&`!@M!Caz·ì ,à&as`+¡j·0!à&`!@M!#aZ"äà
&aS`+¡J·¸à&ÿá)@l! á@ á
@ @úTÞà ý Ü@ @ë ø`b@ @Û è`@ @Ë Ø`@ @» È``c¥çã#¢Ð'ÅTÆ!: Ø   AÂfÕXÑ¢d	A¸~´XÚTGþ Èà9Aµ9 Ó9 Á DCCà9A¡à9 ´! 9o Ú zÀs $ ­ È$(ÔT&Ù X)ÂXÑ sD§½ (I' ß? Ê " ·Ì 8>"% âXÄ çcC a>ÀK\X$C$A,@! { O  + '¶YÄ %)#NP àF £  Á 7 × ?@T`/·T@6eScõ*`M @à
!Tæ B áhhYÏ 
Aè`/·@6M') X4 M"2á& (6@ @Òâ@ `¤bd@ ``m`@ d 	&N- fuÿÄ  Ç ÿ  /åv` Á@F¶%ÿ `&ç$@&ú $ä.ùÿÿ ¶ '¡ Á <üG$ 5 «Ìø¿8Ï«ÿt$<èõWdÄ$êSU.}3íWÎx~J_û*`îa	ÎèÿÿÇn   T  `ÎWU  èH  +ßïÛ¶¿-¸å~.+Ãà	-IIÖ	j Sè³E G0­ø/|Üjî 2`Â][àÁìZWö   rSU¬$T3Ò Ü+0  =Ô (!) å+F^`D  3]WCyàÚ) ÿ¼>   t6WÉ"x -L ÈMGÁë'~]Ì]+#y  sW Q"$WÿP0!«	GÃÿr·"!æ!¯ )ÿP 0/A¡v ëAv è@³S +WÿzOÛ VRÃD0A;Ï|ðÿu¾ø@©~F z 3Z"=4Ç¹ éPä¾A-j LÁÏ 
 ÿP(3Û@ (9@?~a"wl)¡l Ï!P(øÃ÷|$(Òx;W}O4Ì~-N¯Ê kë6¶@v`e C -
,í ;`V|µ,Ü  à Tx 43ÿ9`¹~*`y\$0Áå U {3èC"$["' ;`)|çá 6 5 ,Ô$ ç2*öoW3Â"!. pA. é - ,`a°T$pj!UR 	@Ra)®!+Ý ØÕ": "HB>Èý#- _Áv¤ ~@ ·P(Ç@#¢`´$SÔ+7 ¶BüUèd0$T+ Ælì  "Ú3Ìèí Ä@@ç
UìäðìXÁ"ÍW}@AD$"G   T$02r r KM"¥8¨`}ù &-K ñ 5[Î 3 y@â.v ;øOð!M #0)°@¸@ r1¼9$$Ç`-Cü"ç0.\!$% T%n QI   À2zü/»Çà°@|# 1r $ ì9Ý#)( `3¦ uBØ	WVRÿuèï}  ­éü@ àòt  ß @%¸@ô .ë YLa"XÙ(F»!ÛÆÀ )D$@u)/`Ev ò%ð^EZÃ:	àv
ÆD$0é V( * ( H Gh#e¸N0  .§  , e &uH!<Áâ/ 	E· 8!(<¾"ñï	Ê¸Si   4tµ  PQWè@wàé« ½3ÒA ¥ 	þ& 	Fÿ;øw`	;Á
 Æ÷³(=@(_úè\- i-j%¾>< ô÷+ñA  ,@"ò,ë1WbQ`ð(Ø(ÍYÌ(ÇÂÜT'ÉÐ' N_Á(p-Ç]1, `	 Y)PÃYÉ/ÜHÏUÏWÛV  Ç@Â (ÌYÍO B¼àL ()Y `LU×Y`mVÓ'Õ`Y  Ð ½Yà P/c ;T ÎG'h!è!Ñ  C	 Ì 4B;Ö}r"_)#Ò"»ÙÎ+Ê"sz§ .0þ ÉEà 
 ¨!Ùë(Ö Á"1 È ¢ó_@%þ Î&"C  Y& \@hlÀéu­@u ^  (B Y &
;B.  5FD!L`ÿBU `·#¹Ob,Ý$sé"X/Ù"cqo"x "Í ªÍ É"Í L"¢Þ zâ ,"g Â â> ³"T ­ 	b # buâ  â -AÏ"c(ý)"u\ù÷"v+ñ  8¢x8ëd¯Áb} b¹"D
(ÄTÂ(Õ_Èb7 ]b`YçU"(ÂY)TÝV  Ò@5 \`2!Ã YAXÌâ  7 W aàX U [ UàR â  @â !ôÂ| }â|(î^Q\ëâ BÏ/Âb %BdB æ Ó"a Õ " @"ÆTËPyYÀ K%YÌ "KüÂ ¥¢ (â  âA " ("½b% !õn# kð\E XD?Óå K  ãÆä" dBÑ^Ð(ê "ÎÆí l$PC N}E!",<Çe!#¡" t)µe ÑÅT$<t-ÅRWèc;"þ#X] @e ( w( f ée4 Éå4 %Wb´ %4 
`	;Âsiâ°"ò"¨+÷ 4GHk %Í4 ' <ç!B"SBÍHð  àd¡!y|Ç ?>$Îc% +]Ã@Aò  q)¿A  {  4@|4+ù!ïÁïG¹f4  7  A Fô v!  X"@TH15Á @à  FüàH Æà: H ÔïuA  < ¦;Î};+×þ+ùààf F @F Ü@>A Jâ¬,B%.!ó (B$B:Ú% ) #c "J +%eL eG(L 9i/(÷ôö#t$0ÈWÿ°IPHOÏ÷ =å]{@ ÿ%j !\ w× G*øJ!¶3Ò Wá «Æù;Èí=ç A@7 ß D23ÀìoCõWÉ;_Fw
¸# % @ % A
? f?õ2PìÎ   #Hk5à`))  "  ® $è½üA¾P ¬ I
tÈÆ@0 Ç@@@dèhW½x>@4ÿu=c )`)@Æ@1@)@ÿ	ëH@ùu	 : N ëùu 9ÞFÚ : *,ÿB°{é  
$è1=Q!¤|$+Ï!²U¥a Ç9&ý+?ö+ ý +@ ì,S-Ô)( W3ÿ" í Ô <Aé ¨!ó %GO3Ò 	587C  -= !´(U7!ë  [-y !o OÇm !@1/' -á¹ ;
 ø#VÂÆ ³  @_ ,#a%² `MÌ 6 IÚ=9ÀuZÉuV < @!ZÁ*]H*hvA òP  Èv0@%Aº  °f %  @% p%t (°!* Î!¾Oî nã 9HjÑ .p@½  Ãel%,FX×$<»!U7=   3ÀÚý|YOë+ïS# Çüd| `E $¦ l_BôIAìRD)ðAðBìAôB  øß , !g F (" ;Å}Õ+ß+ÐIAüêuò@ .$A".8À»#   qÖSÿ) í@± Û.ÿ@× ÝÐ	!@ú¸ºEF|$  è +þ 8­ +iRè5fJaºÄ$¯¹ÿ!U óe7 YE?0!u  N7,Á= !ÛMÁ,  Èá@.í~?Õ,!w.Â@" A!@Gü@%@7 `"@ÿ, b¯ âÇbá ÀLW Áï aÝ D!Ý ë ABy ¼ z+ÈÕ) H MJ*?. (Ãé- 3À/M  `»£+Ñ+ù /(Ú(Y @ 'á3½\Ó ý Ë "ãH|D·J¸ ® Y ºFuUÀ" %Ã ot  x JÁóYU Å '  qK;Å|é!Õ@Á  @  5À :  X*@ qXÔ(4ñY	 !¥  @Y  %9àÀ§àé$¥kë ]4'éa Ð!HR
Ëë Ø ])x  ÐA  B~ @Õ"Ä a e u Ç Uá A£"K u"ü,+Ýý0} # $çCûÿÿ]%W,Î  DW 	Hè	ñ &Å[Ä,Â  :SUWù3í#KFë$¾\V&²D  OÞóDéð)·@¿@ ÏèE³  FÇ`*Oøö~RVUQ   L3ï X+Þ@"î3÷¬^j Rÿ·@h@!zð  _ó ¶Ïì!ù
¡¤P3Ä$ EVu ª4MP#å 4\ 
1K Q ö ,) 4#ö 8 Dè{1l¿B À@B¾¨EýÇD$gþ xJ~	ÚÆÛ Àt /ÁæO VJy   Í8Ö#C =FuO[ ørx 	,ÀüÂ;Èw@$Ã  @Á;ÂsW %ïj} ¶)D$@& .Æ"/$F#(#:62 9å5ÑÀA`IÁ ;ð|Ì V;ð ç+Æø|n  		èÁè@4fé_Ü#u  üY A"y @¢C¸A@ <Â$Ë+>
AÁèu¬ m;ð}#Æ ) #è`& \#M@$ ç ÝP0@*  !¨Gß;a£BÇt$(¡°t¸!H»a£ -ë¿@Á»A© ?/ `¬ H!ÿ!U P!¼·X(È 7LÐ= 	 L2í)$ aP$Ô è²9#H@"$Ð 9D5`-DÈ  7t"È8ë  $!µ(¦âÐ  0 A/ÈEX KÂF D!@§ ¹Ya A  H#\  d  (È ýä 'i4)> ã <&T@· @à/Á¹@à H0$Sb+  PQ ë9è à æ
)D$`  ð`(%&  ø À V$\ È o¾8@Bn@	·A#(ÑÑ:ôn(âÆâUX àP  è S> %\ã(,Ô ü@?XË@bÐ@`§À@Yø2 @Xø 	 ? @@w°`ù(Ï_ÌqÇ D-ù\Ì, É,ÉoÁ*ÀoÂÆÀN@	rðD$p@@ ç P@x(T$pf~.JÂfsØ)Ô b  À   Ú@ Øà @DXÄ 1  1 Ü \ø 4 KÃÆÁ/ÕøÆÙ!, Ha,x@Xû^¨(×Rnð`: Ñ@A@NÆúä\ý`. @û  QXý(êÆëô\é~ ^0@!(åúYÅYþXÁF(  l!ÔÆÂÆà ) @@)! S;!aÆá¤Y¤éN¨Xå0½ÆÄª à 7P¦í`@>
(ççXç\âÀC Ê 7"ù À": ªN¸ * @* _R7\át}wó  Ä !&  Ì]/á /FÎv&¸Øi @FW 4  F$k  YÀÇvú@  
 ¸@   :' YN &$´` YµX¤^èàAjp@%º0lÛ{2°@XÜ(¤cçYØ & ` 	XA¶` À @	%z_ÊB\Ê)¹B~$Jë@ 
  ( ÃKo$È@oq"¨*àBÆä"® àb¢ ;Kt@b±   ¨@: R@"n À"b·@ !·XÂ!Ý ¸b\Ø(d BÆÉ`Áh@Ë6¥ Î"¨ÆÃU(àXã@*P`ÔÌÆË!³ ÊA½Q÷A!á ¸  F# Ø Ð`+!xXÙ Ì l!ÂÈ#9T 5 L+B$êH$Í <!^ø 0Ô`? è!¸JHP/#:(³i{&O\è.Å2 !Ø`, PÜ 
 % é`Yá  â  ì WnüAæ K"~NØÆè `â Á  å"Æ$5áAòY% @XÃ\à S À S ?	ÆäU£V!  Y` ` O ë"5êèS1 f@LÁXÉ#q \6ÅÆÅ^ê Æ2  ÆÁ@e3®ayCBP@Ë Ì#à Ç!é&6 @!2 &<ú%rwè%z ºEÉ0%ë"¯  `Ø @¯¦EÕ'G a» Ñ)õué!} D ËÂXÂ@[ &6 uÆÈ%¥(9ø@GB `n ` c ` ¢ `l$H#4f!ÑDÆÀ ! È@DXù%ÒD$Æ@'
D$$@D$ ';D) §*­øÿÿ§-tg¾ . 9·BÖ~Z A ( ¥0p @A!Iµ &Ò*o*¡,ÂG?QÂPè¯'L®$F ã@@. B<Ä\;`Y(ÿÏè%{ÿÿÀu sÀ~	+E`;E  _^3ÌèGÒ å]Â P+@ oìh¡¤l
D$dEÑV3ö 0EW' ' í ­>Ä9²N.¢MÔ&3@J(g  º (g &@Wö(.i Ôa @*µ P ( Rh;m  NK*0) ¡)J¤)(H)`")¢ @f)ªà ºô  4A"7ÇL`S@)õø~/!k$F!¢ A1!Þ t $@¹   ! `CÇë já} Ã 0)t ¿c Æ+Â!yÑøið@¤ÀiÀ@ U0ÆÀ(Úò 4 , J  8+Á)Ì  Au @#u¾2³  !9 *`"Ñ A Xa J ,aK"!<Ï¡%(Ð#@~ `(Æ`	) "a: T #`(aI ¤ `(AX  ô `(06 $¿@o(âX W± #v Y$m ÌCgX) S,(I[é#¬8M Ô &	)èîy± U,L$!ó$²aÍºðAÓD$äY¢B
ð!Rø Æ#-ú@#a(Pô` 9êÀ à Tüà8Xà1 \B¿ P0¶Ù{ à$àvàào à B)`¨Xà 7C`\#Ç#%P(ÆY @st$0A$â\!;-	ÚN(ÊXÚ_% rß;ð _%Ó±XÓ!¬Ð! I ° IOäXÜÆI )c!³  IE)/(à@7/¤Y0`Ð)`@Aà ) &¼à A!ì GL$V8Ü( U  Bàl$^¼ "Ì^¢<ñü%Vt$ ª `üDç$(bÿ#((( ( ( D"D D#ÈCæ#u   \ $ ;¡0  ldüJÍäü  ÿìø$¸Å$ô ,µ¯o Y$M#· Rj  f 0R=
 $LÇ P tTè"ïrR6 mÞ 3UhhNEKïp È'ê TOi GOiEØDHÎ3ö$|sUÂüÁêB4 -  îÏ 'Ñ*p XA  NÁ` @DV@A"  @ n¾À @ M>'\ ¬B¾;u}0 w	+È+Ö@ @ç  @_ àp%]@4 ç@4!B!Ò IX ;Em!HÇî ßw ) îß &n`AZ ?*DXpp  H"Â$ d ` >x{ 
 ï@$ @ $!Xà'7¹$p o Q.î ´ èC   ¿x$°  9 @lDÐ ³!»NþL$H.þL$  ò$	aÈ = RD$Fæ X"A@¿n   *N÷\(Èîï"9àq ^L$, ÷ L&o@ÅPH(hO;#à $È%x$$ Á(íCÐ$à@ !§(@`X û!oî(B W%¶/ oÚ % kn 'j D%`N ª-ûvÈ n¸ !P  *h(B@òY§pu  j ` 	@ W­ ^À)!G@ I(BP 1x ' ô`è@ÆÀ$ Ü$ª 4 Ä@(Î , ,ò´$¬!óZ.hÀUòXá aNè@!   !  À  × )D$l   FÐ + â ¼$ @ ¿``YVØ ! Y~à Fð 	¨`%s(Ï : n û 7½ ÀE X@¼$¤`RXÔ  Ë  Ê!/ *L$f!D$d!0C$ ; F ¡ @~¸  v `n`Æ$ L  -Ó@í - àD@y `  qNàÊè À¡@8¡GWÉ 1°`¿~ nø È !´ Ü§À 
  !HÁs !·èv  ^¼$¨ S!T!·AmYÑ  ¯ GaYÐ`1!p h ?Ø`YF"
aðN(  ÔøF0 !àV !wn ¯XÑ  ó 5¶  nZ Ô.³FÙ  òFñ(Æò\Ö!hÆ)D$` 1  /@~ "£ ¾@ û "Ó > @| @    @f `ð > ¬v$0ïN#" É øÌÆÄ"r Y7$a ´ PXñ $ \@ý  ´(`ë'Ú`(5(øBáMM0r x½YÙc- ()QTòZÚÙ.v@61F ·G ­g`LY H"ËÚ"CP` &ü@yo NN(¯@(Ps@6#^ ø(Fø%DD>& A*  	0@&YïY¿@7X®q0(Õ(õÂ  Â·ð T$âU§@ TÚVà@U @(}U`@	N@	@0ÖV$ÆÐ AYÄYÍ#l .tY°`ËTÆU#ÎV* `ÄWäX %ÃU .ÂYà`À`$7Q ® Ç@M): &ÆÄ)ÃÊÆÌÝ 3© v +(Ø@2ÆÄ1 P# $¬@Y@!X@ 'e A¡agA'ÆÉ(á%( `"jD((!|)®]p \Á,Ð)C, ¶$fÀ oó× )+ / Q(!$Y`- WÎ@=@!Qq+0"ëS´ Ô h@!-   
q1"AÆÌÆÔ3¼Ó(q©ÆÜ-0$ú+ª Y:(bª$@aD(b(Oè! >@Ae#<\ñ àYæY´$C®XáC°)¦,¦@£)´(F¨ "V) (t "3Q"»ÆÁ"¥!JèÆè"Q*ÆÝ @TXÞÆØAÅYP$J)¬¡`$¶ È 7 A 7 A[v@ &!ÈÙC)^ AX w!,n8Fu @ W#t^.­e6 ° $¸ ÆÎg H¢!Zù&·f· À & %4F à   N%/$1 8 EÈ F'V$ÜYÐ`E5%Ë¿Ø`Fp ! ~$ï X%)Yè`n F« |E5f&¡æ0LF c×@Ok@P'Æ&Ø@fL$ L@~ v@@q `´ Å3Xj /r , Í¦£t$<  F Â Þ 4  L`N`èjú fª ÄAi"æa(« ð`À¾#X nx !§¡w   
!H ÎY ±·(   ¶dÖ ÆBah!%É@Èa#¥`'  Ë`YHÀ!HA Te 0`Aq8`YUW A£  [  F­ ®±Aæ° æ
¨&üÇ  `³  F ü ­ #¾#  À©!s Ë # 8 !e8@ÉAZÝ¶  a#fÇ#gÌÆÇ.] £FÄ!×a}'n  \`fà  ´b,@^@ ë; F(¼cr& ø6vD\(6 ¼ec Q!]7Ï(§°`  ´k(®dsY¿ @X¿P@(Ç_Ä% @\Ä,ÀE$â 0B9  
 8@
 `"Ïað6lgÏ o¢  o6l ðE-Æö6l ðe4 ; P@; eC æDL@ X@(`!%,D;¥F ü!~Y ä  %F`-²sÙ¹- èà  Ã , 9( ì F xÝÆÂ%l!5A Ú%zÅ](a9*@\ù! PEPYý &TDaB)¾`RY=ð5Û%;Ç)9% 5Ë'² )'× À'X-Ò(9`#j(·p`XÐ`Yñ(@  
7- ÷6ÃX¶,ù'ÖàóSä(îÂ¯  "(Ì & Ô9?Ð Y &À(  YÎ U'â% [G(vH² `Æ\#à`ÌT'³ôUù D @ V`»BÄ`d¸Uþ"6`ü7øY°@* (î  Ö @|ð@YÍ  Ö@sY×X*ºQ @Ð!D`ØGÌ R£ *@9 Á Y ` < )  w y 	)C \7©Xï KÝ)Þ(®Y¢Y% Ü{8·w WY-@XìY¯0"ð !è#Æ® ö À@X¯ @3Yè 	 `@"$h$ @!c"ú($"Á `B§  
 h@
#`ã NÑBìÃ*Àc À# Àc CsÇ£ B`2'.  `] `!"ö9ûX"ôyC ô  ã ø +¥@# È# Ð#ÕÆØ8¥ d ÆÆþA¡YÐ\V9»`bù 
)V' !lF (v P/õ "Æîª!±#è!!ö Õ!¥*#Yp@7I)@3 T`3!ÞYÑ/~TXõ    f`  V:ùù A @*@2hòC6yì$`T*¦B: Ã H 9yï#[b)@"  7 á` Y)GXò  æ ] ¦@F@" aU a6 ñ(bv`ê#<ßÊP &<íàdYö#paR Ê*é: ` 3  )`D S )wL$Lê0¾PI5¦0å T!/ 0L ÉvïD!ð0¥ºYØ9  nyÇF. ¡PxY0æ (R ì Y X%H,"n@Z q6Ù!Æ¬(y )¬ (y ` (¬ )`!¹¬ \#zq"â  ¥ X ! È îqÇ )D$ Y¬ T"Æ`3Ø .;D$ÿíù¬ jù¬ ] ² $ ©(ù	¬ , ? 2< @ 9¯ |ù¯ÿy¯ TÇ 8t E4y¯ ù¯uaù¯ ü ¥t²¸ô²Ô¯ H "ô¯ D  4¯W}ñM9l P!À8ÁT¥j Q4Ã0(P ¼ < Hè[ © ¾BÎ XFS«"VÌ]2yòô®"Ü6Û RÕ t"îÁçN Vy=:¿!Ü<×!@3ÿ9}& ) ørx 	0ÀüÂ;Èw@T@Á;ÂsW %%  yHÈø@Y99@)D"149 .Ç(Ë& %nÈ	B5   ÀA`IÁ ;ø|Ì V;ø   +Çø|n  		èÁè@<fõO ##» X$  B5F`UX @BÀ  @BÂUO@9 AUOu`è5O@}+Ñ+Ç )
 < \ #' @$ ç Ý !:@:Ý  !¨ !¨;a£"Ý ,°õ?a£ -ë¿@Á»A©
 ?;¦` !¡ P H $L½!@/¾f!jpF`- !()X¤&+gAßU/ !Ðè @D n9D5v `_5/ £U+<ëU+ (!À ,U+ µ pU+t$4 =Æ[ÇÆ W¸ D!*@²4	`Hfµ/G G¼  ðE U)8ÇD$@µ)Â 4ÿH`&× Èd+uëR@@ÈPè ".@Ù `@ Ð  vh L¶8åC i ð%zp6 Â.HI&q@¦ P` @ÆÊ>o@
%í&«)w)7@ ` `@1Üp`	2Ä2@[(G T  &V@`F HF@0Ù H@0qÆÃU8q  h @ &¨` a Ã  à v °@v[­#áà N h]&Å R à&6 ÌEÄFIÉ1 \'YÈ`$EÛ è@ NÆÉª(  ­ `sà [ ¨@(£  
!!bAn"O · JöjCî`f (±rº6ù ø'JkS(ïÆè@ y @ L 2¡ ÈGðS ``3ÊÂØ"` ã@R @"-À@	 U'R    @²TËVá- à@Yô-Q@^`/  @ U+l'@/ @@@x`@	 \(¥ *@Wð  @@!FYÍo$ºd$p!R   ` Ø/Ñ  0b\@ Y@@ P@	 X@	 p 	$¨ õ! +Î_Ë])»Ë,ÑÉ,É°@M2H *   D8S o!Ï Y«tÆä*àM*G¾@)@ )@  CJ iÖ <õ´@S )@M#-J Ä(b*2-'?øPà-\ð¸@. ( *@J"k%!ª@É Ð@#ÆÚXó-(C| ,­\õ`G @ïw `
|¤ `¯bÆèÞ 8ÆÍY¬ÕaN à@Y ,§ | !¹O0`
 ×d XéKÆÅ#q2w+ÆÅª 
 ø"¹ ¿`]gP#Ç PBGÆå"×=f"ep@"^@	b °@
B+ E xÐ`5 ñ ' 0@TÃV@ù ð`Îb8 @U@	 U"´ "P@"3,#!íÆÍ-),À ¬$5	G@\ø_ ,@øó ¢ M#ÛÇÇW2ç × Ú pGYn¦À"N"i  @"±O`!¨ªYÀÚLê£¼ G@@#ÆòXñBÿ@É °@BAÆÈ
 ( `@!É@@ ¹â§ ÁB§"had  
`,Ñ`&zb/òto /ò4'íN¼ABá èbº A À@~ !BÉXÝ4*f¾  `!"! Â"±U? ó,º Lº,á`"ÔsÚ/ò5TÀ b .À)L#BCG`-Ä Ð!gØ§@.ÆÁ,ö ð'Ë#ÕC$ÆÁ`þ ú à#ÔGP$K \A5 ð B .`!$w"h o  NUÆö;KÅ\Æ#¶ B+ñ H4G p `ÔL´@ñLZXá ~h#AÂÈ8ÂT%¬ \ §@5 #¸`2,ðYä@ ¼`!&! Y&jl½ Ø½ $b@bÄAÆMMYÙé%¯"OÈl$H(±   ñ  DLÕ Þ u `^ ²g/Æø+Ý×GpCG`c) %8g`#@#=Op`Àà ,O'ê@7Â"õY|'Ð²w¸¡obÅ"ÆÈ"É °BÉd  @Ä@K@g¤¢ S%¾$5ÂXÒFó \%¾ B×(÷,iwGÀ(  HCÆW°!  @
YÐ,"Im	M	 M!" @sXÑiï D@a$XÂ(Ð!C ¤&Õ@ß m G(&GÀ #oG°  À!H¬þH   !dD,ÿ  Òöiiå,ø (lø lø ÇN¬ / ,ø6 + ©¤a¿'z 9¾Co~T!Í,,²ì
øL; ,ï 0ìïlï$G Á DÌï @,W k;`S+ÎèT¬ï OâÀ~	+E`$L,¾lï§«ìïìVñ!g  ¤ ¾L B¿ T! L-Çº ?   ¼ " l½ 	 ¨SU 3 x è.Ý©p \$W,¨ +ZÊÆ!1 ¾) $@X``td R ,@  ³UÕ+ÍøJf!Üÿ f , :/Ár#ki@
CÀë,CR CÀÂïu¾Í¾( 9*g  @p3ÿ ré -9 @dM®ür°AN@HÆÉ 1nÒ ;èw;Ñsf;ë Ós^pá`ÐsP!á,Âík+ÐÙ- Ý, ¹-a@ "üó[À@)ô@"D9ïàà;ú|Ë@´,â?lQØ!)+ß@²
RMBaí ó2Ïî P Y`!BüëuÓ\+Ë3Ñ¼!	/ ES ú@aùÐ]EfZÐA @ kAE^ iÈ :5³"3 ( @kc6`%ÿÿ 	  b,!¦:)\ ¸ 5!¢   YÊ  -§
¡¦§ë!| Pu@ Á/^QUèþ 4g"ó!UÃ ê B L$ÅC;B¹"}  % "{ýÿÿ_][^ÄÂ Ì` Ïß^ïßä !UEV/âE_OÛ/! , V(az#w Qj Pè{ý 3À  9@}G åO±L$$¡/-xm3öÑ%Áÿ^;ÿrj®%qüðO© Â q¾  ;Èw9T$sBÇâK|$´ D å/¯Æ%D×O©I­$è¯£ð|Ø +;÷ WÇ+ÆO¦ W`¯¥4EO!S#Ú X/£G	oïï	ï¼;÷} ZÑ+ÆfÏï ë@!,@! $a3;aFÇ$0 #V@± ÑAS!3É!à(% 3Ò·~@N  Ð.ö ] ( !m!(-*|$0 Ø-¸= c. ð$AY,` $úDb \g® ( &Q &"âX2  &öGçXÍ  Ê@A\^Ó@Q "' À ð  4°`\Â $Þ X -@L4ßY%È_E!  `\ ã  ``: X p$(s\_7 F´`*àe  Ê À`@j`b ;@b b¤ Fô`F 0þ jÐ`Xà` `  @@B @@``	 @0@` @°@`  Ð@À@``	oATo A§¶` þ5¿5`XDÁoø ­ & @&6ÿ(P@ ) "xX I"%@þL   Z :D$H@.ÆîP M  { Û J  l``/Y-0@sà`Ã-p@8½,Ý*Å,-2 )@oÅ*øo04ÿN@	nÌbÀoàoÐúãúÕoêoÔú(.oÝ§úØoÌ a@KnoÍ `ÿXoÊ à#`oË à# h6ÕD$+. !ÿBD$`!ó lTà T`I×à d`Naà. A #íà `L° `h\ï"ÙaÉ¦`!+à &  \`*]q5@,C Ë+Ù úà  l` J¹à `  op OL¹@ª\`È #z 9f.! \0© b¿ X !@@81Á/0Y@a¼'ÊP@""2nÑ` 9 'YÌ@*`4Y5â5`S
ð,Þ(ÆÆâ
!Ù" Û" ØB Ô@Õâ )@¡â pâxoâ p³â ÐB,f ó!hT!  d&`5aw À@¡ c­àD$t`DX\ =)v¡È$h AJ`$ Ä Aà: x`Mªà ``NàD$|`M¦à$`T" Ì` ¸`mc.Ü@B"Ád N -dÅ]13H "",é5é @4H ÿ Ö4~ÏëfKAô %÷Em \  Ye='" ,g (ñ X,ßV²    ,Òt0Ét, ¢X!% "D$H %¯ \&&A W  4K ¥.<úN  +!ù'n$ì ñl%ì%É/cE) ù(ðdMPE;(Lú(K(@  d\ D$Q	/T 	 =DX	H]p P3À0c~)~)Â.\$l #89c­@j ¼`ZsÁá)´$ªO)? @ 
 <hÏÀ~OD$6§ )§ )`§ `Â /`¥! D`¥ 	H`¥ 	$ç `Ï `­ d	Àha`Æ  0·XZ(r@  4,ÂN(a X ~` A	Bô(jð\* #H(J(bà »	hYÅX)pf ·ab Y4Æ_![ æ.Ç(Ü)@0Ä)b4| Ô?ÊGHY§H[YgYG(¯Ì -ÃXÌOÓ/Ý(á QÆàÝXáWÉX§x® [_Á]~É,Ð4,Èr øqÿ ò'I T#êrñFL$' 9 p1ÏB÷1åØ\çò~æ !÷ ò_ à  Ã ,1ý ÐñõÄÆÙ1ì Ã0FwÆ¾"
!Î8S(FC (!^Y#2Z¨îuì(Á!¶0Á! =%Ac!°(BP C`( &= N) àOþ ) %xYÆ .$Î¢\J-½ I¯X 
 )  (8â X8÷ÆèU)!Ö@uI l$4"0ë, 3~bé5"P $U  Ç!Û"é#Þ @ ¬8ÆLØ ©<@#8Â@5" <Bã ; QÏèD°\b÷p`_^å]ìdSUV#Å-¾ 4 r |$8¿Ô!L
 tèHÿÿ @rh3É!*`¢ ÄP!Æ`4 Gä D{ d E ÅT$0 _"þ` L-L$ 9½­ Õt$dW+½@%Ø,`Lml Þ <?¿  tZ  Bürô*N" aÿrøÀ 1 D x D1El$Lÿ´Ç$ 6èÐï@2D$$Ä ;   l' l!] ¿  t @- HE/ DPé@¹3í P9Ç1& 7|!/O | ! X  x ä$¡)d  9tqÀÇ > (Drô ^RüÕ C ËÀ º Ôèà	½À«  F%û  ¯HEØPaµ Ta 	@Íá `ÅT$XÁø  LO Óà ü L!\D4 .$ä Ô8& ¢ ¬añ3ÉíÆ ý  D$!5ó' 1 ¨.» [HEÿ9 ! %Hw>wc9\$ 	ÃsYÅîÈÝúl$+Ø+ý" H= 81$ H±ÿÁ.Á$ (1$@à;Ë|ß ¥;ÍÊ@Å+Á.Û@ Z+éíò+t Áí'N t q"h E"H©E¯ ÐCô@'A @à[ 
@ì DðÀ@ C '@!ÒC àøí>!cà ¦}'"5	+ÓÝ+Ù 2@"rà5q¬ æ¢FA¤ @ `!!¨«Ð éû!jSÿ´iÏUT9 HÀè? !Ý`8 -À4AÅÝë«aã ë#ó d!ãÛ¨ Rû!ã Á; ¯A ¢U röaäLCáä L!ÚÂsf9!È 	Ås\Ãáä
|$ë+èÚ+ß1 ` rG `Aß@ð2k H7¬8< 5 ;Í|Ô / 8A;Ëõ@¢ Ã¡ë §@AÚj+Ùl ëú+þÁëC"W `@8F " `!ýïï E!·Á|X@üAÉ à!CkE à+!µ @ b* E Å"/X@@ · Sw  x < ö;Ë}9+TB  ´ "¡+Ùfà 1|à c UAëuã@ü G!Ý$E =F#ÁDÜ DD²äâDº#ÿ$;¾qû%Þ Dö*Y@A 1T$0ÂÀ )  $ (#Æ,;¬|úÿÿ3Éd
9F­~{ |eT$xÅuî D",ª"Y	u>à  ·@SÎÿP,Îj UÿPà 	 `	 "¶|ÿPE? L*GAÀÔ v@Z ;`z| &Àx&¥Qu	¿  tÃÉÿ;f'MÁ`)_^][Äd&üj ã,é;  é¬2rT Êï x(Wô t )áVu':$8TM6% v Rj ¼gÆt0L$`P$K1	Né Ä¿#b6 # ¼3Ò!zP!y õ ¹^ÈU}]>ÁæG ra,¤A%Î3ö}|iUÂüÁêB4 ^"2"B Á" b· A"ª`B®³ A"£ "¬ 5A)8À"R@BÂ êÃ;u}, m+È+ÖM`k àl (í 0 ç" Bj B"ü ( @Þ!È,;h3ÿ"!H¡tf(5  U   )(ë"@ÀA!B)ABµXL:Lx·$ÔÀ H@k: -! ,, @mÄÀ$PuÐ&Ü #*$!¢ P$ Sè£ðþÿ!z`($Jj 9 «3DÈ Æ =Lt	Îë! P$|T>5ÿ |(,L$,Çl@ Ï!Ã ¼p¹"îE½  L7y  	E Ió)o MÈ"®¤ !W\p!øÇf
"ª@Ñ   ¿(ÁY`0¹@*õ ;"*ô Á=: U+@îl-@ @pX!P!Èéu3 õW*¶a! -B   @  ð`Xà!?@Íð k'(  ,+ÙvÈ ø@Y^Ð n¸ §à @<©0 -`@Z bAí@»K± (x×+ ½pÛ?<  Lü Gð G YÎóZø@"  À å(× Ð`D$h , F Xá è`NØ  @BXâ 't$ Vð @`Fà '`. p ^è `XÂ  n@è T@|$  Ë  ï@pXÔ(@# fÂ)D'
  0 H@F (~!vÀ  {Nè  dV N6=[!% L$M¶.Á 	T$öÄDBÁ¡*Wÿ @v nø(Î ©@ ©(å 
§0 
 8`YA6 £ á¡]  `N!YP !Vá^ × y DaSH  % F@ò!Bh V ÜADXF  4$N¡ ^( !Y` WÒ n(¬bl n Õ !B À1@KaK Ü  dag d]æ Ã!Q ÃAL `   E@~ø 6F ÁN(  o!Þ. Å .  ^ N-ÌÌò\4B ÅÂ= Ñ  d`"`ä!Ð \XÓ 	(×à  T-æxj ) ( #=X8! } ¶-dAPtH®8§@`Y@  øág Î¢Æ 0`"  ±2A ( 0X` Y!Ô Ù A" «!` # h`#A8X`!­ ÉBÌpx`p`Yh`A§® Æ T@1AâÜ$  ù !"@Ö ? µ¾ö¶@ @j %@  @ÇBú @âú @ná
yv X®x Ã£   Ö   
 `Y^ `XáA N ° C" $?¢ú!m¨  F 3!LÈV° #µ¸F  ÊÂÈ^¨ bú À ¢ú"úDý fâ(úAñ F Á @¾@ñ v  ÂN¨  tB% ¢ÿ À^ N âÿ@"`éS¢ÿ@ \@q#@ Tâ ÿ ÷ (bø# yvH #á `Y^@ n8 § ![ ªä z YD¬ å!c t%®NX£ p . #   #!Aw´$YY (°    VCÝ`ºFP , Ê , ¼¤a  F#ÇY¨`"@j ÙC¸`Y^@ T@n É@2Aå
Î¢î F Ü @l~ áv@  X Nh @ V N9?Ó `¾å Ñ ` Ô ºbÙáP ¶V× N ®VÉ¢Õ à ¬ Õ Ð 
 Ø`YBPA_ ³åÞ À`Zò &ð !Oas !Wâæ è  Ð' Hbé 9{  H
 bì ø 'H- ãâ ïè8bò   8ò ®@Ê "õ@C uâ,õ @á l ¾A  ¶@ á@ %@ %- ã % k ã>B((AÀWÉ  ¾I¢ nx!$ åâó§ !  ¶Ké!U·( !HQP   L`(&Y  D¡ª"?GS(Ï 0  D$"}8`YJT!¦#L#Ë@@  @(ñIt -H  -Aè K9 'YX`®@É(d®  UAÛ@CXô(Æ' Æ@ÿC< Ò  `« Fx  ¾@Ü  D1s  8 @ s@ L  ' ¶  @±(Ø+(Mn*µ À+[Ã(a(¼ª ®GY"Z­ XID t$ÃÆÚ(Ë)Lè@S\ÈY*AÄKB Ç-B)`6 )Þ(´O(Í-L´$J ? H@4+zÆñ('Çh@Y` »XYK(Ù!p Ð@Â° Xà (ãU6+Í@TÃV À@ (Ì L @Xð@ U:h6¶p@@­ Ã   . Ê ¸@t$x wá ( l  ¶ ñ (Ä 	.G \2Õt   Ù(@ÆÉû I[éÖ) Ð% K( 2F A(ô!\ D8& 7LÆôä P è@eWÀ ·` -X· `õ$MÐ  À_Ã8 à@=føèo;H í<ôèrð,4`@zoÁ` CÕ 7kD·8 Ð+f8"p $8o d 5 ø@ hà  ÅAç ¦ Ý :!l "(Ä @ W(HcÆÒûø» ü8¾ Á8¾2é Ö ñ @ Ò/c ¶b¤Æö#¼¶<AT-fB°(øBq !Åà@YÚ!4 Å@ÀEP\"(ØXa@m)`/ ( HGÂY9è"$#4"`((ð@N "I  @5 { QÏa©$¦ØÆØÝ$Q ­ 
 C ô>^ 	CY  LXx`¬ ^>Úp@ÂP B±  (êU!Û` n @	Y`@#%  @ATÂVèX` Å % 0@	UÑ!aFY@@#_ÉarZl+X X!f b:)@""|pa0@!$Yp!lX°@#_Â"S ð@\Â,À@B"XÖ@ 
a ( (ÈePo o!O@¹"}*ðB_Æö" ðÂf{ð b ä Rdi R@"%"f Æ%&Wö$"B!æ" æ;ÆÝ@³XÜ#g!$@jY-  Ø  ñ(§@@ÙÆÀ[Y!`¯@ÉX¯À@!A_Ä Ý  @!\Ä@Ï!  }® ë 
Cö  `àÝ Eo@ÁÀè*À@O o ëÿU x ï À`à M]Â@-`ï <X¤D dæ"@& ÷$U Ácu\ì#=[ú  Z !`  Ù à \ #¥  FÆÉ[?[!6 è%µ"³ëYé!:®DA:(C (¥§##Hè\ #ç0))¦@%"A ¤°j%M§°BwY @X`M¢ï AkÂð Bï  @(ÚesBè À  9  @Bà!Ï0@"|YÐ@"àYà@	XÄBÍ)` ¾b(Y0!ð î@»@ÂÆÀ P ! 
=`@
(¯°`#¦ô§P@Xû!ªXø ;c$ÆÅ«Y¿@X¿ @" Y  Æ! Ð ´îX¿Ð`  ÇD @(âDf(DCqB,`!÷ã" AJ£"XæC%so"-^ %£@!"#ä£(¶a\üÆõû¢8   $"8`$B8 Ú¢8 à B8 &þH øHûY÷!ò¿P@ö#(î"5 ¾dÆÆeC! pÆîª!/&c a'$Æö"\ ÖF´\Õ L Ñ . F»@*   * #   ü% Ø§!» ø %s'I#ðBE(|ÂÈ ÛT & \ @* # oP(à X Û@ AO (!,G° Ã H Â 0 à'\ó_ $" F´! 7 á`Yñ , ò  æ ] ¦Fl@ÙÈ 0#@BhHû #=HL SH÷a&U@} w5T£éH4ÉJ 4ÉêTÃ@5»mëI&Ø¨  Q & ºaTzYÄ?¾6L ì ZUA&µ¾ L5[ \¤4$¸@N)È@ (\ )(@p @q ç9¬uX!h@1ÆÀ5k`e )ê ¥tò ÈÆ 95PA9x ,Yx5î
;L$(Ôéÿÿ¶td¾! 9·J~W7 T «XY& ;\D$(;³WÂVQÂPèÑ\º4F vh@+ ?dÄW?(;`V|ÉÏè$ßñ  p ßñ@" | ­_^3Ìè²{ Nå]Â 8àìVW8Â|$9@ 6 N6ß yïù? !öÌ]?úÀfnÁ ¦["K ^"a Ú( É ' ¡(Áá! 6¢?ðt6â,ñ!î $Ü ÿ|`T?GüÁèN@ÂÀ
  UÁà<ØR8wAøI  Y"¼B=ZA J A ;±A øu»;Çj Í $ÁYVÏ (IXþÂ@ VAü;Ç|êé> +3ÒÿElÿrw!§$Oÿ?¹
 ;Áw^Á$¸@ÆsPÇüØÏ+È@4   ·|Ì ËB|ÌL9 %r" ;Ñ|Ó =;×´!&Ç+Âø|u $J+ú 	ïÁïA0Gº ÏAøø X\¦ @A\!5ï$1 !9ùí Ú ÙðWàïu­A®;×}.`x j@ý!ÌC²  a?B N@8 yà;×|ç -  9@!r !Ê;BÆúý9Øyä9´  B ÒØ!p )(·" ²-©VY%¨^E@È%%Ö5  ½ =À  ^9iA© q $9[  "}  [,@ ¶ t$;lbÞ 'tú~BCf
 >T$BÄ @|$+Ö+þ G #   àÿ2TÅ/J v;¢/ vVUëSd IÍòY   ®À#/Ðv%Ã6I$&YNz  Á +À'` +Âr7@= òv- K @/B Ó$÷  B ^&æ/àv x Y/ÛX ]A; [» C®%ô8 0-v F\Ápv ZF^Ú-Ö1Æ#!? ( 	
(i  ,;;·ÿD$ $$ñ daÙ!T(9T$%;_^ÄÂD^$_V_!J¹ t~3ö9·bÙ!û [WB?#ýD$¡í:É  ÁE( !ÿt$_*PQèýË$ÍT$(E$ÂÁ@ ; (E  - ;`k|Ê@ $ô H@V $Y@ D' =B"5p¨}Ê E`>2,½ö~</d@TÇó_-èî<ã T"@Tï+v!| ÁAô$Á¯L #5 è#n*e¯@&¿@  X-Ð= |]-A´  4 Bá   Ë 
%  (\Ê K4 &"
 B(L@)Æ`V ë=° XH|`> ; §@ Î!Ì ,Ô  Á å L%ÛÀ@JvOÝÈ[À¯ m\È Â@&  / q|` \(T§I³<¾I¬ PZ*¶ ¶`S!Ì  @21 
 ` A ØB Ö.Ô X(úÀ93 P7  43 AA ð# R YH° ð C0x Y& X ^õ  ñ ·d`¡ X ·@F  §JU Q¼ WPÀ{ T@x` \# Y)? X ¤ +éµ!®,q 
.w  Þ!?ó·A!ÆVA @ì`à \ È@ïW!
 a `+Í J & Ð  @ AYÓ t@< `1ö + ç Y ß`ï ÷Y·Au  àó@Á3ö 1 Î~~@#7 "ÏE	 "ìfbÛ!UCG F 8 AeA ðÿÿ£R Ó ?   c2#z$8"MÆüÿdCp$à ì 1hK V ¥FD©èw 7 !UÁ3À$ !X àè
o $èo3Ò ° (q+È  HqfL$ FÇüÁG<'G'? ½     @Èi@#® Hg@ÈlHg'Â!9&ô Hg@"e øG3 ½@p"ª G½ f!Ó  §; .@hr'9'¡'/êé; &Hp 7 Hp v`3èp3Ò¨r Hè r Mèr  ¨r)o"Çè$o`±èo èfo(;o êè"oJX@!ØHo;èobE(o !ÞjJÄ!`$·"V!-PaE=Tw5PbE#Y=`(jú Fs"ËH$  " $ ?(HO ¢¶ # (O ùHO"bi(O&yFa ¥!Ý"$+Ê+ú C ¨O  K H vT} \hTEÍ>èÜéË ¼  D`²2·/à_Ev]/Ýv//Þv HX@¾X \Eé`3YØ ([   /ßv@ ø tZEëk@8Y@  ëY/x(Gv-  ì)m5 p @d  =ë5@5 °  V  # ,È] ,  Z@,ØT (Yp`F#ÄYx U (uE Y<`ßX^  @à ¸gX I; A@`,YF@/(ºF@v N@  F  X¨ø6$2(õ$¸Y $ +wD¥@A{(°!(* × $DøBbB!Ý;Ñ %H@ÂÖà  HßñW) ¾Èßÿ9¾ß  «B	Vèß èß èß (ßPQèÃß G Gèß`kèß B} ÿB}"u! %a-ìfA|5L(ç =t =x ¾h<) :  ¨ <A =è è Ä/øh @)Æ`Fè `> N @'4!yG fHx%á \AÙ G¤ ` -PÂ'1   '  ) IY@)!ú : ¸à5 Äà5 à5 ¬à5 Æà5@! à9gVÉ9Añ~#ë !íøA)k "w ´ IÞ  #@¬ À'ð _2+]Ö-ª!J *WAYÊ  @b !|Y@¨ ê ÇBª ;`z|@  0Èl$M!' /¢µçì  é¡¤P3Ä0àM1MB¹WÀJ/ y _D$<3É`@(!`
 D` H` L` 0` 8` 4` P` T` X` \`>Ó T d` h` l!ù A9!üVWz  À# 'm+;@}	´ä ëB ²@&`AÆA	Çù|Í3É2o@59:Ü,fû@Ï´$MD$% 4 Q?'í\@ øNã@ TÀD#!mÁÄ  @ @Q + 3l  *@ dÀRñ@;  %<D$|@@ß _L D 4Ý ÛBTBF !BAL r Au$ à A$ÜàA£ ¡Å`C%  Ôà! <`Z÷ !A¾$Ìà!AÉ$_ !Aæ$Ä! <  ,  4  (  ,  $  $      #- D}	ÿ|^¸!Ò 4JTDAù -¼ @ À zÐAàÇaæ ÿ  LÁ@= UÈG Lb `ë -@ ÿ|| &(Ê m@ø  #S P ÿ p hHàLÈ@- ]È@!AY  @¥/ÁDå àª ,Ä»È `@g@  - @ìÿ|x`Ë@  ¤   ÿ T#éà@) <H@ Aú  @qà @v #Ñ Ì @ Ð `@m@ K  ` Ì@_4 à@) oÈÀB ¤ @ià @n và Ô  Ø `@m@ ÿ@ ` Í@ ¬  à@) oH@!Db ¬ @ià @n #à Ü  à `@m@ ÿ@ ` Î@Zî à@) oÈÀC= ´ @ià @n và ä  è `@m@ ÿ@ ` Ï@K à@) oH@!Cç ¼ @ià @n #à ì  ð `@m@ , 	   I cö£>¸ cÅ Ê#; DUcD  2È  @p  .\$<D@{ > ô @ ø `@m@ ÿ	À ¤a d D!(à 2H	`_  @pÀ X@{ à ü    x`@m@ ÿ
À ¨  O eB E< à 2ÈÀ@pÀ \@{ à `p `@m@ ÿÀ ¬  O eè Eâ à 2H
@;A)`@pÀ `@{ #à `p `@m@ ÿÀ °  O f F à 2È` @pÀ d@{ #à `p `@m@ ÿÀ ´  O g4 G. à 2H@; @pÀ h@{ #à `p  `@m@ ÿÀ ¸  OÚ Ø à 2ÈÀ@pÀ l@{ à $`p( `@m@ ÿÀ ¼  O h Hz!(á) 2H@;A)`@pÀ p@{ #à ,`p0 `@m@ ÿ|iÀ Î'Í   @ 5F$¤d@* ''Ñ` @dT$tv/U@o@#hë3ö;CIüh²¢p v ªh²`ºX (¹(®+­¤$\@´`³ AO Aë B C# C¿ D[ D÷ E F" F± G@ GÏ c ¬jh Ho K  ´jÌ j·  ¼ªÊd$)§ 3© t$I}3ìdãÄú$¼ @7À DX¼ÀIü¸À*´ `ì@ °À@ö@ ¬ÀA @ ¨ÀA
@ ¤ÀA@  ÀA@ ÀA(@ ÀA2@ ÀA<@ ÀAF@ ÀAP@ ÀAZ@ Àd`ºh²d` ìAu |ÀxÀ«©tÀB¥@! p`P` KB, lÀBL`TX`¼aã ºH ´¡å´bµ ¢\`_þ ª``´._ø(.g FB× "² _4â_Ã  Ä 8Â_ R   ° Ò ì    J d ~  ² ¡Ìb­ b­ b­ "­` þ ) 2 L f  D; b± "Å ,À ð_r!@#ó`Áá  3ÁÁé 	?é.@ À \r{$|#pqgXÈ3K  È.é Á.å `ð$Yñ\4$/ n8`@:m &ÈÉ 9 _9YÈ1¥ Q~]Ø= T Û!·p,8qÓ\Ù HL$| $`C;ö :ÂwNî@`j Y8XÙ(0{XO  YP`"Xß 8ã X8ëXÜ`FX *®çYx *`X 
 Ä@¬ Z<£$6 x0 .× x.× D5N o k´drT 5!ÀÀ!Áà/ »]% á M%è M ]%!@ Y X%HYd@($Ò |F 0PÜ("»YD$t  .w `PèÀ p  ` 1À l  ` àP¯@M ` àPÏ@ ` àPï@ 
` àQ@ 	` àQ/@ `  àO³@ `ü àµKö@ ` øàL@ ` ôàM:@ ` ðàMÜ@ ` ìàN~@ ` èàO(@|Vbd$D!Q®!N0D$|A¿èq!ý` ` ` `  ` $` (` ,` 0` 4` 8` <` @` D@`;DÓîÿÿ"sRß
_^3ÌèµX ÄB& ÂuÉìHSUV3\Ù5a`WþÁç«à  ùQVËl½ l$TèaäþHeE .¨#h	Ù\$ öÄDz#n DgJ E^hl$PD³ OdÁá
ÊÇ!T!,;Ý "Û h!\sS \öxH2DËP LPVè¦þ`j WQ \ \A_#Ñ1× \$  (áCÅ Y$P X XÊë `5(Ú0ø@Éx:I ¤BÐ¬Bö C â  ê C%D$N  - X Xêë(â( \ÍjS\Ü¹ } Bà -4YÛ#¼à[9IXËcG#" Q@dý$¡ X&Y,À + À#å 60@;Á)0!$;Â|Bÿ@
! T!áýá&8 @À°á"  È Ê4ñ !9Ç 5V Q «Y · ãA	,Ä@· ¸@÷`¼ X 7Y8àÀÈùJb:;ÊÀÁD$p!\ÀFÎZ   Dé"  	 À"[(»,ÙB p  V  t* û  B  ">ÞþÿQËÙ$ècÚþÿ@["Lp®²$'"·Áåë:b8»!¬   L p  0ª3Ò8ÎH9T$l/ !& EHý T Ih+AhfffGí  »Dê  üÇ@    ;@D Ëè¸(ÿÿÀ ÿt òËè5à6zt$dÿD$tËVè%á ­ B@ËÀàj  h#@ (AW!RVó&+D_D$PèßþÿØ"îbh ¥'CØ@ 3# ," 9A¢I!¸,Àø!Á@kBE;Á! AÂP N!T 0T 0AO ûbP`_ g\$(TJÎgCÃg ÑN j'3 Y? X'aXÑë"J'@ Ñ » 3L@`F\Ùº!@3'Ëb[ÓóQ# _#â a@M 4,Âà Ïâ\àÓ Â Í àÍ ¢3t" Òâ'Üâ ';Ø@â,!ñ +Èya !ò$Ñ+Áà {Y\&Ge,À+Ð;Êt"  É Â[É( <!¬[Tó$ »   g &`]! -! M -Qv aø`8 XI ¼ B¼!b - èYH<J $Á.ÈEY {;÷@j , rMEZP2@> ¾hÿB¡  +D$<tG ó#W(!d(   LWW` i Çó $  DJZAq@? ¼`÷ @X"}ë@3`û # DB¼a]¹ & A û (÷`Â»Bâÿÿ ÁèÊ   ¶Àò+ -4Óî`A+È÷ Ù4Óú% "ÿÓâ`3Cì8ÐFÿ#Ä4÷ÿ !Æ!<t$7®, FAA ó  +ùYî  Î  @  Ö 3 ó8c((æ  GYá5 @ 
Ê(Þ( (YÝ( ?\5D* AK é *@2"ÑYÞ  è  C¡ -J¹Xë ^Áß û ã lBù¡¢7$5	} (ûë=Ë}!iuá N u UáC!áCMáB À¡; $Aá;A!á; í Æ!X é(ÎA [ ºáH!1 LáH*Ì \!_ á H&rá H %¡H ã ¡H$  E@]+Õ XM¿ EK>cÏ#x#sr	 U#O EÀ(¢"Ô-K$})«E>!~HCT #à ·* $ÿD/`%uXbÊ Ð 9`#|
Ç`@  / #ú È    iDK H"ñLT$(I @ D Y.~XT$T"ñ ( HB z ?¤ ' Q I¸t$`D % H 5/°;í A I @] hf³+ùÿ?É][ÄHÂI®l3ÿ'1$Ò,çGÏ\Ç]«çú"º&ì¸!ÿ ! &×fÿ Ùæÿ'­&º  (ÓIê8iê @&»ôE´  \a¤#ê Ý(æ (¯f|$*éê å 5¦s@.$«!ï\Úæ » É2 EI®%¡%Rhí%©é¥æ#ê§_æ#ÕþÈ³¯Ñþÿ£÷tY"æ$/ Ë"Ó Yæ#.Ò ^!æ#"Iæ fK'Dc!PcF¥ËHëKºE!, DB;}ä tD® }e¿äw |ä0w\=Uå»X|`åÁ 7Ä$Xå½ Ò@¾å%Â! F¤bÅ/ø 
¥ØXëdZ  \DAl * d ;`Eä$mC¦#ð Dq@5§²tA ÅÇ§ Õ k lç§ç&vçº&p¬gº#ü: |d:#Fä:o×ÀD:%D> -5	\ÁG)W hD 6ä;"p#é÷ûä5 @(é<ÿÿÿÌÌUìjÿh=d¡DûPQSVW¡¤P3ÅPEôd£@ñÿP$]ø;ß	$)ÿuÎSÿP,Môd2W  Y_^[å]Â Ûu@ÿP8éÙ ;ßsf@ 1(j ÈÿC;ßrë@WVúÿta^;Ú~Ò;ÚúF$¹LqÀVjOÈ¯ÑRëO;ÂSN ;Ñ~LF;Á~+ÂÑø Ð~êà;`8 $¯ÁPëà¯ËQÎèÀÛÿÀu6;ßv0;ûs,@¦ W ¦E)µðÇEP­ 	tÈèyäÿG !?ÿ;ûrÔ3Ààþ Ì U¬$Dðÿÿì¼  !j?íÁjìMV¡l¸  !|áuù}Ô3ÒÇEP© GUàEØ·T!~	G3ÛÎP Uì]Üp L` t` P` x` T` |` X@U\```d`h`l`ÌUÈUÐUÄèÖ(ÛM1Ë=#jVM èäÿSSS 
]üèÅnï!Ot	!Z
ÚÙÿëAØ"  j ¬àè5ýêÿÜ E@ºÆL Æ û~ 
;ÙtÙMÜ I ` u M uEàt #ôG¤"é M/Â^ÁZÀò5 È0 ò#Ð^E E¼Û§ X3ÿµx ·@4¾è©üêÿ3É@º'< ÷âÁ÷ÙÈQèB Ä`´è`%`$ q%Í æ fYE¼ò%¹à5 J 5½ø ` 7Ç A÷½@èVBPR I 9 I P`}
è^¡êÿG;ûi!a#Mä}ÔuØ Ý  , h!/*· ,/Þ
EäMèr-¿l  u ó%-U§G,ÁEà  ª ^FòÈëT;È~S(ðhE3À8"j iE + Ñ  H@[Ò( 2^!/Èw:|éë$úF©4 ) g Ê  ;@g.Ãlí!LA¿"Æ.lEØPVjèUþÿEÌ¿A@´tX¿H@~O2 ! (q ·@9	ÈEÐèãÿúÿ _ E%&%ÐM!  ^M~ @: $ïG7ÁPD LèûÿC¬VÕ PÇEÀ  è*	_@¯Mð!h^SPÿR UàRSÿuìBRÿP`u  bQ%$jmÿP  j"5ÿP< 3Û½@!Á  Güt¼V   f $ ! W@7$CÇBä!áÔ3öÔ ¡ø  ÿtµ¼ èGì0ö"?`{ÿP   ì  `"þ?#   Ú ÿ´õ< e *Gà+@« +	Fþ{ BxMðQ¶ì@ !e ^jhÿR  í@ $@! i  Ð /¼"r@' e@ù¿î (Ë q @- (ÓxbM `X`  @ |                         @b   $ @  f   ` \   b @ª ,` `   ^  @ (` d   K¤ @ 4` h   /¨ @ 0` l   ¬ @ <` p ° @8 @ ´ t j"Ó 4 ìÂ­â» |!x  Ç B  SÇ  =RDÊ B  (AÊ@ÿÐÙÄ +µBH »@1 FüPÿR(  VAò(Æëuã#Pèãâ] ]Ü· 9¹ ]#Mì&'Pè= E ì Ç   -&é  uÝ"nEè¤ å %Ùb{Y@ { $²,À¿@Á O n'( ¥»åª<%ª  p@0É~ÁáQj PènEû A+Á-Y P)´APèA & C - ± ;aC |/U¦ ö·@3Éö~Sô3ÀÇ¸&-@ Ò~0´A!WÉD  Ý.ñYÀ%ã È6] îJ!æ `7A;Î|º3À XU@ @O 3_Eä &	Eä;Æ|è/ÂrQc ¯M^ÈF_QÁ#³ Ø!SóÈ!vÇ`  @ë
À
?3öÛ~ÿ´µE(èj; F!<;ó|ì` `¯ AèKà 9eØ !f$%ñ1FäÆ÷û0¹ÇEI @ÿM´¹  ;fL}¹!ê ÷ûE¸E´"
hÿ·FQÿ·A®MäPèï ÆÀyÀÑ%gäÆI& ;m$û 'óIåÿ·t sEèEL E`.E E&¤EÌE¨EÄE¬EÐE° !¿j}PÇ @ Ç 	ÿ¼"±EP  Ç`,REÄ#¦ T@E¤ 
 d 
 `HÇEü 
 PÎèc` @]  ÿè1\(Ì½@¨Ût5G~/ÐwµþÿS 3UÚÿG;¤Ú}Èÿ^æ ¡@$EØà Z·@Î TA`%¨Ïè'ic Opè ~ ÆEüÇ¨r+ ÎèTÚÿ@Ç@F#ÃPÿ ÔÇF&¾ ¨ F&© b Iå0c  X Þ@MØW m Áÿèþ I
}ÄÿtÏÀj ÿW f á °ìZ K%3Íè­$.¥KS]ÃÌà VWù4!5@G=àt$ÿP £L ;Q,§à<  ? <8Â@`?@ à ?M à?ñW$$ P=Tª%D[E_-@ 
 ¿E 5$  =äZEÇ º@ Æõ ;0>" )Ð= (@ à P ð Æ`  A p@ ;c)H!i ¹A)R  ¨  ¸  È  Ø è)è)|  8 *ÇB=(_ B,ó "  B ??)R ©Ô?@¹YÄÆÀ ÁB  ^ ^  Lr`C@*à 23BàC49à 
 WT L| B @1Cµ@LØlÁBLø Á@LØ`@Lâ ÀCLì @N@%Lö kÀÜäYABØÇBN ÇB  !D@&uõÂ@!gï }_^"!ÿaþ ÇáÈ@  QSB  " æÁ.·ÇÁõÑøöÁÆaúÆ\îHDÈ3Û;É«  V%¹Bß·Ð  úïG¹ $¡ÿ @ ²)@ð@¶í)Ê)F p ·@ÿÐÀt8N É$H0 ØFïj QèaFÞN$à	 E'@ÆKr ;\$Al^ÆFù_[Y! ÌPoä*¢ ,öÄD$(á	3WÒ¢ÿ ºC%"ö0q  W<â%à%9 -,e#O Â<!   @@ ) P  `   p °  À Æ #A  @!AÆ_Ó kF`!*ÇFXÙÍ¾cM"¨c )D: (=9 BßFd(ÁÇFøáQãCÇFü`Þ^¦E%3ªEYFø)Fø%¨âRÀÇFµù«CÇF8~ 
¼î¢CYN) SÁ *)V(  8 H)X   h Çx  «  
   ¨ ¸ È;M@"cïC4 Cö ÿ`D/  cO="@C CÜ^¸    È    Ø  ¨ $Q@h  ã.Æ`$Lê#. © 	L$,^3Ìèã7)ø åÅÅSUeC ãC	£½	 ì3öt]N" /Sà  èíH@      öß@èÏ@  æ bë@< Ø@N è°@N   Æ 
Ãíu<" H!Q)¡A/¯ÂC!Uÿqè>c"ÇÌ *@ Æ@	W¨böà   Uâÿ( >£#"ß À*cóð%(    " Ð@)@(à@) @(ð@)0@( E 0)@  P Æ  # 0@ É m DÇA&@& @ ÇA&  ºN7?ÇØ ­"ÍÜ 	í 	H`ÉC# ÃfC0  Ä%] AØ(`7 <À)`0  ä E ¸@eÇSxÞ>;Çì I` 	 ð 	èi 	 ô 	8A; K@(ÀK`)Q#4QX h)@Ç)Qx) 4   ¨ ¸ È Ç@0LäAÇ¬ oå 	 ° 	@ Ç´@  Ç@4@ Çp|  ÇÀ þÅ! Ä 	@ #èuû)QÁ !5cC¯ÃÕ4ãæO!´L¤O Çæ\h %&!ÐoWÀ,Â  à _è¤@,      @` P Ç !n@ Ç$ 	ÆA"
 ` .@  Ça@ ¦Ë@ âÏ"Â¢Ì ¹ ¨!ð°  W3µÜ¢Ì<eeÏ Ð,$   À@ )à Ð ð à  @(ð@)@(  >)   0 "Ú  Ï 0@ ÆLí a6e @'¿óâ
¬Ô 6%ØîOü%§
üêCÇt,§C%ØC(%ØÄ SÀ)Ø 1% è ø %  P$ÇJ$@   H X` V)­ V)­ V)­ V)­Vè&NH    X  (  h  8 xnù BÂ bÞC BÑ cB· cCÇ  @¦ D \D  8 ¸ H Xt®x@ Æ&8¢ô F=Æ0[(æÝ1÷!L$!}"D$ (¹_%ó.´x @Æö!.(,Á·Àf8  
 :È£ë(f-ò "]ë.%Æ\È TÅÌ5£ 4XÅÈ`\°ThMD$8$ YG]@H+KÆëXè×-G mD$À3è¢  à q  à N¡   H¨Ot XÏ|`¸= a/ aY¸bE`=\lc`¼ `|>@Y8`CY`Ä`  Æ Ëè| ^Â ì åìK}T$3Ò:ÄWí`-À  LZº=ÂIÐ!v¸
!b;Ðt$aOÐ T O# rPdEá V = X¬!« p"  B  %A¢ >ØW!»1¸ Y!XØ!Ã # d@ÓXÈAÍ `ë1AË@ l  $áÎ YÁÎ ¡ÎT$ c B; 5` YW!Ûâ *(ÌÂ%(Íâ%YÚ  Þ @ Ã §  ` ;åë!(ãâd à , $À $À ×% ó>¬Õ!S +  Q&ÿ g`© (ð  n'^Ù G Y-Y@#Yò Ð(ÅóA"@\Á(å á(ý =ñXë ? \!Õ (X(b X i^à(#X\Â(Ó  È\Ö (5 ©B^ï ! ^ ä 3 <<5 X Y× ÌWM¢fL`E X@äaÔYÝ WÞ  ; V8  Dí _ K " 
<¨B¬   N â   +ü ¸-ð^Â° !	hb=\ ed iÀä% \`T Z!æ Y ´ f  $pw= b ' ! -2ÿ}ÿt|$ u	¬ ÿ	tGëøwà3Òp$¡T L$$"RRgÌ P#1¹MOQW±$¾i@£@ VR$t=D$8Pè g×@Ä]( O @Â  <D%A`b h+ÁÀ~úà øu@'$¤`B ÚYL$_^ â°!@ ´` ,!Á$Ã !A	Y`¼` E´ÆE1«Âä @ `_eV dñ£éè%¨$("¬ a¶EHÎ d.¥ Wèh ,WBh( ó{Y É;ZÐò \è]  ("¤@¸" Ñ 	lf#ZÊè > (#9 g  ! ! V  F 2 Xdqè-@+&4ÉÀ¿ ~ :p^ JDÇ#¡$0æÒÁèòD.^ ^Êè®@6FÞ`^8Éà^¤,@'À^ 	PØàY T Y _@ZOK^Â ù&ó_955pôÌ ÿ w T!µ /%üd²t$v#Fë c1!% ^!Ù<BZÂè bAPaDob@U@  ý ï½ZØ 	%=/Áv 4!- U`^ì zë AV Y i `  È| \@ LBy8 @@MG} FÐ ë!XW`7!Í\\`T$D$D ¿q @I D I B¿ /@h=P&ÚvÇ#ÍÌÌ=ë/ÏÀ   Aë L @ 7`& ¶¢-A(Õ 
H,A ÅÐ/ÑwCAD` _!PL (Ý :%OE¿%-Ì(Ô @&cBD`XÌ@XÜ` Y#- Y '\ø`\ @ÀX<`Xl`À\È`\dcÀXÍ  ° Y$ØYÀ  CÉEq^ØEøEò $ \ ¸-KX!p`Ã"?Y¸!5 à h`!S Yc* & Y&X  `  P`Ce/øAk !|  Ak 8%  [àzDa`" 3 @* W  À B[ _ ´º @ `(ÆèN}Hà©)© Ó(D  ¤ tB¾_B9(q 4"¾Bà ô Y"[x  F`Y $9  A@ 4` X!|` B}DîÌT$D$DXÂ Ì$ÓO¼3
Çn  6ÆÖ(à@ )¹@3 uÆð${ à CXP3à  ? (()m WØ  ¥k2 ]C\#Ëë("2¡ò®Àu!ÄS\$¿+7Aà/ H a!8 Cl&Á,Ã;ÇO'(*A¿, %@!\Ñ9m DHe**b =#Ô XAD`M4ànè@k`% %k%@y.ÃöÄD{M < YÜà À à Ê Æd N!ô@ Y"ØHñ@  ]'-.Á`c @@à 9À%  à%@à% %\$$À¯'Y¤ï Ü@·ø	Fà(¸ <d"l  è¶e`ÍD$, $@ ¡ _^Â(È  /jÿh íd,k(³ìSVW¡¤P3ÅPEôd£  Ù]àCKÕý 	ZËèt´þÿuþ@U"ÐE}ÆEðÿ~uÏ}Øó¥ $ <~
xS@K@¯Çj=¶ èSÿR , _ , :o]è3ÿ+ @äEEìfvËÿPMäÇU1/  QMÿ6}fÚx(rMðv0Æ 	 ømìuÀ Å|Ph !(Ùÿø}äÿt.3öuàiÎ@Ï ÇEr¼tèFè F )T ÿ #þr×Ï{èÜ¥  Ï	KWÿuðè  SA%j@ÎÁ"    P   ×WPèwBlEjj ¸ K)?#èàÆ CAáb@AbKëc¹jè~!mÈè]@~
Vÿuÿuèÿà}P # `&è¨à~ } b@} 4Ìùm ¡# !#iá#¶ÁáÁ#!íA#îá# è¸¤ }K !#`¨ Öa&(K(Á&@a& P $À©.à©K ª·Å ¡ KUx M@«Môd  Y_^[6ê¢ Q%)
ÆD$ W|$j3 T ¯WÈèbÛÿ%@²T$;ùt
WèÈ»Ùÿ Cé Ô - #Ã L$( +£Ïz&  q³, zIÜ 3.ÂD=z2Àë°%à L 0jo  @< DL$4  @9 m= T$,¶ÊEÏ o,[ `Q`sMOàsMCàsÒë²Q<+DSÙÏ 	­ r`M&Ì¶À:2 	9Qt` ±@CD8Z¶t` ±%:¯ L'÷ .&&s@  P!%cF&@¶ÉT©%¸/ü+GÏ8p @UP`i88í 6@@HT¢ qL$Hài@`4L8î 4@±!ç P 0tø Ò T  !  a?a¢ *D O!¢a.Ò¶Á'ÞT¹ N r @$DÈ 9 
  @7  W#±J VàR  "àRaõ 1s¼aý @ MK`@Gx 2@H A EÈ N!å <àR  àRÉë ÝAÔ(þ@<Àª @) I W) 6 J× VàR  àRà ¥@2¥@ à ¥-.  2  J"&à¥ $ àRà¥@<à ¥@) I W+ò( 6 Jà
¥ , àRà ¥@2¥@ à ¥H0 2@N à¥ 4 àR ÉáK@<à ¥@) IW ÎFJà
¥mVþ"D`¥`¿Á@ À¥Í L(Y¡Gã8M±¾Ci ÀA"ÉtÎèèÓÿÿ_°^YÂHIîTáé û é û¼C 0ÀtÐH*?y¥ ëa@ ó+Ì  * ` Çù ± ÆÂèRn@%(3ô Øè  HF]8`@ Ô jèV  @Ä@ mÀ  È@ XÀ  Ì@ CÀ   Ð@ 7¯ô}ÌÌ  M ì)0S*%ÓöÃt` .^-þ!1O!  J ê\¨NÐ né,NÊZÉèópìB¬ ¬h X¼@Æ !w W`löÃtq  \%"/Ã`d )  d [  N±8-_O% J È.2 E, &v
Ç@  ?¾^ï tó,`K* +` ` oûöÃt _!D Ê¼ YT¿BLöÃt`#FQ¥^[æ ò$ k  ìAWÿ5 }04Ï@ÿP8_À'@??@E;Â)aÑÿÿÀ&à  @/)Lý%F`EÀ~Âº-B D6BâÁ@2³ÿ`Pà K@ ø)à?A Á@à?`ÿ@³a(E­-¨" L$Ez ¢S dND'g$èÄ$"!Ë Å È Í ¡Ì`Ð¡¬`X{°,G¤ -/Ä ¨ w( @* _/¨ :- :Âëà¯YcÃà V!¿3ÒWù¸àÖ{904¨	ÀB=Ù{|ñ+ß	 Áâ3ö9²ì ~(3Éä 	IFó~DôfÖD9ôDüD9ü;`'|Ú@/À!©`Eu!!?'¶W¦Æö  #:"át6`#SÐR½¤ë$ %À ` 8  T#· º¥02Gsî Y!FX| #& Áw;Â~(X3Fù§(Ê÷%`U@E Y ÀC{  LAæc \à	c `c &8? xW¤ Ñã ¡Cz Yø:!"HVm ¯D \cQäH× cÆ<`÷ Æ ÇXë@ 3ín ® 0  By©$è b¬h>%¶ u :@Ws'yÂYDt"3¼ ]Bè,À7~ 09MÁ Áà ÖÈ[(A ^2¾!ol W  GYø$DÒ `_,ey%1X()búd?@C``4' l@+; Y2X0`T'C0 +tà	+   ÇL !  %=à5 @  Yô`à	5 ð`àa 8 +Ô]à	+ Ð`à+ aà+  +^à	W `àW à+	#Á%U  ÁÁ  3ìrà	_ è`à+ ð +Duà	+ @`à+ ô + l`À h`à+ ø +àW ü + üaSàW ø`àW  ¡_à	¯ `à+ $+b9 ¢ `â ,`+(`T"A â P`à_ X +4bà	+ 0`à+ P +´Zà	+ °`à+ Ä+¬c9D6
äqWÒ<ä.ÝÀÕâ 1 Àà
q °àqàBi Èà
i à	iå'MÀÑ Â~½  Ìj¨aFQ! N2ÇAÔ ¤ `(@¹5´ &F-l'êVk ©XÀJcþô Ð XèBK ¸ 8èïfJ Y?%Åÿ<`$@ÿ>Gr%¹  t(Õ·[ Ø%eÂ Xå  f*UåÁàå ÎX%Ý@#| ^%l p± QðTEèBÀ¬6¼¬µ,À+ÈJ ÓàFîJHð)zÒPLNÙ @biYTxZ`]@ù , YÈø 5à 2à üà à  à à à Qr`TjCSYÑXPF] I¨ÆÉ #Ú   .<nà.L@6 8à6 0 6á £ì 2 TIöYAÍa%@f¡K@¡pç	TÄ6®;ÁLÁ
çUA±    )¡Àøo@ ü <Xª  "¢fZ « ÕÄh`×,OXÀ Ç8r!Ò   ¬ ) ]"] Î  ¤<e,=Ö 8 Ç< !@    ] 4  -|aZôf¦  {Y[Aþ`{ð`Xx +Çü @ # Ô !à  \ ã Y Ç @  l @ ¬  cdx@×à© ` ÇD   'àÇH`	@I L 	 kà ½ @  A¤eÀ  µ,X@YY´Yà½ (`X  +Çì @  %à ¹ L @ÕÇ @ S| @À ¼` ¬Z@fÀÈX¨à ¦ P¦´bÀ' °`à+ T + |`Cà+ x`à+ X +à \ /ÔvAà[ Ð`à[ ` +´sà	+ °`à+ d + ,!ZàW (`à+ hà"+ l+4aoEÓµvAC9Wíc4l$>Àf/èw(èò]-Hb^±ÀaC¸ Í#`Í(õÎ 5X@!Y-À+.(ù & _ó =>u<\(æ %N %à D g Ç  ú  Â  Å  Ä ÃòY 
¿#YË  Æ  &YÃ#ÑÀÆÀ$¬@u /äZÁ o @o ×P ( X \  XD`1@ T` X@`P ò  T\þ  w\ý IaY-`>ú [ @\ü(å %ÐcB"*@G W Y-  f ñYûW=à5  Z;«" @% (@Ñ `í\%@ÇtC  ==^È 7 é  á!^ LFÒÅW-DY2J  -@@@T  ;`z ZOA  d}  èq]&ÎèbaÚ|I¹	 k"5|N&a Ã%UOÁG¬ üOüD¶("UPè#j`}<~`¯` :Û J@x~Yd"	 ` 9Çw ¤  Ç  	$4xd#8v@ @  ^ÄÂ
Uìäðì\¡¤[QÄD$X jUWÛ bææz(Eæ z@
æ	z ,  !ÚÆz °3V@ ´  ^Í× Î?¸  \gCÕ] Xå 2ÐG`#$l}39  `ãù è +w@Oà+ `à+ Ô +ÄQàWäQ Ø +Ìà+ìé úÜ + T`Çà+ P Ç5$@ !Õ 	à ì ? \leà? X`àÃ à + µnë `7kîà0 øà0$ à8à\ ü + ôe^à+ ð`à+ ðà+bà	3 ô3Øbð%Oø±ì¢ Ëñ¡-YÁÇ!hz./Î¤   !à{3oà=wá  à\e $àe ò` Ù+ù Àv\Ø ¯ÅÌ5C/XÅÈ`AEYÃÇä!§@ Ç i@ Ç 	AOÇ Çà 	 , 	C ( èÍ/©$ð6|@XÀÇ°$6³GÇ´ 	33AÇ¸	!¹ ¼À	D$4@{fã)D;Ù(L@@ 0`YÀ4 '<¤H6 yæä@  ]8«<&w Ð&$ IþD$   ,@)@ q W O à ( / ð@YÁ  Pà  Ú` @ X @	)`à ! 0@X@@)pà  P@X`@ 9)à  p@X@` ` X @	)   LD !d  D$H@T|$@`8(l$0@`ÁYï` @@í`(Xl8lYï@>í `}` 8@@Ù` !3a ay ar( YÇ       @i)< asX  Áx ( #@$!``\Gà _ @"àW@G   GüÅ $ Ð@|   `W!-@F@¹ a5`Á! dA`a !PYç J, ~å&!M`û T  XdUÌ `3 Dà ¨¤H¶CB~ ¶ 5B~@  Â`=!\ =(á.a *ÁA	 @  p C àb áav b H àTa @\A  #×A  Á``ê dÀ àà g`_AV ? ¤À1`? tÀB&à ² q#S  ? àº `· aÁ@_@ïáÆ !eÉ `Gà _ ¤£ñ f@*bv@GACö ¼ 7!`!d`! Cï ` Ç À¹`Ç XÀaå HÀáµ` Xà# @@}@Åà ,C	@ @`$¡M àá­"!m  ¥ À`¥ hÀá­ Rà     à#< E@$m b ¨ÀT`b xÀàb&0E@b  8eÀD$<{ÆD`j@RB W   W(\!üWöSÍ & HeåD$L ! X9´DX  â 'Æÿ FEï!Á %! XB!)`DÏYÅ\È8@)À#ú\Ä  à@	 (SÐ9É(qXÒ*h\Ñ(Î)" T&UY
ÂYÄYÕ)@>@XE#(ÆÀ³\Â 
Xà
¶Y`D%P) @> Y}%fð$ô@¾  @    A%)` )C´Yè) b ( % È  ä@   ' 6À'`` ¡Ì?@AÜCà«@Â    S@dan %A½ lA¼eX 
 A ¼ ­ P ¦ 1% #Ý 6a­ a¦ á  ^B `[ X P `X Q)0 ÇàS@² F @²@à²)Pà.a\ka_ 9áA 4³ÏB² 0 8 %Û@#-"\@¥b³ )#Ï ÀB­#²`(Í )p`s((¢"Í â Ð!' ð@	 (â"â @>"\ò"X`)°@Y¶@!ò¨3H)¶@)p  a©" ÁBAµ@ T` ' 6À 'à@JPn£^ð"@U `MÜ .ô ä Pè\@.è×%$ SE  9.Õ AÀ "ð$è4_ L$\Æå ^3Ìèzú~ å]®È  ì ; devÈ  Ä5Ch   j@W\vID$ É¶È,6Ø(-Y 0¾JA@ (@à`%@ ðà@5 `ð`à øx|]Ë(Ð _a h`2d  l`m@Z p`Bpà T  t $Í+©!Àð!M\Ú f 2]@"àBx 2 +mK ^ ÷  #Y¼p:|`#\! +a@ h1+ø 3L(  [ÀP M È 5 X)èõMQs=åÄ# @ S  P  RD$!­XÀP PQ 5 D#ö $ ?èòl"    0± $@*PQ`$BèMà$,  ÄP( 	`N$ÿtb
D$@^èO )  W -@@O×£0?è}àOàtÌÌlBèØkà ´!t Ä 	àt "àt333?èàt  ¾Bècàt ° jt À 	àt­N ª 4 ïA» ¨9ò!xhyVáÃ4!4AÉ!ÃÁÂ 8 2+ ãb ;:? Iò(e2  ": Yø¥ !a:?ú Â?ú ò
) Ocze@B2D 4[ ^r!$éØ¬ H ÇÀ ;@  %iN·@ #&X  ÇH@#`"²¾ ¸  GØ`G ÄàGv `a Gq `E#2 È / #|púà+ x Çà !@ Çä`	?à? Ì  7|wà ? Ë ³x`àk è +Äm`ßà À Çð !@ Çô 	à? ì  c\\@?YXVB3[` \Dø # yrY8a#H.Ó Ç @^@`  	À8 ü8lo@\à h`àÈ  ; #s¨à +`ô  Ç !@ à5   -¼!V Àþ`5 ¸`àa  + l`à+ h`à+@k #¼x\à +aî ¸`à+ Wx","4&§\b&§Îèå'þ ÞO`÷P"²¶l %ÎPèøU@èQñúl` c;{ |` µ X î;`7Ò# Âu°T$D$DÂ Ì#Ú&Þ W$çÆö!$#èrV    wÀt~z\Gz °!Ê Î ¹´"öÆ !µ!n 0@ J :èX¡á`PÎ@ Ð !!%ÛC L@ »P  ¿>\NÍ%P<S.ÃöÄD{\ t @#@:YÜ3VÃ;ÇO7ý<8FÀ7b @ D"U Ê$Æ± U!írAé! è³k``d ;T  \$$Àr N + pø	àq ° G Pàq   \X L-ñ.Á`×  d @à 9\À% ,à%@à% `% \-¡#`°à°ÜB !" à á"à° \d\$4àdàdá ² G á   D$8é ¶	=X  _^Â4 Ì  "«4"\W¾@ÏÿúÏÿP"z¨t@0 )	¯ÐÁâÒtk@!SUj RÿP@ÿP@-ØÁ+ÂÑøöÁhDè3ÿí~8ô @@   U  XüÀ U@[	G@þÿÿ;ý|Ú][_^Ã`±`¯ <,o ¯@à	¯3É8  t m¯Ô _¾  	@@È &¯Ñ`Í«  N óàÏ¾@K	 ÈtOS3Û9@;~CÔ RU®  A ÚÀ~ Õ,s
R@YG`(;ø|çCÅCÃ ;`A|Ë][À 73Ò@ F*¾$ ¦ffÁ O B`O@@;Ð|æ
SUVWéèÅþÿ$iðB!`|-jE$<õ   t<LWèÎfÙ ¬tötÈÖfÉt;fÖÁêuíWj PE(èÉC(Õ  L t:ÀB B  B @Bà@,èà @  à@ Jà@0èG@ $4Ût8À A  Èà îà Á4è ?D$ õWPÿu(èìB`Ö  À,è×à   À0èÂ zWSÿu4è±_^][ÂBUìjÿhøRd¡!j Pìt¡¤[ºÅEðSVWPEôd<6"CùÿuÌ 
·@ÿ·c+]Îj ]ÿP(ÈèúæòÿÀÉ ' zE}PËÆEèÜHþÿëÆô 	Î3ÛÿP$ ³ 9"2" S  SNû¦úÿ@wà¹+ûÿ@ C 8;ØrÍu!IVE}jÆE PÇE ` ÇE& T¼E+õ	EÐEÈÇEÈ*¹}ÌEìEÇEü ' PÎè Mèò	 À© Môd  Y_^[Mð3ÍèJì/'5à !O|ÿ4SÙVWì\$,$Äø ; \D$(ÆÉ$Ù 	*ùCW)L$2ù$èüÿ  «@ °»  : }D$0 (  [ UC+8+ÂÀ	 W
%°=T$,"$D­ã} ! `\H@t} ^$|#¼t_ÿÓ$y IT$ Ç@Aï Â ¶ Y`¶ J  `® Á N4 YK)ñ X.@ `)èuÂéx V3ö@` r 	ÿrWGÿ;Èw
`	;Âs?Ç% yHÈøyt0ß+Ø @~Æ)2@xBÂ `AÁ ;ó|ß\$$C;÷ c °`Ä+Æø|Q`
èÁè@4f   ®,] &B ¿` A BÀ BÂÀÁ@Ò ¿@g ¢!; XÑ+Æ@O
I =F ü@$êé !] e@ü u  Q`á á_ X á#c¾é \c  	Ac aaYác Iác T¡c
A` :4ªÈ	JafA3j I¡m ÒámB¦ ¾`Ôm f`á m@é  ¡oØ Ás XAsáx XAxá}XA@Á¬;÷}#@iÀ_!Òb"A åB1ò(À*õ,AÂQÃ   #&C.;@Ã×üÿÿ»xe!D :$3ÛCÊ9`"O pX¤  C t#Ò 	Cÿ2$»Ûx;X}HÉ~(¯Ëë3Ò¡ â 2 # Tá
¡ @á¡C f Þ"ÿ	ÁI£A¬ I¡ Ø! ,B  `ABü W`á%o!! X!á áá	á¼;÷} Z"þcO ,áy ëA>C!$ÆADA/9;aNÅ)1EXå]ÂåNåO@<»	!{ `¾ E¹ ÆÔ$ô//x%Wv/ (vÆaÉà ^%%E ¥t D@. =%üÿ%z%p ¥~ Ç'Y u!ù!Q%wK%Aÿx"I $"E (Ebòu1M ÿ1@$""v Ò" PâÊBÉeBq$, tcD, äÄÅ+-ZêÇ 	eæ  $là ¼ 1¥@Ì!nå`%Äé Z3Ò@d  	â å Æâ(å &Âå FÆå Óe,;× ` « Å"* ÂB U`¢ÿ "@Î#¼b F À`DF% FÆå
 k ²!÷@\`O¥v L¥èé #d q`ÿ  S +ñ gOádç? 1 aDÂçárçÁrÀé hr  	Ar acûár Mãûe *È )$©#MAvå¥ Na|å¥Ð|ÒA   ¯@àAA h`áÂ 2ÁäÁäáä¬;×e!eÿ bAÇb!2BE  %$@#& ( ¥ ;D%kÃe%¥Û ã ÛTO TÎWíò3ÑÐR8 ((\!n vX` `YÀ3çf/ÐvÇ`@   .U  @. I 9 Û =à M ¤àM@@ @M2@ 6 É û0n¸ 6(),\ 
 à Q ¨àQ@@  Q .@ 6 XÙ ¼ 6 §  
 à Q ¬àQ@@  Q .@ 6à £ à 6 £Nè à Q Ð  àQ@@  Q .@ &à £ ä 6 £Vå à QN àQ@@  Q .è A  ¡@ I È`Yä  MXã 2ØàQ@@   6ì`&@ í Ì`Aà Q"_ÜàQ@@   6 ` :2l	XÁ/Åv| 9JÃÇ`      8ÄFÈ W!-2	/Áv/0:v(ËBÖ ¨2ùZÁ"·Âv  ò>fZÈ 
@wì/Ù  %@ X/Ùwð@=à§`=&Ò'A?@1r (  ¿àMÀ#=r   Ð e Ê`
5»   ßYz9 Xù ÂÙÈØ ÀgÀ  Ô vWÉ'©w Ì]  ä Û#§Yp`V6	\($=è}4!CG  Ù 6!) 1 62A%ûG«ºÇÿÿàcà	úÎàJÕàZçàìD¡o	ÄD$@UéO
W½@ j1Ï'çx((Ô   x 	 Ê 	½Nò(¶ ½ SV¾Aù95¤~.)¬Xª?1ÀSV C P@	 jh5Èè¦ïÿF;`-|Ý3öV`g9p~A¤ Q@`/ö(a pèaÎHa	ÀD´ÏF`* &|¿@} 5Ø Sàrã·òÿàZ^X[%£H_]3ÌèIÝ~.  Dá|  á Vµ¡ Î ÍA~]A~W¡	uNS yW¿a	 =a	$OØSW 1 P@	`¤@ÿïÿG;`#|ÝSE63 À 8 ª_[^]@|"ÔÇtj$jQèQÃÿ2@	ÌÌQAA"NÌÁéUþÿ 
` ì!M2ñhÀ	AP¾)ðWè{1",  M&_"~l$(Õ`*S ý`(õ(å(ÝÀt" 2 <h@@    HÁ @! \#A`% `@ T   N dC[´IíY^N"|<é    -@ :`F l`< p X@ dÀ7#à E é `'£u è`\@Ð D 2  H}üH  Mü#ó^#ªL<`$A;@$CÓ $ Â D$T  $' ò@ l(½Ý ÛT$!F$uÿ  ú}@!:a À S@      `?v ¼à P   `9@ ¸à L   ` L  = ´à H   `9e@ °à D   `-/@ ¬à @   
` @  \ ¨à <   	` <   ¤à 8   ` 8     (Í ú 4   ! `! 4   !  !ú| # 0 "ÿ(ýëA= 0 " # à # `# , " # õ`# , " # à # `# ( " # å`#rdÇà # `# $ " # Ý`#>H@# à #|#(Õ    %2ÃT$"æ¼bæÀ `9mJSú|9" @ 8Ë@3"ÓFÖC9`0 8 TbÄ > È /D Û@:ÇH61@ @I@"/Ãv. '&V Ó 4 B Ì : Ð @÷ > Èà>@/Ä>@#@> Ô 0 > Ô 6 Ø  !Z >H@{@@/Æ>@#@> Ö 0 > Ü 6 à A½ > Èà>@/Ç>@#@> × 0 > ä 6 è "@>H z  @}@GH`û@#@> Ñ 0 > ì 6 ð "t|8ÇÈ >!|@A@!A{!´ `& . < ô 4 ø "Ð@< H%@  <@!à <@& . < ü 4  ")#,@< Èà<@!à <   & . <  #@<H
 `  y@!à <@&à<  4  #ä@< Èà<@!à <@& . y  4  $@@< H9/@  y@!à <@& . <  4   $@< Èà<@!à <@& . <&Ã@( $ø@<H@w 1ª@!à <@&à< , 4 0 %T|0ÇÈà < Í!Ú @!B)&\@& .D$ë/yLCk,°!²&¥¬ 	 L - ¦ D(° /&.O@D =ð_×w&>F> 1,¨ > % © P   ¤ ÏCìt WW6)x 
#Ö , ! - 	Éÿ4ÉÏt@D@9&ü` >$T &®(ßF|\$$  (  ,  0  4  8  <  @  D  H LÇÄ ^@ (÷ M@  O¦â6n(Ð Ð(Ê @&GXÌg5_Ë\øà X<7À Èà XÏ !YÀ`¥!? \0l XQËk µ ØpKYD`aYó Ü YWô ¶p`YtGËOA´$W Hg'sXlà \d k,@h\È(ø =¸LB@Yû È]@~YËWü .XkL$h`ü` TH"' l! LAuY , P`! ¢-¾h`XY|H×"ß p |`¼¨0 ! P  T   [Ï4Ä@ã!ãXëÀÀ |@k ¼À x@ ¸À t@ ´ÀB°À @ ¬ÀB7¨À $@ ¤À (@  À ,@ À 0@ À 4@ À 8@ À <@ À @@ À D@ À H@ `¾h¶d` ý L |À P@ xÀCtÀJpÀIlÀ*|B@¾H tAtG¬_þ  ¶_¾L (" 0*_P @ T  X  \  ` D@P *q  p      ¬  À  Ô  ø ! !  !4 !H !\ !p ! ! !¬ !À AÔ´$#Ã*T Î ¼£ !ý " "% "9 "M_¸#] à ,ØÁá  3ÁÁé;ð?é+m *$ô  \jÜ [ÉYb÷XÈ]BÿYÈfnÁ[/ Xcæ ðk+\Dº b8"å G ¦X%ÈÉ z_å : %D&(.¿]Ø/ T ¢D)`Q 8#µ Q á E £< : F(%C \Pg w!\¦¿Yà f@, CD$h Ì(Ü "x`XW X#ç £ Ë  l õ#âD´XÎ(LÌ@ ¬V"»F$wYÄ$wé `+ìlÝ
 Û!;´%Í  LÞÇ :@ J
ÇÈ"<@ Ç¸ &@ JR@ '_^ÄLbM¸   a &(Ç ]Ï-ÝPIH­ïÇ ,T
A9A  #à ¸4îà_¸üíà0¹ApºIµy?(@p@)@)HðêuìQ.ÓD¸hZ=àOhPà Hà @à 8à`DàO<Cà`¤àüBàà à à à $à ,àEàoÈ®à¯Mà`à?`ìàôà¿ äà ìàlá/¨à à ¼à ´à Äà Ìà Ôà ÜàfÇ ""(WÀÇ$`
  ¸ Ç( Ç,à 	 0 	ÁÀ #)NcI"b A AðW+ é\   _ P`1`_ T`
 _B Çu@ Ç\ Ç` 	Áà  Q -«_"Âà
_  ' _  @ cÇ@  Ç @ ÇW©@ Á`4)A \ À 
`¼ ìà ¼  
V3ö3Éþ9'ëÿ$µÌ ¹4Céÿ ©¹D 	 õ`	 L 	 ë@	`l 	 á@	T 	 ×@	`\ 	 Í`	 d 	 Ã`	 t 	 ¹`	 | 	 ¯`	  	 ¥`	  	 `	  	 `	 ¬ 	 `	 ´ 	 }`	 ¼ 	 s`	 Ä 	 i`	 Ì 	 _`	 Ô 	 U`	 Ü 	 K`	 ä 	 A`	 ô 	 7`	 ü 	 -`	Dé#`	  	 `	  	 `	 $ 	 `	 , 	 û!J¹¸4 	 ñ`	 < 	 ç@	E 	 Ý`	 U 	 Ó@	h] 	 É`	 e 	 ¿`	 m 	 µ@	Àu 	 «`	 } 	 ¡@	 	 `	  	 @	p 	 `	Dë|¹È¦ u¹È¶ n¹ ¿ g¹ Ç `¹xÏ Y¹x× R¹Ðß K¹Ðç D¹(ð =¹(ø 
6¹ Eë/¹Ø (¹Ø !¹Ø  ¹0) ¹01 ¹9 ¹AEÆ3ÒÁàÜ¥òÑ6u'@ü DÑB66÷V Àúÿ ¾|Ô ÑÆ ÁÁàFÂ 'LÑ*ýÅØ`Q`FÅ@^þ:qý:RÌ^ÃE O  Y  c  m  w          ©  ³  ½  Ç  Ñ  Û  å  ï  ù      !  +  5  ?  I  S  ]  g  q  {        £  ­  ·  Á  Ë  Ò  Ù  à  ç  î  õ  ü  #F 
        &  -  4  ;  B  I #à  G/'ÕD`.¼,öÄD{°'*2À à ) Vñ¾dtÆ`ÇDc#Í ^é=õ$	 Dÿuè¿øÿÿGÐ^Ã`)øu@ ^Ãøu'õ@EH ^ä/@o @'@o`ÇDson oD¦@o?. Ào@) o@
@ à o@ào'ò¾° +½ @ ^.ÁAzÆ`èä7~`( ±`( !Cà(ÎÆ`èÉA  ¾²`' "@' @'9 S`*`è>  Ð *^éþÿ6¥ì*óÄC  @
¤dETaµ| ®@ @`
òÇs¥ 3¡È 3óY50j¬JO· 0ðcJÃ\5_`Î ØyÙYò <_X5h`= Y*A@|sf`2.Zj `2X5èZ@\Kî$ Ø 8 Êj­@?\`Y¤¦ Ú 8D*ø /j\ `X5(`LX`\`'`@@XÙ« H`*\`ª  {MOzX` YÀ« ø`\0W@«\X`ý.Ý  $ ÍXè`![@%<Y@\ð /Xð`ü\`Ço×,t$4Í ó,_F P 1yÇw1iÐëCi3ßh!{`?/ 
ôº_3  p%L-Ì  W È %È£@ ê 7ÇYî ~@-HlX-ð`3,Å·Àf;Â~(ìë(fÀy 	ëëfnÀl¦\è >,ÅÌ5@OX,ÅÈ`B^  P[¨@® Á`® À!c(Þ 6!tÞYa#\ôaYaÀ\HaM Y ´ Y 2\@`Xø^A;¡ ]._@X8` ]!\a^Y¬d@*!  H`!A@1Y58`hÜX %.\Æ À`7XèaØ!~  ¡` à!k $@B`Ä`(@X$à \b@' øbQCpcu¡!M< Y  `=4 %\à`* äà \à Xxb"\`bBF ¾àW} Wa` 3XLà \8j \a;àK @< c « øa58bÑ \2gC¾A ±ü@ø 6 X XH`R \3 X.ÌdL \G Ld{ \@Y5\@bA\ DOv YcH!}   H , @> Ô> Ï 4aÓX¼`,Áµ+°Wäë!(áâ³ à 4 $Â³ $¢³\%Sa% "_ D@kY(  yÐ9¾ 	Æ E  Ç0@  BèRïY@º@' Ô'  ¶à- æ à U À -à
$¡Äà  wà
1¸a u #!èàCà*1O* øà* ÅÀ( ìà(påS üà*#n@*^|QàÚ¹àÄ$Ã?É`" 5¸"<'à 
 p!¬/Êwuq]Î!Ø$Ö" S  -E WB5 Ä"5¿_e,¢: ÇDð Íä ð ÌäðB Â< ¢<Y  n V¸V"< /& y Ï@ ]Þ(Ó(5Y°dBY8:_bA@Xc\Ð  X¸   ÂbÕ ÇÂÕ%BÕ êâÕåPq@\ïÆ 	»X¼Ç @bº®`  à¶$`ÓY5°5 ®AR  - ,!R,Õ;ËOË(  ;w;Ó RÀOÓR wÈ ;¸*f¼ì`@èr ð & è&ð Y'8lXØ R Âl!EaHG AÄ ) ¦· ¦· Ã+AÆ Úá Æ ÜáÆ@` ÁÆ ¡ÆàÒ U AÓàÑ!Ã8\ð ÙÀÕø,`Õü,,-@`¦!SÆ Õ (A¢'k5($ÍXèàØ'|h  bX-¤Òáü Ôaü Õ @§!<YÀÎ  ÎX!Ú Z ×á
Þh à
¡÷ ç¡÷  ,&ô,Óa÷ Á;Ó!î</a  ú 8`! l`a A¡ hA(áA¤ ë !èÇ~\¬cÌá è ìáè@Zè Y®AÛ!Ï ï!®0áãE x1A#  |¬`A'ã  ¨@úã ¸3`Õ¼,ì`açã  èA"ãã 5¢üAõ ,ã8 T!Þ ã d ãLü5AAÜ# ø`!,6`FDã (Aã\-èðá
_[c
kÚë&(ú xF å#¢¤"è
õW}U#¦tá^YÃÌ(+p  ìè&.h.àº 
'¬ À   @)@@à@ @ð@°@ 3ö1\w R R
XüÿÿØ@h@è@x@ø@@1k4´ 	 : 3 ,@% 7M !x@/ ¹ qç© 
 ò-c1ä%à+   *¤Zí<® òJsò=±Zÿ/ T$( -¦ Ï U@2YÍ ´$¨ È ? t@1*«   Ä 	$P_ ¬$ ò@¼$Ð$À (Á *Ã(Ê 8S`R Â- èa5HT@ V P.à" t$  T$ ,m ¸`R`K ÑT$ ,` L$X ¢ L@À  ` À`,Yñ  Ñ t$h `: @ `ýY÷ t$p5¸)p` 8  ô"g  ã ´$Q!V5È-X%  ê  õ ¬$Ø  S-o@´$È ta] 5@ô,Á 2@ÀÀê 0 @D$x Å =°, %X`L!P{¹ (3£YÃ d \@2YA(ð 
 |``Ao@w` 4Z - DAE XA' 88(ë 0 d`0 Ù -û  a² À`ýY-@\   ÏL$P Sl$H # a t$@ " " v!0 O!¤$°`ú ! !ª !{XÈaD$p4r È | ¢JYxð("  ¢|X¡I Ôu\L$x  a  Î  LA \"´'3a  Õ  Ë  \@¦\@  ¡@)^Ñ)Þ _ 4$à ²(êJÊW-à5!\A¨C t@ø \A`  \!Æ X"dC<f+ Åf#µdV  £ 5Ù £# W Ñ> " ô(Ì W ªYT@uYß @ @  ¡a: ) \@ ¤¢\% XC, Ç  = 8 ¤¢¤!¡à | %ÃCò@2!¿ëE C ¡xÀ} X ÿ5Ê \"G#|#«\ Y\Ú  Tbdxú"ØX YÝ  la9-ÈX@ÕE@ ( 7Y²Y¤w W$Í X!Î`) O"$ÆX³¬aÁ `x=¥"Ù"f"¸ Y¢£YX, ! "© B  Lb  LB BK"î"Auae D`Û!%M"`5"~"C $ LBa >#É ## #!h\`,; 7YÍW FF; NÀ"X `d j@´ Y  1X  \\$(5Ee  L`¡  .  ûX\A «EA ¡ ( þ (@ \A !
 #« @ \a L` Þ D#+Y\a L`Ï(%T \&QX¢1\TA\¡XTA  0d¾$! !"}¡¢ÅYÅW"È¨!à ó DAÝÀØÌ Yd! b \b ¸`-a¬ ¤'!á $¨ ! @ L` ÀáGÍ 6{0 .=0@$!ÄH-wv/¾À\N 'z L&S W4Û\$$*ýt4w/vKÒ8%ëH/p  r` p$?ë5 @Ì8W,9³ n¨Ý)Q)g°B  \2`S Y`XÐ0'$j ÿPl * f  rv 2ÄÀ"Îj $ ^8ªÀ}`# è(à
#@>ÀQÎà ²à @ÀkÌÌ¹¼1Å!,[×Çà1A@ uÎ!g1)¶ Ò!j@	  À 1 î¼uâXVþ!ÿ ôt-\DpE Y XLà \ à X¸`+@#\È'x  «ó[jjo} ëê j;TÁ Ú Yî& \4aYÐ!Ë  È ç ÞàÛØ à "Ãè ó a à$ Ç`M@ à
@O@ à. $b­	ÌÌUìäðì3Bøo!Wö!6¶ÀgCV=Ð`%àh@i@-@ÆÀ>®UÍ 5Ñ`@')Í8­Yú! @0X@X=à@)r a(°@ +X0@	) p@`p©!Ó`\ Æ'd(` Ï + À@+^Ì F  `*@ X b à@ ( *h)ð` @¯ ) JSÊ  s@Á)¡@	Y%°Û{  ÁXÉ   @)©0@ 4)@@	\È` D÷)°`X@K  @	)±Ð@Y`O(À@O\Ï^ cP@>Y`VÀ×^ Y` Az  =B   '" à@å]¡½á¿Kö[¼Â%A  W+à5P 	Èá µ !µÃYãY@hAÕ Ë# `j 	X%P@Y`  ó@®((Å ÿ p`	@ WYË+ Ð@9 MXp`	  %aÅ`k 'X°h !)`? `?ÃXÐa¢@	  @+) !  `M@ àà ! 0 !-R#+)­R ,û ò PÐÚ!È(Ü^Ä( @n6â@B)@PYÚ\æYÖ!Õ °@ 1 .)À@Y . Ð@ ëAñëY)à@Y©`+)©ð A§Az/,f ßÈ$©Zð=Gau&º%¨`hg öBEJbYÀ@-(î 
%ÿ -X`I¼YÎ(ý 
-`9ü )]X=  2\X$³  þ jÝ'&"õlLX`3X=Iö?¶&}A» ; @+ \&MZÍW¾" iY`A@u\` i -`E`" È ¾  Ð  @`1\à 5 æ  %@ 8Hü÷ 
ð.Î ô A´ / j(ß('ì°p Í ^*¨Y=Ða5Yà ] M)ñ\<9e ÍJ Z,ÿ^ç 9AÔ ' GY%@;@A«@@Õ)6 Yi?(.YÀ[@AÞ +G AÜãl   U¥/ PAô/ Û"ée/" ½ase)§(T@$£ â h ` p@)p#û  YB £.)à  `À/ °à  P j&U`X`% #3I)à`(@@%@_BÛ t l) @SÌ $ @@	A  Ndü +$ç) @B)¡`À@Y¡`<#0dÛ ã3 ` F! aZÉ"t É`U/l)` T (,
Y+Ò m;5p:_(!ö*Ç)wY%@XD@Yp.ålðYâ I*Ó #*Ü ì!õ ï A­K§*t X*h!Å fJÖðf!Â:(Å B0¢·#ÇD$0G
£_ + !  c OJ-h&=!ÄBÄ  ,± @s × -s \/÷>Y¸b \"íXçbº Yà "H".  `k 4`²CS^ü "Ë_Ó h/"ÄKÌ)ªA Ú@` < 	$/+- ¢2 ÷Y ñ Ð  #@-b9 bèAº {AÍ :Ó bE 9A× bì à!ãf(  î`aÖ"
 2xC¨ ä!æ![@7 Ð +`Ô Ø` Ü @ ð` -ô ø` ü @ "4¡0 (.â  Ì%*ý  #Ý`ØBeì`ÛBÌÃh¿e W$]C0bþ ãE(%#'³Y CQ ( qPC<(ê" 0@)  j 'Y@@XÄ°@NX5`)`% Ç%FY-À`(ð@Yæ  0@X-`#i@(àF ^!Ëð@J) ` iÆ)¡P` `$YÝ\Å^(o `üYÑ\(Ë`@")p@Y` ¹¹   á `@á hCA 0@Ôa @ X±Á-°@¡YÐ`"-à@a   `â ` @t ßÀG +9)°`/ õH" Ð@)à@(ðá > p@C)À`¡> ð` `$á;  )@Y ` ¹¹0 á;@ "Å?©l 
È,3WÉ 
 -|¨=`D>@|Ø$$ X  }  9Æ` +º p@$,,<XÕ-Üðìj (6Õ y<ú Ñùà /ì
l `Y¸=ó  %| Y,|$lô \[Ð#= X m4?@}àu \^ìà Êìà-F Yþà s$=@WH S.FA6à   ' T¡? R G`Xx`,Á·ÀÀ÷ ÷WÉà÷à\È(Ì °65 kà)? e Ò (2 è`@!u¡ 2 ÂáPàààÍÌÌD$(>*ÀtO¦l$²ë {a{YØ/æÔ&j%E* @ý!'Yü-b n ê7Íà íà`ïàÀñà ôàöààøà@ûeÙYÿÿÿëß ä.màß T8ÇÀß 	à ß ´ 9@ßàõà mÀ ÷à  àÀ%@ùà%`úà  ¹¡>À8  *Oà À¹à	ß l9àß¤à ßà ß D 9@ßpäà mÀçà áåÀ%  áåÀ°ðà8Àóà ÐáÒÀ8 à!+'àß2 ¨è  ¾@
  b¬1ùëRèRË Ë ÒËÀ.# ÀbÖàYCFìà. C  5I T'Ó ëG£teYH#,¹_". qPD	I¤	Á~$ò Êä#Yµ¦H ó  á T¼d^ ] ,ÃdjÁ+XWÒë!(Óäçå[¦Ì ø$0 Ñá+ Ü àSM$,   $1! + R¸è
"  rµ  L3/Ár ·¤+ » $@ /2ôë $h à & a\Ø+& X@&  !Þà & P @& @+zà M 1@&S8à &_@\¤+à &
Ç@|Âu?ÇÓ{ æ  àÜ   Nl$4%	.ÅöÄDº&ß(Ý Q ª@ ÞPAü!û V -°76¾
 A;ÁO%,Í G(*fÄ,  ;td ¡Ê[ÀO?d,Å Ø;ÆOÆ^ I Ëá À X&`H@ (I  @ ,&<$`T`\â 8 Á T C"X>\Ë¢¥Xâ ¢© Y SXË bÆ  â7¹ %¹X%­,Äâ¡ Ô §µ÷â¡  ò ´ ìg´~H^ê Ç @asx àÆe K    ]hcVGÇ.ÂÝ ¦ D C @ ºAÒ u Aß ' 5,Â;ÂOH\C@, @Í ¬ éay@ÑÅYê!
é/!Þ ~¯w(  ]+3AÁÁ#Û© Y Y  K Xè`¤M Âä(M¡E!=#%"ÁB]æ@ ]ÞS(iÓ()Ó B-V`Pe` X´àäöL¡ü$f NÖÆø{ !¸àÆ²!·áÉ  Ø$ ¤(­d\p 
 G¬*DèJ# % @£%E·%0 7 AXÌàÌ Áwé»%ÀAçã!ê
? ³/bµ!>%&*G ` `q °àBqài Èà
i à	ibxëá­ÀÙK}Ñ Ì g6  T« 
 -W,O4#w 3 A! ¡X+µXÐì4+YD-	Çv  ìQ8? ¡ ],!pr@ àw à@w Y%¤`Mm tà	m Ô#½à:áÀa xàa»ù ÚìùYAA _#Ø| _è¬, ß Lá ßYAÌc7B!× ¡×Øk) Y 1 XæG­ãO¸`QÁÍ-Éâ íH@µ ày&Ñå )lÍnà*uàe  à\e $àeã'µ¡?ã µ( cè+=Ëç aßã¿¥c¿ x%m =ã¿ ¤"ÕXÈbùâ7ÝÆ 7G @} àm ¨àBme $à
eeà=Óe (à
e¥ÿä«ã"µ7µ , cèO-âáÛ@ !C§ <k>8ð@ <  .©h \ 6 Æñ	ßàG 0 .à
 1àÀ `âoøS+à ()TY 
 >¤'´ ~'cDàJ B ¤W+" Y@ £@R§ /B ÇòYÌÜh¬ ðbUT>à 3à0äNñÐòT¡YD'>¡ "!h\1Y  Js Y,Q8Æ>3¾*Ý/
v.äÂ.,SJ²{¹À!) uÇBü  ï@ë Â@*ÔîuÀª` 
SVWù@Dÿ+{ {@'Øt$Q `$VÿR7@Ï ·ü"Y 5:ÃtO 
 Ï`B0t+ nÀø@ÿ·@Ç &E × ÿP4_^[Â@Bà@ à à  ÇàD) "Õà" ø 5à@@ à! ¡JIË®%`0	-t"I( "æ9Y>H l!ä g Ü"7 ° ­màqæ&,Z<0w ¨GÒØ g¿@nI± ïà ï@XX óã$çéEGsYÐ:± wì \j/@  ôLXÈ  à	à&üà d¡  Ã`ÿHÙàÿ `à	}Ç (àÿóàÿ Ä'­ Ü @ #àÿ ìlìä¦à(ÿ àÿ À ÿGñàÿ Pà<ÿ àÿ´@ï@} ¨wàÿÀ`}Bà5ÿ àÿ ° `ÿ©Ð!W\.¤oCêvqY_Bþ\<>që/-   v`D\ 4¡D»¡IX±#ø0 %j®è  áîr à >$ÅÌ5£#X$ÅÈ`P`(o ±,X-D3[ y âpk_P`¡ðDF#rñÇÓ(Ø F =s 2(` Y X$à \à X `^Yh>@" ðgVG¶RV\ì`@XH5? \4¿À#< \@ \'¾ôà ÖÊÅ/I ]!äà(¤­	ÌÌSÑUVWº#+º"6 t¹4D¾<]D¿ìDë:¹¸D hu   )à* 41Ô¾ä ¿ ë¹`@; @; À ; P U ½'%G³ »K5O  =³NÂ;ÅOÅáËgx 0´\ 2 X@ Ö ×ó /s5 ÃlÀÊ (L5áð 8û	:YH  }-ÌzJ ]/hà1nÆ × $ @È 4 Ü d· ~&j4À	ÍOÍ(ãø	à»"D`»  7 à ÕrX$  \"9D`   X@ Þ  ß@W Ú% Ùà Õ ÛàÕ 3YÂé ÂétY_^] Gô\Ã[ò { Évÿ Ì ñ§Y  \.+ ]3 øáRá5â j` "  Ð+zìà(H¨  ºi²WÉ"« #bà !  0 ð @  @P@@` f"é:ZØ@¨@è@¸@ø@È@:,7 0 ) @"êu¡!®@/ 
ZÒZÉòXÒò"¿ #·(ÁòL$X?<Á(ò T$H @	D$P(Þ 4$ Ú(î 5¨+É - (Ã \$ Â(ã %ÀR@¬$!- $ )á ¤$À#´` À  @CY° 58`  9(Ä Ï`T Ç 
%=4 $p  $xd$ (æ " ÷ % %¬ t$h(ó 5 8Q ¤$ `v$@Í%U`´$8   57YÆ  Î .d$`(â $0`!@ | (@"$°QD$  A) $ ¨ ( #Yð!& $K %PW@è!vY0%U` à T%q @ -   3 Ø  ( H` Ç  è (@µÈ9i`6 ¸ ~ )`_ YAT$P ( L$`  Í 'L$(` h $K(Ó p&W`# 0#s $- ê -LL$8 ß  >Âb8Y5à Ù 3$ð j'$  Î  X`A Ï L$@ @$` ` P@3 H`¶  ø ÂA"$` °ÀAi 3 F¼¡ YbÙ`& `" 7  (¼$h  -À$L$@ (k`2 hÀYn@Y   4 H `åL$pà  p3JAm	  : x Bu u$  P ?á Èa³ 3    n Áp xà  Q LA¿ 0  0 Ô aÂà   z/%`DÈ % YD
 $Ð ß $¸`>  `\$8 ,@$ @ÕX"x(û`+ °`+á ¼$  (ùà (` ú@ X0¸ 8|$@ ¼$_ |dZ=(V $¼$ÀA| =¾ ;  *AÈà  A5à "&à ¼$0 `#à 8 |ajÀG¼$@ ¼Ánà H <A=Ð!r ¼$V =£ð h& ¼Áöà@ ¡à  0à¢  ÁAà- Ø`r È^  à ¼Àø}¡IÀ$z  )d¦ ¢£F Ú øa±Y$è`*&	 Y$Õ    7 DaÒ@`	A@+S`% ¨·D$@à 8 ð8 ¤`;$ø (Â@ ¢%$\ Y Df²@/¬ Z"¸`Z   :`Fßøa`$X} (Ï$À5 YÁ$È O ¦» X  à% Y¡% - Ð ½ ¨ ,æ ²    ¤Á Ä /ÀHXLFT µ %· %­ X%,Le¡ Y¡ (È   { Fh`Ý F?`  j& F  LBv "e Eá à# eå`@& LAÚ Ý@µY¥ÓYàepX´¡v\e¬  õ Ü¦f ­Y5¡I a@ X'Ù E (¬3Og÷ !HÁ  x`. EV  5 I H? 2 ó é DÈ`D½`¤ XDD $z $l >[ J ,< +  ü ë 5Ý Ï Â X)#Æ!Yý  c²  |C C` %b x Câ`) m Cs`aà ;P ;bXH0 s £S \&ý"Ü&YÂ ! ð`.à X)ãX58gï"
Cg`CB   Y C \(9´ e Y"#^á a £
 t@ø)ç aóX$(Ã Ñ  Y×   YÂ6 YÐK$µYØ`;d9 8.î  Ó ^Ô(à  ¡\ `!YåfÒ6æL5(Ü jm \@Y%0c@F XHêp`ú(Ð`_  X \À³ Õ  ¬a EL L`Vhd÷YÈe \*³7%T\ ï¤ \ Ô \)¡! YK¯ À  lË ! ¢3À×èLÖe})aJ ^"«è¡SI	A|@F =À ¡M% ! ð ¥faä*z+ Àe@ ª S9ø  L$"Ì Y¤ü,,³¢­`V ¤ ÂYè A« DhJxa,$Ø`e,§ È¤$Ð`(!q Y¥Ä(ý,å \1&èaJ&)áYÉ \+ \$ë`C \+±-haÜ Ä \Bì b \C d«Á÷ ^ ° ~$#y Ú\``K ² Y¡5\$£4 ä¨l F ä ¨l \"M 0µà	J L¤Æ,Ôà D $Õ Y¡`@ L¤á£Ê ä« wB$. ¤ ¦\L$!Ç æ ¡X\DB7 S &P >$ LN `>Xc Bü ¤ + \è1;  ÖYDCr#L#êD¿o è"¤M""`­ý"·&Ê"J ®)ÐWà5 c /ì  ¡Ï -$#£!_@IXâì ` %H($ÿY¡"O /&  \Å2 \DÞ  b ¡øÀ Y§m |Gd!¢`i 5I AX¡Ú  P ¢ H¡ã ¢ ¡ã ¢ ¨ ¢ æ #{XTAæ!±+À Aã DBg z¡à DBd  Âa TAá V¢^ ¡á ^\á#<"]YTAß =¢Z ¢T .N&X? ¾ Â0â (B"0è Ö 1CXcCÌñYÃ;Ê!çøÂH ¼©ÈYø +f%ÈÀ+Ù)â@ X0«dG&ñ°",ç  ½ .*@.%2% !  ¬Yç`- 6Î §û ¤§ûe! ¦ÍQn XE2 Ì&"k <à¥8lë\%% ¼; @î% *%øeÊ!ªÚ ¤ªú!ì àY%é  Ì\¤©µ . àe9 .é ­ªÅ¤$¶ #Î 5é ¿§H ¤©¿ #à È h (`V©ª º Q® -ê -·- ½@- ©Á`,;#õ ÉZ ©Ï ¤¡a   © ¤¡c àX%ÐlÁYdb&NbHXä @ ¤Ì¡A YF© á¢T{`T¬ ]¤
 ¤¢<\dD ¡ dA ä 5£÷ ¤Ãî ¤£å Ü Aá ¨á    _A{3¼ ~H) dD uà"Ló*&  p# +<Y5§ dD%$»¤å ¤¤% ¬6­B ðY¤«O  xk ´Â} ´Äç ´Â}´$t #k ¬+ ´¢k ¢b ´Å ´¤ù\tDó 'U L+ ´Â ´¢| >s m ¢i ´¢a [ + >¥ ´¢m m R ¢m ´Å2t$%* à à) ? G+'(ô! ¤­ÁÂu#2V!qÉ#2 [ i \$M m -m  vX%£ X¯¸ !¡*³Á ¦%$­¢¤ªmX%Ó %7 .ÀDõ X ÃYóW.C±%³  ;K8 ;K@0FÄXøÌìÑº7[ S:tbÚg.¹DDÇD$T E¾ô¾`)E¿¤ßD»´IE½x)=éAh¹p¦`  - Ï`09 -Ðï - à@- ¤ -ë]Àa+¹ 3 ¬@3 L 3 \@3 ü@3   .½Ð ë)¹ÈØ( ^ x  Ç ^  T¿( »L %½ü 81L Í-P¨ZêYÕ - »úþzC fn¹ Ð Eû ¹»Bû Áû	(Ôú0 Lû ]½¼A³ ³û@Í B:
ûù:ú*>(ëà	Á è -û è Û» ,ûÀàû Áû(ÜàÛ Ø û5%å  =BYî; ï;] Å{]Á+.(Ìë!7D ¡w È , Û[ Û[{|$;=t$!: @!:Èá:Øàá S á^W wX½w Ãá(_á=O%. ù =CÃ(\Ï!W=Àá:Ðàu =Ï£R ÆáØ#D}w  # X@ ¡Ô3L@8¡ 
 /þZã!S _ Á>¥Ôà¨cP(Ó à« ^à¬ @¬D@Ñ@­T ][ 1Cüà8¬.ÜöÄDz Ø@« %£ãüÄÃ=s t%» ìHè+Tý¿ ð  ! °@ u` À  Ð   à 0  f½¿Oï= H}@X@@h@¨@x@¸` 7 0 ) @"Ý¿©øo `Zí!ÑHpIÂXíZÀ(/Â,R@:Ù n#ð(å&Í%¸+`(Ý ! g]`-Y  ( @%ý`M/!D @o=1FpåYh`H)2»+×(R$ j! S  `S6õa|X
VS2 LHêYX L * j0"A >`^Y  'wï1Ö  Ø% `¡ºI X    DSÚ1k.àÞJ` HA $ i! Ñ ÐÀ'«  à I<Ð+/Y! ¼« ò/ H  D\¹`( ( D_%`U oI   Ø] à("ÀÀ' èà m> « ðà p`2x!« Y»« ! øà! è` t%àK i~ j `j,0!H I ½ °!ê Ê0 'YØ`x M¿ I  ÈD$`-X@í`HD$Xa°Yz ? Â@P]@% ?M` ð>/ > bf"Í ¢9 ",i)ÄËYYýJ4=Èxó 3ª34Ñ4	8@«`BÓ  DLO2¤/² 0Ô*[-Yî ¶ .0} .1XèaJ 2I N b¶  DB X3ù 	5ª RAî`Aã  aØ`AÍ`A´`JL`A 5aX*Ó \2[!!QáUCQÜ ^=+|L&  ïY¿YÝ(7r!< ÷ ] '@Êkvþ Y#å=¸¯BÁ!= mB`°þUÒ0Z)0Y=ØYA® _@"Ý(Ç 7WE^ébc%¨\@53 (/L Y²Ùt$x(7U M-ô@º1J$QY¨ A7.Bd6 \6£Aæ \SbçD@U6 e» Y`ë ¸%§ b \¸¡EÙ \ ¡d`Ó7.A3Î@l 9p(Ù(é X`Ì-`$  {\\AÈg DBc Y¡ ! â"w \ ì ! # !t \´|Yx`NXÀ  Û 0@Û3íA Ñ)Õ !¤X¬dÓ èbþ4È¯º6»$`£Y-5"³OL l@ "Ù   "Ñ   $Ï   BÊ l@X\- Y<mYì  % X"oFy¥\ë 2H`Yé \à (0A®\P`5S*WAÁ Ga $ ýOW¯êWî!©Ø` lB ÍdwY db$û?#"® ( ;!]`a\S!"»XÉ $ôY-°`!X-dä@9X¦½ æ \S ¤@¹Xù @#\¬dyWþ  ¹H`q ¤e ¬¤T GF C ¤Ö6O§YÀX-± !Ë"{#û"/"EÂ»Y¬¤| Y¥ B^ DAß B` ¤Ù $® Aî» !ðYÙ`	!î Aî ä4¹ Xä¹!$ X"á ½ è!½x(µÆq OM  @"³ÄIÃìP(Ø@NqZÒ ü5@gë X$e#ð'r!YÊ(C¥%ð#c$¸YÈfûYÚ à"(   é(û "?Y=(`#( (-.h± "K 5À<"Ã XBÈ"?@f=f«B©Cä%n  ;!H #O X"? d5@	-¾q"ÝsY%øß@&Tò X"Ô` DB X/Ä(< X ÇW"Eï ^%2 O o!¦Y¸ Â<U À$o "hdEY``ÙYfD))"Y  w*³`, L%n 
@i(   D@7 "0 TC/\p8` #A Y1ïQf DA X,ÿÀ] \1> 8 ´ A*À#2Z!BQ¢à  5CWQz ò`±@`j&# W@Q JÜ \!Å `@	@  @^ l@@` lAß%2$Æ iD À
\Ï(ù(ÈWü V ú`¹Hk&å ! ßà \`V Þ @ \`½\$8ò\Ùò\Ùò
 \ÙWÉòX  òX`,;òYÚWÜ P ÄPÃÌ `u  ì@  h  º    D°  ! p@À@@Ð@@à@ @ð fD R` R
Hýÿÿ@X@@h@¨@x@¸` 7 0 ) @"êu¡óøo   @p`±< ZÛ  
 © !ÛZÀZA$ð@ä(Ã!ÃZö!D$`(æZí(Ð L$  Ó  æ 4$òt@%$ø d(þ =¨UE(Ñ 
Ñ(Í  ¼$è ! T$0 6È`E!$°`w Ï & Ê D$ ¬$  \$( L$8(Î ! Z =D$8 d$x(ù $ø!S úò\Ç ¼$¸ ?(û =ÀX@3 Y ` ¼$ø  ú(Ö è|$X W |`}T$ (@äx[@:Y=XT@  H  ` 5 p T$P @Z`'$ d(Õ ;øY  p`ÿY¨`q Y } (B_  Ô`@5 Y`V 5 ( 5(ê(Æ  `ÿXï « a±  W`+$P +  è ,(ó ø`¸Y5s o À  $ a1XÅ èa@@XÁ¢$x`IT$BÀXÁ  L``S@2YT$x  !  `3 < 0 Æ  Áj ëXD$ ` H` P  a( È§!Ø     à ×@$YÄ`    ]   8 Ý(à` 0#® H áÐ¸`¤$ W ¾d$(ÛY%B­ !$ `e ¿ 8D$h(D"¤$¨`ÚXÚ @ b° 8°] 8 /$h`& Y¡áXÐaé  p`|!-BÜ$X'a<  `? Y!oýYpc`bà `Y(â`6 xT d@T¡©# ¤$8!#@?(\@?\AxYñ M @`ÁÊ* % 5 -!" ã  |CeY% _@scØ^@
D#ht¤$ØL dAÖY% c!³ " ¡þ w * `ñY$@ *  ` J ` J!&Y°bY%¢j =@F`=ò 5 8 5aY%B  ¡õ¼$ `B8 ] ! `0 9$à 9 H £8 Y¢ ""Ô ÈaI + P=#ÀÐ &Ò T @ö@"¬XÂ d¬ æ $i Bÿâö È!{Y £|Y!ÀH!% @`Ãö µ FP`Dôà3\ø` ¨`¸%2 và N¼$(` = °cà $HÀ#­à ¸À ¾ÀY-á õ À £×À! O ÈÀo X%¦=\ m _ I 8 \¡Q ¦ . W "S$Ð!M _ Å^áJt £gà8 8a Y  Y"å I ("k(áõÁõ È`       Â *"6 í Ãùe5"¢ áÚY¢+ DCn ;, ;£à; Da¿@8 
A|À6ÂCÀ/ ´  ÀþG[ aðbC  @à ß$Þ @ å HÂ[¡ â d¤$Hà9$¨`` < PÀ<R Y£ï\è d$a	Xl@Ü\¬¢¢X¬Ã l@Ö F lBk  ÝÈ$£ h  ¼Å¾ DhggGîH4@!R \ (a7@ vG  ¼¥ÛX´gW`  X- Ãv`dwX¼Åõ -X=¸XaE¬$Ø`þ¬Áó õ H¼$à |`¢BA ò ~B´$`a)+#L {@X5\!( ` DIYØe^@>@&  h ¢ °hèeÝ Xg Ðb Èf xYê  %)%P \adYD$'Ò  @Y 	!n _ p _ *á h·!©; 8)· \¡YÂ ";ÁÈ à È¨; ¡k#G>ç §bG §, §\%Y@«`XC®  xÀ§ *À"#I  {3$è`^ < < DB_ \$ÅÀ$À`  ©x`ç\¿æ !1SÀ) J)ìÂÝ#>`» $  Wa £@®     ¦@  À  À*  °À¡18"(È`U¡ LA  k D.!@8`0@'(" Y¢åà * © 0dÉÀ3X!g])ñcYÏ`ä T bî!)+¡ &¥9 & N Á"6Y((D Kæ`1 @  b± )  )`UY "!  ] À¢ @TD$"Ê %  À%¤Ý b+À# ¨À#¤Ç`#a ] »¢
 ¤@aL$ a C$¸ LBRXLlNÀ; DÀ| ¸*"O LDÒ : F Cm DBS o. 7À 7 ão â B l"`ô6"%&XÞYd@}   Í¥ C  %â¦"È A KW`K  |@Xø¢.W \t° BªÈ G Hª| à ;] Y£8  × Q à à X§§ Z p IDà ¢·àú " Gåà	 +O +§À Aà  +à  +q Gá \ OàF kW{ j pbà YMÏà êPà a¦]MTÀ 9à 1¥1 Â  J 1¤9  ÐXe`þ ñ ä K`¡ é@d D¹  ¤  ) ) ) X¥  N Dr !F ÛiA> TFã AA C@ !¤F!@! ¢Ú ÂÚ ÂÚ ÂÚ #T©ÅM|  ´ÁR 5f! £ï ¬Â« ,(ï¤¢å G" Y-· Y/ù! ¬¡ `/ ¼¥tYåò^'N$Ë)x $*@hZ N¬J(Ù#~:-B a%
=%$Ø(ß  Ç`Ag`M ËJa\$EC£º 1$þYÝ "© g\1ç *(LªX`3 X¤ûX²%l  g :@>  ØAn.»80oï YQø |e2 ý  ¬Æ¬ ë +á  l`A!%Í )ÉôYî 2¾XÈnE@lAÛ%v ¯"T  \Qà `( ka \&ü ñi Y¢¥&bhfÉ4Tv «¬Y´/Ss%g~XÐ(ü ° ¤¥G$$(Â $0p=hA D`å "-!?  Kç` Y¡Y0@`Oô Y§/$ZÉ( M àr DB²  @&q(ð $ðÕ ¢( \¢ÞYô  ðR`6C=aT 6 -T Àtm$è @ñ®ó Yqg½ $ X`kYB%3) $ða ´ Å ¨½ -¡ L@³1AZi* ÇGì(â`cP =  @ Yp¡ \$= B $!^\Å(2  C§z¢+} ( Ó0Yðt6"ÞGÌPý Yl¶+HP)\´ _NDY=8cÁL\c¼!©b \!C"'´!B  X#î#9¡þaö v¢  ÁPm3 \,!C¤ £Y\ñ  á H ðkY5oXØrèA» X"Â( ½±x6Ò uÿBêYÞ !ÂayY YUµC®A+#GCõ\Ù ( ¬³5\-¶5û!æ_#Ûè\Ø ) ¢x#¤ "a  Ë3+Ú0×W , Âp \d$8¢ D~ d°  ¤Ì½Y¤UXØ($ !a#ç\Ë   D@ £éG`kK hiò#Ûê ÒÙ%¶ãí Ì «9 ¬ÂA< å= DÅ%dá!aB? Á7áø¬ p(á`4= \£; UE CÑ¦ 0. bÀ$RK(!¨!e Pae Yª9 $ Ã!û0z&/ XÓg Ltnº³ë H~$ $ ² HPXJ ' È© D@6B  ø`l%À `/"CYb Pd®@  bÃ ¥Y/ yYß` Ðg \@g  àZ H!2 Wæ q" X#Yà"è XÃ&Òé =â Y jX=B¯` Ð V  \c$Øàt °` »¡b à Ä±R À Y  Ø`3à Q ààQ ¸` Q¡FD:Y¤ <  `6"ÛN@c 3"l¡Ò DBZ Bf% G Ydo, £V'Ò#ûY!¾ Xa¾ PU ± RÀ­à ¨À*\5 b¡H!#Ö Â³& Ü%E( Z &Äó &0 I@ + è`!R#C+ &+ $\5Øeg  `ÀÌ Fªla	`¬£Ç4$îal < hÀ<ú=`#::³ç  Ø $p4 Å5 É  ðà· Y  x/¡J Y$ \IÉf¿$! £;@"  àÃÛ$À£3 J;ÿ (#GÁ} $ Tã X$'@(XØÏ¡ )  )¢» NlA{à#)BG|ØÒ$øñE` 5  À¢¬Ð²`8   eÚ B2   2£È@$¨ `n 0 , Ä à	= °) à p a@:à gÓx [ À 1 o 0s  ¸à  `&ë®  Èà  °Y-{ Z!
  à (S  Ð 1 C Df Âh ` §¤ J\³B`J    A% .¤ .   `à& h9ý*ÏYèÜ`Ù \  C.Y¸Åç Ø La# é @^ l`X«Zü#+^" D lb  à> ©ú!3eü -J¢  N&Ì©RHAÀGÀA èA DS#²ù#Û X` H` P"¬ §ë!S ð2 ¼² YãÃ\¡M@ó D`ÙhrÀ> (`n Y´} S »"¾&ü1ë   # k ¬Ï ,5 ±¶«d   F"6©K@ Äì£ dÄAÊa° <K @fDz 3ªýÓ} La`Ð ?Iló´À0 Pb¹ 0B& - 8". 8  ê fYlA  }³ 3 % {«ÃD l@ <N* %`!Ø¥Â b E (\¸}W`y  Y " àl K< k©; ö!sié()hÁ! øaðX®Þ ó*gH¥ aH Èz³K"S\ hQ ?²÷ \>ñ Yj s ¸@=¶­   x¾ Y¥F"©°8 ¦o Ôkú yå Xc &Ú \)m » » Y¢Ý ®àg¼Ô Dæ §Õ d\è]_¡@fò  YgD*½!4s ä\`"+Å " `<\0c[ Zh¡KFÁ 8@ | AX LI Ë °À # \b ) ¦TÁKÁM¨¶X¸Ä}FI!¯ ª pKà.­¢øÀÀB ¯F	 à| À`ïÀ| % È"6 )b` ½Âq ` · Ð%Â"qÙO?À §Ë@-ëY×  >.£\­\ PÌ \ ±   ¥Ä @ fG \¢!Ù à¥ °!ü è` \¯@ê2³Y=1%+ ( ¨dx1¤ '¢Î ¥4À0$N#þ² ¥XªZÀ<=% ¡Dô  êk 3 ª< ¤È ' #¤q  i r  `×@Ê 0  i XF¯ L3\Wà5"-û(I´p¯BL¶%d3 EÖ&x @ B ­ X¦\@,¥ '` j\Ð,Ú ±p+ÊAi].ÿ 8  £    Y»º,¢¥'* X \¢Y! Xå#I¯±¥
'»à¥  daG ¶, , , , , «#7 0 ë ¥0Ò¢( Àà ~Aã Ðeg G~ ~ Û  (j!S X£3!j q= X£"@e= ý= \¥=!å= = X¥="å= Xå=ê¥= ¤À ¾h ¥JÀ ¬-R2´"| Ú Â. Db.QÊ ÅHA~pÂ b !Bà!å=\Pf )¥5G5s\ Å1 e  Èw¦Ó \¢!Âå1`: TÓ N¥0$õhB@E Áý@ß X3È .¤ô B2ô(1YlA 2 ð` X¡Þ( H`!· à` Dð!¸ è`@ PY(dé X.kÔY :%¤ ê C¤¾ ¤µ u £  \M¤ \D{ ¤{d{mÚ 0fç$,@5(÷ á qC(ï 58+Þ(ç 
@.- ràY%±ÝÀ*1­\°lY5d¤@rK\À+5 c l k­Ó ] M ¬](^ / Y `3  RÊñVA#æ=h`îXø J `æ J DR!~   ¦ Y¯XXú ¼ ÑD L`& ¤aé a6 # = wYæ  \b@«YÐ`uù\· ¡.cg'¤6N x 1AG@1 @o!l DCXÑ  ? \W«` Ø,'£auÂ"v ïZA"  )à# \ #!W(3 X6pmlXÛ U¦¦Yì Â¡YÔ 5-ÎºwÖD$ "°bï \­Bv  §( ex X <)² 8 '`,;!é 1 \!_fU9
78à
ÉÆ 9 3É´&X`b¡a³Á` ·²/ +CöÀ |³`/À"D é]Y8g¡`ü Ù%có èj' ß X¡ßT!P±÷@N F ±@ Þ ÀT Xâ T¡E!´ J±à1à ±`  D-®B°cY0cù \¡ Y!s`È PcP °¶ GS ¼¢q#µ¢ ° XÇ"° â aö \:AÊ(b¹Y8 Dn~@p!@$ <YpnÝ!à
$9 0 X"/@x!¤!Ðd;Ds@«@SCy@eP¡¤^ Ô à !@Y XBÆ \F@·)ÎYá &§I DbÊ §? $lâÙ@O ¥°â@OÀ+ Â C+  el £°+`1 hl(@ XÌÏ¤À@¢ JÏÞµ0@) |Q!øù! (j)@U@M 4¯ f!Ñ Ø@ D±qYtZ;W5¦o± &o%«`' G 0Ç§º´±ª% p 8 È j'D  ¶U+a%gX #   X&  8gc   ` [ X  ¾Á ©¼eö X³4+ày . H  ¶a X& \+Â-¥Ñ LAÎ XOe L@W[@ ±þ ±¶: ×s Ê§ ·| m h \¾
 +E   "b i` iV 4»  E? L@¡ \(±#d \ ÎLH2\\l@ò WN Wò »!9 Xàù"¹ Y!!É ÀÃ£Ò 3_,·@s \ÒêNz!ð 07 5]à $À:é `  t@y @q t@q  ` X(¤ \ªÅ Y7Ãb¦t@2 ¨|"Ì @Yþ `	 BZ ¼¢µ\|a ¼ÂD ¼Â |`q |`q |`q |`qá 9gçú$ y D@[!¬#ä8 s Â ¢{X8 @ 0`@Xø`P /@³+T\ø  ¼ä & bÂ@¨¸  Z`@@ 3 aX k ÀíA'{@o >­S Â« Â«$¢«Å±$ír ÏR Â½ Â½ù. `Â Ï4 Ï @`Ïà `Ëö + hà (àWÊ + pà+à  x` m H`z +  Pà  X% Y¡ . `fÑ  h(ÕÀ J p £mà xao) O 6 xÀ6IÀ m à ; pT £¦£!#?(!bË" 0aK@æX÷]#1`#` ` O¢lAX´$¥ ¯¥ ´¢c@`~  h` À F u  ! uX5U§ ç!n  !ff$ ¡^   0  ¨ ¡N M ¸bà  + 8À¤å ð  ´£ ¹ ±W Â  @`9 # H` Ô ÕeÔG9ç5 ¨'5°p  Æq  Ç @!-Ä@'CÃÌà 0 ìÀ  C'º +WÉ  ! @@@P@ @`@°@p@À fD R Dv
üÿÿØ@¨@è@¸@ø@È@ý@0 7 0 ) @"êu¡ó±@    Zö 
\ 
!!@X ZÀ(î ¡ "½ ¢GYîZÛxÅl$KÎZÒ(!ã?á ( %X/IAZä  e·<è ü"òð %Õ 8f Â  dXp%è`&j*Z ?ID»ô ¸_-(`:&³ !°7$(#e&º¬boç a'XKp"®`"(!¯  ±CJmLº C´( ÃYhjî J¬ @@Á(ø/n# ªë*¯/WF q&a)®A(*¦ ·@.·Y%ÀjC.h(+²¤Ë¦ ¡ kÐ(Ö -0À-'bà!QY(ÓàC
`sYAj Ð  m n H`n  nz ± a¶ Þ/,`F "ßYxa Ü Ð  ×*,  `#0(o1 p,Ê{)YÀa¯Ykg &y WD¦(ù  «Xú()òY jT$AGØ øÀ|!ü  %0`Z@R!Ô¡* pé ¥ZT³  CÒ  ¢.nû"· ¡Ü A,``*!Õ,à2zÝÀS` DA@­ é   4B| ³çÉ©YÈ b@  Dhí>V!!+>B¸Àím,  4 ¬  Qí AP ø g¢¡Ú  <p;  È`»-ËC$h`¦%ä,pF(-²Y@7 XÚL co  .¨n6"áF(î G \c É5¡­ p± A¶Ì(ã %"  D@YÈ`n"ïXX¤$@W !y`® i¤fY{ 1!$Y%D(Az ³ÁÄ> 2×!S* d °a"AÞY-¡ È Ø`27 ¸`XpbðXlDE %  h3 £6"©   ) ¬Ä¨pû : p : ÊN ­ Xkæ(à` à`iYâ A ¢'$À + d`¤$`w¤ ÄY¤Á¦%Øà !o  èà Tà B  B¥^d² «©#Ï,i  0  ("  (@   ÈyeË ` $EZ $bKY% !b ³ È`9 Bà " ¤±% \!/ %\ÀE ª F   hà ¨ ±  IH`EBà3V 3EHà dA.àJ` Aàª G¡ àD µB+â®
    x\xbS r d S\ À"È ¨ \`"!	  Ða{#   à§ GÐ@ä }³ä"Í££ 	 PN&j D$¹Î$Ú!¹ n X¥ 3Ù d£à H	@  `¾L$  ¬fC -ðÅ±¨ Y5¢j ¬¹D r È&,  ³.ì X` ¨#Ð #Ï(#Y%à YLáhíY¤Ò Ì%`
 \  aK é@- $[j"­ s$F|%nE O c X¯q =` =N´°y,Ca¤ (FE`â 4 YÁ(ù!} æBg%8c &± @°](½ x $ `³A"Á Àav à °a*'; ¾¤½aD Y'» " ¸ "  Â8 à çEÅ ÞA J¤³`J B¯ YÁÅW´'!¸YÖ@t E< 6 ÀÀy¢-à y ¥) ¯ Y Y @U`å  0aÆYû`! ÈÀUÁ Y¢½Sç'ÇK HJl$" \ÕJ OX¼£-åHÓ1 C |D¼ !« + * X+2&û:Á(Yhi¦ &]!§' DD*Ã Â  Ð`¿ $¡ ?°|2³¢;)Å Yª4K# / ªÂ# Y ý `"B@Wäê%3YÈ( "@  Ø ¤% Ø¿ ­ðI«A`\DA$¾  ~W $ ö   !à \à!"ªÉøjPB=à à `%SKï3Å Y \È ½$X $j³$!     S \"*#Ç+ð  ã È(¡ p 7  \a6ÃAø ø x ÉJÀ Ê Qs)`£ LCô' @²   b¢ ½Y0cÚÄ°YÆ(é`( (²ä ¥"X  è DB@!D¡o |dh³ Ê(/ 0w ·ª Y¤©\5öÊ '» 3 `d ¹ ¤fx`¹\¤©4!È K (!' ¤©Ã\5~ #_X%`XAj % S ð`\àS  a@ÌAL*ú¼Ü1à 8 8 °aO5ÚJ3(Ù`V O 5 9\à ~ £ K"
  øÀÀ3  m½ C o` .!A£¿¥¯ Ê6 s(Y!At 3yà3À* * 8`Í *øY0a/ ^ ð Û` Y ^$@ 8` ¨ J%B ¨1` ø` 9 `Yæ 9 É Y P`øÀ9   jÇ 0à À4à 3¸ Ê"Aj +Á ¶
`¾YPmþ!k@,e ! (@Ç!¨¾ÀJ L@¾ + 1@³% À%£- ?Ð @? 6aI 0 0` 0 _4ÀVP Õyà6  6gG (1 È bÙ   Q`à + (D$# Z z% ccH @Ë$Ø± D ©   r . Ç]¢Ìà?£4 L@? 6@k` @q$0àB ÀeÞ k (` . Ì % DA~Àk (GÚ" LDnX>< $ ±\LEë  k# 1 h`H ¦ QÀnQ " 1 ©  !ð \¢ ?6 ? f&-"ØS¿`$m =¦6 ¤g pÏ ! ;ü 5 Xþ&¥m@c5 Y¥ DV ®T HîY eDÉ fë ¶àÆà nÏ Y¤I r¼@ ¬ É  X Z Èam R Ð` , ¤Kèà	 ØÀ+Ó +KZ`+àJE  DJo j5à àÀQv ( èà \üú ©à+ºà  + á 1IH   ¨ÈÀ ;% TàH~¾ÁT  ´)àGÓàÑgÿ«}XÈi {´À wI@àq  0Õ"ä\à j ¦  ø`¡ µ ¤  @À® ¥ ®Ã ®¿ Z ¿ ¿XÈk]A Ë@c( ² Õ ù Þ#¡° ¥õY¼eG  ´¥5@]Y¬å 0ý1; Y( @9¡<¡Í ¥Îá9ñY¤^F)$7^¡=m ! ´¶U+\ øÖ~ÒtYå  Õ + X4U,) 0  ¤£N-ã è`3 \)ü(¯¥Ó 0`¢­¢!ÂE@ A ÃÞ ÃÞ ÃÞ ÃÞ `RXÞ X*y*'® Y65 3m v­duy ^È¦ø®í%Pb!{&wf%ü   Y@âIz XO+-@t-ºÆ@eÆ&U@`xWYXlY\EÂY- §<YÚ / 2  glX¢  ð`è+iô/o P`" o¯ð \` ê B F0" 1 (®
(@$À ½@´¿à# Ù  È§Jê 1( 1%Y5K ×Ø \dó ©ÃXTbE éYÐ~§º(ú  a  ø T ¡§[WYVLI g9 -Ò> - a Â 4 Á' D`0 Íå$ -ÐP ¸Òí ø.v. ^ Y¬ÖXàÇ%ËXÉà¦ X+ý _d7L ¡t Çà à v ¡Q@. Y´9Yãfä¡[(á  %QCo!ú Èaú óç DCh  w{#úRÑ(ì  |B">*E (  ¸G Å!Ë ' Y¢ñ\UY-IyiÅ #§úL$0akYbèYl`\ Ï #$0k "N#(*C5#¡   	#,AEõ$1Y.à ( `É # À B hÀ Pc YhÍ I  Yê&~ ²H:`%Y=Hfb®ª¯)¤C¸ û`% °e1!H$· Y!9(è` Àdý ß "@ \¤« Y  ¢Qn7 Y³¼Y5Ä×}õb!ì-;#% ÐÆ%x?±ÄVå!"!\ Ð ¨ñhxX YB-»$À!C Ù h C @ Y9v Yàú ð` ¹ §.úÔY5ÕXÇz 5«÷zÈ \A L@dSX 	  	!² XC]#Çb!- x g~`f] f o"ø=lS¬&ED õ "p WYô  [ õ K \ a%¨¡x r+Ù¢ø`ý&<BB Y<aB7H>k ( õØa=¢L¢ð`RÀ ) À`RX]B A] [ ¡&íeú&ÝD. \!r « \¥« X!µ ¢àc¢ X\æ|!W5× ¸R!] /!6®12¬1ð ` h&o!ç ¸b_p 0°DÏ!+§¥e\-5 L¯H!Mm*#x ZGÜ²B Y ua \%=!h /,$E Y¥^T©Eb Ä $À È§ä ¥q\¥ r p  åv ¦ÈJ;@ZN X`  ,#zà{V¡lRã  ¥R` DBÃYÁ!VAÚ!P!y 0`]%)#q ï *!oY-'ñ(ç - ×%b6X"d( IY Ý!3$~@¦($ÿY@L ³k  @#§ í/RRÆ"ýY5ñ @ D{ ´ ê  (0ë¦b 1C3  0`  D«  & Y½ÈY- )E ýF* 0uo ÅÔ") @Â ¢; Y¥1  Àb,   P` 8`#öYP(í Oû 4¡Ñ=5$¾':#éXB¨kÃ&2  7@4=bÙ tg 5ÊXÐrh K `* ½EM@3 h  aÌ Yà« à« pÀ« @ H « e_"Ô `( X¹
 Y ( ¡|G`£%@ëÀQ H`Q"ª"¡[ ´à ¦oY5÷ ­ °À® ï sP`Þ _" X ÷ $x  IÀu 8 uÀ @  Î ­ #wÓ Ó Ê Ê Ê _LWg< A Ã%Á X =¸lî$ÿÕ \ XÛÇ ¼¬ñ"S! *¼ J #à<»á ¼­ <à 3»ó=Ø`xXó *õ!p Àa þ Ç HbÄ Ä £] "9@"a>Û +¦z¡\=@`pã= Ha\!k(( 8\- V è`D#G P£{EÿF·C±*¾  "$X" £@#  `À  hà Ñ / pÀ£ Âà 3 _¢þ !É À@9a7Å*	  xÀP¢çE@:¯¯ ! À!Ya* !éûG¿ ¤ ¥± DF - ÀG§à¦n"1¡·¢\ *V «"Y¢s$ò")+ 4§è H XÌæÆ  * `Á'ÐXV Y*pYï    È K  hà :@2!T   3(.ÞL2Yñ ¡) YÝ¦À, ¾k ¨u´$  :  ´¤À (p@as Ý @ Yó÷ ¨ 3)ø$°  - DT1Yð&Å`L xLe±AÂ ) ¸ ) = `=Y-àuù  À  E å ú ? µ  à	N È 2l Y¢PbE ;! Ð " `D+w"z'(g@ R àR(IÚ ø  Ø :Ø ] Y¦ÒHt,\ à  Tà°©Y5#h%Õ y5GYt@  è`3AYò " ­á %# %@@ÁA@ a!²j5M 0@ë-0 Da'¬$ð`b Ý@`k D@X  ø`à P YÖ¤CfÀ) &R ) Da1HÁ1   ¢«N(Ä* _. ÆcÃ\¹Ú D@£  ì 3@*f Æ¼ æ ¼b`çp§ LAL -D - `Q W ÀÄ_o]!!y 8ùªBfà à£`B Ô$H.$H+* T :)x4 ÜÉ!FB l  + Æ®¶aj7G h / n< ¦%4 @ XãN[  @ 1 H@°ì$P =À= Õ±· }k`4$É  ( GXm AÌ¡û Ab A\ YL`Ö0¿!Î KÀ2 xì D å ÆáR  Ò 6À èÀ6^ 6 Èg* YªÄ 0\¢S ñ YåB ¦EV¹Oc,%{ a!é@¿ K  X`³ æ@6`?­!! à@1Ã4& AÀ °aÛ`/ mÀ|C©à| ¨ | 8À|s ¼¿,KU Xaç [e \ ò"ýK¡ ¹& §K 0 ÿ ``%ã  c"¤\` é\`"KL ¹ \!` TJµ  «àJ¨@ hywX `C·X j¢ KJ9 - ë ~® Eà ¡Ø	 Öô b( ù¢\èh  Q^ I Xd[ \-CÐ3!!Ì\`% Z "\ ` \(` n Ö?KW ¢¨XxÁs *L * Øbu   e{ Y£  ``ð Q aß4g#Ø \Ò, ©, ññ\è]UW × RPÓWf) îH_ ¸1@" ©  `uY4! ª$p`¥  h  ÂÚ DDµ \©r HW ,u jTYÐü°aTXÐ` 1HK < Y  X¢ö }Âí ah âíHD : y K2\°mù 2ö \®
 zH  2 ¬ àa-!Xbö 2ç \ðëÊà2¦ Xá©JàTÃS è¡ ðr$ ~Å zàG¹ Yª ÓGd  Â w[ÀÐ#àª\ c²!ù@ ÌÐYB&ò @  §E  qã\@`5 Ì@$±)n H| 5C  å ¥· ¯ YÂåtY5â\'&rOÉ eg 6K#$(S %( aP RNW  < 6ä)N  " ´£dà g ®F n b  `4 =C(/ /R /Ã Y¸ . Pc¶ " àc%°ÄXNSWà5)Ë`qâGW æ`/aó â ¤Â Ù`I\%b ®W!(ã ¤$!ü! à!" ~&   L ¯`' dC³ $ $ß#^k´X%ï ! !{ \Ã ¤£ï ££ dCø X¦}X%¶ <KÎ XÆ %ý"Yæ9( Â ' Áhj¤ (¦ªÆ7 à`\à2`%Q4 Æ{ N,ò =¦ ¦:UÿÀ)Çhc:[B} #º -Ú \73 Õ øb+\(Ä5ð "   û XÐÜ ¦ë@b XÐ¹ ¦ó ° X°¨ Ï¦ó©XÚ º \§X%Hg* G !À  X§  ç  e 3  Xç {Õ Y¯® X<s 2 CL`  (; ¦Ú${&Ú Xå0t àÞ` XæÚÀz`J)ùD6 ¤¦Ü Ê¦ÜB¦Ü$EXÃ(ß / £6"s$  h åö·  H@Û Y 6`G6Àa`)ã2 {æí\ØaR :¦åæå \Ãd £[ Xæåã D Æå8ð Kå Xæå Xæå 2 ¤åàîåàè¦åà2å \á´à!Ã ÃÝFª váàC¦áCý¦ÝC¿ Lmî [ô Ù XÆÙ%H`!7¦ÙC«Ù ¤æÙ XæÙ@S$Ä 0  ¤¦Ù QÙ Ù Ù Ù 2,D@2c¹   a ¦: ¤f W%¦¡h&"2d$f%eP ]k/ý-6ùh8 (WÙ¨u,½2e,Ûh\he½%µF,ÇÇn0> -@Àu,ÿ&V Â % =ïY8 Y¢ø1Õ:¶úT$;p aÛ ±·¾@%xÀ, 5çYXÐù@.qÙ\Ð)¹rà 0 ' °( `]/`! Ø BpG ¶ö YT`)¢ í ÜA¦`T KÏ1® ²YÐaD è 
 1 YÌj ¹> >Aîyu\Î   -*Ó$^Yxcá(
üXl@Â¾ E g XïÌ@bá - BW$ P` ¬Ù¯ì 1íO 5\ j0\À!9 ®#(Ë % L@E@+XÒ / Dc)§^U*Y\Q9$¡Ã`.!ü =!4ÀÀ\%°`^"WòK $  Ü Y# ABX `A Y§@I #à`å \¿îà? @à ,A¨ $bÄ3Á C$Îñ ñ!Jk VA XbÝà#«A(áaº YµÞ X)0*AiAÏ ÀÙI*&¥Yî È($³@ X;¯9±  	 ¡ê·À$£X¸WA! bÒ A D9G`ü Áp(?\ë·Ë°@/D` å ul$B¢!Y¨f ¥!¸`iD¥á  aúYø».ë\ø`B Y Ù`8 $H 8% 8º0±&ì-º@<A#9¢¸ §¡`. DG¥\`,; MYÎb¨·D$ Ç iºa L@Y0i'`bÀ^AA ¶`+ Q·`Q`6 a  Ã¸c
an*#· ¶¦!¤YÒAA  .H]A ¶!\bÐ@5ç "+ç W Y£õA@ Á Y¢4Bü é¶a DD@^È§o¹ R@A ä»òHn°$È3XG"Õ' P¶`PG}@NBp Yp`B@<`$" c´ Xã´aí-C¤ k> @¨rÓ YX DsoD!àw¥Ð Â  @$ w@¡nCÙ ^ 0Ü à^` ð:ÀÁ$©Ô ©Í Í"ºIÍ ©Å  H p ÎÙÉµÁAðb\¡(µ` ` 1µj` XdÍ 1µP`  g 1Ô àc@ `$pnR"Þ xyP`O@! S´`S^ Ôs     Õ¾@"5µjòû ]  i>¨§  k¼è° ph° ëË![ ý a `M"äKÝ »­ ­! p ¢ø'ð û÷  mi # # 8x°L¥þ Z'Î æ ­p ød% ¾² ² ² \ía   à` \í¡ª ½ µ \­ª ·@æ g ­ xaëCí`a&@¦Ñ%@ !-À XDä Âæ Lx­ ¸¤¤$£ ¤á.h! `   ´¼Ú\´¡´*³6¼$¸aù DC1>×¹ ´¡Õ S£R ¸p í#X=©, taï ¤ÙK  è (E U« ´ äXd@\\@8!«c\|r t@÷\d@*N a3 \¥R)&àX5> u   Z È#ë ( °b1Û a
 )5Ì" @  þ ¥É!X\@ ¿ $``C"_ \±.\ \(_XJ E;""½ X` X Æ Ý £ ©@,Vb_v# d@ 8 / ¤  A ``A \£=\æ  ´£a \¡ 7% ô) "  c7X5 4$ 8 ta tAkX´ÁI ´¡( \5è ( ¶!î@¶ ´  \¡NY´$`a« @Y x¹!ò@p ´¢w ¢V ´¢6 V"ª b h  ´à `  b¸ t` ´ÁE tà h`A©  D  >$»  \#Âl â `DAª YË@×!"Ì±@î ¢ AXpî$`J Y²´cò$¸aå   (ñ À  ð T à     @S X ð`> m ø ($4 § ò"è P /`H ,²° å2c 4å ; 8ÀOåD  4å M% råV! ÈWIÍ ec` Ð`¡BEy` ù + A&
¼"úG$Ø`8* ¨aM\ð(CÉ'JÁÖ °` *¦¬BÜ¡l ¸àlàk a /Àk à`k X b ^ P è`@r ÀN$È`@ào@ 4 Ð` U ÎÌ Q)d  Ø `À \ !'   à   Úa­2J @oI¯ `%@ è   `²àn   `~Ar v ðG ÂÆ+ N a 4D£`0@ « ø`4¢$ä«@u(§ (aÔY¼$@Ë@9Y$$ `@Ë!;"[ ` "[C` C(!E!$G»  `) ´µÄá T ´£- - "-  `Ü ` `X5`¡á  dC JC 8C £C´$Øf(  à`X5®2' X8» [á ®  `%\ó! 9YÓ  ð  áº±A &  @\ò "Bc!  0`"¥ haY  ´$`m Ø Ø ®Ø Ø /X5; \$ç  R ´³4 5³4±x*Ð  Æ   Ç0@   ÄÀ ÃÌ` VñÿP|$ Ðót$ >Ê	óYñóvt,E Æ D$ FëÇF J   6 *ú Ò 1l$  F <Yé $
D$ó\èÃ A=GõW¿ÿ ë (D$ZÈ3ÉWÀóZ"éLÍC,ÁÀHÁ=@)O#¥$Â`t TÂ0y\Ôë ø@Z\ð  RN LZÉ@O(ÙRqØfn fæÀ - ØcúNh^Ø /f/!¬AäXÔv z_ÿÿÿ ßr`vN _fZÂNóYt!	 íZ Wv B Â "ÈóXÍ!÷ È>fó,ÀF@~3À[ + \ "N!	@¾-ö \@< Aü  D`äÂ@ Q@Á`|Ð à/DÆÀDÂø /DÆ^Â Aà %P,ì
QdWÛV(ë¾!ü fÀ(J\\J Ì,"ÆÀ /ù)Jü  R YÒ ù!àvÇBü ; 3ÓB\B@4 
  ÉZÁ` Ç#@ËB`B ! Ê@E  $àE$@% EdB¤ % Ñ %J %à J k  $ k KhB¨ %ÊÂ"]XéîCÿÿÿ/ë^vC$ ¾Æ! Ã"í @g¢çÀ á tÁ"<á l!  \ Bá lB@4 
àÄápB ¼átB %áxB %áD)T ¾ÆQ ARÅá

ìSVWù@ (èÍ_ Ç 
@ [ÇQ¼  C¹CóÇDaåCÇHà 	 Là 	 P 	ØåÇTà 	 X@	 í@ \@	 õ@	_)ÍÌ2FÇPJB O $ ÍÌ`  4 	+V PQ¸NEÇF 9´  , rùt  < 	?5ÞBÇÐ 	@ ÇÔà 	 Øà 	 Üà 	@'¡VÜ ;@'	O¨@ Çäà 'O¡@ Çìà @'í| m@'	 ðà  ôà 	IO@ Çü "O`y"HlEZ `9@@7$ÇF. ¼ÆF¾!AYÙAÇIJÂu<Çt QKY 	YB@ Ç| @ ÇHnØÝA_ &@	)LM  ` % Ie G Gs ] GûÇ@@KBÇ¸þÿ%?Ç¼à 	 Àà 	 Äà 	 È`	@1 Ìà 	 Ðà 	 Ôà 	 Üà 	 à 	@Ýéu! %T3Þ  ¸$` (` ,` 0` 4`Cë  =8` < ÇG¾   ¬Ì`LaÇYNµþ7ÇÄ 0b7Dì S  ¹  Ç !ÇDr |$%"D  3Ò ñAfBAýQ%Î ÂeÌYÄ!¿$Pè%yý&3	nÎÄ[ÉÙ  Ì%û%nÀÀþ`,eù  ,øxýÿØ@ìÄïÆÙÃú| zAÇ6í  {x$ê_^[ÄÃ T@äº_	 "<YD"L$ÉÇA òC !5Ìfz\¬kBiYBó ©ð ã@Bq '`3 @ D Ç`W  !<à9 ¡A 9%`6± Çe  pA$%À`sX% S!Ä·Àf;Â~%%È£ë(fÀy(ãëA à M$ÅÌ5£ 4X$ÅÈ`-A%(Õ %¨ j@x@ ó^Q  â Ï ¡B -N@>Y  L`YÂ + B(@+,S+  + ( @f+H r@3À_Ì`3 4p ¦È E0ó])"B¾ ; @¨ G%ðX`,Áá á Ëá È 7 Á ¡Y e Î e Càe $à	e `e &!qx!)áo Ø Q Àc Àc  c Þ c C|!f iAf-ôbR©CçSì&=#%T$WL$Éã!¥VQñ;ÈOð)·@¿@  ¿Dê  ~tÆA` ÇADì è$T$ë\Adÿu9WÉA º"Â f#?(@ @)@Ð)HðêuìQa@7 GFð	ëApøu	  ; ëøu $2 L$Ç`¤    ö~ÿt$ÏVR  è< @"@P+ÎÖ Ý  ë  á ÿÿÿ^j  ' /ÿ·@ü èHÝþÿ_#ÚÂ ÌUìäðìG	¡¤P3Ä$GEVu!=ÁàMP Z	,ÁÀ
 j Q#ù$t$,D$0 <èK~ $¿D®DÓ "Ì]# D+  á ã^Ð(ÚÆÛ *Õt 6ÁæO V  RDß Ý0Ö <3ö9u& ) ørx 	$ÀüÂ;Èw@$ @Á;ÂsW %%  yHÈø@} ¶)D$@& .Æ"àJT+á		BÂ ÀA`IÁ ;ð|Ì V	;ð   +Æ!¹|n  		èÁè@4fáÿ ü "É#Ù X#  BJn@ A  @B # A  @BjM( @Áèu¬ m;ð}+Ñ+Æ ) $º`& \K @$ ç Ý !:@!N !¨ AU ;a£þÿÿ   ¡°tSÛF`a£ -ë¿@Á»A© ª!R(D$Pµ 2 H@V $ L!»)D$`F" Y> @$)~{á´$Ð C ¹C5+t$HC+@ðD0ðGwïJ` + ð ++ðà?#[à/_À/CÉà/Càß ó!ë l e@|8Aa 	 1BrAd# 4`	 h 	 8`	 p 	@í!nL9D$A¾$< Dñ¡Z"ÏDt!0ë  "{ 	½ Ë È  ( =ÇÀ	 Ç  !0 <!åAmPL!§ D @ -kp#ÚB| 8 !<! ,!¤gd BhÈÁù3ÈÀÁùáÈÆJháI# Áa!fÚ °À  ( hÆÉh	L$PH  cÀA ëN] · -@Zàr0AçWÂ@3.CY(ÂÆÃ
Æó Wð(ùÆÚõ0£ù riíXù(7ä`Î(æ@9 *Æó@zYå#
(l$`
j @@YÎ@"J"@#ÌÆÌÿYÐ  ,	ÆÈ¥XÌ(ç ÆçUXçÆñr ¼!AÆâð\òÆæWö7¶ P'õ`/YÌ\$- B #@ Y l$	L$X@L@_Î]È,ÑÉ,ÉoÁ*èÆíNLoÂ@rðD$p@@\å)@à x(L$pf~!>ÁfsØ.L·  À   Ù@ X@È(Ó@ ,  ,LÐ ÈÆÐÝÆØ!B°YÔXÓ"à(Ê'Õ Ïk Y 	 E
 J ÐJ° Fò\Ê! "¨`, ð,! R 0 B", k°Ò\A  (g" ZPYÐÜ{ BIø &Y @XÚYØ  ð@Ç X 	BÀLÙ`¡^ ËÁ^Á$YÓB: B:AnÁLi@Wõ( #$b^oxjo ! ÐAÆÒN@	A W_w@@\Ú) a [j@U@!!^ À!Ø$?Ø,#!z !zLá@ Å
Ð(éÆé!ÉYë0(Yè 0(å(ýÆåU\üXåÆÿ [ Ïd ( ad 0A 0 eB`(Ø  Hí(È&] Ù Ì'f"AÂÈ*ÂÂTÈ\ Z`  D5&/ Û Bd(' Æ  Ã A&#LWÀó_ !JT`[Yñ`Yá ,*ÖXô$Í 8$43[H$v 4 i r U Þ"$5J@Æð!× G$  Á#4À bY°@
JC£\ÙaêB@AçZ@ C BPBÆòKmz xÁSÎ@Á6XÉYÆA-(ÆÆÆ¯ °Æö s!Î Á@    Ð!v J"O=à x ©9é%7 8%fÌú$¾wBI ¾!r&Y?  p ¢V?C*  E %$tÈXÑ1íué! <@ãÂXÂE®! ,!-$x$j#, bB/ @f `Bp 
@  ]MZ @!eä!T <1ã  !eaûù'·D$ÂFv
D$@D$ 0û;D)9  øÿÿ¦tj¾& 9·@~] A T$(#Ù@A!IÒ ê ¿ÿt$$ÂFQÂPè_~FêF ß8@1 E 4)÷ v;`\)ÏèÕgýÿÀu vÀ~	+E`$R¸_^3Ìè÷¾} å]Â Òÿìd5òèÅþÿ@ ;5¼Áº$  j)'òKF õ+ +$ #!8GöQ !CI@  	  Q$ AD@C¡` (@ H@'³` ,@ L@)qPïQ#pAP@,h`)BéAT@ @WQ8@ X@ @ `) <@ \@   ¦C#C%L-Ö(Ä(/2Yd` ì 
8-%(ô 
-` ü ;D$ ,   5T` *¼` `Y=X`    èL$d`'A`/ ì":  ÔÀ   ÈÀ   ¤À+`C ¨À $  PÀ (  àÀ#`2 `À$ö D³ ·ä #{ º"Ê ^`¬$Y<!` 4`5Yl -` 8  ÜÀ# WY\À @  ÐÀ D  ÌÀ H  hÀ L  xÀ$`T üÀ T  øÀ X   `©Y%`!^\@& Ç@ø Ü v© Ç 
  @N"?O 2 @B'D$"«@"Î 
"¡@  
"@h`
"@l`
"@p`
"y@t`
 G@x`
 G@|`
 GG`C}D$Bÿ D`BøÀBñ NC` 8@E­ÝD$Bã À)C~¤ÀCx G.`7Cq¬ÀCj _ó`CcÈÀC\ K`CUÔÀCNØ`H@ñ hA" hA pAxÇEP@ Çy@	Gû@ Ç´@  Ç¼ @ ÇK@ ÇÄ@  4+   T]Ü  Çà 	 ä @   ì Çè ìô2£ À¼ ¶@A @"|'l^Á  HAD HA; @#.@ @`,¹B `4#`AK @!@mÆ9@"y@à HK¡ û ' L++)BrÇM;$ EV%AoýÿÿÄdñ.$T$¨ )"Æ8¨O¸   ­&è DRC2d ]CÀ ,*Ã +:MÂ Áà,k È4r ò¬ H Gø$=#¿ ^ H­ ²¥ÌorÅ  \Hcg ] èI@'$c@' ²w/  ` Y)]Ë +´&9@ °`¼f`3 k Yrý ¸` Y!_  +Ttà	+ P`à+   +<sà	+ 8`à+  +Ô]à	+ Ð`à+  + ãà¯ ãà ¯  + l`Çà+ h`à+  +á À+ uà	¯ ¸`àWL8 {4và	+ 0`à+ d W ¤aKà¯  `à+ h + ô`à+ ð`à+ l +_à	 `à+ à+Ç !  Cù 	à?   ,bà (`àk  +áË  +Âé C\$wMDG"ÕYÄ%=7TÒSlÆö #Ù#-ft- ·ö ÓõÇ ÊõÇ\D,Â@e@ HÇ x , `ÆQ1!!Ùý@3 4  3 X0à \ à !`à3?Î  nÁn%¨<C
'¬!>$ ¸d1\ð`láØà \´à X°` ~a +}@J*àît
 y Dõë!Q  7Y® ? %y&!© YàI p!
á@á3 Ìp`fY  ,÷ 
 
@j  Å J·àË ¨ä"ø 4 à`F¡ Ä'RYô`JØFX ½%,!q , j¤Au ·â1rdP@ÇY|`iX``xht`KÌ +6à )¼ à
ÎX`áP øe Ñ& Àrú\Ð JÅ¹Õ ¸e\ \ `LàlÂ#¦/ê%PT*¹Q$:åV(ë¾!éï(J\JÜ ¸Alg°.4)J+ÓR YÒZÂf/àvÇBj(ÓBB@1"hYÉZÁ` Ç@X ËB B/ÿ¬$Bä %ÿ¬(Bè %ÊÂ"°Xéî( F4^/ë^vTëAdÆAa?£¯è- ÌX?jÿhòíd¡  PQV¡¤XFÅPEôd£  ñuðÇFHÔ ÇFv_9ÇE`ïp! èò!ÏP  Æa@ Ç(J  CÇd@ ¿Çl 	 ÿÇ$@èÝ%`K 0 &@/DèÀÀ ¨àHBè£ fÇ "     Ç @ 1Ç Çà 	  	)Ð T  à ð  N P`ÇT`@	 Xà 	 \à 	 ` 	 >   
  0 @ èI F  ÆEüè:`°i`è+`P`è !ZBÆ!\`Môd } Y^å]á°/\=qèl&@l@]èa`
@wèV`
AèK 
Ç! ^@H ö!  DtjVèXª} ÄÆ^æ¹  * `­ o ü ¯ o ñ`
`o æ`
`o Û 
0 `¨t"¨uVÿ^ ehð+ÊVè¾¶:ày :8ÿ t39t@Ù¨*ÄÃÙ TØ%°óEØD  &=  %$` =@é àO¨ IØ@U >ÈÉØ% à q'«àOì!$5È'e\B7$óæÀÁèòXÅ^fZ  YbúZ$¦.I-å-k-ÊXÌ+sò^&|Y¬  - ò 
   v@ Ø`YÁèQ~E3 |/ä W$j ÏW(ß è " = %T¯ @EË dP ë  -Kù ò`zYL W âFî5Ê(ò %X x  0\4XÅ  \ì(Ö  R t  Ó&T+Â Y$4OW ©@TFi,z-ÌXê  AX  &'`hYé À`* !? A?!ÑW-@C! l$ Üa t$@¡ÂèCa \! Z(©YÛ a  Á=¾ î@  TA ñ Ñ(ã  %A
5¼   =Ax  &!Á  ñ¡$ X' Y @ ö5) Q  5hXæ!ø(!& \H¥ ç ,÷W5QYï ÇW5¼Ê5ØË0S F d!b)@g TQö`'@$ Æ`$ Þ  P  8ý@ Ô`F Ý` Å  ` `2Jà
: p @:@7 Ë@: x) ^ÄÃÙì,"¿· L E!iL$âÅ ÁaW"Á!¡¸ Á!tp!Ùè¬ a d ÓWÛZ '3 #a ! Y%B­ !$ ÷  5A!´ Ø! ãk!5BÀ%T [!q a@"^t Ç ,=ìf@Y¢Û ú! è`G \AÁ"Ã|Q Y"@7"L1+(}ZÉ  Â¢w l$ Wî ä $àä ` èÇÿ}!(l ?@ä Í Å`Ù  Í Í d @É" Y@ Æ'ã O#ö Y¢"2\JX X@ Ã!« ®"<gãTb X 5 X$0Pcµ#Ò#T#`!ö# X  "YÕ  Ò`èÔþ`c«(ø!' é D t`)>B( g#»@¡3 \£#P a c X< TD¦ Y#<!D  	ñW8ãÆWÅ("è$2YïW=6 Y`& X! ûXÜCD Y<bªC! (PBz j4|`$@! Å@"ô)` BÏ@
 Þ` Æ  p `:4à : Ç` ß   @:@7ã
  øâê¥°$FD$,â	  B	½ýaj"]$Ï p  DV"	b ö Y=â ëWÉÑ¤aå  È î !#D¬ ña¡Y=P c!D!­ XBç  \!qd| î!ÖAK "IBÙYòâ ÆQ?%áÈÆ2Z) A9U Æí ®0@)@@Æä 
¦P`
9n)¶` 
á!/¸'r Ãa(%¦äú(º!.üa. T"¿WäZÊ(Ú Á)@#?' X #ãá <Ô"à Y!Å ï Y7hWR_a C3\é(þ  |Bw Y %C@ X+Y=02/"R´\ó  ¢» ð^­ W&P%"P ÒYÍÀ"Ï$37£!YçWû  ù [&Xý  ldc#²Yø*té¿ ù !ÄèûÀù (w' þÀû B$3"!Í@ Yn   Á ` B` \  [@þ DËd èÚú`eù W\#/H_$4!L&Ó${  Y"F@¿ \\,( ·£ùBkB% ÍC8(ÕFFWícWC p"b³ b$Cy aZ`/&ò#¼Ì#`)¶#Ò KÇ Î  ` Ö@[ @1 Ï   ` ×à)° â¢ â!aA !GsáÀÃ!0!§÷ Y bà !L@¸eYÈÀq`- $``z @zùa |"AZÏ bö  g¡ú$*> L ß	d9a° Y$ X!¸D#%ä AfN bÝ  %D/  ¾ \(d3H°$3$hd3"·GYêh´5£!,è¶! (@C¸!Ö¡Ï(­!Ïe!¶ `CA¡¼Añ"B1 °Àåã @ Hî À ÀY"
"@S Ð  Såäa!@A^2øa^"Ö* á ^#V"ÚG*%Å!	 ÓcÖAÆP2²îÊÀ DYXA!ôC\<'¥M  DFðq T$ èb÷`{Aô (# \f BANW`XD@G X * #¼K
 - ©'û Oèf  ( Áh@× Z[ TC®ä"9`ñä<Aø$CD: ^!¸ ^ #!÷ @çDö`Ì$Í$+ '(R %'òÊä %N(?!ç#æ!©!çªÜ"`a² Táç#ø!çB pÀ<xÂ% )j1( !!#Rm]#I#^Yx ³%èD¤AíM%° Xì!ô!Ü g L`ô X (\Ú!#t¥ò\ S á Ø $ Ó aà  E)èõa a \t­ (Ù%%$e! Fd$,Q!Î@ÕJ@ Þ  Þ@$!)!&5 ÷ 9)  à )°   F[¸$èñÿÿK +Â ,nT$BABABABARWA R7 A<$B0.A0öÄD{¸&ë3À`.±B0A0R;A(B,A,A$QÆQRÇQ*@5A0ô 4à
,PòÆQ7 3Q@3 Æ`eR@¬oøw(ÿ$¬Ç ÙA  ÙA(`  ¶AD$Û  ý f /      Oá@OÙ @ÌÌ`la*` ,ì°Bð ¹ 7`
p¹ ,`
P-%é   /'Ç2	A0õò R ÇòoOÇF_P ÇF*À<ÉF   ?ÆF    
 sLÇF0 `(   ÇF,ÍÌÌ=2À!º3 ÇT 	R_2Ê 	ÿP` °Ó¼r%à  ¹Sô  )° @)@ð p)|  p!û  ð`     `0` °0 0 s 0	` 
   =)g4Rh  QF4ÆÀ  Pèxñc¿N¹_ = ó$IQËÄÆC#ÿNEaDX¼e@¶zÁ~#D Vz (F$ë1fÀy	al  ë#LE È [Å¶ ¶NC F YÌ2C @ tj@YMÞ ÆbgÇt!6@ N- Yr$s R 5 N$£ Yfèéð@ÖF%Ï tqÆ~t D F-çF0Æà é cÂàn(`A)tÈàH D U-à="+#ú"Kó  Ø%/ jEt#¡ "E uû¢m eò h ?@/ ´%/Árâ¨Â¼ë@ÝBÈjjÿ¶BÖQT} O$èx@	?"@F "Cñ "%Z U " cjPj3­ó Á &UMóÈ; `;@Rà
;DIà; Ý#ÉWVY ¦¡YL! 7 @ã  Âb[^ÈBZ¬B .kç (9?§ Á?§ &x ¯8¢@3V®èý ocî :à i H i@-ô´Áè} H#P °"V D @ Æ@@	^Â¥l  ÿ  å pUìäð¸!#è } ¡xLÄ$ E"
uWù%áHL$|$Lt$<WG;Ð   ÛCÈT$G 88GtÏGÆx]è"@Ú M 0ù L$DM!F @FÁ|$D G4 ZP4"8 	 T 	$ 	  	 J 9 $  ¦D($  O4&  3À £t § "@)$ @X³ , 
@!Ú  ÒN @C1 5@vhJ@%µ È`D$0#H+Æ 	d3öh  j ÿt4XèÆì} h $ø`0è¶ 
ÆÄþrÕ 7t$ ö `A< @ P 3 4ÿt(tCÎ ¦(VL$l xÏ q$A )P   ³!>XPPè ½ IF%C4	¯Æ jP +(PV dPuCtè¨!>¿`-$"¾¯þ4½ Y V I Pèèë}`
 0   ,%PèÖ ` Ý Ð8+5¶ú ²
lA0($ð BA1 	 ñ 	A4 Ã ô`	 8A À 
(A  ø 
Aa Ð 
    D/ r`'FÁ@2 à  ó;Ë<3Òÿ#&$ZÅ BD$ |ó  ¬ëfAÇ(&î X%A=(®AH(åY¯Q3 P!W*ÝÃY§qc *Z(F(Ñ0ÝÙ(q{ /dÂYq¡XÃX/¡ q4)`_0û)&(@Å(¦AY X0ÜY` Â AoY§°/,.+ _o_XÅX b  @ R@>YË)`O HXá)f¿G. ! ¤bñÀ@ÀY 3 ×Wö(" û Gì(ÆÉ ÉÈ_0Ý{7à S2ÌÅÂÆ##`Ä-í\Å_è]-@$ ,+5ÅÅ,-  G$: ´$´ *À$¸@
oÁ"+@	$¼@ÆÀN@ dc5ù w,5$õplE,6Å Í Õ õx #9 ÉAâ  À  Ò  ä!£`:@à Í á Õ`Y=  Å . Û  É `>!í =aÞ ö	\Ü(ÈYÝX!­ ß2oTÃUÎV>=!Hë5j è>õÿÿÙ\$'Û #W S¦ )¡f`$@NDÉ@!x#Õj)c¹èýôÿÿ¿HÍ  àGu
.Gø&QYr&ñCåÿÿ%lwm"üG0Æ`;( "ô"X"r  ` ¤ÂÆ¦ $¢ N"ZxcYÃ#® "J"    ¢¼/µB¼YXs `@)`M3Â)¦e¦ %zÇp^"( @+T @#YP	XC4 À@#BÔ PU L' Ã ``O E >)@¬ -¥ '."¤CèBÑ ±$¯ÁCê;Ð Âüÿÿë@  4" <$¶ %# D$ \ tjQ D( he O KP&&E!E 0e °=ðèeK , .\Ï T(PPèy!L!AÿD$,Â 1  4 
;T$8æùÿÿ  @ * 8 vt)L$D!À DF³@@"$'U_^3Ìèl%På]Â 'à Vñ¾lË iÃ
tÈÆ@0 Ç@@  è+ë>@4ÿu$å  $â,ÿ)@Æ@1@%!
 ëH@ùu	 6  ëùu "' ¾P" @`_^t@_È @aé* a`_ à_ Ã ^  3 H Ãà]è Z` 	ìÑW3ÿ9|%" VZ 
Áá°b 'ÌöR   $jJ@ à@ !Ü !Üf­@ùWÒ@J¿@CÕ(Xn eå   #í! cî  $EÎ Y2c @6,ÁYxXÐ(XxY&A ò Xú``)Q )`; $@)0dò G) <(Â i)òÂ@ iÆÂÿ`µ  $  $;|$ -^_ÄÂì"D ÑÇ$!j 6! 5VW¸Ü ä ÿ°ì !>ô !C  !5öA33ÀH9 >(0!ü  Ó B M !H)`!U`¢@ 8u  A^ ^R@Ð@  !^ ü úA^YAP A^(RDCîá ERt@)ú(Q< %qVY!e ÂD(YQ "Ý ! È 
A# ò¡tYá I?ÄÄó¡F  ª¡V $AV@ ú;A!W _1 ÁWÀ  Z #s0âº!0æ Ù@ñ s Q@Z$èFÈ ^+D ñL$;È
 íùïâíù V k Nîà39ÕLiÀF@fgØ |  Ó  ÈL$ºPIL¸ Ý IïKÂ~@æ¯K Aï K AbïK I/FA ï K@N Æò±ò    Q!~ t²ëö ­ "¼ m M¯Ð­,A "õ  íË È "58 YmGm Ym´qí¥ í¥  "Gécàÿÿ ¯(I C:\	@ð <(x%PT(H5Ù )AqYAv?iÃf/àvÇAlz;XA  I/ýYÉ5P` ÇA$e@  ÊSæ A$ÞUYPhà F %,¢@% F4  % Ù % IV	àK  $ l K,A"gXË/ÊvA8A4ÆA1ÃÇAf6E¹ @! %!° $/ÈÇA,2   qå< IBtAÁ#!à   ÇA JKÇAF º@íÇA)C@H @Kâ @Ç@KÏ  <  êuãÁ@   Q#  'RÂ \!SUVWu;,(ÿK ?, A  ( +ÞUÿ43ÿ6è ß-Ävïuê_^][YÂ@.(7;+$"ÛtX@6í @ ÅU  ¹ '	Áàø+îN?. MBÀRFüz<Ç  Büëuà `Z ²  ºy !f 
$i0Q!s<tI qEÀþ$wwBDsÝ è !À¢èC-Öà  '¶à  Y-ÀSUèÊàfÛÜ H  õ   Tá}aeaé  ­ #x W!S"ªF.Á6 ¶z9~u9Vu	9F î> tÇ ¢ [ FÙ F ½@aóFÇ#~?æÀÁè~VÇFb"? N;ùXÅ^#¢3× $+ Ð 3 æÀà  0÷Y VC Á"  F"Ë3¢r3  \È@ söF N ;úuÇ © Õ_  ë?v3Éu?+[
V$;øÁM!í ë;ús3É?;Ð!| Îè/ Æ' ¸BÓBÇF@   "ÇFü@nèbh Âç¿!XAaë '!ë
dà F#@nF 

Ç`@~7X' P<xSnUW)ftùt ¶X ¨<Ù ë#¬®@VÅaO n<F æá	K ô,ÅÿtP!V¿øÿÿ+qXÈ )& 5 Ç%, QoAjQÎ  Á '\Áa!¿$GÙÃÿ|Í @Oíu°`Â3Ûþ V !-9^vR¾P ï®CSÀt1øt,hC=j UèzÛ+Ä#tøt
øtøuÇ!d CÇÅ@0;^rºF_] V [Wu ,B@= 3uÁàF,F, ×"'bâ\ F!=F(%×	Ã ÇÞ Ò  Ý ¤`  Us/ìDÁÆD$ SVW(dH0)D$1	!·$X $@
@L$(;H4i!Øx@<fffÉE)7!B$!*2 C Ç(µ@Í E,è¨$Å¿ä!Ð*É$A<I8   \tÿ !	Në8Òu4O@j4|AG@CPSÿ,@*!kCº ¬  Cè H@P  @ÆÒ 0Q è  K >$!  OÒt!÷ JU  Y`Bé® *`Æué@ T2é<IYLA "M' 9) 	J-ð)   (B @$ @à !  (;`0 %B0 B`}!
  }B,B["B,;jB0ÇBC  22Ét ÓÀI@ÓA2ë!¼%äB¨!w!D<`ÿ"94k$VSÿ·A¤:¸ Y+D$(Áà.Q`t$0ÆPè²Ø!§Äë F@ ¬$3À8 v Ø§ xÀAÕ!Îà$èâ Xb7k"¥`
 r$ù~$` ¶ (#Jí(;A4¨ýÿ*ì [.] Ã,?4Ñ ì+ !«dJ0H!ë$;J" $àVWø²@ÍÁç45ç !FÀ *#?@Ç" $@ý¾¤b zU]  )(u.ÿt*OÐ) @a¡Ç`@ {@;@+`à,+Á!<V@ÁÁàÐCW · 8"? Â 4BB÷ ,B "¸;" ` G*o `o!½ !p"ÍXÁH Y  =  `ë "<FÀÉQv(  ñ 18`D$4t. ] Dl)­`G A  "Y#} (àêéÛ !t3éÑ 	FÀ À 4 >  ,F3HÂM)8È0I 8C*.Pã 4  4,ó#C  Â :#@Þ 8  +YÁà -  1à! > 0 Fà b  Ì XJ¡A*,j2A<A,ÇAi¢!VA#8,!T{%æ@!À D$$!f!~ WcF@# 1P= =  $v @Ö.« #ÃUWÒ,tDðIAüZA î'Wë&N@¾B 7)à')ÍA^3É8L$3(ÕEÁ { ~ A$ ½ BàCc1Ä4ÃUå ßVÓ Aü(¡EÐ%é 3()\$Ã)d$@!à B ,Ct0EÝ ±C@4åßF@»@¯~ÀÀ@Ã9 QC9	$u(Òt$J£5e§ã1 Çc+ W ¸@ ¹IY +`  Û!` +O(ùH8  É$#! ! xÁØÛt "ý XB­ K =$ë ÇBóI@ö    3!+ (BæBðâîJ N ãÚé £A í F'her"ë!° %í Ò!F%ÿÔ(5ËeÏ&   A"   À%Ý 
(A4 Â   
 (!`@ 0 K XB¤ X¢±µb¦"¬0A,8^A0¸!*çf@Ó Ï  >yA%à"²aQ%Æ    ! {@Ä  ¢³ (!¬Â²F@KºAÄ"¹"«+ÓtÂvL³ð("("!  bv r (r"q ,@ nb/ãbre¤ Ö^Á@àXë¯hvà  ì8hy 3ÖP0B£ Ø %(;P" %ÏEa ¹E V2+B+È<  è  GA«f (G@¡4À   %ðiSè&~&Ù ¿E­  ##²$ ,Ë(î u  ,Ì ; J@
@pHOÄö`'æ ötU >ÆÁÀEâÁNÁá#Í$ë?öuÎ%jBPR¤<T$@!@` ¾Aá%x'õë3À3É3' 0@Ä<Tg)b D"ûöu<95Ót%uE« , ¨4ë N (` ®  ËB<é î%+ <"ÁYÐ#?"¶  ADc <!àHKà0Á@ a <! %ýÁ  <à>èÝ  BHÜ(âB<B,ÇBD$F;0u' Æ 3ö#´aËFc JAlGÀ Ù ëHë ;Hë 0AAN<ä# BÇ%$ S1'V tGk 4ÈùRÿw@¡{L$4Å¤ 8$zPG@QHô½Ï"(ô  !B>'#Ë èõ ;% (ñ3ÒBG"@÷6(ò-ÔæÀÁêk ÕN-ï È#ß I ` )"§ )ë¼-ói 2 * D,Ø EýIÄ8nîÌSÙVs"`UWö»L Á/ã «L<·èüNí "b! 1ì§ÒÎ,§ì§"t»_]^$+Ñ ¹D[Ç@/pù _  $uê@ 5ï S0CUé!PÙ;Ë¾ '#Á<d Oý+Ùæ_E<u% E3ÍM$!( Ð!(Ò¯ð!+/;wMÿÅA[;5g6ÔÂòNò^Áè+|T¤ :ÈÁéð $ DamM' Í@8 5 È2Ú D@2\Á!¢ i?&E 9*r	J F!+u8wÀ!1[ÿÿ*][-[R* V"\0 ßþ|1W~üÁïGÇ÷Ø'<CúB'üB2cB)-A#,QÆß_ö~+ÑCß
(( N()öòUAEà ìVW¿ ': +8Ç*
â4Áþ( öJ? þ !m¿  Ç+Æø|N"T¿Pº+øÆ.@ª±±V¸%BüRFüv ðFðBôFôBøFø@µ Ý@øV /	ø }$P-+Æ ±A`ýR0P@5 ñ(»  9 @¥ "/!o-©!ÊWÒ 
 5Oû Ì]CÜ  '® Bm	ó_Æó]ÃT0¤ Ò!¤ /Ðv(âë(ã  ¡]Ï(Ã >  '7WY@+  ¡; Y#f  G X2:l`# O Â@O`D0 \` _ @_À@ `` X àD`G #`3(Ë B ^A 8+ i`¦` ª ¶ X e/Ñàî `Ç%ÅÁø $`< N 5a G&& h IdW`, A¥!%< _$S BÑà  Q1í"IèSjâÿ3ÀÇpô>½ óTõÄ È` Ì Æ^YÄ >èÈPãÿö%thÐ VèfpEd  (÷+@  r_f¾@`u>¤ 3Àt	Îj ÿP@3À DYÛP*O!â >SüA^	Ë;ØOÈà ~;È@
ÑÉ~IfB_ AY I!%»Yä !!rè` *R 1x`¡ö`2 `É¹)@f+Ú)@ad"Ú Ä. ¾ø D u(¾v!u%  u¾wêu¾@ý  oèxÙ^F@$Ç [É ªB'à@ à @¸à).=Ô ) ê Ê ¼L$@& ¨  && 9 $S£&BaÁë/ÃvbY¤5!_X4!gèÉ}"Â \Ø/þ 8D$ìS^ \8 $` 0`/å "G"` (`"ô  3 ©&`"ia«ÿÿÿ¾A~ ¡ó}NÇa% ë;¾Aw u9£3'}.ì J @4   ÉtG3}~Z<> Îèo/ö {â6"NÇGcv[|ÆD} # Eò¾C  SÒuTâ @ ¼A¡ u  |ëBÔà # fÂÜèNâÚ *óâ ÞÒª KBÉ.`Ï ð~L Ò~:bJâ«² X`ÿA' <!f`Â u>ì}5ÿ`Ï@Õ¼bm u5¨|åBþ `; @ç c^ ¨cÿÿÁ3 á2äP S! W¾t#° u@Ø 8ó"ö(%f` 5¾\ "tl`Xp` `u!¾P 5`OSÃÿÀéM JUl$í?  W"6V  %FZ - ³Lõ[A¸=$OÁ £2Û¬  ¹DØ :2F³@D "Æ Y%µ Y(7 _%_ YF1Á'áù, ~|ÍDô¿ EDk#hS6%ÇÂv"ý _S	³QÚÂG'ÜÛtDð W$ï Á â á#  /"^  MÀá ÀñáaHA!>ñ&]¾L!x tÃ-äáÕ O#ÀVQñ!#¼èìÿj0cj PètÄ}$N À&[!¹F"fÖØ O Çcñ@  Ç`=Çf>?ÇA3	D²	@7	 Ü 81FÃ  8ûÇ¼ @ @	F  `	CÿÿÿÇAÄÿÿÿÆî   Æx¿QÇgÐ«ªª>ÇI@ Ç@3@ ÇEKÿÿÿä'çìÿ¦¸ì"ÑEÜÀu)9EÝu!9EÜu9EÛu9eÀu	2À$F  < xeÞE@]  ¦EÆ  CY  5En%þC(  %¤[ä"d%rYà %ü %¥Òdbæ %EEG
[)T &fEç 8 Ð F )[  I   E C" P#D L !´ Òé & ÁF"¦BíXÄèÃKd\¥ø`= 5 ±ÀD5¢a Y9ÿT4àZºÂàZ BaK V F JHÿC  JF©w `à¨'Í¦¨ hàQE`Y'VA Qÿ Ñ Y!@! z #<ÿ7`#àuòÁàÇ ë5a#' Ç Ô`AÅ D§# , z Da D§;$%ç#	  _°FBKæ_ ,BC"9c\u9cZub $²â }bm"u B}  CG  %Al  -QA
 aeb"\[Û!'-YØ   T@¤\$!+ R *!&âB%(XÅèÒÀá - X  ? à|!  `É [ 1 à[ v [( \B¡ `ü : 2 : ^_g ] tYÈ]@ XÀ#! \`a¸" 7 !\hÜ`£!!Dó8
  aÃDO Fi ºF/ 5 CW  Fn SF2ÛVWù·D]9Ó GO"
 YCe© ¥"ÁCn:FÆúfP@ceÃE$ \f»F[vLf`Ba¨æa6{Û_^]Ã[$â=B?$lùh%óX ;È~*ÇG  ER G@ ÆFÇg° ÿ"ÄBX G¸Z«0HÚ/[ ¥  ®"(Û~ B§ëU ÏEó 5Ìa!þV4@D¤·AX)Î+/%D'Âv" '% 'Ä(Ñ * T.Ëÿ(Ö`éW'L  @,H /ÚlÀ 9-(@9/ëK¤/ê%`"Ærjô\ê ! ^'ÚYàéK*ô  \>K Y  !@ ^$8XÎZÁè·½BÞ>G 0#ï "è© $; ó2p}é  N.ÚöÄDz (áé¨-P`Ýi/Õ@-<Z@r.@ÀvYáënà   _à   ~àQJ £È!b1# Öaz1+ ò ñ13 á`0GB³#Ò\d"-"¶"¿@ð!È!¾è¹h`o#EqÀ^$m1p æ H± ¹!r DÁ/ì!=bS b %\DE `\vD o$aÁvE T " Bq iÛÀ\2.@_r(J^ÈéQ ( @0b/ ©'/ÓfGÐ&="ÚvOAÑ '# V$èæÒ VZ!²á#^Êè±»ÀéW'¨ pÆòZ'¬$>$x Y`x ±"1 Ã `\ÜeYË þ H Ü v!Q 	@æ af§C  C;BÐu¿u!s uT @[C¸cCà#Û@ xHÆí   Æ  fOl Æqc lÞÇL@ @ ó`¼H£ u@ø|@ñ×`üh@F ã" eJ î Oj `1 @O q Ç`  $l"B O Ç`@  E \ÙúÁ ÿ$# ¡NDr'à@\@mÇà@' ÿiÀ @R$÷à & ¿ U @& . Áà*`w *¹NR tà 3?ë$±\Ó! @Nà5 @Ø 5 `Êà ÀA@@9@ à fK  Ð ¦  Ü  ñ A¿ÑaÁfA³G¬ÆaÇÆ@LÆaÀKÇA@  ?< ¼Aoa¿ø|ä@mæ FN @(N> ½Ì'åS,öÃt#!8 D"ì/MD v"à_MF'ÿEÎ# %p$D *cöÃ { 0$.¼]` D,e DÞ Z5/à@SG;°Xv
@ è$(ë/Êv 8-Þ J¡ X"j \#ª Y&\Óëcæ X YÑ#t` ^E:# Y$_ ¦BPöÃ[t! H Ï`#_Ãdé Ä; &FxÂaà `1dëKp () 0l· lç.Á@Ú{°ë2ÀD$ " B¯Àu8l¡!--/ ÃFürKW 5  Ì Á8$%0 èy·e¹$e$S 6É X`> ë@ð XëBàC 5àCà ;%öµ  @C `¸A$  A  N$¯Kn%&LT p,È;pu3¸ D"fG%B!æÒ` 8`E9 Øèt¶¥< CZ ÓA  B f Y7ê°pAk`i ! !YÂÂ '@!!;M^t> }8)'0 `@xèþµ`u`Ê 1`YÀwN `E e3/ [39 Y@ð,Á;G©t&@XU@ U Ú fè¥ XÀH À!}w1 âA¹@ t%å"© ëAW'`n#OCàâ= * jT  %C: "Ò@0  A! X',Ð;e[a ,"" `"
Ü¶." Z'Êµ ¹  Z!¾ ·YÓ  Q@H Ô HÒ;A_`H4` ´ ~£W¦àPAÂ C/eñæc#Gô&#æ# ÅFd# öf Ãà æ e¯ ÃÆ à ' ?åÉ!æ 2f
  fà Z%`L@ Ão   ²  å  î DeW¹Atÿ~?9g lAV@:qXNÀËÓ;Êt­@PQRèö²WaL5RN Ù:° _A~ Ì DÇ@9>Ç >Ç@@EÛ@ ì]ê,V3ö=Ç  7ùW57tøtT$8ú:rë" H<3ÿ@@àt¿ }+ø@ 43ÉÀ`µ <9ð $=cD/ËD$0:ÆXÏ=¯¨ 4u
A,å;È|êëf>4 *wÀg 	 ) <;j , z	$ÁÐ
 ÂX ¬4a  0 · " 4@t^6Æÿ Æ|$@_Xti3ö/Ô|DPGüÁè@ .ø J ;BèA 	ìA BðA0>ôBôAZ Þ:Ñ  h ;÷G+   5I²F;÷|óé~!3Ò@hYwüÀÁîFµ "# #¹X@ø"#@ c·@ü@ A   %   `w  @#ü@ÀMÉ ¼ ñ;×}@@%4FC² $B;×|ê AÖ !7À!4kê A;a!ß3ï * 8 P4+×÷!F 5Û Jr"â ± <"i ù0Æ LAÜÁáAt¾Xð 8 4@|¾\øÂàü;ÂuÁúë  Ba  4tH@_ *»vß	(I@(Að<yQÐ(Ià&ÞÂÁ)FðÊ)Oð ¿uÏZ·  %T@G È"(	I 3A0('ñY !«Ø(ÓÙXÂ(XË)Æ)Ç @J ÅÀJ"ë| K!. 0 ä $@òÆ"Á
tX|\ðBæ 8`L`È!DB 0 dÈÂ  4 õ AÁ!, Áá
 G!Y@Â @v!a @Î )A(Aaa @  Q ÛÝÆØD(ÌÆèî@âÆÊ ÃÆÁA"(Å  @ 4ÆâîÆÙÝ)_ðÆÄ  @  ì  )") % 4 % @A Á@ { }`()@w@p (Ô(IBÿÆÑDÆá Z@ Ë@ XÆÚÝ V|)(ÍXÆÌAn`x !rX)"ÃX)à	 ÀDà ìD[ ()b"cW"t!¯7,#ëúë Ë 8d 4DáÄ ù@d 7 Ö 8!Í"ü  
 ,d ä¨udL$0|ìÄD å!w"º(ÇÁàÆDPj V@è­}a3ÄD® ¦ ,@  Áá!   ,@wÂ#vÎ% %qD$$?Çü$4½ C BøDBìAA _dä ? j;÷}°$FAð@$ î ³ 8%a@u 2  ³{ÿcõ4Ï+×Aø "ë3É 8 0!_¥@|$,WÛ DDH8Á¢ÕC¾ðÞ ( QCø  #ø ãø ? 4@c 7 cD (bß KóÈBä )¦ÁÃD)AÀBÔ #ö A $  Ã 	 à` Â 	d »B+ +"X f , ±à	ª ·ª ¦ 8@#$±(|· ª"Cê   "  d¿ @ $ðD¿ 2ã¼  8 c 0!M Ò~h!.f(.`Ï   É!,C® Ý@ÊÆ_ð# ÔÆoðî@¿Æ#>"îÂ!4ÆÂ#@îÅ#?)0c¬ í ÆC¬ið i,uÀììÿt$ètcÙÿPÿÝ\$*¶ Ä1«x=­)Ø*74­jèh%i 3«@AÀ? 4à?à7 èà7À ìÈ!Ê
¡¤P3Ä$Ä $Ø ¹"7V´`,Õ"Þ$D$HWA	@ðéuô" +@ à8$ð  Höxn XV¼$Ô  æà5+øsdDð`3À å`!I <@]!<D< < A+v Á`1 @Y¿EÅ( üEÆÀ  Ä@¦ëk  g |@ß@ `@~ 3-  `@¡@!  <#   @@øà à  \ ä ã3ÿDJ=`ËÈ/J+°!Ë æK° Ð W4ññ è]`# Ï # YÊ /2´ð ?è	©} ¼a\#Ð; g % ï@ à %Cm [<èG - f( \ Äè`d&ZWÛ(èÎW <! nA, +OF(Óf !iYÔ  Å@.  Ýò\ ÁYÌ  Ù ofÃ@hA rG¨ Ø hA= X!Tè"3 $ Ø@@<y£ ~Î v b`vDÄLC hà'o , dà	o 4àoy¨ P&@z0èegáÿ!,é/¡:  !`,ÔAd$, ¤Òf!P ý3Ä!E íl$ @
A' q`°'(Ú'Å!!Ì(Å!A% Ü  Ñ@H 7 \(º@ Ä!% Ã &«ÂN'BÈ@#!"(ã D$ à µ à@@,y(@!* k`y!* àQ}y¤!A3 @@@è1f3`´ <8hA@L$ÿ¸NÀ$ø!N$" ì 	  %T ($¹t Ü(¬Ýøëà \¢"XCç@/CG;¼c@çü&á$Ì Q
_^3ÌèÀP} ÄD¸ÃÁP éõÎ P Q D$  jè<  Ù%P/%M  $h,;;%èÄwÂÿÄ-ê >  > è=$Ýà 'è`'{@ UìäðìOE UÀÑøVWiøX©;ÉMD* Â(l Ç!ë! þ 	  LÄ<*8< Ä ²$s` LÀù~` \Àù  lÀ( ;)D$P`, DÀO TÀàO dÀàO tÀ  ËkL$$Rà W@E   )(% yHÈþ@ Ý )   ë@ àÐ àÐ B@4`-@Û  :!à à
ß ``0àß àßà^@êà^àîiE A¯à í0ÿuÿu"0L,Þ$ÆÀ A`aj @	 |` < à$ AÐ < @àP` Dà\Z` H RÿuÀ`$è»ô#EMJº(\#(d$P(l$`É~j(t$p(¼$"» +ò Ç$}EXYÖd$V %Ç(ì(é Se2` D"KYD%, )E1$¶X0'9U ) L Ú+ò%Æu¥ë( !X ,!ù)dBl¤bËÆäU`AøÂÃ!Ú ÉÂÃD$`¡é b¹)\ ÆÛ@B b¼àBAÑàBAÍ 0T})l`¬BÆí@I¬À  ³ (!_ ¸ àT  Bq !  É@MBt@àMà
¢ @¢ÿu¢\ W!ØÎèIîÿÿw_^å]ÂÅà ì( ¬<SV±B33Û$: !× ;Æ# 8!ÿTU@%°!£DT$@UWø*m	 Áçh,©++ð!+fèoEA3 @/ÐH xDØ|$DC2 %#â$	 lit$PC'7þ (    0E@l$(+Â  $  , ¾ D  LO ¦ %CT A¡ aaWYCT1( Ø )@ y`CKÀ C9 8
&HÀ&C4!Ð `8@ `g %o +XÜ  `x h\$0 &mjl$LIM_! Ù ,0 ,8Å/1½aR AV®1_]^[Ä(0ÒAÅ U¦ X EFVñÁâ ÁÉÑùiÁ@»W} T$8Â!6 H $c =  DBÔ BÇ`ÿ¦ 0EB`ÿ¦ 0¢¼ SÒ$Cå`CAm`/f! 0BÌ`àRBÁ`àRBÁ`U0S >kÁR@XWäU ¨fÕâ 	&#JÊþBM/>Á Õ D Õ( Ù <@æ' Ù A¯Á!ã *@á  7 Ñàæ+$à[@êà[àîE$`î)D$p ÑúiÂAµ$= 8 Í L@¢áB§E¡`Rá8§`µkÂRU$" Fá§ 0á§! T"w Á Ï4¦!ZâwçÅ¡A0ÂÁ`*¡ 7á$Y1`3àÛçÅà^¡ à^á `çÎÇÉ!¦ Pg%f&w!Dr §Åb»  ^Y`Dsà	[5`D|à	  "æ`Dà	 ÀDiE$B1à	%   %&`Gà¤bqaµ 4 !`à¤àH âà¤àÜ à¤à dÀ\@¤À$èQìèi b<(¤b(¬dM(´cü (qAÙÉÏ î?(I$^I(alHx(R A[ (g`'¯`(( ATYÆ AC@%p)t : 0 ³ (Õ¨(Ê(òY$AJX6k$F6YÇ(ü(â.T L/hç $ D#Ï P)T  Xç-Ùhç9ÿÿÿHë "$" H@«%3¬cíÈ[ 0EB¶K¬ DèeÅD$ 4 Å ´cØ  Ñ(P öHP ´e "ùàBAàBBóL- ¿ `(ñ5¤ D`C°!Á@OÀ  ¶&ö  #®D$D@c°àY F0@U p@! BU`Zà QBH@¡àQà
« `« D.& )ª¡5á'5 ¡5 \@á'54 |a, ¼¡, ÿA, ¼á ,Fs 8!$ 0  44Aá.  ¡) T@ Ò@N á )àNá+*Îä·$è)äê  hTà ì8A^3ÒU©J (@nc;ÅDJ8T$F -JSVW)ðD\$XxÁæ<¹+è)äUù (È \(Ð (ï P*X ª Ð* TAË (&$IÑOil$`DÖCpÆ&<4. iD$d@ ,¸j7 0)C,$&J~ P x 8)Z \ (@G@ 
0+Ã"Ü   < â T f!
Bå  #ª- )E "!®Y¤)@õ 
B¾)Î à *C-H  %d E ([ Dý 
@²!Ö@`p ` 8   Xå  ¤ d* vêÏ Ù R jÏ Ì(» Y?Ó°ªÎ2$ *ù !Àª¯@ DB¼@¤jÒ ê Î Ý ê ÎH'.XÃ!8D¯Ã*Ò *« ²*« 	 D! !p \*Þ Ç8_í! \*Ò Bìýÿÿ_^[]Ä8ì¡ÊßQ÷0üÜM É"l¨êÞ(hD$TA7d ¶`£ D³`hE	 eF`éôÅF D§÷ 'ÈéA2+¨Ekù*ÚD$`Ðú|$<ðú4E~·*Ù ,D6+È ß H@ÐéB !Î <*à H`,©D 9 Ùàíê	â gz`3æ /!ä *E¢`a@à`Dv s H`!à`E¦` ûh RÆ Ä0iÀC@qKáa¸ X@háB¸Gà`RàÊeÙ``Ê@À`à¼g`k °Ò² hF Â 8 Ò¡Áá½ @!xîE# á« 0@¬Á« 9!{àá«I`3ààá« !!``'Û , d@î àdá¯ (b«á	¯Isa¯ \@{áB¯I¶`RàÎá*¯U(á²Kì Dì	 0ltäá®Gx.l¡G£X 7á¬ DHû [àÚá©à[¡£à[á£a ì  kF§ã@lëó`,3M$,*â`FÞ)#@)ô`§ëóàH FPà	=A`FbìàD lÀFÝà	D |Àà¡ ÀG|à	= Àà¡ ¬À¡ (dá ¼À%à¡H `æà¡ ÜÀ=à¡XÂ`=à¡ üÀ=@¡à .mIÁèß'`õ© ¤bÞM7CA -7lè-7EM7 e Q(,| fÍ(Ñ-<lÓ,Ðó?@ 	IV(8f)ê D-Z `@^ *EÉ`@"i` ` ` Çí T ÚJÓ `(¿$p@H¤$@
 DDÔ)¼(ú(Õ    ` -½(Ó$°` d)´ Ð`.0V\[ù)$À@(ë(Ü- C à@ Ç. T ~ZN " D( c *N !`  XíÍ áÍÍ (öë-Í7#*%`T fH@ #c'H-¨C_!ÔKÎ"] LøF%í` CBí@h  8¥ DD`Pà GGàG d`[³#|`9 t )H S²F`I@¶ÔÔ.5  Æ*_ B ÈQì¶ CÕ@XAö@$ à§ À§àTà
± `±D$XÍ^¡@^á$@ ï8,ö@â¤¡Òá7EÌgv(¯% 2áá 9GZ@$á9àVá;\1Aáð5Z ¤¢w/pï gÁÏâ¿à
Âwq@ ¡3Õâ k@ÜO  Dá3!+ ¡+ \@ºâ eàNà
¡bgï
$Õï$ $ï$ìDB¯V3ö,waO   .å\ 9@ #:o%Y@\S.ã$ÐWW©x/$  /(|$hMù?O* \ D dï*ð|$`C (-C P*/* ./ lFÆ ¨E¸ê N4,  p Ï*M#8ú  t`|$< 8 0¯HÂú  @"è\µ   -È , $ D-Ì h  Lï
H H! ` f 2A .äY
G? L)Dû )dÃ 
GB.Oy 
G0 7oO%çn» 
G&à !G !/WË$N¿ mY`b ooR`"  Ý " `s | [%Â M ¤oI @ 9­o¿
 ÏSXà ÏNp @`% b @'
!T3#á`g(Ä « @@; A( à§à /ò% Á%  "puaH  YÀ pöà ' H Ea"` #¡oæ,ïæ &ï Ï " PBÏæÂæ hBÙ"/æ 0Oæ[^/æDÂÒhì /ÓW¾õ", Æ
!Ì t¤ 	
ÿÐÆD$'Àu@ @' Æ` ÀtW$ 1 §( 8 Bú k¿  á VâÀt `%ì= D$@@@ $ÿP|=Ô@F gÃÒ É Å e#hÒÑ`s ® ÎÀ°  GX@u°ë2À@d@­ º  i \`q#Ú ' %© - !H ¶ÀTÄDa 2À }/Åw&=ì@A@Ô@%/Åv	<°Ò ; ¹@dDÈ03Ét¾  ;@X O ÿ~0ÿt$0@© W  $ 8ÿPp|d©à B!â " +Ç#Þ ÉM N )`T `  À x :Ç@y  @ t(î ¡ t#®Ar7[ ÉË(Á`ÈD§v"²T =!XT[  Ë! @1 ë3d@	@AQ  ^  U  ,î@BÁ!A8 @- # =c \ 5@gÀÅv  r X"! X z & @Q  A{@:à2" a¦Bm"& Iâ
oAZ!9³C"^Ä Â [8 üE ÕÌ]b$%`X8¨@^f#©^È (%%A+]T!E jd$!+_t`. !ÇB¹ &"Ós= T WB C8.Ó +"ÙöÄD{\/Úv(%\Â/Äv2 w Ô  `6ë,KVÄW b¿!/Áv à# DuEc  aAã67 5ã7 Æã7!Ëw0 æb	 a@! B @
  "L&"/ÈãK ãK ,#> 0@Íã
KcÑ ]`©#$G+×#ÏcG {"¹ãG * \  "Ò$hVÅã M ãMOÞ @[dJ Ü"° I(Ñ Ð/Ôv$WÉ/Êa6 `) ë#_ Xà"=ÂÞ c!ãO¾E[ uS¯c |c  {"B Ú  Ù!øaq Ä@! Ã` Ì@nCÆë àB/Ã ãmA¼ v)Qä#c¨ã!u!`§ !gñüV{ù ìæ Æ ¾!¦#c  IYÿr&9 cwÉB3ã1 !j£ %F9%ùú "ã ÃBý Äbåâý Ã âå âå F1 &1Bå $@±Bå "ò ,1 à"åxIf-&~jâå'Î UÀ~QâÜåËB#"+g<â@VCbÆ ÂG -åèaEè Í"%?nâzà2â r'î t_¼%'æ &´  lQf$è94 À à	=6@ ÄàÑ1&dÇ+¢  X!¯¦N &NÒ jÈ=S*E@êE°;/&$v2»P"¦ u)»T` »X` !ð &¨ @	ÿ0èÇÿÿ[ÂGãU3í=Ä¸ W»\'tVù |Q#aÐ
@ËCÿ|:¸ ^Vj.û÷OðVU O,Q@ËRè-h">+þ ;î`. 8}Í^ÿt j @2 $@2$Ë 7Ù#¹ ]@@ß @ßìB`Ó U#À3í íbG/Ðv@ò9®@éu9®@èu9®@çt	*¬½"®B> ú@2  @2¾!z u¾`	¾ @t	ÇD¬@4Eíu Ì   © @ WÆÿÿJö A-$s3É@SA) W!¬ ,(8A@R&ú  j ( A?txû|o
ûûOøýu@cWA8ÎR p 8@èÄÓÿÿë#ýu+  @`$ <$ < <è¿!7  (`T!tÏ+ß@ j}@ÛtF  $@i  3QWRP 4Î ×¿×!wkÐ@Ù@l  #`l '  '·áà'  	ì¡¤P3Ä*W#½ a   B!½ W3ÿ c/ÑAÂÈv9¾¡Â ¾¡Â ¾¡Â|$¿A@2Â ÑAÂ ÈáÂ ¼J© G@5 È!Öà5 àB¶Aø ä`!ø è@Aø¼@5ÿu" þE$ , ôbÄ ô ^!U
3Ìèn"} ÄAÿ Aô!u,S? ,#8!p £<Å Iaü ¼ aø­ 
ù@9a«ùÙOØ#b 6 SC DB  D (èÃÑÿÿëLÿu   ! `$ H@$ H ,è¾!Àë'2u/   `$@.  `( L@( L 0èuâÿC `} ¼4+Ëë@¸@mÿ \$06b ¢´  ) ; @@RS! #Ü][á X!Á@§ .!+ BÈ ¬@2 D`2 {6åà2 %à2u `   6  @6 ¾@6 H`6dî L$$@:!î Ài¢wÀ 'ßSUÙä ¾ 3(VÄÃ [DÃ V î (ä Ã H ×|;aD-ßt$4dÉ@ 4$ÎËVURè¥. J 0dÅ (äÅ Ï%F"3À(
 !Ù ;ïF? /,sIL %L	4®Áá8D$4AgL'DL$0 MÁáË1ý(+ý"ì,f J DVÀd»6T$t"Z|$4 DÅ230 / #M §@, Áà  À?"ú`"Î)[   	  Q8/&,YCk'# Ø  A/1YCt@ C{@@%}Y\`HIÂ 11'Q XÜ  Y)éE l$ ,a
ÆïtBR Ø$	  0Z(Á@ó@ñ "_^][Ä#W¡Ð$OáÏ,VÁÏ cAÏ ^!Ï ,á Ï PAÏC¸CÊ AÏ
QÇ$333?ÿ!Ú <× <á ×­  !§ 4a× ,á× ÇA× b ï3Ò!×iâA×A2 Â0M êsÿI 
5¨m¹=Ì]!8T$8!0 <DD!ô D!çCX!ç¨!êD$,aêpÀ(¸"A  !Ý 0!; 0!á 8!á Ð!á 4@mAá  u ,,b$µ +!J4LIC½  M  "2"¿  ý `Y a÷-ò kð `!aá`ò iA `AñAÉ * I!æQ Q B rdY,@2 °`2£ ` Y3S%¢A ¤``¨``pSnA$ ¬`bIIBW@ ILÐ Q Q9ñXå. / Æ/ Ç, !/'!="@-aLÄ`H´` Y 0àû&YB# 1BÝ¼$4` A7×YÀ`I -a @Q ï Yç + øX#  yE Åó pSJAá!¶A¾ QÁ0#!®UyÿiÐBóFK"óQSÑ3ÛUC×WºF !ô8HJtXý |S"¯HC*O EBï <@Ë V@D¿ $"ë÷E: $"çVSQÊèu$ 7 bçÞ`0 :}ÏIGáHßÊ@6 WEÛ  _][Yã@ àNÕà(r"àUìäðì¨!U(lÃ¾MB    ÁàD$$W!Ä0B !»D$ !â `'~ 7QN "r #ù@ àúÿ)D_ÜþX#©`1 ` hÀ`U ` xÀ`T ÀS@O6J OYàOXî`àO tÀ;àO ÀàO<o O\`@[ç`àO²Àô à	O!-Fg9j<i|Å( >Þ@À x@ E=À$.@)$!@F}à	O@Fà Q@< ¬ < -éF R?GÀ$$èÀ¿(3_PC-(\$@(d:­
(l$`É~o(t]Ö ¼E?((Ç$/SYÖ~õ é>y(ì(  V#ù` D!¥>o0)'Ñ@X0^¢ ) L ÚIu¥ë( $	 ("")dAy ` ,»{$0br Ñ! xÆbr` ¢x { 	 bi »&bg@DA­ D  g@C%» Bg ÜBb\Æí5Ð BZàBBZàBBZ  ô@ bOÆÉ@B bMàBBMàBBM ÿ*õ uB* QAÁÎèe¹û EÀ Ãß è"!Bãß Ãß@#Ò#Ìã â   ÛD$ãåB	 "ãÓcC  
àG<Rì p! au_`   `ãL ÈÀ`XAþøÀT # "Ó`CãïAlàR ´À>àR äÀàRN`Rã ã¥ À*à¥ ÌÀàR üÀàRBÿ`RäåBUà¥HÞ`àRAÁ`àR °Àø pÀn¥  Àà¥ ÐÀàR  )¯àR Dd b`OBr`àO ¼à
O ìÀà¢ ÀÀ¢C`CR ¤À*àR ÔÀà¢ à	¢ PaE `À,O ÀàO ÀÀàO ðÀà¢ àÀ¢æ [R ¨À*àR ØÀàR à¢$ÐÀRDàõ À>àR ÄÀàR ôÀÀ¥ D¦ÑDàO ¬À'àO ÜÀàO à¢ DfÑ JñÅÿ%z@ ½ ð½ Kà	  `_Kà	P@@Kà	   ;K&à	 0 Kà	Y@YK'à	 P ;K0à	,KBà	=KKà	  Y Ä*Þà	jK6à	 ° ;J>à	KMà	°KVà	 à Y(5!· )E @&&@èL(,@(=("UKF?@6@$è¾·è ´bÊGñC%0ß @´(/ dH	ÑYb/(b H	 eFçp(d¦Gä "BYe_)¤(%p;; !B"È& b@/E<) X`JAñYÁÈ:(ê)wY¬b,@E!Xè@JB@JD)B  hAò@ P`ÄX-agÂÅ fÝÂAH 
ÈTÌ(ÓTÜV -f añ
\áYÇXãY áA{Xá\ã(ßTâUÕVâ)Q0(Ì(NPYbG(Ô)T@üXÈ@Mal @)IBYÆ b " `@X`¨(æ(ñYL#Ó)2`)SB-b ë"`e@R )Þ $If $pik$d Iz,"/ "!H¤ ik "k$]çþ)YH¤)nÇþ  !G`E  gö N gôèóGô@N `fyGô@JGàJGîà JGìàJGìàJGì@JQ Û`Gæà JGäàJGäàJGä@Jbdà JGÞà JGÜàJGÜàJGÜAû@ gÎÆÒAr gÌàBBàBGÌ@ßÀØL²à GÇàJGÇàJGÇB@ ¬g¹ê èG·àBG·àB &q)/³!^ ¼g¬Æÿ@Ð ¼gªàBBèàBGª)t`B ´gÆö@B ´gàBGàBG #:@ gë ôGàBGàBG #E@B ¤g¬x ¤g}àBG}àBG}ë±³­ë± ë±Ë¯ H$6Ø$D -WÒ>>$VuÑWÛ0ì3É$5\$þ Ü'¹ %ðW<@ ì`T$l  ü  |@Y«A<%U  ^@. ¬`!$, W}ö¯ ÂÂBÚ	BüRà Bè 	H/Bì 	HBð 	EèBô 	EÐBø 	GßA;Î|¼(fOB®@<(e÷1ø $ ² `@$@O@bÓ($@A@&V K ×_DÌ ºC'Ê/GVWPèì°ÿÿ R(=ð;ß( ý@À $a¨Ô"¨ Ø .ù ' í%R ý-ÿÿÿ#>`gd1(° 8 ÿÿÿ ÿÿ`ÿÿ` ,!  (  `$  `    #P-ÿ.ù Z\-fü)¬dÜGa iHh/h² LA `Ú6ý R¶4¼ï(Eø(¤# UAYOO\Ë%å YÏFYà » &Ð&±/ \ 7ÆTÙ V6Æ `XÊ(ÖT&`y0A1ÂÊYT ¸(ñTË\ÂGé d \UðVñ@¥pY÷>FY5g Á@@ ÅTá\ð&]*d Ð^CTÑVàÀZ vàa ùGXX5Ai`h D EUøVù(î YAGXÏY=à jÀ0u l Té\øàr ó r(Í rX=`cày Ù`o dUØTÍ`ãVÙ!@Y\!¿ X0é à w` a½`ç!F D çX`Z#]7 KÙT @ýmÂË!X \AX Ñ@ö\Ã¡ë  ÷@UÐVÑ@|`Y2 Xb\Ú@7à	 ( ÀAsa àcQ ~B#  á â(áÁô D _UàVáÀ-Yd@ôY%Æà ~!áA
@~!ò Ö`XX%aJÙ%Yp)¤éajTæá T!Â( (ôCAAI!;! ûá 2àþ×#%a@à¡
`aÃ!I Y ßá "ù#)Ü(|A L"nçÂ!n Ìà #JB#kÃV#tø"±` Çâ
)>T$Æl$`$C)·)¼$E_@*FÄ"²A«sY0 ià  %XÚ ÝeDÃû%uÿrIQVWRÈè§F3Éö~[% å÷A eøFBä B?Bè 	E«Bì 	EûBð 	@Bô 	@tABøEþ$Lz|U} åò´ÆÿT¾æÿTê	VWùEM:þ % %¶^¦e  kô@ àL%@  à  &Þ@ àJY@ $àC#@ àA±@ 0àL>@ ,àLm@ (àLV@ LàL@ <àI@ 8à®I4àJ@' PàEý@ HàA£@ DàB@ @àAÁ@ TàAË@ hàAË@ dàAé@ ¸àQH¯'$'<ÿÿg 8ÿÿ`4ÿÿ`0ÿÿ'c!¾lÉ )D_ ü DD$JÚGÔB®7D$HVPQÏ  $'¶@ "@ 4`D$d  D  4@BCèÝ¨ÿÿHÕ &" Z±´ > 8ð4·ÁáÁé¼$@ <ó¥}° 
½ #   0  u '   µ  È²W³#;  ( !|$ÈÇG« 4º 0  0ÀÇtà @åà d Áè 2Aó¥)@	 Cá + $N (åoù)$@c)DD( ¡pT!CÃ4²@Ã(Lú Í  1. `û@ ë`VWÿ H ü ¿ %AòG /qB#8¦t$0fèÏ(\ i&²%%>TÁ¨z Y¥XHa XÁ@//QìYhÄXL$`\`@TÐY@@-XÐHÌ Y/xÃ\ : ( c &CùX(Ç%%a0À (%§ ¤c¢XD \ X/8ºñ Mâ 1Cµ=(@»/Ã 7C² /Ü& !k)
Û ¾PàÕ(2 dxàÕ @àÕ ÄÀÕ Ê@ÕD@BD§Hé \ 'J%íD%EíBJ@Ú02à Ô&á$b 3D:F@ö(° Ú* ?"ÄXÜ'(B) 0 àÝ&ê e.àÝ PàÝá ³*D$  åD©@JEe`¦`*Å(&Ê`!`$!¿  @C@9D×Xd }"Ë  Ë*ÒX%Ä(s', dï ({C	KD+- ÆDñAa1> ?q9l$21>{CÇ2PRÏèìç 2 k#öÂdâÿ&úBzRB¼ C¿Bü 	A£B< 	AB| 	@ÅM½ @Mµ DA<$·'B ©'B \#gBý|çBì(Wù%n !:  ') .%    ¿_  _,b Ê<P%·5Ì]M%t%=@-#\Áà|$D %À( QDD$DVwX t$3ÀVÀ¿  6?Î,t$, 2H DÇ@:E   ( ^) 4?&  X BMê D  $ 
óXIø ¿Ô Ö Qü(Çó"N  ó\þ È`¤DW\I2£YÈ 7 Ñ !=" Â 
 5C)«TV/`ÓX¸@ÛIüv/Óv<^Ìë$¯Íë2¹Y0§!ä (= \ TYÊ  L#3 (à ] A  V àa 	à/`QàaIà!bAM  ½à Éàc àcO; Qü! Á AÍ maL!Hà+áý§!§=ÁL!ºâ× ÏBÓá&«A¦ X"ÇAÂ cAAø$ (  ## Æ% $%SüeT$ Á$ B 2  D;D^è,Z^_Ä(>ìV '(3ÒH$d9t$$,8T$4  =C® 8¨` %CîW<$^  $ $H 0D 8  @©À+ [ {,D$pÀ¹D÷8 /$ 8$ Ñ$ 4iñ ¬  $ \I° 4  *    ( à (Â O ¨ø !$& 
 6"Ðg{ T!;bÚ Ì!-L °$).b #fL!e 3YÔ %xÅ Ó 8  ' G!Ë GYpHc V#AYâ   à , LË  Ä  Å ¨x`<@   $²X°dßXË  Vd ' lYL  ¹L·  L«  G Y#¹% X% X1i »\\þ(o T `ó¹L!9 4¥ X%á ïMr % GYAÊ  \@S`û OÁá!á n .A àû@û" U MB * ±M^  ¨XH  ô 8i¡Xð  M^ * ¶Àþ X2º!\÷  ±Ml  °aÂaÁâ
NU < Sá
 óáâN "á Ç áÃB8ã Mú  N G Mö  G£¡£ Ð 'x`7ÇMú # Mîê\Ö@Mê  N. +Â~  X CGIX
('®Ç$K ($K £DK T$K#¤À@ ,  = _^Ä$: Ì@  X!ÿWä 
l$ì  ¯XÕ/âGÈÔëGÒ ; ò(Í #Få Ã ©x < =h" ZÊZÀ  BÁòYÆò%ò^%W@,'Ü\ 0`YZÀ \  ÈfZ!þ(¨ àq`<\| !iàa `  àaD$ H  àbj\ !b ± ¡C@j  t@A©\ó ½àÞ!ó^D3 Ý j! "!­ @Ü\Ã éÉ($    E' ("t YAH$æ ¤ } -#ÌÈÉ  Y!= Y$AA 4Cz)H^ø+Þ  lAû ^@F ë  *\ê  R ^@y D`.`oXù!©`,; R ^ 9D ! X@+ë  øZ`Ô ¬A BÄÂB1 0 \B$"mY´)øWÉVñ p`¶XÓ/ÊB(E§tÃ/  &Vv 0 0l  è]@÷ X*  Û\¬ X `"TÉèØF} )YÀ! p <`< Z VY´  u ? A« vAZ @	 (`Q.â àià	_ xà_ 3 P \!ÂY\A	 Aö`\ @	 ( BJ>¨ y DAC7(Ø 
 BÉ!g B  ¾¡Ö ,¦ \$ \"®@Oæ \Bá ÷!Ô"D*µ ò ¢ Aá Y!qAá!0>m(¡5!9*	!Y ^%O!ÝbBâ	! Y Xñ!¢à !@ ³"!ßEXµ%¢ Z#Ìâ  B$G à  ¦¨!=ä O ÄL% f©/áCÌëS/ËvI/½(ÃÇGC@  Ú!n \!Ï X! X!î §O§_¬ c  Í@J 8 J énµ/Ñvµ&úÇ@&@  F J@B@J `jë·@} FÀ}F@ 2à}æ¦æ°}Å/àv5#Áëj@z ¸`z@#@  Càz C`gëº/Ãv9ëAØÇF.@  3!¬XÛ  ùVFV!i/Ðv#÷\ÐÇ`@ )XÒ@% - @M -aV¶t$.²Q°@fnÆ[ÀQ 4$jÿP0  dMN÷À?!²$@#á@9@ 8   8`"VØw à 6à  `à? X wà	? "ýÒÀ   l 	Òu 	Â`ðào à¯ ¬ :àoBºøÆ!`Âº3Àú  © 
ÿ$üy 3ÀÁA+'éZÒ  I  à F@'âà 2@"7à @+¥à 
@ àöÑ c ¯à' â@ à Î@  @éº ,@e >é§  5 Ê F  Z  n      ª  ¾  Ò AA >uàSÓ  Vú?¾+- DÆj ^@!éê ¿á þa¿@? Bà? ? Cà? úà?LÜ3ÒFêøwVê^,@ÀÛ þà+@ @¯BÇøwJ wê9t2êt u*á ï >áº Û  3WSÀc Ê á? · @l  oÜøw1@o $j àV  ñàV  àV ð VO Øà ¿ (à¿ ÿ 0àh ë àh Ú àh Ç  »@ oÓøw^ÂÓ ÂúwE"ç|âç ò 4àl Þ@âçA/bçBé¶ 'à £ "  f .  B  V  Í  Íà}à b @à N@à :@Cwà & à    ­  ¾  Ò  æ Uìjÿhîd¡"ë PQV6ÅPEôd£  ñuðÇFcaÇFC~ h@nË 	 jj(¬ ÇETk
 PÇÜ
FÇ   ¿Ç à 	 ¤ 	 ÿ  Æ¨ 		 è5â| j Î ]@ ]@fÇFX àÍ {ÆMôd , Y^;é ÃAÕà àL¿<à¿uáà¿  à ¿ cá(0Ý h Û jh #&¸ !9á !è×à|à)	< ÆEüPè¶  Ç vAÚ¿;kÇà ÉÇ ÆÇ Ç 	!Ã!Ä  	!­P@ I T`@	 Xà 	 \à 	 ` 	)  
  0 @ âÇF, F 0  ?ÇF4   ÇF  (L[£*ÈrH` `E Æ`"|@kE¼â=QV(+2 »Ç|!(Ç    Üà 	  	 åÿÆ 	 èþÿ 5 G­ Gb­ÇGP  èa ÇG 
*ÀÇGr©ÇÇG  %wB)G:Gp)iÑßËG   0 @_^Yâãß â'Ð$¢ÇÜ"Zÿÿp' aüè ÇK  ø@± Aî  Çà 	   	!!ø $ 	Aø `@ Çd`@	 hà 	 là 	 p 	Añ 
  @ P ">  @; `@	 à 	  à 	 ¤à 	 à 	 à 	 `	@¯ `	 EäSÂC( âSá=o $@è!Yáo   Çáýoáo Q+z5ZæÇ¼	#ÈCºaÌ Ìà 	\r"{"| Ô@èbq /âB¼ Fc"¹ F[ Ç\ñ@ ÇÄ@/  F$fÖF4 Ç¼ ãoQÇ<F/ÀÇAt  ÁÇAx@ÇA| }ÿÆC·"µÀ  ^Ä @ ÇÈ@  ÇÌ @ Ç\@ )}{)    ° ÇAH A`¼ÇA(  $ÇAþ A$þ&÷¢@  ãä'æ
/Rn¤ '²  ôè§Úæ/P=Æ/   $B-	ÇP   ! ÇTà 	 Xà 	 \à 	 ` 	!7!· d 	 èªo w·A­ùF8   ÇF@  78@ H ã§À !¯ ü ºA¯ H\   !² h^ ÇH ~!¸° a¸ ð@ Çô`@	 øà 	 üà 	  %@@ !ª À   Ð à á¸`¾a¸ <@3ÇAÈ AÈ A`ÈaÆ ¯ \"â`¯T   £@¯T5   ÇSÝ ® ¯PBhQ S Pª@  Ý  Ýà 	O³@  ¨R© så) " Çâhà ¯fÇA&Ñ ¡ AfÎÇAÌ AgÇA$@q ÇcHÇA!Ý@*  ÇA    Ã¯Pª_ê^jMêHj@PèØ(òEå«@ à-_ <%Pè!à@_Ié)^ ÇiPè¾×£Qà"=Pè¦  ÇàÚ` %#p'³ ÇÄ\TFTGÜèQ 
 Ç`C ^ä à/f , $ / ! 
 !Nà/á?àßD G#uPèÞÖàßDVPèÆ  # káº` ïì âìhèZ kEn¨t0¨uVÿÄìA1ú hS?Vèä95ù à!`  à5 <"gèºÕà/ãà>á¿bá Bl(  ¢à$ AÆÿÔà)º p+ÌVèÄâàº` =S= Çb+¨t"!¼ á¼RÂh@2/VèpÀS@`=âïjä<Qâ ï 1 
 ^âà[ ð*Vèà
[@ ãOÜPà _ Ñ 
à _´á¡à»@  @àÿ `! ÿà
Cà? à%Vè0à
?âßâ?cÿâ ?Dè×Òâ? ¿ ã' ð(%Vèà¡/ä?#¼A6à  àÿX¢ ÿÀSáà? À'BVèðß à?	è t!èt@Ù¨:èÃÙ"zØX5
7	6iè-}.ÁY¸bE.Á\lc@YF  " 8 å Ð@à$_¥,à_\¼&zràg`_øu6  fà>È Yà>@@èàú^@õÌ]9! óQÀ Èó9Ûë ð!)[ÃÌÙîà ú` àÆ+àÞÀ  à	 :@ áà( à 6àánA/àJ#âÿ$"^bi*á*À8 Bâ q 5{Ý!! Ü¶è[`EÄ á· %AÝØ,!w¡Èa÷£ô *  \  m a?#/ A  uþà5 o èÚ)àÀáëa `_ø `b_ Y à%Y 5á @`Eá A@aÁf    E  w   `¸  `¿! N!ãTT§Tà°(A/à AQ `! Yä|áQÀ Zà LB2Y|" kÀ Á aè`yàì'@½à#@ Àå LÅA ¤¹_	TAY¼`©YH  óXð	,Á·Àf;Á~ ¬ÈTeã !fÀy×V"TÃ<W À<i!C#YÅÌ5@1XÅÈ`ä â@ª` à0¯ Ä`¯\¢üà_·`¯ø#O!áBÈdFº XàfC <EÒ BçmÜÀAäæn Y¡á !¹# ð&!àß °aràkßæ!"àÝàßâmRA¿àGß&ÿ Ï"&ÿÄfÿâ¦ ÀcÙãg9#+ G(Ê | iX±@\Ð" Tèÿ"» ¨"t Øe?Æ4ô y × «  ¤ !Öà  b¿&/ C 
 u@GÀ;  zä ôâmÑà ¬  `¯G Î¯tEJÃà|¯ á*ºÁrf¤ ¯  4 Û _  f  ú` `ÿ!¯ G!ªçß  &à# «áàÀß Sàß!ò#	p"í Âán Èã' (àë@  Q  ÉQ#Ð.' Æu¯ UA8Ç(d¨ ø<d¨)Ð(ÂT©HYIâ$!HP$:Yt!#ëD hØ + @@Ø!=ë*@ À-àEKO +à E x E )dY )A$A$à´Ã  É @ ã @ï $´VBABABAB A )3Àë
¾6 ;ÆOÆ  ôt#òt	øt@¸AAXà Y`w_¶hE× \ !EÑÔ@Ç& Çë3 6q9= À 9: A 13 ë 5^à 0@{`$ÀA f 5 f  _&> t ÇAL  >tAT   ë%`@3P à `@& - i!I$¾Êca ¼e@ª[Æ^~Aª\A$ë1JX 	 ¨ @ ë#êTI$¸ Ý@Ç´   ¿Æ¼ 	"yX¨@æX« ±Ü   `& ä 	 &Xõ& "@Ç   `&  	 &  @   YT yZ1fÌ"Â ã   "7 3  C  Z  B<  B?â>ADB$A$B(A(B,A,B4A4B0A0 @4_@ÆP  ¡ÿ ìD @à
 H`@à
 L`@à @ ø Åà ìSÑ»!P UVW|$(½lûÿÿ+ïG·ô9BGBGBGB(_ðB  ?ôB0  @  @  `  `  p p(\n)@GPBP¸p@`ÇD$¸tÀ
¸xÀ
¸|À
¸`
   / fFü. 7Æ !¤Ç0@ Å L$ ÎàFà Î "à  à  à  à   à Æ #à_ë, 5;  Ô( Ç_^]@[Äá¡âoâ	ibcbo	¶B8A8P6 @Æ` "p p@A,T 	@à
 `@Ç   cV  	 C ¤@  !Û¶$ 
@à¼  Vt$Wù!GFGFGFGF G ^ô@Æ@"ÇP@ `$ 	@à
 (`@à
 ,`@à
Ea@à
 4`9@à
 8`@àÿw è7ª#tæ_ì _õpáÏáÉ _Y@ Æ¤!l_aA(¦¤V¾@ ;F¥ ^$j=	fÖA,ÀuÇFC?ct ð!/uÇFuà!¨  àäßÓi8Bb °6ó ± ÆÐ  ± à@  !½´ 	@à
 ¸`@à
 ¼`@à
 À`@à	A8á%!ª¡%FµLÒ ²!%(ÈëWÉ(II@AàDøt /}AH_ü@!J¡,  á/æ¾ Æµ!_FÅ fËà
 è ¶@à
 ì`@à	@ÛhÅ" &øàú <àú! á á ° @á  á   Ð Æêe J|@à
Iä éê`V@à	9á\ d " á:äðì!ó
¡¤P3Ä$ :WSV%&×Pj@4ÿÐØO,WÛ'T(ËÙ\$$"²T$$Mp 9L ' uOoY8k\ WYOPQë@ë- ! 0 !ëÜ  ( @. Dk .ÌÉö+òÊ\Ñ)þ ÂtZÆ~,øD$©ö@ §ë$éõ Ð 8Å´J ÔJ Çh"$ þ j?ewU2OÄ 3ôÓÆ~
 + Jvë(Jq #»ëàwL+ôÂ]3öZ,-Oò,  .ZÉò$¸ (Ð   8ò ø È! ò ð@5 Ã5` X B D=ó^ à .TÛ@C F!¸@U ð`U Á ? Ë Ø]@O$È ` è$ÀÀ\ÞI!   r	ÎÆóæÉÁè è`?5^f º!( Ê  [ Ì ð ³èT}   ø$¹ f "à'=!®(fÿ  ù!4(Ç(÷ @Áf÷(æ)´$@} á(è|$p! ì [à(Õ µl$` a(Å d$@ QÄ Z  T$(Ú.ß Yß4¬ q  jA Ö  Æ  Ï T Ø GÑ(Ã \$X C ÂÀC \@C ÓÀC ×àC Þ ?ÀC!®XÙ.. T$8 C ÃÀC` ÕO X$ "i !j !Z!  ® ( À 2Àº ²  *$(@*(Â"`,(Ú$Gv wßP 0 Á@< ,àÐ$ D +`Ó"o \ `\   ô(Ó N ×  Þ %àQ!@ÞXÙ!" Ð  
T$< $`Ú J Ú @× Î ¬@Î  Ô èùÎàÿ j!¢ á !! @® !Ì(à  ÿ Ý ZÁ Z ª!2ájº!p ¨ Æ@P!s  `  Å 1h ü!É TAA ò`úÉ!àÉ ' Ä,A<$\ 0@Ð  Ö ìál#ä\Ø! `$¼ w 'Áº"  Ó@R X ,âÒâ$4 v FÁ¶ ¿B$< ÐAm,`çè=Íáf» `á!ëC¡|P`åà-óâ§A¬$!^!¯ v -Eb b~![$\!i ÝÁi$< `-ál î!ÃûD? éÁ³ tTÅ"× IAþ `$|  # ãnÀDã
q$d 8 á½ l!½ ` #3èËàÿ¼d&(Ï(× ³ @^Cä@Ï¥MD´%µ 8%[%x%¬Dj /J#½%@$Ó á A #¾E" Y@$ Y \à Ý&d L#ê(Í ) Í I d@@i@@\$h *ÐfX 2É!$@J f !t ( <L$0!6 ¦YÌ  ¤`   T%*WÒ J È " À" C 5 @ U Ä 	D$HRè K2zP±&×ë?H²ë8`Þë.(Ãpë'@(ë ë TF;X×ë@
$y  Ðë@`ì!	 Â Ü#Æ _  $ÿ¸Gz +4Ä5¥(í HTZ$ò &@Ü 	ÝðF;ó·ø/]$!´_^[3Ìèï´| å]Â ®° º  ³  Ä  í  Ë  Ò @ Ý *Æà  é¿SÙ)¾})½i» Ki» Cé*» K Íé"».éu»»i» KÉ»ûé-Ã Eé Ã K#äéÃ H"«f÷"·%ÞiÃ^á"$ TéÃÀ´éAÃ$<é/¿ée¿I7e a#tém¿ HÅoà gõ %éµ¿ LÀÚ"¶"~ D¾é	¿9Åè 8! þbÇ é¿aº¨BEéé¿}Ãáf»"QéI¿â§éÑ¿¿Áé<¿ C(ÓéY¿$){é>¿0ê©¿3ì¿4»é!¿&;é¿@é#¿} )¹t% =)»8Ý÷ëà \@£)î ©Y0¬÷ñF;uéâ«â nº z  s    ­     @  ÉàÉß ä, ¡ó Q mI ºý
WäS Y(]2öÝ(n	£VWL$Ló]$ZÛs( Âs(T$, 1+ª ,ó(ò
° %L$, UI1èÈd]yXÈ?@ H1ñ@ð%Só½Â+(Ôë!(Ñ(Hó3·2©ó}%²X] e RÑZÒj03 6 ÇrîYS&2è Èbs Ä L  Ã` T2 ·x^@YtW ÷Id4!¶ Mâ)"°  \+Ï ?³
] 1`tèuþ|  /
D$LÄ(È3ö (,o!,b-Ï Pà Pÿ³5b ³n Y p  D/N@zYD$%À)rÌfD@éL$HóQ  (SB  \4*/& 0@q p!+Ò3N È 2Í ÞXD$lA) @ \ Á D
4èY½De|$XEI3}  Kó ¿Sz!3³uÝo, AI li©2¨-Ý < ÓA  öÓi Þ Ï)Np.J-J !\AKXÚ`~à0G =!t! X ö`Ì  !! X  o!' @XP ó ( Ý@1ó x/¦!Ü $b^/¯ Ü#} o¬@À/E® 1NÔï© @Ð$Ä@6  M J Ú $Ì@oþ *qø IOA@e Uá"ÀHD$D DÚ @!ÑÀè»gï! ïL$8 ìODD$? ã! d"#WÒB¸@¼!- üE"ð \/½ % ¦"ª4/#Oq â o Ø@4Eâ X@D \È ½ Ì%i @? #\è»BKl$0/#3ë!Ë  z Ô`<YÕx, ü0YÝ"@@á o ¦`ò `#Ó $/§D$0u1·@ëf\è$(  AK¬ o `" f"þ!  d `!"O© ¯©ÝóFÄ;÷züo ì Gb¥© EÅu}A E%a`VVWYØ9 1+ A0¿Ý{`u$xó(%°@)LL¼p@(ù ÆÁUÆù YþXøªÆÉÿÀÂÆÂ ÆÒU`ùIp`	 ø f 0`_ Ä@$Ó(`VéXúÆé R î   @YûWð Y _ÇXÄ^7)	Ä\ÜYÇ)DQm Ç%2@
!Xè	  î`à  é` 'À`c2Â `ä\ß`êYè#R(%óZÅ3ÿ'(T$ !¡¬ YÜ ## Ra  A¥ eø"b u{5GÆÅ!3íª '#° X®"QÆÃ  ÛàX´Æ  Éà Ø!ßÍ  ÒàWBo3û Wy`Y] Â%Üyq`7 ø _%Ì Æ& &&×"Á|öe 0! 5EÚav@Ñ@©`EGØà' 2" UÏÇù+rá÷F½YPÆÐ`è:ø@#(·#X`è 9  Á  |3´&
(ï >è"Á!¿DK #S ñ#§ õ$ é(á $³ ·Å ($Ã#Î P$ Å¢a Ç db
Yã) #3¿DKYÊ R"¡ &SÁ C× U Ü  qÄf%( $Î P rP&¨ JàO$BàS`F  %¦± Á`H E d =(D c"   Æ r" B%N&Q$Ù!XÞ`"%W & å` Í%N &0<F@ $àÛà(Ý àÙ @@R >!    BàGA#8 " Y@È!Mn`Ç%´5 ´" B¸ @Ô C$$"D  Ô$ènµ% Z  ** 1 ¢ X º µ@!» fÚ g Y&³ B)pî  Ô!¬6ç qBÇ Á(á) % ]C #Èb D@wa^1Ìa^@  Ñ!<  T "  R ã âCü TáB p¢ G b`N`WàSD S"ÆAY øâ) D! R 
@¶Â) `Ê "@  å ,àaÞ à~â  <A`z BàG!­â ±!¡D÷ Ë L@" ¢ BØ P"ÊèQ³$¨d(Ê µ e Ýâ1 ¢@R@!¼"  z@? Á ""EU b® ¢'HaQ "² r@ý \@ TJ È7âEÁ [â P b PAQ#ÚâpEÝ SâCý d J!] O@çÀÊ ó¢>¦ Í9 T "`É! ; å! 0 ïYã PYÂ"6 ÊSlåA]b¢ f£ü d`4   L %® D! 9ÌA{ Y%¥Yü A Ð 6 ï' 6a[ d $" !! @@ Á D`è=±"íF¢)j YÚ(@Ì@µ)æ¤$0`TB
 a `@#¡%pXÂJ 7  0 	:YXÔ  Ø  T$Ú ´I· ©·$$ä)º'|'`ÝøG;þØ/n_^BÏ:` É¿BpVñ¹O/ W ; Nn¾ °'N®î¾Á~
 0 OEë(ÈWÉë'®Å.oYÅÌ5OXÅÈ .Å 4 5¾
ÁF4ÈÁá)n9"I( ¬þNªØ§hLD$x [Nê(I Ø( ^ í@/ è /;X  "F,#ÉEdvJ >ØF*b Î .-(\Ë  Ó  É  +/º\Á  ÿ@w\ð  é![@ ° /Åv9 <Ì"@T,Ü `  Í @ RàH@< `H   Hë7 *% Î ; +,àà8@, *`8 ¤ 8  Õ 0Õ(á 
ÖT%©A#\Á3À+gKW â!c æ # à ¨F(* áZ,¨XÉODB¡ !=°H  ZFQ$ºAGAA¤§o÷ oKß"¢ n!ÝæÉÁè"©è]A¡!ã^@? Z!YË !0û ð!¥èfî|,/ `~#Þ%úÀ#ß h,o°)@"û |Að7u#s = -H l @iD$tèµ­# , @ K @$+ Á K7´X@³@1 D@  - F#u^Ï  @O D ^)ë`cèj`J|$h(÷(ß#f .l>ØI·YÆ(ç !º×*-&`)tCÜ=¨ ($A#E-(yD.KcÿBÏ)õ Y#Ï \.GXÓ Z GEYì )v )$eHN`) æ ) è )Üov T#ÐF `V à% ¶0N'NYl$D^ â 
 Ó  Ã,Ü <"(n½ *n 4 P à@$üâ!_ ¤(Ì($X  !gy l X&\Ð ) XÁ T!K¬AiDñ%²!# ø( MâÅ(A%) Y&¼ ý@7A%È)d ¼Qi7-ê! XG Ö`z®Ì0,nHuaQ'M
 ;!F \-µ&4 å#² ?³ ï J%ÁAH;çeÈ ê  /"³ "¬ !@+H áF@g L$`F/¾A !à'YT@Xô  ä ?Å_ D $\ Hd%Èý!`BãXð u  ©K! ¯w ;ÆB i J(òa¹A¯Àc1Y ,:¬`¬ l ð &DÄà h"(! `@N"6 ô @ ô a [ BeAÃYñ$À 6  Ô`£ \ £!A= û 2 D J ax 0+{A¶À"Yé`C ¼`C\à#:aZÉ!@è Z ï '!¼a£ g£ ù `Ý`? ¸ ? 3 BØ Ó"º/(ÐàC  À1 "!k'm@ Á'J!C#å)D+& - êL$'.d O!Ç  p $7 ` 	ÑD"Á Ú 1 X+6Xô  Î"ÿ i
!ô"½!ø!>  Ñ1¡ 8'GM À&ÝÁ@Eb;ÇûçNçOWùgP|VZOgSÿhç-S UçS GçS o"& ÞA,& FªçS ÂçSm1çS¨%`fþçS $F& X@wÑ \ ç S   çS ¬ ` 0çS@< g ` HçS °à8@,À8 d 8 çS ö µçO GçOÒJçO GO}ç%R @$*öïçQçç)Q <#6Bùç
Qc¦Eç.2'Q 8#kçQ <@6Q F$ %a O'G #§Q `J |%6 ('J#Å  çQ (#úçQ ( "ÉBÍ%Úd)çQ )EDÑ@)çQ ± Lv$_%I 'N;&xgLâP@Ã ,hçNYÍN ¡gI , ïÑ&U < ;'ç-Rø¤Aj; 6!$ tDÛ$° +æ.YYÌ®Æ)\@®Q \0Ü@Ú&V T@æ%l§= GQ ü »g_YÖ w(%°e»Fý&¥çOGµÇO& !gO&WGS(ÖMç	OA­ÇO 2%"M `%< L  ;çM@(GM'y &2%ä"( h'f 'S Ld%&/ $F/çS 2ç4S ´à h ¾!gS"8çS ° 6 ç4S ¬`C!=#<aç&S ¨ ? 3 BgSSyçS!v*x"÷'SAm çS HçS !§C"'#:'\gS"dF Ç[0 Y" Zç
V =uÜ^&>9  ç U î ¤Î t/$ ¡ý ß p  S=Å8ß  
VWj`<ÿùèåá|M GÄ'YÀ=gÏj%å NÆ".D$0ÿÐØÈ)|g¡& LMû%H,¥  -¡ Ù" `XÙ I L@YÌ &½ÅÁ~=À Êï! @7åXÝ @Ã·À @ÞWÒë^:üÏ@7.þ!gË@Ý" j@Ø!Ï<ZD8DÿÐÙ,H ¾8Þ)Ð"ã1EÃG5@$ÃDDÇYÊ?²* $ $)ZE(ì LS ë  ué  ¤i÷pò*á %÷è Q*è½  I$X! #X$Z$` X & u;= LW L$p /$P/ LJ      91À x %¨  ¬±6%{ h` #l$`éã~  N*Ý h H $``!þ*  @`  T X  8ë À`à
=àrà= ~ë["*ÄÀh `0Þ V%Ø!I6`ò  Ô@ \@Ñ Y,¼ ©  ê @$ !²  D` d$XEH câ +¹Z(Àh ê dc 'ÎÆï± Ê"P  ï±´Þ_d©(ø/{#æo«   H$G ÿ  ù1û(49 ÷ @$> 'íæ)´oë _'¼jD$»"a X&@7ò"K5 G¥"kPg ]ÿA#­=8YÓ" z  s!eÈ&Tl =f¸-ï"Bª  ­ ;SC>N!|à'M ;/ gX M!¡ F 
 !g à"!  h%Pÿ 3 & Sú$¶@# $8b( X þXL$# ×( H' ° Y$%` F§K Þ (ÈàÞ! \ 9àä \#ü 1?R O8ö`çà"N4õ X$à R L Û1tXDY¸ÈAv L`è;Qº õ *²aÒ¡É.L2(@S0¶ Å í MáØ á!Ø® Ú`Y!ÁÕ@£`F!rRé"&!_ !H ×OIÝ!WáS | ¹AS $¬!Î ¦!!\ t@a!\!ð XÝ!  J !÷Z^aB`á û@+ L-;aÖ Þ MaÖ 8"¢á	Ò%È`~ 'u2½ -  C *"º#k`Nâ % N Í"W DbW@[XßÞ@Í8¬áÒ$L`$áÕ #Tèbàÿ|$,uS& H!AX9A!»6Æ2¸  Ë#£`@°Ë t&,C{p>!_rÆ â yì#â@*ë"¹  R~.!C#Ä7³  (! O! Dï$ò ToÝd`îD$ )ó À Ö4ø @=ó^ (^$| 	_^[3Ìè| ÷ìtÈf%n LI!Ò'~wº_	 (x\$|V'º HOW  X@ h@%>4ä(x'Ù ÁgÙ Â÷,! A.l ¿ Ygæ ÛD$0'ft+ ï LQµ!¥*ü  X`  GS(¦` ë D$<Ì!
 (´e3ÿ × Wz&ÿö±!  F5 DIóÿ/_ØF2 L,Øæ/ "æ	/!ïF, ôF$"9Æ FL 8d1  Ó\$)'@b  Y#  Cæ Y,ÊyÜ Ù"¡ E TyN Ã!: \-m á ;#Î Î @ H!4  Z@`| Yä ª ( Ó c|#(4ãÑ +A² qcy,à *2¤D^@{ã @D DO>#| ( Ò È/f H`¿ P$ 5â èßN ,C¹ã!¼T$,"ÿûGYÜ[þ"ØL$|ÕÃ|9ÿtÂèìEÂÒ$$ÌSiÉ r l+: 0K:ñèªÖk:N«ñkGé@âÞò-¬Î"ßj+!-bä(J±&c @	L$HÿIÈ82!J X^F8+ !DñCå \ + YDwaj 5 LC' t#tL 5 °)É  ý`!!!%æ -JNL$t )6  LCgug(£J$ 7ëV3"`$à6 DÀ6ë3 " DX`  0(#@  Àz`+   Q`& ¼$F8 ÏÃºÙ+ôF4Iâ  @  ïÿdY© (ã  T#éÒùéÍæÔ# (¾# µ Gc È ·iÈ o Í!^)Ê ÷#YãV !·&å@!$ \ #!¤ ã!åXæ@M a¾ÀL T@Dãè d î` ç­ f l£á c3  Á#/ d`*#¡ . Óë ÆHEG Ï '{ä j 2@~ \'ö È `S(yXÚ  LR\ Ã C $ Á`L@G)áàK`9 4ä@@O D`O Dr}'< L E@è§ä7 Dd7"W"P UcOcB  ÜL$Ý',÷¨ý$RïUm}| ÄDK¤X  ìCä_N5SU¬iA0ä`IÒ` äe`¯ä`#æ¤` @d` %ä`(Ü!)ii  !.#¦a&AÛHÑTt"IDøÓ#Êÿ$Ôí#Ñ *<W>£ã I | -D$$æl¤g ,  aé¾ ;`" l`4 4é¤À|(d &ÀR@: @5$¤ÔÀT4ë+¨"u \Ê 	 `^\\Uª\Ä AÀh G#_  /ë' ä¦  ÚÈ 3  _@Ô$¾K 3Û!&ä	À   D³ ¬ä³Lf àCWnËÃ®##ä¼)Ðä¼ Pä¼)¸(ä+¼#[!# ÓAd t:  QGà Þ £§BhZ  ¾!y>`¼ 9à*G = TcÒ@M aÞAi@L T@¼ @ \¤¼ ªì j '"+¢ >$¼C D¼ \@2Vé .ä ¼65 DH§ SL¼ 0 ] C@W`ä¼* @Öè ý86"A@OD$x Ed¼8- èênP d ÂcG L@®"²YÄ(Ù) 	2Å Y3N$p¨ \6ðXäí ×@+/N`% Å 6ÁA£12   éE 0)E e
Ý\Ý C;ßiýdûDë_^]L(pxDüAI$ü
fîé #ê =  u ¥
` å"9Íåd!/ F$ËYF$× ô -äó Õ$àM)qY\& -½!0Ar@5ý!H"á" <dþ Û#Å$þðòdþ¢>û a Ld/ \Dòb 5½Éh éÄ = DÊ@3 -%à -L$0é¢À!åÉå B@:ëj Jå"?ô \" " < q)© ®  7à zå@! D`Ö& - D¥ 0å 8E Ãå ä-ÿ Ë$ÿ!32ó$£ í5W#!
d" b ä%ü<ä8üé¹FÛAk "4 ä-ü`B(6r Ó)¼ ÜEÄqÿ¥ÅEÑBùåÉi¹D¬ Ld¬ü<ä$ü 4ä"üídül$dé"½#{<u"®lá32#Då$Õ X5¤NX@@Ï  ê  âcÌXëbÛ:c(Ñ( é  Ô  ? YF!/a@÷(å Hå KåRsåíî $ï F  ~ <Q$zD*v.Â
PèÊ ÿÿÄÂe7à	Z¡à$fw$btó ÙA$ 9ÙA(`   ÛA, Ù¨9¸  \ ' P  V  b e  @o OuÛAP -øsÙ  à B *`  /w6 ô@`mA0@0`y  Ç å  ?u	  Ù @"À Ü  Ð  Ö  â `\  @_áª£àÿà¤à¥à úàº¦à?¨$³ Ã © và  ùà$Kà Ô2Nàdwà? °à_dà/fÇA`$WÀÇAd!V ¸ - ÇAh   l   p  Á@!û)AÀ3³)AÐ  ðOÈ ìà}ÌÌVW± < ¿ 2 / ÆýÿèçþÿÎè~ Æ # Mïuã_^ÃVñÐ èb p'  ^éV  L  @OP=àO 5   O . àOÇK@ fÇ¼@Ï ÇÀ`@	 Äà 	 Ìà 	 Ðà 	A-@ Ç´`¿Ça   N ä`Çè`@	 ìà 	 ôà 	 øà 	 Ôà 	 Øà 	 Ü`	@X à`	`X !@N `@	 à 	 à 	  à 	 ü :Ç à  `	@X `	  FA       ÿv ÇF ?ÇF@   D   H   $   ,   4   L   P   T  (  À@è RnÿPÆBÎ °^¢!ß"\!9 P"Ö 2T`@	 Xà 	 \à 	 ` 	)  
  0 @  ÇàÍÊ ÇF   @¾ Ú  ?`CQÀàI)F` p)Vô(p©.´)F   0 @è·N@p ðCÀ]À_h@# jB0 `#­  F<Çd`
 ¡hà 	 là 	 p 	  ò 
  @ P !?  @; `@	 à 	  à 	 ¤à 	 à 	 à 	 `	B  `	 EáR PaC !JB	 0  ÆF8 Æ!jèÚÁ| ÇÌ"i  .Ç|@	 #4Ô  Î   À	a¦SL[K<YÁóXH`F( `ù ÆaAÇa!T!èaÓEáuà ßáÑ  á ZÀáà!¨è¢ùÿÿÇ^" Fäã ³aÊFÀá Ê¿"ï\Ï ) LÀ@ ÇÈ@  "t @ Ç_,@ #.S NV  °  }à{D(d!`{Cáà {@ VWùp'CèáøÿYÈ BGL$Æ"¥ È¢Z P"­ ¢­° .ÆÐ Çà@ UÇG{ Gù Ge{ÇGEx « GY GCY ÆG< $ è¾| #DÏÇL#`@N@® GÛ ®'7@«@ / hA-do ðc_FLÇææ	6!+G G  à Aá9$!8?èà½-ED`½#¨    ®fÖ 
.ÿ¡á¥Ày3Àë
¹ Ë ;ÁO#ë[ F8Àu8ë$B#õ N.õ à@øàT t 0!FHÎ¢Ig¼æ{@ á  @ ¤`
 ¤¨à 	 ¬à 	 ° 	! p 
    áÀ¼!¿F8!¡" Ça!@ Ç! @ ÇÀ	 F%T  á_+Já+@ Âë :` !?h@" j!3\Pèå»|Aé Ç&  ÇF<   â / W 0^@08Pè´0jÆJ ìiÁ | Æ ê Dà  hAuC#tèeNà$@^yPèB "j@`µPè2 `" ið@  @" ¨'@  Ä0éëê Ý à@!µA<@6Øº@6à   VA4@ »à
  á KPè)¡"Jì¡" ` |*ä Y á"@ÿ@@ÿ $`N BN Çg®!¢)¿?á V@/¡Ï`/ à/JýKRDJÔJcDP ÆlÃ a(Iª)I¿ÆIöÇI× m I*`  / ð$Ó / @( `    ° Æ   K 0@`KIzàK@  AI0 OIEÆI 3I]@3HùI ÆmJà	?  "8 ?FÄ M 0 ð =ÆA9 M P   F»àA 1Fz ?FÆE 1F§1Fqà1@/&0 /Fs  À  ÆR ÆR ÆmÜà=`?A ?EÅÆEÿ 1LoEà1 aDÀ /DÕÆE /Dí/Dà/%¨L$ e®ó^Á/QS"FWQ¤!% `F $èï#_  >^È%È]¿%D   xÑ_þø ¯  S  SYË3ÃÀ[%ë^È'u ,É(ÊùLË¯ÁJüà!JBðBäÂ(+ûu­_^Ã[6X!-à6Ï - àÏaC ºA½ !¬3!*ÁS$j ù!¬	Z -B·E!#  !MGr  5@  !y =!ñ !a Áá AÃ!ÁMÅ;ÂLÂ
! *¡® Ð = MÜ( DDD ² @j Qù 6"=q×þ 	@@jQÎ V ¥ëu» %GQÏ y"u_^°aó a áT$$TV¾A72  @õ Tõ  Ê Âàõ($;ÆLÆ
¯:àõ,  #kä%Û±DÛ ª A£@U G£Â¼    Ç ã  ô@Å  è¿\@>à=à&?o^à?áO$ ¹AKÐ  È`â FÌ !%áP;ÁH$LÁÎ 
áRL  è\0±(E£ °/ ¥ ¥ e¥ ¥ Å¥á>á?`Å"ôBC. ¿4[  £'~LjV| ÅNtàÂ F;Kà¿6ü
9MÁ  ¼ ¡d¶C L´à` !ÉáÏ `%ÿ ~PT èÏáà
? Ì%G³ C ¥¥q oÅ á$Í ~9 º@õ  )!²F êãñ & k¹råù`
£ù áßH!¡À!ÀF¡F A Nà¿ `&$@E X\`à ¿QM@¿@$à ¿) ¿#Ãà¿ ¨ N ¿@
à¿L ¿1lG1G0@¿û  hû@ ÆHààH¤àp¹à/ ÔA|àH àmóàGÐàG°àì4Ñ!$ %A£V(ÌT$Wr3ÉÆ|$HÁèt$$!Æ9kóæÀ8ÆÅ^!2 Z§e;» ;Pí	*B; _ Wöf Z @(Ö %;v&C ¢h Ø!è@J( % Aô@B@@>O   BJ  @ ªÔ`Gz ¥;2  l$!ßûó\B4 I ­ X" X(J@ *@?YÈ`SJD #`fÔBHö."2D$@² ZL$Dz`+ÈD$0!   $ (ffèT$ W / : Í 
_ü(Ã ÁáÁ = YJ@ Y 0  B@wNÀ@Â 4&x@Ð&GL\ñ  rH  Þ ¡t$  Z `wü Ý/Ãv/
Ðë(Óó]9t(ë ÐTT(ã 2# @0 Y -YY%Ø)e a! Y(  @ZX^À/ë@V ÕàV :fC@^[ 0 Xà D	FÀB0À½"d 1jP(Ç '(  ¹B ¼eE <\D`YÅ tÀ`,a`%	,Â·Àf;Á~
@7È£ë(f.òWÒë" Àe2@+YÅÌ5TXÅÈ`JL BT!hAq Ë # ì  dBYÆ 	!Am Y!0 Ô! T@éþ#0Có#k A ¯Cc  W>ò 2!º& a¹ Cá ± á  bA± QYRA« g&XÕ/ÂAT àAT â!« %A«@7Cy#xáT Ä`,Á¬XÕ 0¡À`cX/ê@^Õë [b * [á° #í B 1"!À Ôè t99®t' uO¡Æ8BG\%0 % BRÖ`ë- ! 0 !ëÜ Aõ@.¡è.B¢áö#,Ááö áö Éáö +YÁö Áö`g Úõ X$w Y$2¡õ Z"YRT  Ø  Úá÷]®é%åø!û#ñ ¦ R â`5·o"O(*WYDcdF o!á Y!ïb#XÐ("Õ  £â %jYRB ê l?@  jB" W @Xî/ÅAÃ ÐB"!éáÆ(#ÇÃzXî  ãËÂ@[À{X.à^ OãÖz àÔ ·Mú Xü ã N%Y@õã

 §@2 : %XÖ/â@ò Ü@ò Ú ò ã Ëã?ï , Y öAâV@ W Ôã%F@"þ&¸(ÆãX eã ä÷(Öã  +ä÷B´jL"° $­%X\Dåäú"°"'ë	 / ! <0ÆL:hÀÇ&»0l$(# 7¯ ,'aFë (#H. i-H& -4 g-ð%D*,ÅcÑD$ eÊ -cÓ ;EÊ  Dp $(î(c, ¬DC GåÝ è N ,Ãæ ,Ãæ5#3 à7 @O@A E« ] PD% dEÀ, N¼ rëÀ	 )èTG2 0`  ð  w-ô r- 
 D` \#âXd`ZJ8/Ê Øv  Ýcó¤%!® X$J$`)R8Bý Ñ¥ ì`#\z(( FY=X=E)!B ÇáB =aB (AB" þâ ø = <Á/ <¡/\üH(ÔA(²)!Yù Z(E ^'rBFÀ¯Yà@å _%8\R< @´@ @ YB-R4;Ï öÿÿ_^Ä4Â,  UìäðìM
¡¤P3Ä$Ä$(EV0a"A$M  *(X G  l(6Æ'yUw<H   Váú  PP
GT$ )IvT$¸ = 	0P¦ 	 Ie .T D L$P9 ò )D$p(@ $EÏ  ¶@0$z	¶Q0½  ¡ <T  ¿ ¤`Pº  ¨`P S¼-ËpD t x<3À@ZSÌ!R\ ?!8$¬ 4  9EL «Â Æýÿ! ( ½ `   ¦$Áà ,C¿j0Ë . adø L Q ' l $ d }dPR pPèÅ6 KÉü&¿ O <.áXB&w-hw) 
 J#åY   Y ³YH$CY [B}QÖ $BYZ 0D$)J=@ @-(à ( z#TY%@"D ~(K|D[Y=¤!@OX%Ü¶"Í2 à(Ã  Xå&÷ 
 @7  ác½X, \Qªd$h 6 &  ä   ,F"¾Rk× Õ$? 
  HÔ"¨YÂ(&, X $å H²)½ X u )+| / Æª# (3  H  $L7o TjKÓ(Ùj`# \ ] '$þ`' Ø×ÅW + !,@ 	W d / %a (AP Ï# #õ%} KP@mY×Àd û X$oA+ \(] I y@*Ç !³¨%v dÐë!  ](DÑ*!<T@jT+u`nA:@hJ%¨@ Y%, GlyXL$'D ÁD Èd8@_AðVüT' Ü 1j	 \)M Y! @c Da1a  4  YYLa ãEN!¼  Lb4X&1!@Y": $!á X æ >@^ G"KY_ LIºx^B@¿ Y F  é&ýÿc÷#! 4&ÉcFÿt$  #F X  D#1DPCE 0 	HPèÒÁ#; D !T$Â ! ;#«mü`N  ,ÁD$Z}@D$0Æ&ÒC ,#Èû 3$QÁ_^3ÌèÀK;àå]E&ÅCÂåô 4Z%3ö%-æ E K#ÇHXî+MG  ¡EERL$Dèäªûÿ;t  T.­ @,DÐ3ö K9uÝ @ Â}Tî ¯(@0X7ß À!?uîEµ   'Ó	(B () î4!>.,!
)l$ ¨@\(pÝ{" !ó(ùÆù ÁÆÁUWä(@Yþ(-°@	XøªÆÉÿ@@ÂÆÂ ÆÒU` ù` ' Å/¾ ` ú/ÌY  Ç#^è`åYÇ6* À ²"×Y@(@jC© @	ÆÙ ÁYÞ`Y%À@ X#­@§  Þ`à  Ù` Ø`ÚYÜ)K(`Ë\Ç#ë (!  ð % % @(+ `Y	A:(aðY-ßÆí +- %`¿)!\é@M)ið#C 0#¾ÆÊN#: `¨ ±ddðB¡)þÿÿë@r!° )EFÁ !ÿ " "ÑC$Kb(Iâ À â" V"¢ ½$E 
|$hG8w fl:G tè|F  3Ò&Ë Q? 7MFÿ /<¾GÎ[h'Ü `P L;Î[_ PGÎ¸ÿÿG +Çw|  d"k$+@o '  `6ª!.@F;T$<'«aX¶a@ )§È(@   ÑAd '® Ô` h @(G¼ (\   Ø` p A"él  AÂ#'ê.E'Ô Ü 1 " ¼ \$GhPD$p ­ @(@A D&y 1Hró~  fÖh( 9$g=!* õ$~§þ D ÷$° D   CXÌúTÌ  4RjP y`PQ lPÐ è½$Í`"@T &!q 0 ®  DRx@=F_@WMD"/ ,ä ö, ª#ã  w J \ @Ç`@ (A# iE#G(M%·@$ F-%ª í 2 8   °áÈ $(j&Z , ¬+ýD$`l+ÿ +Jè 0F !ìFYÅÌ5qù jë %*¿@ÈÄ Å F¼YÁ(ð  5hX5a Y X÷ $Þ]5L`6 ¯AG4(è@NèÁá Ü!Ý@Ì¬þ ø/Ívf )ØL)(«Ø'd M Ý ÿ $Qó \.Î %G  É  Á   0@ÅÀ4 \(gæ@HW @éÅ!o $°`r Å 
nþ v%m\é  @% Lg âàh,Ü  $ Í Vàu ,  LSàp   pëW M @àX àà(X ¤ X V'Ö X3'X÷} ~@ç!V!\ F%8,^Æ 3'Iô¦?@(×" ,2 ÿb  f!÷.  ¶4Y!A¶!¯.ÜF!±Ybz6@kt$&® 4;Ât?.¾d(Þ $ ÝõÏ7 !:Á Ajk7JYÎ;ÊuÚ :h&3(ß  N )| X ÆHê ^(#@  Ú !Y\$"])3 Ài{Y` @<Y|`Y`<Rf\â/ÄI¡ ài¡ %OE ^ ®CÅG	TBl(B×`)¨(Íÿ$ # T@ÿP \"øYô0ï  @Ú@
 LAb@" @U  B¦@gñ Ì Ìré@%! (à:*Ö@. +Aä`: ñXË £ / :@
àu"@. + Ø ³À`: Ê '	 !j!Å@w@à< W@2 " Ð#Ä D¸ýB¼`VAà X#à  À   Ä a  È $ÌOB b@ z"`*%¤ ,åw 9!oå¯ú&ÚI¤ÅÅ 8 G ^§J P ;@%´p'  EÞ* 1·%Ò 	"ô  xE HGþË1F*B1±G|'lÏø çï8AçIï=_çýïçuïµ"çï Äet \ç¹ï'á /Çï¨ G¾ÇºïX@&»ç/ï \ @ç ï  `r%Xçï@% }$ü l è X,¬  | Í çï ` pçï@àX °à(X d X E'çýïçýïçdï¨B'ï ¬`çï °çï ´çï ¸ 'wçhïA¯%Ò'åç1ïH9çïNì ¡÷ oUVñ.& ,h WN,é¼)rF . L(á( (¤ 4V^ å7©+UAoÚ¾à (NK( @ %$F@ (2PÇ¹*¼ +×( W}Dð2mðG ` %p+Ðfà
 @ o* +4úà@¶G` ¨Gl/êoÏ¶Ga 
 ± nGd/¹ ´`	 h 	X-Gp|)j oà!^ <)  @¾ à$¼ .DøhÓ89U3: È/Oï  Éà (8?ó	?  E  ) @@AH gWro)ë Ñ i)­   	 dJÄ%'%O  DQô5\2) Ä" ,¦^Å ­ $ \$ KXí ; */Q 47xw6±,Ý ,%À !+b l5Ë 2WY U Y+¨"Þj½L¦ H-5JÆ-,Kô U  x t%¹5  ÕWË Y+(XÙ $   I@Q\$/ÓLâë(å/J ã ? @Õ,-½Ë(ë Dv H 3 -Ø/ L@ÍM` lv  @+XÀ ^w
 R TC ]7áÀ\ Ê \ =ÀY |AaQ \e !t@÷@ óf!NF![Ný Y@ª \a Q_L¬ FCô! §@`È!'p ì C d@ºd@SXÛ !!8 2N v lAP   `ZTº!RXkX8  lw(;®À[ X`2A\ï iP-pXÕ @ i YÔ(ãW%XT5 /¿@"e ]N\ |Aû0h Mû 1¡À` Y"AZ¿C@B pJ c ¸7!(X \anb¢]â|$4á È 'à\A± be FO V"XWÐF@õ(ÌXÐu  G fYÂëP@Y!0 "u1y]5 q") H ,5 y \N¤.Ä$x    Q9#~8B$8;#ÅC7ÇëCBCN   ³U) BM¸ ÁW_ $$ì (-@L@ûÿM@Sçu0÷3åP/ìxÅLD$t%IÁVW3EH O 5+ E6 `­| I \+À4 )U@#ó8«	¶A0;|$D4R¶A1Dñ%8$ 3ÿ(A@QA4@6! A]$TA8@DuA< XA " \ `9}v| ý _FX5Ñ)Y	7% 9k6ìB¢$¸!m Ä!0Bý7""¶PPÌ\ãdCHZîCH!á@,!z Y0Ç?¸G;}r w 1&	ÂD$GA Ý6 /  |ab2áb_æ¯E!h&² ÚW!¾F<~ W
L:F$t	èÐ3  !è &ÓVy ÿÄ%ÌGÿ  @}pw9¸D$8ÿ& &¨!4G$? )1& $!· 	P=>iD$& D K T&ÝÁ+T$4f¦æ¿ðß ]` *&â Æ¿à   °à  æã #¶Ð $© Ñ89"¬!nAl&éô Aæ ô Aæ ôAh&æfôAp 	S6"PD$U¦é È,3À  vRj!Á  D !=G, ^!jP>L!*;)% L DHL!_¯Ç² W nTPèx¦(ÈÀ!y  Lv º!T Æ5Ì]6 @N "o ,a-EC$Cç_ !(Ö &Ó\P$½`$ûG&Ý %ÔXÒ á DE| Do :  h$XXÔ < 5_-øJ%Á (&:@"±Bµ!G! XÎ    $kE\ú  õ )Æ­ øç X3ûx& Y=$¬0&«' Õ$Êæ
¨(&oÅ?@. %Ø z'&e¨ Â Cç | !0XàZ Àåì@AV`¼F <%8Y^@LCÓYfDA!»#ÝFEXT¬@¹ETEH"r &!#µá Á;ÈU:s FAµ!ú !Yb W(ßD$T  4!ý4Pà 6B(Pèk¤""oÇ " rÁýÿÿ¢Û#©=a #  ]a D+$0 $SY  8% %Ê2Öå a.ä2UìD/ êß  :´ÑVD($JE ,"    E .*Î!	=ÌB²À"ÙIº("+E!%d  	Z f#ü@S  F0(EC 5_~%©`F1 aFÅF édF8 h6Þ)D?Z (+TD$p ñ9D$W @s@ P F<%ÿ0D5"Æl} 6­  ²  u VCh #XFAÁá%Î @ _ãBH N"÷^Á%, V ^#'_ôB"mJ4$FG( $tP ( &.Þ l=â "	l$öÄD s  B#y ×"O"Ï(Ï":ChG×ul!/ W¼J z Y5¤ ,óXÏ@ `&"WYX?ê [ ##·àN `'" N ;  #à K  `' Wü( T Â!¬   ~ I)ñiW9,Yª@ #YR xo#¸B(ª X)aØWIa/ÚCÁ#]Ú)S(Ç£i(ò 8 J!E XD95Øc·cf Ö K DiW@[HªXQ }!ÊA B7ðàa ^à R A ?b<  B'ÑaYÆ   A* 2sW*&X	 J±BD  Å `~YB#ì!¼ Xà!%  ¡T,ôó\;Y²WXÖ @Ãw U ¹  Óà½(ê 8a T@iÅ1@Î \,a%  Ã@_ Z V ] áz#& (á {"`[@M`I!- J! Yb àB,`÷,«%Ã #@ b  XB' N! J@# D­DZ D#dJ@ÁDzÇD $,@&$!h´ß)Ää hVWBJn]Ðä À'äp#àHºØDv D( ²B²  D $('ù$ #É $(   $} ` A4 + dª ) AD h*Dj$ Ad%©$m Á@D~A<3É!D$l < $ô 9M/ ÷ ( X@ÁDk  d(Äk  !c Hdo  Pdl$Q I B y!µT$v. § 'XÀd} ä } 7 b#XÄ(# Ü@`[eF4"V"®ì[]Cë$W!ÓÄg E  n#Îl&c(# FþX_#DJÊ" \#§gæ-] $ xF 3b Ðç m Y-æ-/ÕD$¦ ]$1 }Ã Gw:ý ×YJ ß=ê@* ­LB\ó @´ Yj Ù` *oÀ eà[@SDdBC=@B`> G ¹ãþ V#YrBç Æ;R" åãÿ`ÞX âãö¡G æ #ú ê¥/ ècn l ¶ % Ó#£ã`µ Nqåúå \ j@± }¿ ãú àZ 0á  ÷ef Z#ñcûöO ü!åb7å Äà ÷(ì¦ &? F6*"< P¡XO%hD,á ®e"« à¯ /2)õ%|]â Xá Þ z Ä  @ á  GXW@à[Cqá u&óÊ6@N G Âa e ZB1'Fa#2á XË  H!	 E  J ;#ö	Dì D%d ÇÆ v'å Ï$ÅìÁ¬$ÃVqx;ÎL!p y -B+Á 
kþWä 
 =ID9 Ú!ÃA YQ Q#\QðA3À/ÜfÇ ÇA W@L I F(m #$IôfnÀ[À.ÄH»	{tTÍ/Ëvl I$é[É$×TBâ"º#^ÁZÀòXØ]ò$  òÝ ÛA"Ë¯Â B@Z /Ð/'ùQôRíÆëÐQ$õ  · A@ülh Y ´ÈvFÇA%á  ëAÿuAüAðÇAô  ÆA ÇA@ 	ëAøu	   ëøu % Á(Að;ÆÒ+^ÄÃÌà  Á v y0 tÆA0 R @A$éþÿA4 uEó)!pÀ)A # 1@#  W Ã&@u  3  Ã t @@tÀbÁ +é\ýÿ`s!ß/¾`K 10 tÈÆ@ z @`zè zë>@ |MÎ) `|@Æ@ | @`| óH@ù@ó @`} ó ù@ó @`~¾ Y" R">  b1 
!m`\  ¢) `9Ç¤ A -  !¢3 ¡Û¢6ê ò B¨TÈ"BO ' /âI%ÑâI @9#^"L Á HâL @ vTÞth ëBý C \Ð@Ó"\`%@Ã@-  ¢bÉ/ÁvhÇ`ú@ AAÇ@,@ Æ » A!É  b? `5ÿtË`B "@ "" 
B`"¹aäV±WA
tÆF` ÎÇFpAi^én"vFdÿuÎè   `uÃFp@f 	 `c``  `]@Z` "o â	ÏÄ Xâ:Ï¹QY@¿ p.îà¿Ím fÀ¿`à+¿ À!	à	¿ à>¿ÁA0à	_¤ ¸á:(I`YI (QpYQ(ç Hm(ÁYY&]ð!>Æ Cc0@   ÆÁU ô %`à
Éª ø à   HàÆÂ`U  .@à
 Ò@U à UàÆÃ`U à Û@Rà"¥ìTWí¹_	@cV*NF¨nÜYÀ%=#ÂXP[$¢È YÈ]$YUv \(¶4"( 9µH7 ÆC`$¾ P AZ(Xx   5È£ I û =\$&ð`rYù &¹ | ,Ç·Àf;Á~(þë(fÀy 	ýëä  \'kY<ÅÌ5£ ^X<ÅÈ` Y  X/ò,Â@+ ;õë!)ïà>0¯Y4À> 4 >_=P`®Ì ¿  5_ý SN=H$A Y5 3fYò(ç ç(Þ  Þo@S¶XÜ¶  Hâ8/*» Xe3  Ç ó !,"! `3á
Dà D $à ;*2$ ; X´ là8Gî åyk):./ë@ Ý`.ÁY% 7Îj °`¨ @#!a)q>, fà^ 0à'@Ð~ Ù!ãud ]
D$WÒ/ÐwÈÉ`n    qXÈÔa T!+@LRà¹b\È MùÀ!©ë5 B 2 != ¿J:àH`kL©@6 (àÂ`8à^Ä#NÌ p	Òy3Òë
¸$I;ÐO)V útút	út3Àë¸ ¤ AX@àYúR·
¶M ÿ$ 	ÇA$ÑÔ@ÇA( <  0  ë3 ¿` À ,   A  « ë 5^à 0@y`$ÀA gw5 c 0 \ c $ 
ÇAL  ?ÇAT   ë%`@0P à `@& - A>I$ºLYaE!ÈX¼e@,ÁcÂ~$^Cô!lA$Â C 
 ¥ @   ãÑAÒ Ã £I@4L 6     4S e  u    !@ K$8A 
W¾ ;ÂO"×k)×A,Àu$X ÑK)Q0øu$I4   A@@MàOApQ ,$èG`Õ .À ë 4 |@ëº ` àWÀ @¯`   v$fÖA4è tJèt% uXÇAëA"	 ¼AÛ 	è!úÿÿ ¯b @p    èÀ$ @A8`àáù`?À @á	?A( ¤@A< Ü"~? |A9+÷` à?B`ùá 8á+Õ á DIÍa H U!d A@@¡àIà_ <à_ q àq àq ¹$ÎÂï¼$LWÉ&Û¸ 
# G#¦Ò,Ã£K& Cæ É ÙæÉE Â÷ b÷(&Ä _&ÌY¦i !BÇ´   ¿Æ¼ 	ÇÐ@  $:ò(í 4fI Æ} æ 8!¸ 5 à ÇÜ   `T ä 	 T ø@  b³Ai àÿ Ä ô`ÿ\%á×#á -Â ÈdDè XÉ#i@Ðå  2Ìå ë1Dÿ/-#%o #äþ ? A@g"/w!kèA~ (%2% Mß D/O$ÆP !Æ `@ f A;9 ÀZF/ä C 7 @]´8F"  KY `Y¤'N!ã"AH Oà\ Y#b  9AÁÐ ?ÆNÐ >§`Á!"À  P Mö d° ÇMç® ^ ×(
j|7#	iX¡`âæa , Aa $¤ ;`ác%äYÃj cj % Q@5à3¿Cà¿ \àj¿(ÁaScÁHËáHD§ ä§ Ñä§á<ä¤Qx©´bY« «AÕ èI"¹ °"¡ÆÀ !C Ð@ !Æ"6åoB#qH Xä o x" E)à"Ò ÔàÒ3.Y"/^ùå  \/wààà X ì Y*I, ´ :ÆOÀÇà @äU} `KY%È o`>`K|A0 ¼ -à:á& á& Ñá&]Lk ¯Áa' ¨&3á(ÃTR¤ /«Çâa*F!Àcþ\ÈÆð Z 3Ü!ÇQÕA> EVÔ  (d¢ ì * 0à(!,$¡ @ã(.áçCÊ#" Ù z % YA\(²!  Ãã- ´@ãt"ê!}(¡%  >  ]ÏÆ   ºÂÇ°@	#@ 8H5 4kW"> Øá0  /@¨dE"î0þ`JàGN1 Ðn1 {d4`>Y$` \=Éa è­CÿJ!h   U Läð]@ÁI  :ì,D äWÉâ Åì
!@æôà à $ Sà  3ì ¼ (ç »mç»(A(P4ÆÆVv!W p Aàààá.* °äL B¤jI \!ºK#VYÁ#Á ¸ D@ ÆäÐ@à£ãB5Q;À 9à5¡
!kà BäãáA8©R+¼w,.Ü[@`"¤ë l@	 @	 h 	  Ñ NQ$A$èàT  B E L @ V !&à   ¯c} 9 O DäA%Y<`fÄáX¼dÐ Yj(ÆÀ 8Ô 04] I@è>ëã>ÌyPà [Y8$  uAô 5I.°Wö SðWÛ$5 `j,ÆRß4ìl &ÀZ\  ¡ ð $X```AYÖ L'ß  h@Å2c X  ? dÌD° Î  Ì'Ê õ5 E `ÚYÈ Õ `  P @{t,``L÷ ¦ d` c p` \'3 YSH@d- @ l? X@Æ!{XÅ Á!D p`%p f |,h` f l` f x`à
f tàf VLèéÿÄåNì"P!þ0åDO¯ c/ªt5 RøYL!·+ ;Æ[¸+n 9Ý$Ûÿt$è´íÿÿÄÂ!A%Ç   m  	$6  @  "Þ`(, FèjñÀ9".à@ $à0 Úà!uÔT!# i#D_`À$è©ò!M@÷c; \, Y+»CN%A Låß E P½@EXÒ#ÂPèî`V2 " kÜ^ ê  0 !&à  !@- cA¼  }  ø '@vó=  # X XÁbÜ)A èç`c §Àiøà  n¡© Ð>u ¢[çe2}ò8 >º ! ³ ç  |  Å  Ó À° ¯áO h ¯`á O yáOJQTKæ¬!OÓø/aÀA   r g ,  :   à aà áßà Cà  g ¼  Ê   @ã1É ,!¶ ÀãìÃGè×æÀ
aoàO3bèuh#ÊÀSãÒ  ó5 ³5ÌR ³8¢4 +!Íb Yàøws"¤br$ Æà 4 E %!=E ÷Àá 8á â¸A$O"« Q x /  @  b   `¬  à¯!? K% L#X å à  À Óà À  òà ó và  à pà  qà 'ð@/ p&á$è©D"@GMQè8À5 ¤}óÀ ¡Vñ3ÒQF ÀF8ÂBÌ%æ'Ã%æÀÁêòXÕ^fZGgdb g#Á1&$z``F " m%@Pvü  ¯Èj `$Ë `èR@a ÅÀa  Q]h9Y Qþ ^ |2èkÁ , "J(h R5uLÂ
¯Á B À`:@2l  (P@)0 KKÿ¶@ N @ÏQÐ þ 6 ½Oxþÿ@@Üj(j "p'À" ,",[MdY\¡ ´|PÍpX(`^Ñf]_¼`ÅAª Y®Ãok*  AF-I 
0Å(Y°Å °Å Ø{áXÜ Ú(.|`;M­ \ a`  ^Z/áVï ='¶á±ï_váï <"á ï Sað W#á $Cá <á L"â#$"_#ãáPwMcbJX`R"ÙÃá Û%` ¾P=@`6cï"c¼ k Á#Z MãÆ Ø B£Æ@
ã	Æ Ü  #ÆN<#Æ pMË   RÙRØf*¨@@Åjjÿ¶@÷Q Æý#×Cámtñ@ÜÀ #áÏ N Ç #*òëu³_^[CCà ó~ÔÝ{ì¡Ü Ì:Aè÷l+(Ç` ÿ  ÇØ    	@* ÿÃì'ÂPè#Tk 7hSiN T Á Ö`9@£@- %PhFh  h$ Pè¡l!h 
ÄÌ £$v` F`Ôk  Ã)¹Ì!;ÐV>)òÒ~_7c0ê!0fV&¸ '[ u$TMt   ÀYÄ I* `&Q¨ Áq¨ÂJÀÀ>¡¶"A<ò 2)±@B~^ò'x(=   òFÌ[Ü/Á(Ô`-v&!È8À*	¹U¹ t¨ Àt   ) * @jS\$ÓV,æW¹ %Æ`4ÿË Û@%  8 H	 ¤°#@+ t vJÆ `U `­ ¦Ø CÀmrKiÔ 5³!Î  
@kc6`%ÿÿ 	  k`Lh `_3ò\à LTl dÁv A`~ÒeÿÿÿS-¼è'þÿÿ"!@Ê u-¢ 9 5@ºW"è-G( (ç '/üA©
çë/åv(å!Ë%\&³Ç!¸`)\% TÜ&mW4"6ÂÁ ÈV&s X0¼ \&Ò ÌfªFÁX%p`8ÂÃTÅ /Î \¼ Á 
"(1 \á g  Y ,Ä.á Y (/ÌBá Tá&iÿÁ!: ýá Æa ÆÁóA ¦! -C Ì  ì%W¾bq"¦ â	¦ B¦#o,øB#¤.r=A¶Æ`9|$T$ L$É+0ë¾Bi  À	 @ ffä ÿ Í @^#]PF"Û,ÉÁ%ÿBUIh æ)0¦àÝ{A \È Zñ    !Ú ÷`   "ZYÎ Q»Yî!Õ ÷   `  Æ(æ á(1H@^Ö(Þ 	Ð(þ  5@ä  ù Ý(1í^ \(Á\ø @)=@" ûXû b  6¾ðAW= ©@E: ïaN6Í ò òÀú X àþ$à|àþ`@þ ó é@þ`àþ ê\ó   þ  (!R½Yé@þY\óì(Þ! #U@2Á# YC.á@ý\à  ùY%	 X9¯á ¦ô! ' ü þáîXHáö ÷ ]à÷`à÷`@÷ æ¡S AúÀ÷   !ö@û÷@Aöàô ð@øàôY¦ø`ìXç ì "! [ª$ d$ #&µÂ +Ã{Aü 8ÄÝ\$   LdiT$O#k   @"$ÈZÂ"ÿ,=Læ Tæ Rî và = v$ÂÂFbe!^ d D%¤è & v`$ä ¦	  
¦	`Æ	  `ä `l £Äà U]Ày uæ`w Od8ÿþ1ñéb  d* $# `  "­G-¦<&è $[È `" !'/ÄF( àF( çF(!x((ÍÁRºæ* Åæ* Ç ÿ"
U vÁ!oF2F yæ: Y&ºf:4ý Y E aÏ aÿt; @ &×-w¨f ] n@[AÏ Y· X+ _ ]8dm bZ!fãOä?åý>åý>å±> ,#3å><Cxå>E_L$6®%> ¥=(¼H åJF Xå+F@CÃE·#ÃåJ K+%J ÂiØ&åJ ë¤må/ IÀÇú/)¿ ez¾+ ³  ( $ß¬h¶TÁ A(T+Fz÷ FÝ ÀF³àFà _×ó^úÆÿ5º|-!
,xüÁïG½ v +Ð@ YÇÁïuï@§-òZJ@I%YÇ+÷Aü-ªëP,U,ÎèÏ9J_^Ä,Y*Ë@ QSUêÏ ®jÉ D"# ø- ªÇí^!®J»íux!@5*À*² D`exI'Gâ	ªaÒm'ÐÙ!ßføÃ' O!Ë Á <`aÓà ÿéÁ  w ½ !ÁÜ§K@ ð? E@!pf<Å!+ ]ÕA© æCàÇâà4Çà¶GîOÿÿÿéå.Éa],' F!k@é Ó  2Çî e+3 À'Üw `Í/àGßJmnGßì`îç$â .uî n
?»1*Îêçâç Ú    HgÖ eb&äµá7[a(AS Ï-Øé¡E   z =z5©<ÁM ojé 2ï[(ÎáR Æé5ï` é
-Li%áJ$"Õà)? # ] Z Y)% X â Ý J#@'é)áü
á7Ádat%/ A !D[D© $© %6w_^][Yä© Ñºo@/z ï	z OSD«Æ`(Ul$VõW|$1O6!ô$¶,eá$s @: N&ð dêN	ïW @M` ÷­KîX Þ í `¯W 5 í` M` æU ã-j#b@&qYÙ  å ®e/ Ï_B \XW %ÊY®Y Ü& +, 1a%Q Lá¥P`å P`öí! U&4Êè:©A!A5 ß!= Ûa5 cW  #ã )ì	\ Ã"ä$y$bä tÄid|"Ãäq ìT óaÔÁÓ!!9 ,5c:Eê aï A §á èQT`QY ò,½.M±H!ºá-ð(OMQ¯QAÛ%>áð á(è"Éé!b+áñ ïaÆAù 1áù éá ù|  ãxò.×ã N"ãèá ãä!%hã`  $åp`RÑáðã æá ù#y ãx4!E	eå`á`á  ãäá ãä!!èã` á+ðã âá ù|  'M<~+ö T$äØ]jB -J9'Mx(u Õ#(4,ÒTP26Âc6 =è¶!^ /6¸¼À(|| ?\ÐB`. G ú W9½ BAt þ` 9½`Ce ß YÏ 0P \9 8¾  (ï ):Ht @Htç( (Je ß ê e(@.5C Y6%ê]\$ Ù,/º<ï%Qy ºXÑ ÇI# Ã!5Ú  Ã` `ª(¤ â - Ð!$?h`ä Ï`  Ïàä Ã i° Ï`8 @¶À³Ç`Þ)Oà Ú*ø,$ ;h v T@YøjP Y>ù.c * \9½  ! [A  /  à  ì =9X ~# { X)À  É AÉ V Í @â Ád÷ Õ 1 \@1Å %Å(õ  ñ/ nc @²l$(Ý +Ì8G  	 ìoÅ \oÕ :V «   ÙAÒ|$3¿{_»[ +n@t\$!3Ú j!r Ò 6 h B -L4 î Y@ á;¬ D@#!-\àÚ¯ å\ÄbÛq2 Ý BQ$Ç.%: O?Ç 	ßo·=Ç 	à   	s§@Ç 	@ Ç 	¸!ë   	@ ÇAÿ  ÆA 
  	ÿIÇA , 48  ?ÇA0   ÇAP= ( @<FÇ  UÉÓ??Ç$ 	å0¿Ç( 	y  , 	rõ¬¾Ç0 	Æ  4 	!An ' 8 	ã 	 < 	@ Ç@ 	6þ4 × D 	@ ÇHà 	 Là 	  	 Y   	GU E ¤ 	@ Ç¨ 	·, m ¬ 	@ Çà 	\j¼Çä 	¿AØ 1 è 	Ìg 	 ì 	
1 	 ð 	æ@³ ô 	³Î>Çø 	NÅ_ mO§Ý6 
   à°ºÇ 	{ ! m  	@ Ç 	\Ö   	@ ÇD 	PNÒ  H 	{I 	 L 	<Ad½ÇP 	ZÒ:ÇT 	?éð c X 	@ Ç\ 	2´!Û ` 	@ Çd 	I( ³ h 	@ Çl 	>õ@w p 	@ Çt 	¸¬ Ç x 	@ Ç´ 	]?ÇA D,GÆAE!Ì ° æAT bhÈ  bj´`BlÌ`Bn¸`BpÐ`Br¼`BtÔ`A¨À`AªØ`A¬Ä`A®Ü`BZP`B\h`B^T`B`l`BbX`Bdp`Bf\`Bht`Bj``Blx`Bnd`Bp|`A¾ !8 #   #   aÄ` T   aÈ `AÊ`AÌ¤`AÎ`AÐ¨`AÒ`AÔ¬`AÖ`AØ°`BÞ`Bà,`Bâ`Bä0`Bæ`Bè4`Bê `Bì8`Bî$`Bð<`Bò(`Bô@@ÁYÃ'ßD¿Áä?{ìD{d  y<"ÿ 	Å?#1 l 	cª 	 p 	B Ç 	 t 	 x 	' | 	;  	Z®ÀÇ 	½Q#c  	ð<   	Âê?Ç 	$yD!  	+Ë>ã;A`1¿#W  @@  	 X 	`þà7ÿ|@ñA@   dADX6¥à }I  bá_@%  åâ´ fÆ  1Ç¤ è i T333? h  Uìjÿh8ïd¡ & PQV¡¤P3ÅPEôd£  ñuðÇFn F&n FfnÇFvÇFu Fu Fu Fu FuÔ&g3 Çx£@ Ç@   Çvã@ Ç ! 	@¶@ fÇì@ Æz  Z'@zwÇA´9SÇ 	>  	@ Çà 	 à 	  à 	 $ 	Æ( 	Ç, Z+Ç0 	@ ÇF+è@  ÇSK@ ÇUJ  @°ÇEZÄ)·ZòÉtÿP<ÆMôd  Y^å]¡á>ï !ïÇ¬ \@ áÞ¡ß háßìVWá	âù}ðÇGâ G!â Gâ GâÇGâ Gâ Gâ Gâ Gaâ·Ì |¡ ÎÇD uìè¸ñàÿÇ`F;ÇÇÀ¤ÇB(¶ÿÇÈ 8  H v 	á- _á. Ïµïâ ¯àÏG(ÇÌ"vjP Û    ÇG` b$G@ÇGÍÌL=ÇGC@ÆG$ ÿ¼;Äwh ×j ÙGX   ÇG\   @á6ÚÕ á  jÇF$  ÇF ØÿÇF  hð¡ ÆEüèí/[ h`¢# 0 	 ° èé  j;çÌ{ *!
EìÆEüÀt kÈè ZÈë3ÉO`"J5L !"T *E,Gá0Âm ÇbÂe±`ã*-(&ÇA:0 ¥ AaÞÇAT  ÖA`) d   h   ¢­Á áä.~ tèåÿ`Ç¨rt8Ä0çÖ@F öPÿAvÇFA Ç$s  àáâÇx>;à  Ì=¬ÿPN$ÐÉ¸l 8^OÁ¯+ñÂ¡à  /è(!© ö,Þtj(VèYËAÆ^ -9t  #Ç@f¨t"¨uVÿ¡$	hð  Vè Ø8!Á 8 bà? °&cVèÀ×à	? à   xVè¸Êà  gÀ À/ )Vèà)ÀÐthCpVèeà(  à/ 8"PVè5à / ¸!Vèà/ Úd7 D.è¬Cûà   H&¹VèÄÉàó¿ââ zDè	´"K NCKP %¢jÿNhèýÿÿF(" ¸cúöE"hX÷Vè>Àâ"(¡/ÑBD"Å\º!)Æí! u@Të@XF&3À9Fª
~;VWzD3öO HÎ;Á}të@tH@@} ;`0|Ñ_^ÃTc >|$"ôh%M ¶@tà#ÐN@è^!}F u_@bÓÎ8èS"ô _@ ¸  QSÙVC\STClCdCtÒx!KPÉx0C@;Á|0
0øæÀÆCX/C@`j ËÿsHPèu 1nKLð/WC@ *ÉsHQÎ@$_K$Ì#§@H;ð,  9Ëè:(@	sHC\ÆÇCdà-}&C )ÀPè,  Àt;þ ïClÇCt! O 
 !` &9èü  À[À%;C|è& ÁøÆF2tÀ Féø è " Fà`BàÀ 0`¢@Pè@ @YUW¦W ðè«øË¯þè  !~	Ë;øD$èj@ÆNï+ÅPè W!$øN;÷|2D"!1 (`bu }ïë@ õ!`k a é è+îÑý$Ë+Å ç!_ ¥ £ ç@tÅ_]àØC|# nÎ!¦ÿÐ!@  
 ÎA¶ " ÉS\ 2É[É  ÂaMXC|/ÁvÁ+Â á bClà  XaV@&+È  Á`9l&ÒqÈ°ó^`'^ÇÊ'@$" [YÃ^2À ÌÌ /%!("fp§# ù1}hHô V À"xÈv#ú é fnC zè¢|  >8v u Z"L$1»0 ZÉò^Â2Áò_ÀtÊ]È k3²@`&è`EZÀ¸GSW=EZÈ IG %`  
@D$ Ê`¢#6É;ÈLÈ`G\GlGdGtwTL$ö#}WP#C}G@;Âc}=#} Gc}G@¿IL ÆD$ Ã$y àOL Õ Gc{ ÿÁr
_2À^& $­ÿwHÏè/#.@	O"& 2"\ ¯O, G4.ÁÙ\$öÄDz@8ë Mè ö »O4!èQA8A0G8 $O(  ÷@çO @ìfZ41Ì!5A0/T Br L VóYÀ`1^Ð!q` ë`¨ 	 À&`"Am^Ù!@3!_@ æ Î!	 É Ê # È!© Ë!VÁÀIÈ!A;OL~  ÃA #Vë%ïwHQ!Ë  GH  ¾@ \A @ÿÐ"úd¡¿þÿÿ@%OèçàÁÿ;GL« #TÏ U`SPèy Q|!Èt .ÀGOHA`K Á!í;OH5-(ÏPèH u@Y Ï! < +ð ÕÆë( à O@à!A æ!R ^ Ù ,(È Á ¡@}- } )£>G|! D°wã³ C³ÊµW\ 5ãµ GãµG|Gãµ`["Gãµ`!  @ YÀÁòÀv
Ç`  +Ü#Ú @¨ÇÃÙCîCÛ _¢¡¦#ÙSV#Ò_\+Ä  ÜWT#
!OÆ#æÃ ââÿCAAÛDÄ¡Ù ¬#.A!Ùß¡Ù  !nG@+ Ï Pè¢  PÏ"+è!á!@"OlP '"DÉ eðÏVèo`' ` !Op9·FtM!Õ G'-$bf.ÈcaÇXÛ@ ë"ã!é ¤a ^8ÿca`!Ç'Ñ`  `NUw|½': APcömW$×!edb!YF _Ë(ÅË '' V7Ìâ Aí åÊFBØXF@" åÆ@k @ Y¢â
FvkÎB % çwt â ÇN ñ¤5FÆí&#z
]_^°[ÄÃ_Eü@"#Hþ
ÿt(¾GüM+øVWèE×ÿ
ðWèvÛÖÿ)5H%Í^_@5à #S:´U7óV4]   
WõVè<Öÿø ]	:ötÏ *-Æ Aîuó3Ò÷ó;Ó}Ó`8Pü_^Í@m][ ¬]3À[à tiÿt$Sè Õè Èíu *"ç
|$ÿu3öë`Ð÷+ð¡Vè²D×ÿ)@U+ÇÆ;ÃGÃPWUè| "ÄVèÚÖ)ÖÅ N`ä$G!n @%$G$ÿR&@ Vt$#_ì""F@!#PF`"¾F&dFhGhê1à?
NDF@G@OD 9à/qó gDP bC ;@ à? #¶@ q½QÃ qÓQÙ qæQìàWÀ a+OG(á 3!` `« ;`«tÇMG@  `´ ÀHh c+G¨ëwàÏAM`}@PÿRQ6 q< `V cà] ÌAj Q#R!út$PèÅZ.ªÂý¹ "à/µ`à/!' S-Ã WOt$*Æ\$&}S|$ÿR(Oÿ¿O';ÙsK/ÇÉUïOé¯ë,óOÁC¯ØÉ!iOù\ ,+L$I¯ÏQ%<ÅQ  "çL$=G `Q]VúÿtSÿNF ;Ú;N ;Ñ~4F	;Á~+ÂÑø 
Ø~íF$ÎÀj't ø ¯ÇPèÿ6Ø#,DJ#_^#§ `
 + )@0© Öà((  A-í
PèSaQÃÈÿy 
Á9 t
QèÂaBà QÁ$¸B" t^S!>V3öÛ~#D W¸Aï&Oÿtµ .³F;ó|ï#×_]°`+SÿP0@ÿP `$`ÿP,@
(`X^[YÂà½ÌÌ@' !QÇ2º?  à P@Âà2ìTÖ ¡v"Ä$U$ô &rWÀSU¬$UND´$Ná)n 0  U¡W3ÿl$,{,$¼ 2t$H@@Å"1 <@ Ü @@Y 
D$|@ 3H.   @Uw 0E c @@McK0%£J8F4qÁø"Ô*~# C,& C4ÄÀ¿ C,*ÀÀ?{I ,åËÆCI èÿ-§;KPsLOKP"Å   DNh@{Tv FD+øÀT T$-  !& D$ +@Ë+?¦ 8{@@)!0è÷$Yø~-Û ì 
 N
0KPgû+ÏIÁ ñ$;D$A:{p}SfKpIÀ|ÂD%*dCpø|æ (õ	9CLÀÀ(¡( à&=/Clrf! H.  L 
 X@ \  h@lèL  !b/ L`L $- L Ô@ÿCH+Ç@ \ 
 X@ l hC`¯ÃÇCD ÆCh s L(s Ç«AL$A¸ KL CLiL~C8ë#(+Ì~K4 ?K,,mèÍì  C`<&Â É¡FCD!( ö : ­°K ¬ he(ÊeßHs/Ñ&÷ L õ| ¤)@× ç |aÆ`î  + @´'ª K  Ï,uD$L  É EÈv7À~B# 2àD 2'@<*køCPB# ë#Ëà6 9 w~'àaë@¤@RÂ'æ+Ç6Dt$Í;Î}.!HÁü\r#6Óiá CT5!WÂP*ù @$P$ &# P$>Hèâ6æÿ {+ST cS\  e Ñ"è .@L3ÿ%Ù+ñ9¸Ü9 ~l * kB$VÛL¼|3ÀÊ#)S\ö~0  C\/Ãv*f ëÇ /BÎC\@0-7C\;Æ|ÐfG;`_|°@ B`!"Ç+ Â Ò  (@	É~t$|¼d«ó¥`*	t$3À+þ){P9@+~Áç@ ||@;`
|óST{P ~F ³BfQ¯`ðÉ9`6D|Ç ´#Ä 	A;`|è@gÿKPN!¯öÈ ²Cl+o Ö!v(ì°!×'3 9`¶[& $ C Áà" |¼Ex3Òø FClAîö« f;T$00
@A	,s`j ò@´è`nçÿ3} 10 -!ø +Aç  h 4&$L  D (×çÿ0= $!c ëdòKA× Cô" v*n Y É X#ÝM ClÇ D$8@ì B@ 	Clíeÿÿÿ #D$ è@Ø &I A@õ ;`û L , "S`  D!¶<+Æ Hø%^<)AuT%]~St> Âùÿÿë>ÆCH ~5!23_á¯ á¯ÿ 4Ñ$[ÿ+ô	[3Ìèè·{ ÄG0ç xUìäðìN9 ¡ç EN=t§US]VW}=xt$ ³ (! $iÇfpÈ !ZµA£M|'B(À¨c(%`&ù"ºX(p@
$\¯3Ò+ù+Ù+ñ+F> ßBI'RDNÂÂ$ßpÀ2@þÂf8@Ä .þÃ !àAð  @* À!] Fà+àú|!w (Ô $! (!×
ëRE {gÝH@'Ý D ®gÚD$h 03À@
 xCTff ¬¿ øÀÁ <vø@|ë3ÀJHF,",N0( 3"0hèF,v	Ç^©À¿ëçþ`?N\#0  &(,F| OÁC P"õ @dóTP!9PWèù1æB @  ObàTC N"ñ,À A  A$á@: P@K J(P!PóCH<Wè° H &Á+F 9@QNñ \G#`+\$ ~Y!¦nÃ! àDö`{t%1#s(Ø~Z4FÌ3Ò*P vAJ V iE ( K\Ê%yD<H #7Ñ<AbL<Hc#«YÃ#@$ÿ@|Ä  @¿ B Ì  ;Ó|¹P3À §"E ò"@@^(Ì"TÄ  B£ È`Àø|ÍB>Áÿ! AFNN|NRÊ Àh@aN|;+|$ N, rC0 Ð F44Ñ)$Ýè SF8èS NtÒ~	|  &´× FHSN(`Ä(X¨; N´Üh»1 YÈZÁ4z F1ÛF@);à òÐD#£ ÊÛ L  #à  X éÖ|$; ~,ÿ~fÇFY >nèhæÿÿC> Cp CDýÿÿÆK $sJ_^Dru³{ å]äoä  äo à ä oErñ ÑÂW$s $o $"U$k D*ò\$± 3o häoNÌäo xäoJªäo$¾EO ä6o Fäo "0 !&$ëVDk äk h$YD ªdk´ dn e&C& ¬C|#~@ãäo$÷3ÿ&Õ%    ~*µ X !1¤ 5"wdì Fä ($;d~8ÁP$- <@ 0@tP  ,'o<R§pv-$9D (!« <!ÅDÀ )D$P ä Éä 0 1 4a 4@\ f$P¼à d h 8 g @g 3Cä ¡$KgÙ zC$´C @ à d$)»Dµä ¤ Ú¤â ".ÿÛÔ 	WäÁ@½D¯$aÀ/Âv!dØ§X7Cð_Ì(DÈ]@d¥KÔ@ë/àv% ÄdìY #$ø@\Ñ3Ò-/D"Î@B¸  ¸AðLhÂ( @Eý ¹@$¹ú@|Å dý G `ü £ «;û<(( ý "*dEä  àBh $÷@odú` CBà@¤' Ê"à!åCO! 8Aå  NA4e äû -ÍOû|5~vläö"o%RT<$úE P 	aÞ%zäÿ à çdÿ!dä î#D$+à  x ×ÖOÂû#P  'Á,(Â'¿Ó$*/Ç!]#eë  @8 ~.&à¥11° #$èàã%7¤
.ëfüå3P_3A®å3ìK=éPÌ © pÐSU%(#ä %w CJ$  E6 0"ð Á'îE: ØE:Dï"Ï )@"#X/=!Ó %i­|$P(5iª$_á(-PI­¬$Ð`& i»t$`+Á3Ò q+ù BE»)Åé+Ç åQ È O)À þ'f8@Î  Ë ÁiÄ(Å@  Â  )'éÔ %d È%à;##  Í @S Ê 6à!{ &Ïièt"é)ì0ë^¡( 3ÉæPz ` Jn$p 0%u @î @ 1vÿAAÂié3Iù@|Þ3ÿÇµl?3í")¾KM ~l%~,|F\+ @"G )¬!C   5"= Å"]  ²åb" ) 1 $åÙ`:ê`o: ¡l$@ê¿ó,L®|í%Ð P.X@åDø!IDj  Ë8@!®F|;ÈO\¿ "Q @;ØOØD®\%´ 0 Í<èÌ`çEj <êZDPW%¶ 0 8èY'j `Tê   Ó"³ I l E ( ~j.õJèz Q P  ,@&iF   N`R )   X%ü,WÒ! `_  K R((ã#Ã@e \-ZE´ *8õ 	f%¢ âJ¡ '~$ÜA`O®æ ÃvDËæ Ê(Ó"%æ i ÐF  ÐF Â(Ð   ¦ @ Ð  $Ò\Ú3Û@÷9o P#}Bsð+l$4&C Ò *ô Y&T/ë+ Y+ X o+;@C|ËC.EóG®Ë$Ê$ L3 A* :;Óÿ#E"­ýu7ô3À°c'<Z!Á@®Ðr ð@;&+L$< ¸"k è 8!K(^)"L%Ga  EBýcýoaæ+ "æ+Vþ%3 Jæ/k	¦&F! ó&b #&F"0¸v ¼  Â/0$ê v,«Òë1Ä@!L Ñ!7 (	É 'A3Ò9AZ~MDHÑlé Æ G 6 Ç¼ CQLP, @ Y "Çº ;`H|·@¼ "À Â ¡`CÃ@[  $eG;ùs! /á6ýá.Ó'L\$Dá%#$AA$ ¯ìGA9`ÿ
ÁáLP@è@;`|ì@Í!9 (eéù!Ö;DQ~"2ÈÆ,K,J­à^ 'òúç[3°¶1§P¶Gì Fà  ì#£çGVW' ´pÄ%ú , !((!ßD$x  8  
 `'[v cd &i8@â  ^# *Å!Ø3$$ ;! Ø4$A¼$< %*XsÍ`0-¤^È(!dgb ¥Y (.Ñ ^C$DNC³$4 E ;D$I!Ä: Ù x ØDe *2	ë(Ëó] É G üF2¾@R oº B f¿v/ø v(Ù  r3À îNÛ C@8%Uÿ~A²Lh   j V´è %}Ôú"7$¤ Ä@Æ 0ä ?;Ç4É¡g ë~E'.Gc![h¡ 3hÀ	'C F3µPè Jh 5«¸@dPèvà  c Ä$Ç¼ ?  ÇÀà 	 Üà 	 àà 	 äà 	 èà 	 ìà 	 Øà 	 Ôà 	 Ð 	ÆFEAÊû&a \!Ï Ç%#Y ÿ   ÿf   *D$  ö Ä !KD$,O7&!«Y¡w X9F X`¡dq\Ø]7è + !@ Ä 8 Ý 
 ÛJ! \"xIy PA z,åD$Ç`@  P  À@  èç 'T b¢Dc@aç`BL d@S"¢@S .'v U8"nHÌ`3Eú 3D$|  P'M@; 
&ÇYÈ ² TÅÏú 1/Âº@OÂ¼$^Á   ºM lFb¾%D³ 3G~T$l#&¬  5@  è"t â!g[í pSµ Daw  õ  è8í _#W@_ ¿ H"b@r jADAÿ Fø[ÿLo Ê[É K+dYÍ!>2 Y9D0ûá $^! @@ ÝaH¹ÿ · =@(Ù=ú ©H@©Àù`[À¸`OÈ/Ï%â Ø #r¡ Tü#V&× h #á Y#Ñ X A!MB;×R"M ÊAÔ ÜE- Ñ Ø ê ëB hÀ !ø@@  ýP ¶C}é jWçEø a¸PFHP!ÄA+Pÿ´$C³ Uâ^@>FÊ)* `   V©-b!æAI NSmFLN@9'¢"ºL óæÉ2<f
 &/È!, (:Á;Á"!{à aBèzÌëÿ6Ã3Àë¸ 0  !(B#FD"¼  Ò@°5÷ëÿ¢@) ´`}t%4FñÈ;Æ}mÆ++
ø|?~ý 1 ÇS¾@D$\ 	$Å 	  K¬;Ï|Ò!x@R;Î}à?A;Î|ò A{/hï zá¹ ò `Í! 0"bS!ó DEôé óD$3½;Jâz 0 :@ë t@'*``NÀ"B«@ !@NÑÏ;LÊ <#ìBHeÑ@¸Ò#¯¿ ²Nd+þ Ä Ô Eê ¿¼^Ð B¼ap+¼`Ó  ° +à{A ¼A° `  zA 6@TD0`AA	lAAA	xAA$A(@0BAY q'%i, þ@  	#,i0  q"uåAü!T°
` aIY#\ È  Q@C A1YÈ`XÈ(*ûYP  $ A'ÀYhà I ¦´`Ì` Y@%Xá  I }Xà TCÉ@A &l`@a)¬Y¸`X`QXÜ D"p A(<@Y7¿Y¼®\`XÓ  Õ  QE~À```YÆ '¹@× 
I!/YÄ`KàYà`d` aº\þ$e b!XB@ÁH".@
;Âû+W U©D$XÁà!ïD`@  
Bv!ñDB@Gu rD$T+v =FÖ t`bã\ÇâçD$På_ |F{@>$@c xCøÏ#ÌD#N Ç"u@ Fl`0	;È~9~D u3= 5 `C @:+ø 8 C&M&@A h<3É+Ç)B©#FP`BÐ " Þ @< ê-Þã`&+Á °@IÁ3É@= b¤ú|uBý!aB³Âþ#l'<tð@ X C_ADÀAQ&`P W ` @#ª E¹0R@B$ ¶%f+Ì	;Ê}GÑÁâ z ÆI0@v ´aì ® I`R@A`J À J ë #àJ ÚA.5 A¡ ;ìþ@«!¹iZ!WD$|¼a/A`Ioá
÷ ,á÷Ä)` eCê+ÁA=` lAR&>!6 `nn%I@!B!<ß  @a"Þ$« X(N\BEZÂân tàv |0×"Ob\Ð/Ór5
\Ó!A@wNPJÂ#FyAîÇÐ#Ñ$Sí
Px#ÑÀ+Á p =Eb#Á#ù¢Ed KC@B+]î&x ±ÊÇî Ù(ñ -P'<¾"lB-°  = @& 0ò#3 p`(î(þ  -\ñ ;@`   è D@! f c@ $@£  ø!ê@3QW ©CªXë &@© &@  ú!È y¥!o
Â7'`Z\ 
(Ô À!\ÜÆ@Ç $YÕÁ@Öº Á XPÁ Ï  Þ  Ñ $ÖÀ@¬`xu UaíÄA §â bW"4Aª rÃI¢. I`"6ßD»WÁÿ  !s ÂÿÄ"| BuA§ t a!ÜA ;® 7A¾ä!µ!¸ûÿÿ+Æ A$!+Z½Ðâ $íY$msbù!;ªP@Hâ "}D$bYÔ-z@0:G1à oGGGGGG,1ø@GG$G(  *G$G0G4    ù`  G&¤o8  w/·g'o'1wIÊ@t G'5|-Q    _'4W 7g Gg4 `F\g4   (,`YG'<@Og4 ``G4 O' X5Ã'+Y`G"G@ 0 b]gg6 `Y`ç2 4`YGg2+R 0 _G5 ` X/@G2ÍY8 ¹OGF`$` Y9XÑ(L"§G!%W!>Y ¶(`gk,EODÇT *äY´`# "ÕBK ¢1×B'!¤BÁé@@	i  w D4.&=Xõá$B  DíD$!D%C°WÀWÌ¢1 Á+aJç#ÃB"s@ ÛL:$bóK¬ÐFPyÿ#GDyþ`B§yý#-7 Ò'7@Byü#ø3-9\ÑC) #) \$Ñ Í@>c: ý Ê$Ø"¡ ÄØ@? ,`U<¾   ò!Þ`,Â@( dçäÒ >&° ÙBÆ$ @E ~ñ  
äÞ  ø$Æ! -N;W"¦. p  úç¯!5(å Al  $«  ¯!ºf Ê\%l x ã/ )A ¤×b¾`jYÖ $ÙBèXâ %¤!= $Y~`Ç e{$ì Ø;Êf'Ó éÑ d½!à  $: "@ôdAA¿ ¶@áÍaÉ3ÿ5- Á#NP"cA(x£  1|$xø1?Ç QBü¡PÁèÀ)Û A¤á/"»@µ ¹A¶hªOèHª
OìH¦`ðH¢`ôF
u¹ lå¾(2@e"û@«;ú}C8àÁ(¥`©  @èðAv@ {¸GFÀ s aF;ú|Ý [ r  B ¼jÏ}0!1jºÇ;q}!Ê@ÆG"×J¼Gÿ=@4@õÿ)Y`/ ^QÁ+$J ªV¦ XG8"@ ¤@[;Áï :ÐFH_B]FLI]L1Â `3 rM @U-	$T^3Ìè{Tµ@Â ÌÀ ìT@ô¯[ =Tó,&f I9 Pö V)&!$@$.WHN÷ g¢^ c(Ú á H "ÇGd!3 h  ËFtÙIETÑ!!D¸"SJü(Ý `&² ÔÉ °UÑ´£H ^-M%t!$J­ FYÐfÚ ^%¡-Y¤`  "´º4Bà á/ÄT¿Øë(Ü4¿ ´¿ ã@-  ½%Ð \,é 4A  ¤aT(Â4ßTÄ Ú   #P&Î^ÃP  7 $è¿3'	G`ÀþøKÛÿ$°ì Ç  ¤FÇ 	 ¼`	   	H:ë^ Ø`@ ð`	@r§³:ë>À? $`	@¥H;ë @`@? X`	@µ.«;oBZö~E"sC,Ç µo
W¼ô   èdåuoLáuo Çµo@=;Æ5oÂ"@D<ÑE "$tL" 	vÁàP,%° j5c @Q Æ  + PGl@üä{ Áæ & "c@ ê  V  	6 Û # @R,  - `' Â @'#Ø@6 ³ ÄH #  H ¡ @         W ü ìÄ$â®Ç,!@ Ç0à 	 4à 	 8à 	 <à 	 @à 	 Hà 	 Là 	 Pà 	 Tà 	 Xà 	 Dà 	 `à 	 \ 	ÆGE #SC<"b5è ÂÑ$B¥*É O#B Â)ó6'ö8%ï TT"¤F} Ã#áDv#& X`¸&,Ú,Þ # $!Ý@ Ý 
gá|3É 2B/ Sd@ #ÅDsG»=@L4DÓ U¯$#Cæ Ä@9 }'© "ÃAV  4 ÛHêT;"D X )C  \  H =5 Ã ÀüYÁ JqD$Pë	<d ö	&Y   ¶E BÑQ"N ©ö&\$x!@Õ ö& ã!Uö& | #òö & ø _#¡¡ D cA4%þ P(çöËIVan$«Ê@<'@at Dv"ª@È =vö"Æ 0@ñö+r	 ÙT¸¶$ t$ë%XRZ@ý" !õ  6*ÖGÿ&} ¼e« Nfzf ã Ä õv1 tÀ "@@ Eç!¶Pj è?A¶*A##ùö*H6*C Q ^F!ç$Pÿt$¿¸60GÐè7±OL!YGHO@6*%} æv+ 0<B*¢ È "XÖ* !è (ö*BèO¶ö* Gv* @C aNv*bîö§ éþví! Ao ü v-oÆ²3ø|AFý!+Aßøö(/AYö/@ö /@,xA¾·! bú! d"¿ !þ DJÉ  cùâ d 2@cv'@v@Ì@ 60@
!@V#$ ùV*¢CÖ1@"$I vOAH »!`"54(uWt¿aN!>C° {@^â`Y j 6 ß ¸@g	øBüBø*BBBBB´RÔBB B B$BB B(B$hB.ªYà(Q yA> ,"jø#':-@  ô   J  b$~ XÌ)  º  `@,&Yð`/Y% `@Gj.õ\é ? R.Z,5C`!Yì`1Xì  [$òYè`Y`"D/\ê ?B  `Xë @ª B-ÄYÜ`6.   j * @ìYä`@+j.äYî ,@!f@ú;Ç­S ´ÃóAbAÂ<¡³;Î[@ ¤65Æ `$At$h'ß!ª@4@  
A¼!¬AÇ@`A^D$\ fu ~`b\Æâ&	å TF"G_"^Cm y@e +ÙÂ"æÂ$Tã"ä ü È Y`0;Á5Ç uÇ Â"T@<5À@< Bb+Ð 8 C%î <Oo h5Ç Â! Kx#GP`Fõ  Ù 4Ië@ß2 +5µHÐ E<#WP cDï$x )ÀýÇl(Õøõÿ µ¿Õ¿ ì 5`M %[b`M I½u¿5¿Ï|¶á¤@'@;È}9ÁÁàÐÇIU@po IC4¿ J À J ë !E!|AÆ MAkU¿@Nr ät óAã POÚ Xi
Hèav hõÆ$Ã Ð * `"aLèA }÷`'3Ò8 !Pá@!Q@3 @ s L^8 7 a­6³@#!½!Dx ~`z #?3 L Ø#ÂË2è jA+,LvË f )D Âb±å5@/â °"ID$L!BI@bQGkAÀîu¿£\ G`ø¡I"²ÁB Ò +`9SA\(!Z¡0$k)fÙ Xj]@-Je`ãB Hà ¼n`Dö `2(ß(á zà<°(' !$@úàPà S k"@07fGP5z ` Ï@ÀA¢  !?WÒa?Gd Ú[Û.%XÜ! W  K;ZÃá \ ö2«#j&ÁD¨@à#r!¹Aè#yb#$ @!ñ  @8 ×A©þ# p ç
ÆüÂÛ  Û!÷ÁîFAíµ @.@NBÀAÀDÐ cc C@BAAç Ë¡ç!`B%@Ã ËÁáË wÁ m Î@ B{È+´`19Ï "D"L@U ñ Ué~ D! 8 Ð@× A@á A¸  < á Là'0HEÛ@¡!ÁA" 4@!\G CU/Ør @(@ @ @# ÝAáWPIÁ8#w#Â !@ q@47@IÍ @: @
%í 8 @+C  !} \`HÁA!G@" A;!@O³Æ@!4#¨4·$´Dø)`EÂC¿ 	5B Ä8h Y/÷ X°\
 Od  
x3QÒ¬uÉ k@L"ÂÂâ cw A AÁJ"e&$5| ÈC# nI /@ÁádÓR"Âÿ` BA6'!á*Ã P¡Y4@ñHDãÑ#Æ½P:2 <@:A:<#Ñ:eõAQ ¹!QË/p@GaEâ@ 4@@E!Èa@à@$ A #A@¯ ¼`v@b¹3@& @"¿8y¡AÀ5!]@4?½ÀFÀ@BÀ¡­u¸ +frw!4Aê Ñ@	ãH?@gN$h!t$p¦ÏaU"]GP/Î §@ø®!]A ¦ %Ý ø%íAD0"AJÇ@K"è!Ç"!d"Ü _ìh` X(oð  làp`Yô`' ø`Yt``x`Yü``  â |`` A*Y`HäAð@ à ô@ à*ÈYàJòà` Y"Ó@SI*K C ` `Aü4^`» `AøAü`Ù `AôAøa `AðAôa- `AìAðAO `AèAìÁ $à óÁô¬!äAÚ`¿A· I!·b!¶B0!Ã­AÆ_a¿B#B¬#B,#lL!J   
 ù,HsCS³ Kð Ky Y+þ XAê @,YB+ÐÚ¾!:` A@X3 %JàH P 1@+Â Y\Þ@&'1 XZ A YBÀ@"BRF ; H YJ'zZ1@@@Às Â/ sû ,/8#lA'!a êáaZ .i;4AlÄüÿÿÔ  h-WÀ O8¨dû *%@PÉ Xëº æ %Ù(S@ºGPQÿd´DSQþ`CQý#ÐZ aÀQü#ÐJB\ÑAï V!ï"AÚZ ´`>(ò  Êb&"   ñâ#Å 3@\ rsz- Æ@-ú j@;&9 q$@o  è"eaFØ§`-ø(AÂº-±*DÐ! ú$|Eå@  =6}$ù  KÀ1\Ô Ó Ä /f|\!8  Å; Ô ç Yzº+ Ý Z'¤Z%XÙ V¢ oAë QE&Ç Ð(}l*K× ÞEa8æ ¸ w  XæÊxæSçÂ8æQ¼ }Xæ@B! MÖBØæ)ò#²/ ASë Xæ ° T i2X 1@ @S QAì 7 p 7QGH@³GLA3 W u CÓ_^ 7L-8æy{ ÄXÔ8æfGÕ g    § ì":øïY G@<"ÐSD$0Ù Xê Xé , 0 UÁÌ3í j@@Msk,@
J V@  -!iY W ñÈ"@ ¨!L$#ót$`l$D@Ao5® d! ÿ     h 
ÿf   l@ TÆD$n Q@0u( 8@A"; m Z5±^È)Û a"r D K0Ét>]8,ÜÅÁø /È"¡
C,vÇC,  À¿ C,/ÀÀ?{I tËÆCI èT O
;KPsLOKP Ë  \KÿP{Tv FD+øÀlà!m  DL} @+@Ë+ï{@ õè@"ø~	Ëè	 
ø!H AHï 	Àá/Á|$4*ªÇv)¾ æ! YÁò,øëO¹#NAó,è T4CPHõ +ÇIÈ ¸0;L2îÖ {p}SKpIÀ|ÂD%+Cpø|æÀ»@H9CLÀÀ <!9à?G/Clrr!FHË@Ô p 
X$M  h@Wªè&Z ! !*a8 ,A%!6!H+Å!Ô`5  A @5 hC`ÇCQCl z ÆCh$©¯A`÷ ^AÚL$$)KMÝC4.Á_åz C8ë#!Cè"!|K4 K,55è¡Ë{#¢ ZA CB2K( §FkD 6 A!g K2EBqYÈf%ò%`@y ®Au`  p # Á!ªÐr}"#@å õ|@WB5  ¸ Í!¾É+   Ç AÊ! 7Èv7@*@ . à@à	8" è!ï,Ð+ÅéZà|@;;ï~%à
dB!¥ vB¢!  c] b  Âv ´%ú`´ Â`y vÀ  É 6YÊ-# 	,Át$3ÿÀ$Iø;þ}.!7ÂD\r#\  ?  Mo C ÅáÙ,CTT$,CXR$§$ÁP-à3Ã#LAò$H$`W@ 8/ÈEÝ Q  ·V T7`\èãóåÿl$ +k9[3ÔÚD$#?    &Ö3ö+×WÜ 9}§  4T$,,½  |$êWä5vDø3À!ã[\Ò~bq\/Ìv(Ø$#©HëÇ :@HC\"¿XC\;Â|Ì@mF;`n|©  <`£ë
@kë@!Z 4! 07r Â! H6^LÉ~´e¼w­ó¥à 3D$(2&T$+ò 8L)sP3À@tA¦9@A~#Áæ@,ÚÏ´@Ý@;`|ð`~ JkT{P@ÇL$$° ÆKX ~`!  \%?·@`3É9`^&@OÇ @  A;`|â@@]ÿKPJÀ?1 @SÒ·! i¡Cl" r#Ay"7l" 9aY   o è j X0k` DKdAê4/#¼ $  4 qHÕ Cl m , u XWv þ@7D$L+Æ TG ;ê×   !Z$j!z@áèC'çÿ;è}2íx."© BW " U" H  Plè©ÎæÿÙ\$?D Ñ P8gbG É Cl  C$N v%ñB6 X+§ë+0 u TA µ X *04 % d * Ð ó#~ F  #T À 0 ,#X H Á#Lí`d X& O`. õ í#'ë@ #!W#H U AAT ;T¬KM T!ALKd" ` d \ D+Âè)B!bDuY&Û 'R
Àt> Pø bCÆCH ~:g¿ A=" b !¯â`|âÿ 9Ë(¢( )][)pIHö
Â UìäðìJ¡¤P3Äj¦=t§UES]VuWù!& Â'e !ö,fpÈI$\$#¯AìMt$h(À¨ca(%`(q|$x(p@
 hê3Ò+ñ+Ù+ù0ïD$ BI "­à@lÂ&pÀ(À þ7È8@Ä &@þÃ !àAð  @*A¾!Æà+àú|!² ®!X:
,ëQE''T D ¸@@ x   z@03À@g|£¯AÀÁ 0 ø@|ë"$3À7m)¹ D"' ÿ  H ÿf L I» NA6(G,",0O0) 3"HiéG,v	ÇGiëé`?OEGdA;  #K D#*,G| YB´  XE DF,PSQ"$!C¥ P" @#qLR£æíå0YD/fr±"BOl@` Gt@e Á d( d < Àd <@d (àd À"à d@h g ~ g!,4Á+GCË`pOl!ökc D`b G> ` +\$Y"nÃ!ï à#Ë´)d$PtWÛë(ØZ?Ô  }3ÒÛLª * e7¡¿  H()#\Ê3öD4"¸%,YDò&4AáL4hd= @DhWµX þ@|Å!E ß h B B # @` & ©;Ó|( ­B ¹-]' Î"Øòàffà fP(Ì"òÈ L&à@Àø|ÊBß BKïL$<A]B$O|O\ cáZB" G(8O|6+tgD O#ØnÆ!X Ð ¶G4*-)T$Pê 2G8ê2O4*-sÁ{  &ª2 G"O(º@Û  0¿j"O (ü*'nÆ[ ô Z%ËYÈ*50( G?G@)1a#ïòÐD! Êÿ L  $Cà  x öÖt'³³9 D	~,ö~fÇGY4CÏèRÿÿAk D% (%,üÿÿÆN| %#[B_^E"_k{ å]å[>åMèå %&ÀÅ  % 0!Be (E ² "Ke ÂÅA»Å ¼må " È 0å"$å6" $ åNå"  A*"F !(0ëNå"E%" «¥%e@¥%C4f@Üå (%JWÀ% P% ÿ* T 	e"X E" ZE" ,$Ó  %&"  ¸Dmå2, å, 4$Ç PDÂe( L`_ ä Ã PDÃ@PVå ( !DÃ D$¿ TÅ(½èåÿ$JÂd¥.!ìCjD	À )D$`à#	@@hå@ D ,CD$Hà H@ HàQUà   P¥D 9@%ë|`Cñ l E %Iå
S%Ä%S#@£ è#è\EV%@(ÚE@ Ü@ Ì%ù3ö¿©   ë EMF °uä¯ ¤æXÀ/Äv!¸ØnYEË_Ê× ²°+æ Y., Ì@ëIÅ%¶ Âe YrÌ %$(Ô39[\ÑDx S +A@=°BbLxÂ)ÞEÁ3sX±@$±ú@|Ä e!)%«$YÆ °F ' µ¤;ó2"éÎ ê Æ eO@BÎàß F à   ¨àÒ ? ÒC×ænè@ Ü  â äæ X ÍoX@Dà@¥x Ê$("í¦o HB}æoCi¦o!K OBf`æ[òÐ[»ð ¦V`Ã&:!È æ V &~ `¦[ Ãæ[3&tgiÐæK ! qiÆ_ ` é	Ð\$,4V6EÕ)¸E# Â)¶Ó%õNNÃ#Ï$ë,  @¥8 ~2ÛÆQ5)èi!\$f ,Eoûÿæ ü!ÆdÆ Ì ìKÈæT¿Æ$TöSUV&D, tÆ  <#Ð   
 D 
A+Ò 0%^ (& Ø@@ò v 3 8 !*(Cc&£ ÀKÑ t+#(5kÎËÜ-PKÑ ¬oE(kß+ê+Á3Ò i +ñ B ø P+éé+ë"Xëî È D'ý þ(õ8@Î  Ë Ákñ(Å@  Â  )ì È Óà;$t BÑ@S Ê 6àALfòtC!ë`!`ñ( 3Éì 'Fùÿ	 èÿÿè ëGÂlÁù@|Þ3ÛÇ°   ?3í%ú¿W9 ._,'g Xÿ   f %\\$^|G\+@T@4"- -.!a'ÔclJ 5"ulJÃ"  µßìLbÔ"Ð ) 1 %´ö`¸v
Ào: Àl$<åÿ,L¯|í'] h1ZADð!k @#,4%?,¯Dj;ÈOUt "t8NÕ uD¯d;8°#:POØD¯\ Ú L LTPjIÔ4èçL¸G" T@ DP> (RÍ ( =$V' @ò ÍHèálÐ `z-DGÿ"Ù cLyD¯t i D`i ­j @§càu L@u 8`u"ØsJ 0  0D$,@|  H <àåÿ' ,e$Gå `  @ 4D(ã A #Ã !ô d$Ã&ô' 0íu	g¡'& âÓý "{!üAT`Q¯æ  Ãç Ó#&÷ç e Ðç<t YÚU@ Ð ¢3\Ú3Û³æ p O#òBø+7Qf%8 C < M.í5' Y' X n;@B|ÌCw1 <&IF¿M8¯MG% d: A+ :!;Ó#Cýu¢E3À³(!&Ú @Cm?ó#@)<+"! Di"Á îF©"! Á!! \"ª1ía " EBúýýÿBæÌ"òæÌJ´%Ä Jí'&Ëæ ÇFÂ #M8Øv  Bh"¾ 0%kv! ë>O@!Y Ñ!D3öÉ  'd CY3Ò9Ak~MD]±c  Ê EÕ :INiJ C±Lh!H "ÉH ;`H|·@À "À Â ¡`D$@[  $åF;ñs!© /á#&³á#,4'ñ#Úá)¡¡A( ÊîHA9`ÿÁá.B@è@;`|ì@Í"g !A é!Ø #mÙ3E ~"61Æ.P.Oz9õúÿç®ók]ókG±$*w"g @	5j   à PD.y@-Gß $¤çß  &¡  -?SÙD(3$\°U&Ô   3\@@SÙ¼NÄ V@  >´h üO"ç| T! @@2HïÆ \ \!Ò& l,Û xB< b Q @¼ 4@ Ì  ñ mOÿ|L$tC üB7 Õ ü PÙ³ü,FOD$<Yìüè#$ y 
ü Ü:iS" ÇV æZÁ0áü^T'V} 0:ü , Ó!= \  <!/ pü$  ?!}ÚJlrl6Ñ¼ d 
 X@Ý | |F8è= Ï:æ sü d;ü@2  ;!Õ@2 ü%N KKúü¯ë ÿü5Arb" d%f* /ü+&ü- t,è!ìDq< !ü?T$tFk]  Âü4 %-ü ü+ (YjüK[I; ()Ði¯)> ´!F $IO Pé ¶Xè^×åÿE +üUÞ'® üMÉ"þ T fü  <é /<Dñ 3üW | &» < Dr× (/ü@4 ÜA ¥)1:@3À+ò<¨á <|´@3è Ðüh!TKX~S<aOWé  ü_ ":?@>ü _@ü_\[.Õ <T1S$Úü	TLsFQ}|T ÜT S@ D&¢!Áà&­d´@Þ<^ L 0 TKdÅ&G/9#@µ<Y5  -HÒï ¸ ¿;èQ S ! $ü Oó
ü	O \O \OS´ L;èY²|O2ÿ ÌDë F"#{ê üO L$$jÐ X¯L`µüB Vk+îJ2`]<H$ûà ä,'B|F+\%V LDA+K\J;|J ðdÀü	N T  P  @üN@uZ<N Î'ü N \N DÜN ;#X IüOBâüO 0|O2THãH¦ÂüO\LVuW0t$,0y9xo7, T5å\$(µ!ô w(0kÀPvÐküH ßð_öÿü	N Fà+p8|NJ$ (#ÙBä$ëRW+ü$N ¬ü
O 3W( @")ÿJü S\KH IrJ #(W$)· L ü,K ÷  R / @6ª"B· "¦EK @åÇo¿%ÉDc"ß
$PBPVèÑowv/¼H ";@M÷-ü aMÀa 8@a $¦) < _\H % _+, h)Vè7 e#8 0TxOÌ`nö
ò@`üFW· OM"}WüF t-[üAHäm "!m¤ ü	?  <<V ü"@/-{YÅ$,õÀ ma;Ó|tüô Åü</3ød/AFõ¿Bµ¿3+,µ ü-/C¥{3äT$ü/`Û-æíâü+ 3á 	Ï$/ü hü, ; ü%,ÿÿCÊu  %$©üÿíÝü%9O.£å]$õ-¨  UìäðìMuíµ à"5ÕUE$ÿ"y Â$ÿ $ö  $i$ÿ D|(± 3ä2ÿ)èAÏä7ÿ Fäÿ /9 !* ëVDû ä&ûñäÿ&á3ö.ï.eÀå" w,[$JD%õ Æõ#å $å 0D¬ |$$­ET 4$¬ DÜ2Ìå2(ç©¥&ö L"D2Pýå* ,)8 ã 8 Eå. 8àE/à   @´ @å1T£ Mi   ÀRõ O%Oh½ Å oü 0E+ eg¼t :u\5 òESWí%E(Ý@ ÚFIõ2ÛIÁ 4¤å[OÂv@ü/ Íô
«#Þ@ ë</èv(Åü
/  Ñ3Ò4D$4oòâ t¯Lhü-%< D</å\) 8'$3 d¹ä  à£ tp<ã8È:N@~@¸  à@ÀøO"
C¿!¤å  §ó^ N è4K!³OÇï Oû	O4SQ¦ YO%sbû!O!påmó#° 8s $@ ûDK ¯D$»D $ [D .û
D$! \ 3 å³Iå³ì#bå©SX=t§[?SCû? , ,3m{? |*º,#)0D4<L«;4 4 ($NÙ(%ÀJ½ t+Àû 4¤ @Û4F-(Û4t+4 {4 ô )û4 åÑû21Jäû1û1,ë^!`îû12]@A¿ t  4!Já {1WØEøû /AAû/ ön  {/"-û/ %ì& P#[/ T 4t$X4Z |û0  _æ Åæ#û	/æ\û/ 8û/ d;/A/ < Ã 0û/ 4o#ïD¯d»/ Lû/ H&¨ P&F#èÛûæWw³KN P@ @ q}#a- <L&#DèçÅkµû-  û- @`g#Û- L¦] gàs H@s 4@s`o#V-@:[+ <@t : l z& (8Û@Þo¥ú  Xa o @û+ `&® óf«û+ #Buûq/ P;/Bã{/ 0& ;, [, Y&Ôû0 Ë0± ,/ñ 8&t 0 =,4û0 `?a0 V![0 #Ei[0 7Fû 0'û0C­  [/@®ò ^@;&[/(! ;%»/0çû/8ýû'/%³ Lûp/ d ámy"]zÓ!«û/C±Ld!~ @ûn/öá#/ \M´§Ñ§Ì\Ñû/û
/ d;/@èû/ l0ùt$éñ3¼ -L$³ û$m{nG û$ $#²@ñAR@GíJ` }¿í   !m B<å@@TÿÐ `ù  ¿ X ì $*3Ò¯eGD@`ÀHÂ;ÈÇ ${SÏRè   Ïè9Aâ0)0Ù\k L?¼/Ñv*ÏÊëó]ô]BÂ^Á iT¼ H>Àt)A  ' Y(h¼  ? %=w BË(Ñ¿S5"OD l#? Au8[ lÁë<+]Ãëà  T]t C# pl!¸  tBP(p(5¯ Y`/Ãv ^Ú 2 @£àÈvR D~ @ ëU %_° E`P+@E Ó E`¨ @³@E@ Ë  @¿]`\2 $ ! Q!"2S(ÿu & V!l,3 # @*  ;E Ã ¿ü   ¶ _H+K@¸  +KDIÁ`/  s@Ë&F$+sDV@èS. FÌ)u!Ó 1Ô$,ÇC@ , ÇC4ù6	/5 ,9·ø ~kob\ÿPF;`>`Ç@&@  S@ "Dn%MC@;CHb C@éZ #ßÏVèÊ4 O 8 Ç3ö+CDtø¸A°Gî`Z
;ðOðö~îæ{@píuð)` _(é­!1 X!a@!;Â= !ã Zù&oá?fà$ b kÁKkD¡ U!@	$tèþ,  ).)áG¡@ GYà¯Àu	ÁC èáC	Dø}l$$@¶ÆCºéY!@ P6¼!"  éD èà~á'¿@b¾!$!è"à q ÒWj ¯Aóí~DC@ÍA» !AÅ!n¯Â3Ò÷ñÈ;ÍOÍ,	É~ééá±C©)@G¡t6 L J>ªÈ~*AY Q@ ñ  ß   ÆRl E&ÂBÍ $ÿ6@,èt+  _Ç$©  7 $  /¤ðÜ N DÝ;Ø(2(LØ3/~~( +,, ; 9I °ÅPèåöÿFÄ;ó|ãÇ !e¥ `eÌADÃ à  @¢àI-Ì  þ`@ÈÿÂ 7À A@ÀtÙ@ÃÙ&=à:` ÝA@à Q-^AHiÚXA(k*­Ù$Yà #ìVñFF
@ÿÐÜð µ^Ý$ò' _À%®=ò$Ý$ Ûà = I B ² @=<ÿÐÈè@Oà-Ùîà3 / , ,àÙîàJ`  L 2ª { V3Ò/Â IT$rÙè^@F%L NPä	F4.ÁöÄDz&F8ë ¨ï ¤N45 è"@  = ò'¾ û FQìN(  ^§ÐÊòoZÂ Éó^0÷A!@j@¯a( Ãà  @ ¯SUéVWuÎ@GLt 
 Î>xë3ÿ`.ñ   !  
`!     À(d;Ø|GÿB® ~ÂD  $ÐX}#aÀ9 = 
 Ï@[Ï3¡ ÿRHIöy#, @Dë;ñÆOÁ@À k;Ã|Nö¨"ÇHÿ;ñÈ!òdàj ;àjØàh d@ë h`d  .U   U  :­~Ë4 ú = 
 Ë@ÀË ? ÀW ÿ`À  [`ÀùÇÀ `[  À Ï+ é>y0@Å÷Ç<$çÀþ;ð|N}T |}P }B!SÁ¡U|'Ru#$<M`  ;ù}Ç + )_Æà^]3À B  !øùwáú LAØ S@Þ "a4 L ¡PJÉy3ÉIA$	;GL[OGL_^#ä;ÊOÊà3À 'à & o#¬â B < 
ÎWÀi ø@Å L1Âi `iÙDàaà Ùî@xì0S@ÃGHD$  X@   h@,èÈ)×GLÿy'(p I¡H!ÎHÁëO$¯"ë@èGLwLöx#Àv \à+\AËÛ-Ã  
   X@ , h_^!q 0c  Co@¯_"QwLF"J¢U D 
ËU@"VèA3öv$%D)b ä]ë"ôOñàB´ "³   Zãu [ã
 Ù 23ö_ K bØd$@½$þ ;ñ_ànà" _#/`zà9 óä	\$) $` 3Aû@ìBdaú@ìÛy=|ë;Ù!X@$s#!á 5 ; 
ãL:cw a1"`#CML;ù;Á f +c9"Ì ¶à  A¯ ±UVWSéèí'ÀuG$f@äÔÀI: äØ á Â aÆ(été SÍèzü*/$µðµfÄ Ï%RÿÒ!# ÀO  $e aÜ !Û  @.àz%« v @E«À;t9$O@ ó;Ø}d@Åfà:å à ±dÉ Dµå äÉ;Ã}F p|¦ _{;þ}n$) G$M G!v !î@$ðÈà lÿy 6Båëå8  'W/¨!
sG;þ|ë÷àÒåò máyá¢B¡" öàL IÁZ&ªãÛy3Û#0[D+ðå e% Ù#' Ùà3À+ðåâ d "@à$"l ND$` #í$ÿP,Â ? "yÿtAÃA$ÀV¾l!,7 !\3Ò÷ö^Cuà _gÿ ) Ãà ÿ bf(mO@(°!#¡¼  
c©â\$ ÏSè"À ®O,3ö G4èèÙ Gø~HHÙhÓ¸~h¾ð£ Z7U n"móæ(Ù!   "Ö)SÈvBò,Àj#?
ÏPè9÷ÿÿ;Ã/"VF 3 Å*- )
 Y 4@>`X X ; Þ 	w¾Á á  á $Aà !?à+@  U]ïÀìWèøE °!]å	VuÙW})=D$T)AXèù[ëÿ#µÆK:3É hè 5 	`2À%J H   #E L D;½5~$gµ  ¿H R|$@èª`N÷ /UÎP 	`PèQ­æÿÙ "W+èü{ 0Ð3§ , _%Ú ;D$PL¾@ ||!J \ 4 `ËÇ`E@ !à @Q!_ a¸ æ*î XAY "­ 8ÉÀ~4Àÿ`Öu)Îè0 © YD¹$ù |$` ¶ÀDÁÇ`"(ø ÿ@ëà² I ²$ X ¬+@¬ ¿$ ¿@+È;ÏLùA@! X@D6	Ñ+T$L%ÒLT$@?X H dÒU w» 3Éÿ~& 2LDM- z@ R G@DxA;Ï|î¾2%-Aó8YnØMV Ï" @"] j!æÉò+B·"xð $.´6"pD+ê{z¾à ûQ p îX° t ÿf!ðx  8²z |è'äæÿ0ëè + nL$lQPa~Aé TWV@¤7W  ] p$PFPÿt$tè®åÿëI y ]Éãà] ¼ ]BàXPP O  OÀJhè>ªåÿ!QÒ~¸!GB®Dë°!=Dë!P D.h d!L+úÏ  XBÂ;ýÿÿ) i j@ = ~à é 0  9`Ý~a"4ËXC-uVà	;  .à ;ôâÀ; +`;!ÂhyÂ2À_^[;C3Ìè-"Uå]Â ?  X_^À[  cà CßVñW~çn <FkFëµA©[&b«ÀFÁ¾ !9 t3å B|r_°JË_2À@@và  $óÈ4$µ A$Ë"o&AÄÀìÌ Và(V±@`/QÎ  # ?F%U5È]@W $=&uYÆ =L/"ÐÂÊ`
Yp#="Ù Ø ! 4Z ã/
æ/Äv/çv %Ì N(ìëP(Ì N Ì4à  vYÔ@rp `l Ä  à 5 `\é Z ê  è `m  ÞTÁ/ßw=(Ë , Ëà] Ó  á  Óàa/iXâ  à Z à@R ¨5/*@}t%L  Å d $ÍZø h`!'(ï !{(Á$é YïZÒ  Ç6 .¶l . ¦p (Ú ßò\È(Å 
0OÅZö <  XÂZä  Ç@%!ZÁ(Ï! P ?  Ï8D$ '\Ã OäPT $  Æ B ÷  T Ä  @Q=2ÀY @X÷@] X 8  Í`- \@s z`R \ R@C ê  ð G`@{ ^@B Å@, / d'7 ` 7 ÷`· à@Ê@@­Îà@@@à@@`àR@@@ZW ©AÉài@9à@@-5 \À  ³ @E  @`h\ø!ß ) Â": Ã`^ø! Ô Çàï1nà@FZ! à%@QÿE=1õã ­¯@FCÏ0v" èM~{ @î8 ©ÆÑzp}6Vr5_Jp/fÀ|ÆDABpø|æ^ÃDÆ<¹&MÀ^'VBt1ßy À M O I4¦të°Ã2àYià .Dÿ~ tèR	GÓ
txuÇFtEÿêm*ì-òl$ %8j&RÖ FJS EH4dð)»F@)¤Pó^EAÃI@èníjJN,Djó" "è% 0"ÿ|ê HóFYN*0 Y(8!d¾ÑZÊ*=Áv1M Ã/Â { `{$ÂWû!( 4#ì 'ìFL#.N@'Ý"Ú$	  ?Ès]Nð 1H;ø}G ÑD$jW)|è©ìÿÿ u ,ø;ûu0ÀF LY±àGr¸_^ UM ]  5 Ç`1° !Và  Q0Òt7'iEÇ8": Á Ö!I,vÇA6EÀ¿  A:´ÀÀ ?Æ5à  SJ |0ÁCøÿt({;Ç}	À;Ç|úCC$¹LbÀjOÈ &¯ÁPëà¯ÏQ)"^Õÿ7ögV6gÿt]* ËVÿP(!"=EÇ @ Ç@$7  D,GÇ@p7Ç@nÜÇ@T   X  C­  d   h 
 F;÷r¦3À^_[àÐ*µ3 "~!"¤!T$;8 tP  À~F  /ZÝ wFÄøFÄ"" (!µ À"£Ç@"@ "¬,RXÊfx"
 Q vz  [ O Zù:ÙmÅ$RÿP4 D$W"\D@$$ t  Y k 
Ì vv
"l"Þ[æY &§¾( , -\Èt pY r Q J$M÷ Lÿ¶,@. P$s®cì¿,¿Õà  #¨  9 `PÂ @. â|  /nO à  6ÿ4R Ó OVå Göå GãÂ Ovå<yã Â®Ï'£Ä OcÄ%}Áò!&FÖ#¡%C¢!è¬#lh Ü ÜØ!FÝ\$cGPtVGdO`.ÝGX3ÀÉHÈOT4Øî ß  
ß0 À9GT|= .à!÷  Hë3ÀHëT3a!ktDÇGb¯GTÇG\ $tÉÇGl@ _AåOá? A?ãÝà   Ã.B*ÿP$/nDPßtÿu@³* ,*×Â Ûu¯¥8_^3À@U;ßsë@'4S(E;ïróVúÿtf^;Ú~"@ Ò;Úú FÃåVcè¯ÑRëP,;êTN ;Ñ~M@/F;Á~+ÂÑø è~íà<`9 !¤"à T`¯Ë*è»×D"&;ßv ;ûs@  W   *°$  9xPÿÿG;ûrä3À]_`ß!  !~D tb!© MÊ~&ÇfU@ ÇDH@@ÇM@  ;`%|ÚVwÆFà BÇD  ü  \~ Ç^' ÛBÌbÇG ÿÿÇGT ÿÆ!í ¹±!âA"¨)7Ï"ðj$6PÆO4 ÆGZ %ÛG@Vèæ\äÏGHèyè¦/ $s+æÀG\B=  ÇGt  Ç @ ÇG|@ ò$C$GdÆGY<#J`|  zÀfÇAD KµÈA??dÍDG 2IL,  !O"ÆFH ÇFL@YÇFpnÆFh Np¨r Â(r Hr Fr!Î \1|ÆFI ~âß 8Bõ V$ñ ú$èª=WÆ¬@dÀ4à  /%J ¿ÂÆ|Y Çp  (ÊP@ÌA&á A_ _ [úUH(æ C  <à ë@  _!  ,   à
à¯ ú.ºÇÀ !÷ 	 Ä	ÇF\ 	!/¨ FaÇá ¨F`  N @ Ç@  `ýÑVià &éß
ÁàÀ(Æxéä á&ôAUà Ï ÌA `ÇHA@$#o F@øF4 . H  4Q A(`L`6à  O ` )F ºG© ó=X )YÇIÃ@ ó]ô%"s 'AòYp&Ïe²IXE¡!ÝÁ;ÂLÂA¨Iû aÏ"Ú!áA(`Óà   LGE0 X ' ÉgA
I(vÇA(
×#áïß FÕ"&ß :# Q 2A 4' öçà/) + ;ÿP0 *à/ "O ÑÀÆ#n ãmà/ß`2â Ö(q££ BÑàþC¯ÿFL~, P#¸ ãl£ë0LÂ,DÂ0Á9FL|!FtNL=ÿÿÿ}H
Ft~t 
ÿFp#Ç 2ÜêÕ@1 0 Ã (øÿÿ0¡bx"VWøw1åùw@AxF@Hë¸2¯	 ÿ$dJ |&¹ T6R$â7Æð±;Æu _rB bàtà_Bï$ Cà D @! Ì WÒy2bÌA@Â;AHwñA@°BR QVÝjÙèz1ôðÄ9ötÇFÇF3Ý  GúöjèU@$ ø@$ *ÂÇt@$ GÀ$ÿ3í9Îæ 2ÿÞ K$k b".C- Q: R'@T_OBã@"  ${@""8@  
B0¹ &z!LÀHÁ&CÿP Ï-JPXK h?ú@h Àh Î h(À htO@`d  Yàd
{ ,@}ÇC Ó FÅ Î@d `d;k~k_^]°[YÃ 2À !k@ UìjÿhîÙd¡ û PQ<ÎøÅPEôd£  Ùs(Vuðÿ´=¬ !U'àPÿ× 	{X ÇEx	C$ vw3öD 9ChKhL1'\øt%àÀ¹G±à(. y pFþ Ë rÀ¾@j !SîuðK`#üPs\sX³uðë2ÛV  : ÿ°à¤ÃMôd5Ê  Y(43ÁÀ SÙº@VWC{ u0KXÁ `AbsX!¦=Lj IÒXV>0Öÿ 5 @5 Tà5 `5 Tà
5Õ/ÖÿK\!  "!Ç?3ÇCm+ÇCm9 [ ¸¿ÞïÁ¿"áÁ ìÁ!±!»
Pÿ¡É8á½è:=¤¯}!X¯{Áç;øt8 7 ÁÇCk$#X   j//ÿP !2Ûë` {!9 ÿ<&CdÄ hAÏÿP,3öfâBã{V"àEðÿP( EðFMxH` @|Íuì"b³áéàÒá
íDAà ?ðá ?á<E Â Ø";aô
èþÕÿÐU/Ã "9öMÊ þÇ d @#  A ùrãCd-ôCQSXÊÇH2  8¥ á$3s`ÿ`d ¸@ât¦  ¡@.Chb^ sà  yàdëàÀ Tàurb­Âñ dÀxj$è{ "<E¢/ í{j#¶r!Èëpãô,Öÿ¢- 2?¥ã!ã ½`6p@à63És`¯sK\  ÿ  Áæsd"v 5A¥ÿP#HjV P3ö9s`v'{iÁ @#Ô¯ÎFGü;s`rãzØD°à³"Jy$ u3F­ S-Ñ/,>yhEãDô9XuÀ3ÉPg#ð±
ø!¢Ô ÏÍæÀ+À3Òfr@G$¬!# oA#¸u	!Ô3Ø 3óê` A\AX¤  à/ Ì@/N à  W3ÿ@ÂtAsåYh1ëÑä¥² À9huGÀ³Ù^ïB© ]Hø[Ç_ ¢(Oè9èta xÝApÁ@la/ `q @q ä ²_`zuàzrÙ2 GþEÇ&Ð [ M Ñàï (²á?@:Åu3À>. @´U3íl »ø°#(ëÄT Íÿë3íë;Ñè!Aë@	"fÿSW